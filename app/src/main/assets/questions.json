[
{
    "frontend_question_id": 932,
    "article_live": true,
    "article_slug": "beautiful-array",
    "title": "Beautiful Array",
    "title_slug": "beautiful-array",
    "content": "<p>For some fixed <code>N</code>, an array <code>A</code> is <em>beautiful</em> if it is a permutation of the integers <code>1, 2, ..., N</code>, such that:</p>\r\n\r\n<p>For every <code>i &lt; j</code>, there is <strong>no</strong>&nbsp;<code>k</code> with <code>i &lt; k &lt; j</code>&nbsp;such that <code>A[k] * 2 = A[i] + A[j]</code>.</p>\r\n\r\n<p>Given <code>N</code>, return <strong>any</strong> beautiful array <code>A</code>.&nbsp; (It is guaranteed that one exists.)</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">4</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">[2,1,4,3]</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">5</span>\r\n<strong>Output: </strong><span>[3,1,2,5,4]</span></pre>\r\n\r\n<p>&nbsp;</p>\r\n</div>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= N &lt;= 1000</code></li>\r\n</ul>\r\n\r\n<div>\r\n<div>&nbsp;</div>\r\n</div>\r\n",
    "tags": "",
    "difficulty": 2,
    "frontend_article_id": 932,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-divide-and-conquer\">Approach 1: Divide and Conquer</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-divide-and-conquer\">Approach 1: Divide and Conquer</h4> \n  <p><strong>Intuition</strong></p> \n  <p>This answer is quite unintuitive.</p> \n  <p>First, notice that the condition is equivalent to saying that <code>A</code> has no arithmetic subsequence. We'll use the term \"<em>arithmetic-free</em>\" interchangeably with \"<em>beautiful</em>\".</p> \n  <p>One way is to guess that we should divide and conquer. One reason for this is that the condition is linear, so if the condition is satisfied by variables taking on values <code>(1, 2, ..., n)</code>, it is satisfied by those variables taking on values <code>(a + b, a + 2*b, a + 3*b, ..., a + (n-1)*b)</code> instead.</p> \n  <p>If we perform a divide and conquer, then we have two parts <code>left</code> and <code>right</code>, such that each part is arithmetic-free, and we only want that a triple from both parts is not arithmetic. Looking at the conditions:</p> \n  <ul> \n   <li><code>2*A[k] = A[i] + A[j]</code></li> \n   <li><code>(i &lt; k &lt; j)</code>, <code>i</code> from <code>left</code>, <code>j</code> from <code>right</code></li> \n  </ul> \n  <p>we can guess that because the left hand side <code>2*A[k]</code> is even, we can choose <code>left</code> to have all odd elements, and <code>right</code> to have all even elements.</p> \n  <p>Another way we could arrive at this is to try to place a number in the middle, like <code>5</code>. We will have <code>4</code> and <code>6</code> say, to the left of <code>5</code>, and <code>7</code> to the right of <code>6</code>, etc. We see that in general, odd numbers move towards one direction and even numbers towards another direction.</p> \n  <p>One final way we could arrive at this is to inspect possible answers arrived at by brute force. On experimentation, we see that many answers have all the odd elements to one side, and all the even elements to the other side, with only minor variation.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Looking at the elements <code>1, 2, ..., N</code>, there are <code>(N+1) / 2</code> odd numbers and <code>N / 2</code> even numbers.</p> \n  <p>We solve for elements <code>1, 2, ..., (N+1) / 2</code> and map these numbers onto <code>1, 3, 5, ...</code>. Similarly, we solve for elements <code>1, 2, ..., N/2</code> and map these numbers onto <code>2, 4, 6, ...</code>.</p> \n  <p>We can compose these solutions by concatenating them, since an arithmetic sequence never starts and ends with elements of different parity.</p> \n  <p>We memoize the result to arrive at the answer quicker.</p> \n  <iframe src=\"https://leetcode.com/playground/3NT7Bgm6/shared\" frameborder=\"0\" width=\"100%\" height=\"480\" name=\"3NT7Bgm6\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N \\log N)</script>. The function <code>f</code> is called only <script type=\"math/tex; mode=display\">O(\\log N)</script> times, and each time does <script type=\"math/tex; mode=display\">O(N)</script> work.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N \\log N)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 931,
    "article_live": true,
    "article_slug": "minimum-path-falling-sum",
    "title": "Minimum Falling Path Sum",
    "title_slug": "minimum-falling-path-sum",
    "content": "<p>Given a <strong>square</strong> array of integers <code>A</code>, we want the <strong>minimum</strong> sum of a <em>falling path</em> through <code>A</code>.</p>\r\n\r\n<p>A falling path starts at any element in the first row, and chooses one element from each row.&nbsp; The next row&#39;s choice must be in a column that is different from the previous row&#39;s column by at most one.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[[1,2,3],[4,5,6],[7,8,9]]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">12</span>\r\n<strong>Explanation: </strong>\r\nThe possible falling paths are:\r\n</pre>\r\n\r\n<ul>\r\n\t<li><code>[1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9]</code></li>\r\n\t<li><code>[2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9]</code></li>\r\n\t<li><code>[3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9]</code></li>\r\n</ul>\r\n\r\n<p>The falling path with the smallest sum is <code>[1,4,7]</code>, so the answer is <code>12</code>.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= A.length == A[0].length &lt;= 100</code></li>\r\n\t<li><code>-100 &lt;= A[i][j] &lt;= 100</code></li>\r\n</ol>\r\n",
    "tags": "",
    "difficulty": 2,
    "frontend_article_id": 931,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-dynamic-programming\">Approach 1: Dynamic Programming</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-dynamic-programming\">Approach 1: Dynamic Programming</h4> \n  <p><strong>Intuition</strong></p> \n  <p>This problem has an optimal substructure, meaning that the solutions to subproblems can be used to solve larger instances of this problem. This makes dynamic programming an ideal candidate.</p> \n  <p>Let <code>dp(r, c)</code> be the minimum total weight of a falling path starting at <code>(r, c)</code> and reaching the bottom row.</p> \n  <p>Then, <code>dp(r, c) = A[r][c] + min(dp(r+1, c-1), dp(r+1, c), dp(r+1, c+1))</code>, and the answer is <script type=\"math/tex; mode=display\">\\min\\limits_c \\text{dp}(0, c)</script>.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Usually, we would make an auxillary array <code>dp</code> to cache intermediate values <code>dp(r, c)</code>. However, this time we will use <code>A</code> to cache these values. Our goal is to transform the values of <code>A</code> into the values of <code>dp</code>.</p> \n  <p>We process each row, starting with the second last. (The last row is already correct.) We set <code>A[r][c] = min(A[r+1][c-1], A[r+1][c], A[r+1][c+1])</code>, handling boundary conditions gracefully.</p> \n  <p>Let's look at the recursion a little more to get a handle on why it works. For an array like <code>A = [[1,1,1],[5,3,1],[2,3,4]]</code>, imagine you are at <code>(1, 0)</code> (<code>A[1][0] = 5</code>). You can either go to <code>(2, 0)</code> and get a weight of 2, or <code>(2, 1)</code> and get a weight of 3. Since 2 is lower, we say that the minimum total weight at <code>(1, 0)</code> is <code>dp(1, 0) = 5 + 2</code> (5 for the original <code>A[r][c]</code>.)</p> \n  <p>After visiting <code>(1, 0)</code>, <code>(1, 1)</code>, and <code>(1, 2)</code>, <code>A</code> [which is storing the values of our <code>dp</code>], looks like <code>[[1,1,1],[7,5,4],[2,3,4]]</code>. We do this procedure again by visiting <code>(0, 0)</code>, <code>(0, 1)</code>, <code>(0, 2)</code>. We get <code>A = [[6,5,5],[7,5,4],[2,3,4]]</code>, and the final answer is <code>min(A[0]) = 5</code></p> \n  <iframe src=\"https://leetcode.com/playground/zERoz5Wa/shared\" frameborder=\"0\" width=\"100%\" height=\"412\" name=\"zERoz5Wa\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>A</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script> in <em>additional</em> space complexity. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 930,
    "article_live": true,
    "article_slug": "binary-subarrays-with-sum",
    "title": "Binary Subarrays With Sum",
    "title_slug": "binary-subarrays-with-sum",
    "content": "<p>In an array <code>A</code> of <code>0</code>s and <code>1</code>s, how many <strong>non-empty</strong> subarrays have sum <code>S</code>?</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>A = <span id=\"example-input-1-1\">[1,0,1,0,1]</span>, S = <span id=\"example-input-1-2\">2</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">4</span>\r\n<strong>Explanation: </strong>\r\nThe 4 subarrays are bolded below:\r\n[<strong>1,0,1</strong>,0,1]\r\n[<strong>1,0,1,0</strong>,1]\r\n[1,<strong>0,1,0,1</strong>]\r\n[1,0,<strong>1,0,1</strong>]\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>A.length &lt;= 30000</code></li>\r\n\t<li><code>0 &lt;= S &lt;= A.length</code></li>\r\n\t<li><code>A[i]</code>&nbsp;is either <code>0</code>&nbsp;or <code>1</code>.</li>\r\n</ol>\r\n",
    "tags": "",
    "difficulty": 2,
    "frontend_article_id": 930,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-index-of-ones\">Approach 1: Index of Ones</a></li> \n      <li><a href=\"#approach-2-prefix-sums\">Approach 2: Prefix Sums</a></li> \n      <li><a href=\"#approach-3-three-pointer\">Approach 3: Three Pointer</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-index-of-ones\">Approach 1: Index of Ones</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Say we number the <code>1</code>s in <code>A</code>: <script type=\"math/tex; mode=display\">(x_1, x_2, \\cdots, x_n)</script> with <script type=\"math/tex; mode=display\">A[x_i] = 1</script>.</p> \n  <p>Then, if we have a subarray of sum <script type=\"math/tex; mode=display\">S</script>, it has to use the ones <script type=\"math/tex; mode=display\">x_i, x_{i+1}, \\cdots, x_{i+S-1}</script>. For each <script type=\"math/tex; mode=display\">i</script>, we can count the number of such subarrays individually.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>In general, the number of such subarrays (for <script type=\"math/tex; mode=display\">i</script>) is <script type=\"math/tex; mode=display\">(x_i - x_{i-1}) * (x_{i+S} - x_{i+S-1})</script>.</p> \n  <p>For example, if <script type=\"math/tex; mode=display\">S = 2</script>, then in <code>A = [1,0,1,0,1,0,0,1]</code>, let's count the number of subarrays <code>[i, j]</code> that use the middle two <code>1</code>s. There are 2 choices for the <code>i</code> <code>(i = 1, 2)</code> and 3 choices for the <code>j</code> <code>(j = 4, 5, 6)</code>.</p> \n  <p>The corner cases are when <script type=\"math/tex; mode=display\">S = 0</script>, <script type=\"math/tex; mode=display\">i = 1</script>, or <script type=\"math/tex; mode=display\">i+S = n+1</script>. We can handle these gracefully.</p> \n  <iframe src=\"https://leetcode.com/playground/xeXqLmYy/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"xeXqLmYy\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>A</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-prefix-sums\">Approach 2: Prefix Sums</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Let <code>P[i] = A[0] + A[1] + ... + A[i-1]</code>. Then <code>P[j+1] - P[i] = A[i] + A[i+1] + ... + A[j]</code>, the sum of the subarray <code>[i, j]</code>.</p> \n  <p>Hence, we are looking for the number of <code>i &lt; j</code> with <code>P[j] - P[i] = S</code>.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>For each <code>j</code>, let's count the number of <code>i</code> with <code>P[j] = P[i] + S</code>. This is analogous to counting the number of subarrays ending in <code>j</code> with sum <code>S</code>.</p> \n  <p>It comes down to counting how many <code>P[i] + S</code> we've seen before. We can keep this count on the side to help us find the final answer.</p> \n  <iframe src=\"https://leetcode.com/playground/nAHXHKUL/shared\" frameborder=\"0\" width=\"100%\" height=\"344\" name=\"nAHXHKUL\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>A</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-three-pointer\">Approach 3: Three Pointer</h4> \n  <p><strong>Intuition</strong></p> \n  <p>For each <code>j</code>, let's try to count the number of <code>i</code>'s that have the subarray <code>[i, j]</code> equal to <code>S</code>.</p> \n  <p>It is easy to see these <code>i</code>'s form an interval <code>[i_lo, i_hi]</code>, and each of <code>i_lo</code>, <code>i_hi</code> are increasing with respect to <code>j</code>. So we can use a \"two pointer\" style approach.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>For each <code>j</code> (in increasing order), let's maintain 4 variables:</p> \n  <ul> \n   <li><code>sum_lo</code> : the sum of subarray <code>[i_lo, j]</code></li> \n   <li><code>sum_hi</code> : the sum of subarray <code>[i_hi, j]</code></li> \n   <li><code>i_lo</code> : the smallest <code>i</code> so that <code>sum_lo &lt;= S</code></li> \n   <li><code>i_hi</code> : the largest <code>i</code> so that <code>sum_hi &lt;= S</code></li> \n  </ul> \n  <p>Then, (provided that <code>sum_lo == S</code>), the number of subarrays ending in <code>j</code> is <code>i_hi - i_lo + 1</code>.</p> \n  <p>As an example, with <code>A = [1,0,0,1,0,1]</code> and <code>S = 2</code>, when <code>j = 5</code>, we want <code>i_lo = 1</code> and <code>i_hi = 3</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/7oyzRqG8/shared\" frameborder=\"0\" width=\"100%\" height=\"480\" name=\"7oyzRqG8\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>A</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 929,
    "article_live": true,
    "article_slug": "unique-email-addresses",
    "title": "Unique Email Addresses",
    "title_slug": "unique-email-addresses",
    "content": "<p>Every email consists of a local name and a domain name, separated by the @ sign.</p>\r\n\r\n<p>For example, in <code>alice@leetcode.com</code>,&nbsp;<code>alice</code> is the local name, and <code>leetcode.com</code> is the domain name.</p>\r\n\r\n<p>Besides lowercase letters, these emails may contain <code>&#39;.&#39;</code>s or <code>&#39;+&#39;</code>s.</p>\r\n\r\n<p>If you add periods (<code>&#39;.&#39;</code>) between some characters in the <strong>local name</strong> part of an email address, mail sent there will be forwarded to the same address without dots in the local name.&nbsp; For example, <code>&quot;alice.z@leetcode.com&quot;</code> and <code>&quot;alicez@leetcode.com&quot;</code> forward to the same email address.&nbsp; (Note that this rule does not apply for domain names.)</p>\r\n\r\n<p>If you add a plus (<code>&#39;+&#39;</code>) in the <strong>local name</strong>, everything after the first plus sign will be&nbsp;<strong>ignored</strong>. This allows certain emails to be filtered, for example&nbsp;<code>m.y+name@email.com</code>&nbsp;will be forwarded to&nbsp;<code>my@email.com</code>.&nbsp; (Again, this rule does not apply for domain names.)</p>\r\n\r\n<p>It is possible to use both of these rules at the same time.</p>\r\n\r\n<p>Given a list of <code>emails</code>, we send one email to each address in the list.&nbsp;&nbsp;How many different addresses actually receive mails?&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[&quot;test.email+alex@leetcode.com&quot;,&quot;test.e.mail+bob.cathy@leetcode.com&quot;,&quot;testemail+david@lee.tcode.com&quot;]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">2</span>\r\n<strong><span>Explanation:</span></strong><span>&nbsp;&quot;</span><span id=\"example-input-1-1\">testemail@leetcode.com&quot; and &quot;testemail@lee.tcode.com&quot; </span>actually receive mails\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= emails[i].length&nbsp;&lt;= 100</code></li>\r\n\t<li><code>1 &lt;= emails.length &lt;= 100</code></li>\r\n\t<li>Each <code>emails[i]</code> contains exactly one <code>&#39;@&#39;</code> character.</li>\r\n</ul>\r\n</div>\r\n",
    "tags": "",
    "difficulty": 1,
    "frontend_article_id": 929,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-canonical-form\">Approach 1: Canonical Form</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-canonical-form\">Approach 1: Canonical Form</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>For each email address, convert it to the <em>canonical</em> address that actually receives the mail. This involves a few steps:</p> \n  <ul> \n   <li> <p>Separate the email address into a <code>local</code> part and the <code>rest</code> of the address.</p> </li> \n   <li> <p>If the <code>local</code> part has a <code>'+'</code> character, remove it and everything beyond it from the <code>local</code> part.</p> </li> \n   <li> <p>Remove all the zeros from the <code>local</code> part.</p> </li> \n   <li> <p>The canonical address is <code>local + rest</code>.</p> </li> \n  </ul> \n  <p>After, we can count the number of unique canonical addresses with a <code>Set</code> structure.</p> \n  <iframe src=\"https://leetcode.com/playground/bxsVPJCq/shared\" frameborder=\"0\" width=\"100%\" height=\"344\" name=\"bxsVPJCq\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(\\mathcal{C})</script>, where <script type=\"math/tex; mode=display\">\\mathcal{C}</script> is the total content of <code>emails</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(\\mathcal{C})</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 928,
    "article_live": true,
    "article_slug": "minimize-malware-spread-ii",
    "title": "Minimize Malware Spread II",
    "title_slug": "minimize-malware-spread-ii",
    "content": "<p>(This problem is the same as <em>Minimize Malware Spread</em>, with the differences bolded.)</p>\r\n\r\n<p>In a network of nodes, each node <code>i</code> is directly connected to another node <code>j</code> if and only if&nbsp;<code>graph[i][j] = 1</code>.</p>\r\n\r\n<p>Some nodes <code>initial</code> are initially infected by malware.&nbsp; Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware.&nbsp; This spread of malware will continue until no more nodes can be infected in this manner.</p>\r\n\r\n<p>Suppose <code>M(initial)</code>&nbsp;is the final number of nodes infected with malware in the entire network, after the spread of malware stops.</p>\r\n\r\n<p>We will&nbsp;remove one node from the initial list, <strong>completely removing it and any connections from this node to any other node</strong>.&nbsp; Return the node that if removed, would minimize&nbsp;<code>M(initial)</code>.&nbsp; If multiple nodes could be removed to minimize <code>M(initial)</code>, return such a node with the smallest index.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<ol>\r\n</ol>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>graph = <span id=\"example-input-1-1\">[[1,1,0],[1,1,0],[0,0,1]]</span>, initial = <span id=\"example-input-1-2\">[0,1]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">0</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>graph = <span id=\"example-input-2-1\">[[1,1,0],[1,1,1],[0,1,1]]</span>, initial = <span id=\"example-input-2-2\">[0,1]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">1</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>graph = <span id=\"example-input-3-1\">[[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]]</span>, initial = <span id=\"example-input-3-2\">[0,1]</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">1</span>\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt; graph.length = graph[0].length &lt;= 300</code></li>\r\n\t<li><code>0 &lt;= graph[i][j] == graph[j][i] &lt;= 1</code></li>\r\n\t<li><code>graph[i][i] = 1</code></li>\r\n\t<li><code>1 &lt;= initial.length &lt; graph.length</code></li>\r\n\t<li><code>0 &lt;= initial[i] &lt; graph.length</code></li>\r\n</ol>\r\n</div>\r\n</div>\r\n</div>\r\n",
    "tags": "",
    "difficulty": 3,
    "frontend_article_id": 928,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-depth-first-search\">Approach 1: Depth First Search</a></li> \n      <li><a href=\"#approach-2-union-find\">Approach 2: Union-Find</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-depth-first-search\">Approach 1: Depth First Search</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Let <code>G</code> be the graph with all the nodes from <code>initial</code> removed.</p> \n  <p>For each node <code>v</code> not in <code>initial</code>, we want to know which nodes <code>u</code> from <code>initial</code> can reach <code>v</code> in the graph <code>G</code> [with <code>u</code> (and its edges) added to <code>G</code>]. Let's say these nodes <code>u</code> \"infect\" <code>v</code>.</p> \n  <p>Afterwards, we want to know which nodes <code>v</code> are uniquely infected by only one <code>u</code>. For each such pair, it contributes 1 to the answer for <code>u</code>.</p> \n  <p>Please see the inline comments for more details.</p> \n  <iframe src=\"https://leetcode.com/playground/zWWFjBM4/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"zWWFjBM4\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>graph</code>, as the graph is given in adjacent matrix form.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-union-find\">Approach 2: Union-Find</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Let <code>G</code> be the graph with all the nodes in <code>initial</code> removed. For each component of <code>G</code>, either it neighbors <code>0</code>, <code>1</code>, or <code>&gt;= 2</code> nodes from <code>initial</code>. The result only changes if there is exactly 1 neighbor from <code>initial</code>, so we need a way to count this.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>It is clear that we will need to consider components of the graph. A \"Disjoint Set Union\" (DSU) data structure is ideal for this.</p> \n  <p>We will skip the explanation of how a DSU structure is implemented. Please refer to <a href=\"https://leetcode.com/problems/redundant-connection/solution/\">https://leetcode.com/problems/redundant-connection/solution/</a> for a tutorial on DSU.</p> \n  <p>As above, lets consider the components of <code>G</code>: the graph without any nodes from <code>initial</code>.</p> \n  <p>Then, for every edge <code>uv</code> in the original graph, where <code>u</code> is in initial and <code>v</code> is not, we can count that the component at <code>v</code> of <code>G</code> neighbors 1 more infected node.</p> \n  <p>Now, for each node <code>u</code> in initial, for each component of <code>G</code> it neighbors, if that component would only be infected by <code>u</code> (\"uniquely infected\"), then the size of that component contributes to the answer for removing <code>u</code>.</p> \n  <p>We take the best possible answer.</p> \n  <iframe src=\"https://leetcode.com/playground/Bov23LZs/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"Bov23LZs\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>graph</code>, as the graph is given in adjacent matrix form.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 927,
    "article_live": true,
    "article_slug": "three-equal-parts",
    "title": "Three Equal Parts",
    "title_slug": "three-equal-parts",
    "content": "<p>Given an array <code>A</code> of <code>0</code>s and <code>1</code>s, divide the array into 3 non-empty parts such that all of these parts represent the same binary value.</p>\r\n\r\n<p>If it is possible, return <strong>any</strong> <code>[i, j]</code>&nbsp;with <code>i+1 &lt; j</code>, such that:</p>\r\n\r\n<ul>\r\n\t<li><code>A[0], A[1], ..., A[i]</code> is the first part;</li>\r\n\t<li><code>A[i+1], A[i+2], ..., A[j-1]</code> is the second part, and</li>\r\n\t<li><code>A[j], A[j+1], ..., A[A.length - 1]</code> is the third part.</li>\r\n\t<li>All three parts have equal binary value.</li>\r\n</ul>\r\n\r\n<p>If it is not possible, return <code>[-1, -1]</code>.</p>\r\n\r\n<p>Note that the entire part is used when considering what binary value it represents.&nbsp; For example, <code>[1,1,0]</code>&nbsp;represents <code>6</code>&nbsp;in decimal,&nbsp;not <code>3</code>.&nbsp; Also, leading zeros are allowed, so&nbsp;<code>[0,1,1]</code> and <code>[1,1]</code> represent the same value.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[1,0,1,0,1]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">[0,3]</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">[1,1,0,1,1]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">[-1,-1]</span></pre>\r\n</div>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>3 &lt;= A.length &lt;= 30000</code></li>\r\n\t<li><code>A[i] == 0</code>&nbsp;or <code>A[i] == 1</code></li>\r\n</ol>\r\n\r\n<div>\r\n<div>&nbsp;</div>\r\n</div>\r\n",
    "tags": "",
    "difficulty": 3,
    "frontend_article_id": 927,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-equal-ones\">Approach 1: Equal Ones</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-equal-ones\">Approach 1: Equal Ones</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Each part has to have the same number of ones in their representation. The algorithm given below is the natural continuation of this idea.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Say <code>S</code> is the number of ones in <code>A</code>. Since every part has the same number of ones, they all should have <code>T = S / 3</code> ones.</p> \n  <p>If <code>S</code> isn't divisible by 3, the task is impossible.</p> \n  <p>We can find the position of the 1st, T-th, T+1-th, 2T-th, 2T+1-th, and 3T-th one. The positions of these ones form 3 intervals: <code>[i1, j1], [i2, j2], [i3, j3]</code>. (If there are only 3 ones, then the intervals are each length 1.)</p> \n  <p>Between them, there may be some number of zeros. The zeros after <code>j3</code> must be included in each part: say there are <code>z</code> of them <code>(z = S.length - j3)</code>.</p> \n  <p>So the first part, <code>[i1, j1]</code>, is now <code>[i1, j1+z]</code>. Similarly, the second part, <code>[i2, j2]</code>, is now <code>[i2, j2+z]</code>.</p> \n  <p>If all this is actually possible, then the final answer is <code>[j1+z, j2+z+1]</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/svqa2QF7/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"svqa2QF7\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>S</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 926,
    "article_live": true,
    "article_slug": "flip-string-to-monotone-increasing",
    "title": "Flip String to Monotone Increasing",
    "title_slug": "flip-string-to-monotone-increasing",
    "content": "<p>A string of <code>&#39;0&#39;</code>s and <code>&#39;1&#39;</code>s is <em>monotone increasing</em> if it consists of some number of <code>&#39;0&#39;</code>s (possibly 0), followed by some number of <code>&#39;1&#39;</code>s (also possibly 0.)</p>\r\n\r\n<p>We are given a string <code>S</code> of <code>&#39;0&#39;</code>s and <code>&#39;1&#39;</code>s, and we may flip any <code>&#39;0&#39;</code> to a <code>&#39;1&#39;</code> or a <code>&#39;1&#39;</code> to a <code>&#39;0&#39;</code>.</p>\r\n\r\n<p>Return the minimum number of flips to make <code>S</code>&nbsp;monotone increasing.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">&quot;00110&quot;</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">1</span>\r\n<strong>Explanation: </strong>We flip the last digit to get 00111.\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">&quot;010110&quot;</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">2</span>\r\n<strong>Explanation: </strong>We flip to get 011111, or alternatively 000111.\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-3-1\">&quot;00011000&quot;</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">2</span>\r\n<strong>Explanation: </strong>We flip to get 00000000.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong><span>Note:</span></strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= S.length &lt;= 20000</code></li>\r\n\t<li><code>S</code> only consists of <code>&#39;0&#39;</code> and <code>&#39;1&#39;</code> characters.</li>\r\n</ol>\r\n</div>\r\n</div>\r\n</div>\r\n",
    "tags": "",
    "difficulty": 2,
    "frontend_article_id": 926,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-prefix-sums\">Approach 1: Prefix Sums</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-prefix-sums\">Approach 1: Prefix Sums</h4> \n  <p><strong>Intuition</strong></p> \n  <p>For say a 5 digit string, the answer is either <code>'00000'</code>, <code>'00001'</code>, <code>'00011'</code>, <code>'00111'</code>, <code>'01111'</code>, or <code>'11111'</code>. Let's try to calculate the cost of switching to that answer. The answer has two halves, a left (zero) half, and a right (one) half.</p> \n  <p>Evidently, it comes down to a question of knowing, for each candidate half: how many ones are in the left half, and how many zeros are in the right half.</p> \n  <p>We can use prefix sums. Say <code>P[i+1] = A[0] + A[1] + ... + A[i]</code>, where <code>A[i] = 1</code> if <code>S[i] == '1'</code>, else <code>A[i] = 0</code>. We can calculate <code>P</code> in linear time.</p> \n  <p>Then if we want <code>x</code> zeros followed by <code>N-x</code> ones, there are <code>P[x]</code> ones in the start that must be flipped, plus <code>(N-x) - (P[N] - P[x])</code> zeros that must be flipped. The last calculation comes from the fact that there are <code>P[N] - P[x]</code> ones in the later segment of length <code>N-x</code>, but we want the number of zeros.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>For example, with <code>S = \"010110\"</code>: we have <code>P = [0, 0, 1, 1, 2, 3, 3]</code>. Now say we want to evaluate having <code>x=3</code> zeros.</p> \n  <p>There are <code>P[3] = 1</code> ones in the first 3 characters, and <code>P[6] - P[3] = 2</code> ones in the later <code>N-x = 3</code> characters.</p> \n  <p>So, there is <code>(N-x) - (P[N] - P[x]) = 1</code> zero in the later <code>N-x</code> characters.</p> \n  <p>We take the minimum among all candidate answers to arrive at the final answer.</p> \n  <iframe src=\"https://leetcode.com/playground/AoUF2isa/shared\" frameborder=\"0\" width=\"100%\" height=\"310\" name=\"AoUF2isa\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>S</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 925,
    "article_live": true,
    "article_slug": "long-pressed-name",
    "title": "Long Pressed Name",
    "title_slug": "long-pressed-name",
    "content": "<p>Your friend is typing his <code>name</code>&nbsp;into a keyboard.&nbsp; Sometimes, when typing a character <code>c</code>, the key might get <em>long pressed</em>, and the character will be typed 1 or more times.</p>\r\n\r\n<p>You examine the <code>typed</code>&nbsp;characters of the keyboard.&nbsp; Return <code>True</code> if it is possible that it was your friends name, with some characters (possibly none) being long pressed.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>name = <span id=\"example-input-1-1\">&quot;alex&quot;</span>, typed = <span id=\"example-input-1-2\">&quot;aaleex&quot;</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">true</span>\r\n<strong>Explanation: </strong>'a' and 'e' in 'alex' were long pressed.\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>name = <span id=\"example-input-2-1\">&quot;saeed&quot;</span>, typed = <span id=\"example-input-2-2\">&quot;ssaaedd&quot;</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">false</span>\r\n<strong>Explanation: </strong>'e' must have been pressed twice, but it wasn't in the typed output.\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>name = <span id=\"example-input-3-1\">&quot;leelee&quot;</span>, typed = <span id=\"example-input-3-2\">&quot;lleeelee&quot;</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">true</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 4:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>name = <span id=\"example-input-4-1\">&quot;laiden&quot;</span>, typed = <span id=\"example-input-4-2\">&quot;laiden&quot;</span>\r\n<strong>Output: </strong><span id=\"example-output-4\">true</span>\r\n<strong>Explanation: </strong>It's not necessary to long press any character.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n</div>\r\n</div>\r\n</div>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>name.length &lt;= 1000</code></li>\r\n\t<li><code>typed.length &lt;= 1000</code></li>\r\n\t<li>The characters of <code>name</code> and <code>typed</code> are lowercase letters.</li>\r\n</ol>\r\n\r\n<div>\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<div>\r\n<div>&nbsp;</div>\r\n</div>\r\n</div>\r\n</div>\r\n",
    "tags": "",
    "difficulty": 1,
    "frontend_article_id": 925,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-group-into-blocks\">Approach 1: Group into Blocks</a></li> \n      <li><a href=\"#approach-2-two-pointer\">Approach 2: Two Pointer</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-group-into-blocks\">Approach 1: Group into Blocks</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>For a string like <code>S = 'aabbbbccc'</code>, we can group it into blocks <code>groupify(S) = [('a', 2), ('b', 4), ('c', 3)]</code>, that consist of a <em>key</em> <code>'abc'</code> and a <em>count</em> <code>[2, 4, 3]</code>.</p> \n  <p>Then, the necessary and sufficient condition for <code>typed</code> to be a long-pressed version of <code>name</code> is that the keys are the same, and each entry of the count of <code>typed</code> is at least the entry for the count of <code>name</code>.</p> \n  <p>For example, <code>'aaleex'</code> is a long-pressed version of <code>'alex'</code>: because when considering the groups <code>[('a', 2), ('l', 1), ('e', 2), ('x', 1)]</code> and <code>[('a', 1), ('l', 1), ('e', 1), ('x', 1)]</code>, they both have the key <code>'alex'</code>, and the count <code>[2,1,2,1]</code> is at least <code>[1,1,1,1]</code> when making an element-by-element comparison <code>(2 &gt;= 1, 1 &gt;= 1, 2 &gt;= 1, 1 &gt;= 1)</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/TfwwqxiQ/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"TfwwqxiQ\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N+T)</script>, where <script type=\"math/tex; mode=display\">N, T</script> are the lengths of <code>name</code> and <code>typed</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N+T)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-two-pointer\">Approach 2: Two Pointer</h4> \n  <p><strong>Intuition</strong></p> \n  <p>As in <em>Approach 1</em>, we want to check the key and the count. We can do this on the fly.</p> \n  <p>Suppose we read through the characters <code>name</code>, and eventually it doesn't match <code>typed</code>.</p> \n  <p>There are some cases for when we are allowed to skip characters of <code>typed</code>. Let's use a tuple to denote the case (<code>name</code>, <code>typed</code>):</p> \n  <ul> \n   <li> <p>In a case like <code>('aab', 'aaaaab')</code>, we can skip the 3rd, 4th, and 5th <code>'a'</code> in <code>typed</code> because we have already processed an <code>'a'</code> in this block.</p> </li> \n   <li> <p>In a case like <code>('a', 'b')</code>, we can't skip the 1st <code>'b'</code> in <code>typed</code> because we haven't processed anything in the current block yet.</p> </li> \n  </ul> \n  <p><strong>Algorithm</strong></p> \n  <p>This leads to the following algorithm:</p> \n  <ul> \n   <li>For each character in <code>name</code>, if there's a mismatch with the next character in <code>typed</code>:\n    <ul> \n     <li>If it's the first character of the block in <code>typed</code>, the answer is <code>False</code>.</li> \n     <li>Else, discard all similar characers of <code>typed</code> coming up. The next (different) character coming must match.</li> \n    </ul> </li> \n  </ul> \n  <p>Also, we'll keep track on the side of whether we are at the first character of the block.</p> \n  <iframe src=\"https://leetcode.com/playground/Wv6ufLEV/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"Wv6ufLEV\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N+T)</script>, where <script type=\"math/tex; mode=display\">N, T</script> are the lengths of <code>name</code> and <code>typed</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script> in additional space complexity. (In Java, <code>.toCharArray</code> makes this <script type=\"math/tex; mode=display\">O(N)</script>, but this can be easily remedied.) <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 924,
    "article_live": true,
    "article_slug": "minimize-malware-spread",
    "title": "Minimize Malware Spread",
    "title_slug": "minimize-malware-spread",
    "content": "<p>In a network of nodes, each node <code>i</code> is directly connected to another node <code>j</code> if and only if&nbsp;<code>graph[i][j] = 1</code>.</p>\r\n\r\n<p>Some nodes <code>initial</code> are initially infected by malware.&nbsp; Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware.&nbsp; This spread of malware will continue until no more nodes can be infected in this manner.</p>\r\n\r\n<p>Suppose <code>M(initial)</code>&nbsp;is the final number of nodes infected with malware in the entire network, after the spread of malware stops.</p>\r\n\r\n<p>We will&nbsp;remove one node from the initial list.&nbsp; Return the node that if removed, would minimize&nbsp;<code>M(initial)</code>.&nbsp; If multiple nodes could be removed to minimize <code>M(initial)</code>, return such a node with the smallest index.</p>\r\n\r\n<p>Note that if a node was removed from the <code>initial</code>&nbsp;list of infected nodes, it may still be infected later as a result of the malware spread.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<ol>\r\n</ol>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>graph = <span id=\"example-input-1-1\">[[1,1,0],[1,1,0],[0,0,1]]</span>, initial = <span id=\"example-input-1-2\">[0,1]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">0</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>graph = <span id=\"example-input-2-1\">[[1,0,0],[0,1,0],[0,0,1]]</span>, initial = <span id=\"example-input-2-2\">[0,2]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">0</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>graph = <span id=\"example-input-3-1\">[[1,1,1],[1,1,1],[1,1,1]]</span>, initial = <span id=\"example-input-3-2\">[1,2]</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">1</span>\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt; graph.length = graph[0].length &lt;= 300</code></li>\r\n\t<li><code>0 &lt;= graph[i][j] == graph[j][i] &lt;= 1</code></li>\r\n\t<li><code>graph[i][i] = 1</code></li>\r\n\t<li><code>1 &lt;= initial.length &lt; graph.length</code></li>\r\n\t<li><code>0 &lt;= initial[i] &lt; graph.length</code></li>\r\n</ol>\r\n</div>\r\n</div>\r\n</div>\r\n",
    "tags": "",
    "difficulty": 3,
    "frontend_article_id": 924,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-depth-first-search\">Approach 1: Depth First Search</a></li> \n      <li><a href=\"#approach-2-union-find\">Approach 2: Union-Find</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-depth-first-search\">Approach 1: Depth First Search</h4> \n  <p><strong>Intuition</strong></p> \n  <p>First, let's color (the nodes of) each component of the graph. We can do this using a depth first search.</p> \n  <p>Afterwards, notice that if two nodes in <code>initial</code> have the same color (ie., belong to the same component), then removing them from <code>initial</code> won't decrease <code>M(initial)</code>. This is because the malware will spread to reach every node in this component no matter what.</p> \n  <p>So, among nodes with a unique color in <code>initial</code>, we will remove the node with the largest component size. (If there's a tie, we return the smallest index. Also, if there aren't any nodes with a unique color, we'll just return the smallest index node.)</p> \n  <p><strong>Algorithm</strong></p> \n  <p>This algorithm has a few parts:</p> \n  <ul> \n   <li> <p><strong>Coloring each component:</strong> For each node, if it isn't yet colored, use a depth-first search to traverse its component, coloring that component with a new color.</p> </li> \n   <li> <p><strong>Size of each color:</strong> Count the number of occurrences of each color.</p> </li> \n   <li> <p><strong>Find unique colors:</strong> Look at the colors of nodes in <code>initial</code> to see which nodes have unique colors.</p> </li> \n   <li> <p><strong>Choose answer:</strong> For each node with a unique color, find the size of that color. The largest size is selected, with ties broken by lowest node number.</p> \n    <ul> \n     <li>If there is no node with a unique color, the answer is <code>min(initial)</code>.</li> \n    </ul> </li> \n  </ul> \n  <iframe src=\"https://leetcode.com/playground/2UnP5s47/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"2UnP5s47\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>graph</code>, as the graph is given in adjacent matrix form.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-union-find\">Approach 2: Union-Find</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>As in <em>Approach 1</em>, it is clear that we will need to consider components of the graph. A \"Disjoint Set Union\" (DSU) data structure is ideal for this.</p> \n  <p>We will skip the explanation of how a DSU structure is implemented. Please refer to <a href=\"https://leetcode.com/problems/redundant-connection/solution/\">https://leetcode.com/problems/redundant-connection/solution/</a> for a tutorial on DSU.</p> \n  <p>To our DSU, we can keep a side count of the size of each component. Whenever we union two components together, the size of those components are added.</p> \n  <p>With these details neatly handled by our DSU structure, we can continue in a similar manner to <em>Approach 1</em>: for each node in <code>initial</code> with a unique color, we will consider it as a candidate answer. If no node in <code>initial</code> have a unique color, then we will take <code>min(initial)</code> as the answer.</p> \n  <p>Note that for brevity, our <code>DSU</code> implementation does not use union-by-rank. This makes the asymptotic time complexity larger.</p> \n  <iframe src=\"https://leetcode.com/playground/YV58cfEf/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"YV58cfEf\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>graph</code>, as the graph is given in adjacent matrix form.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 923,
    "article_live": true,
    "article_slug": "3sum-with-multiplicity",
    "title": "3Sum With Multiplicity",
    "title_slug": "3sum-with-multiplicity",
    "content": "<p>Given an integer array <code>A</code>, and an integer <code>target</code>, return the number of&nbsp;tuples&nbsp;<code>i, j, k</code>&nbsp; such that <code>i &lt; j &lt; k</code> and&nbsp;<code>A[i] + A[j] + A[k] == target</code>.</p>\r\n\r\n<p><strong>As the answer can be very large, return it modulo&nbsp;<code>10^9 + 7</code></strong>.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>A = <span id=\"example-input-1-1\">[1,1,2,2,3,3,4,4,5,5]</span>, target = <span id=\"example-input-1-2\">8</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">20</span>\r\n<strong>Explanation: </strong>\r\nEnumerating by the values (A[i], A[j], A[k]):\r\n(1, 2, 5) occurs 8 times;\r\n(1, 3, 4) occurs 8 times;\r\n(2, 2, 4) occurs 2 times;\r\n(2, 3, 3) occurs 2 times.\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>A = <span id=\"example-input-2-1\">[1,1,2,2,2,2]</span>, target = <span id=\"example-input-2-2\">5</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">12</span>\r\n<strong>Explanation: </strong>\r\nA[i] = 1, A[j] = A[k] = 2 occurs 12 times:\r\nWe choose one 1 from [1,1] in 2 ways,\r\nand two 2s from [2,2,2,2] in 6 ways.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n</div>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>3 &lt;= A.length &lt;= 3000</code></li>\r\n\t<li><code>0 &lt;= A[i] &lt;= 100</code></li>\r\n\t<li><code>0 &lt;= target &lt;= 300</code></li>\r\n</ol>\r\n",
    "tags": "",
    "difficulty": 2,
    "frontend_article_id": 923,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-notes\">Approach Notes</a></li> \n      <li><a href=\"#approach-1-three-pointer\">Approach 1: Three Pointer</a></li> \n      <li><a href=\"#approach-2-counting-with-cases\">Approach 2: Counting with Cases</a></li> \n      <li><a href=\"#approach-3-adapt-from-three-sum\">Approach 3: Adapt from Three Sum</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-notes\">Approach Notes</h4> \n  <p>The approaches described below assume some familiarity with the two pointer technique that can be used to solve the LeetCode problem \"Two Sum\".</p> \n  <p>In the problem, we have a sorted array <code>A</code> of unique elements, and want to know how many <code>i &lt; j</code> with <code>A[i] + A[j] == target</code>.</p> \n  <p>The idea that does it in linear time, is that for each <code>i</code> in increasing order, the <code>j</code>'s that satisfy the equation <code>A[i] + A[j] == target</code> are decreasing.</p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"k\">def</span> <span class=\"nf\">solve</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">,</span> <span class=\"n\">target</span><span class=\"p\">):</span>\n    <span class=\"c1\"># Assume A already sorted</span>\n    <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"mi\">1</span>\n    <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n    <span class=\"k\">while</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">j</span><span class=\"p\">:</span>\n        <span class=\"k\">if</span> <span class=\"n\">A</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">A</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">]</span> <span class=\"o\">&lt;</span> <span class=\"n\">target</span><span class=\"p\">:</span>\n            <span class=\"n\">i</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n        <span class=\"k\">elif</span> <span class=\"n\">A</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">A</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">]</span> <span class=\"o\">&gt;</span> <span class=\"n\">target</span><span class=\"p\">:</span>\n            <span class=\"n\">j</span> <span class=\"o\">-=</span> <span class=\"mi\">1</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"n\">ans</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n            <span class=\"n\">i</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n            <span class=\"n\">j</span> <span class=\"o\">-=</span> <span class=\"mi\">1</span>\n    <span class=\"k\">return</span> <span class=\"n\">ans</span>\n</pre>\n  </div> \n  <p>This is not a complete explanation. For more on this problem, please review the LeetCode problem \"Two Sum\".</p> \n  <hr> \n  <h4 id=\"approach-1-three-pointer\">Approach 1: Three Pointer</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Sort the array. For each <code>i</code>, set <code>T = target - A[i]</code>, the remaining target. We can try using a two-pointer technique to find <code>A[j] + A[k] == T</code>. This approach is the natural continuation of trying to make the two-pointer technique we know from previous problems, work on this problem.</p> \n  <p>Because some elements are duplicated, we have to be careful. In a typical case, the target is say, <code>8</code>, and we have a remaining array (<code>A[i+1:]</code>) of <code>[2,2,2,2,3,3,4,4,4,5,5,5,6,6]</code>. We can analyze this situation with cases.</p> \n  <p>Whenever <code>A[j] + A[k] == T</code>, we should count the multiplicity of <code>A[j]</code> and <code>A[k]</code>. In this example, if <code>A[j] == 2</code> and <code>A[k] == 6</code>, the multiplicities are <code>4</code> and <code>2</code>, and the total number of pairs is <code>4 * 2 = 8</code>. We then move to the remaining window <code>A[j:k+1]</code> of <code>[3,3,4,4,4,5,5,5]</code>.</p> \n  <p>As a special case, if <code>A[j] == A[k]</code>, then our manner of counting would be incorrect. If for example the remaining window is <code>[4,4,4]</code>, there are only 3 such pairs. In general, when <code>A[j] == A[k]</code>, we have <script type=\"math/tex; mode=display\">\\binom{M}{2} = \\frac{M*(M-1)}{2}</script> pairs <code>(j,k)</code> (with <code>j &lt; k</code>) that satisfy <code>A[j] + A[k] == T</code>, where <script type=\"math/tex; mode=display\">M</script> is the multiplicity of <code>A[j]</code> (in this case <script type=\"math/tex; mode=display\">M=3</script>).</p> \n  <p>For more details, please see the inline comments.</p> \n  <iframe src=\"https://leetcode.com/playground/TCrTgDfK/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"TCrTgDfK\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>A</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-counting-with-cases\">Approach 2: Counting with Cases</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Let <code>count[x]</code> be the number of times that <code>x</code> occurs in <code>A</code>. For every <code>x+y+z == target</code>, we can try to count the correct contribution to the answer. There are a few cases:</p> \n  <ul> \n   <li> <p>If <code>x</code>, <code>y</code>, and <code>z</code> are all different, then the contribution is <code>count[x] * count[y] * count[z]</code>.</p> </li> \n   <li> <p>If <code>x == y != z</code>, the contribution is <script type=\"math/tex; mode=display\">\\binom{\\text{count[x]}}{2} * \\text{count[z]}</script>.</p> </li> \n   <li> <p>If <code>x != y == z</code>, the contribution is <script type=\"math/tex; mode=display\">\\text{count[x]} * \\binom{\\text{count[y]}}{2}</script>.</p> </li> \n   <li> <p>If <code>x == y == z</code>, the contribution is <script type=\"math/tex; mode=display\">\\binom{\\text{count[x]}}{3}</script>.</p> </li> \n  </ul> \n  <p>(<em>Here, <script type=\"math/tex; mode=display\">\\binom{n}{k}</script> denotes the binomial coefficient <script type=\"math/tex; mode=display\">\\frac{n!}{(n-k)!k!}</script>.</em>)</p> \n  <p>Each case is commented in the implementations below.</p> \n  <iframe src=\"https://leetcode.com/playground/9nU5mTcv/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"9nU5mTcv\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N + W^2)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>A</code>, and <script type=\"math/tex; mode=display\">W</script> is the maximum possible value of <code>A[i]</code>. (Note that this solution can be adapted to be <script type=\"math/tex; mode=display\">O(N^2)</script> even in the case that <script type=\"math/tex; mode=display\">W</script> is very large.)</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(W)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-adapt-from-three-sum\">Approach 3: Adapt from Three Sum</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>As in <em>Approach 2</em>, let <code>count[x]</code> be the number of times that <code>x</code> occurs in <code>A</code>. Also, let <code>keys</code> be a sorted list of unique values of <code>A</code>. We will try to adapt a 3Sum algorithm to work on <code>keys</code>, but add the correct answer contributions.</p> \n  <p>For example, if <code>A = [1,1,2,2,3,3,4,4,5,5]</code> and <code>target = 8</code>, then <code>keys = [1,2,3,4,5]</code>. When doing 3Sum on <code>keys</code> (with <code>i &lt;= j &lt;= k</code>), we will encounter some tuples that sum to the target, like <code>(x,y,z) = (1,2,5), (1,3,4), (2,2,4), (2,3,3)</code>. We can then use <code>count</code> to calculate how many such tuples there are in each case.</p> \n  <p>This approach assumes familiarity with <em>3Sum</em>. For more, please visit the associated LeetCode problem here <a href=\"https://leetcode.com/problems/3sum\">https://leetcode.com/problems/3sum</a>.</p> \n  <iframe src=\"https://leetcode.com/playground/Ph3ok9qb/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"Ph3ok9qb\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>A</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 922,
    "article_live": true,
    "article_slug": "sort-array-by-parity-ii",
    "title": "Sort Array By Parity II",
    "title_slug": "sort-array-by-parity-ii",
    "content": "<p>Given an array <code>A</code>&nbsp;of non-negative integers, half of the integers in A are odd, and half of the integers are even.</p>\r\n\r\n<p>Sort the array so that whenever <code>A[i]</code> is odd, <code>i</code> is odd; and whenever <code>A[i]</code> is even, <code>i</code> is even.</p>\r\n\r\n<p>You may return any answer array that satisfies this condition.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[4,2,5,7]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">[4,5,2,7]</span>\r\n<strong>Explanation: </strong>[4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>2 &lt;= A.length &lt;= 20000</code></li>\r\n\t<li><code>A.length % 2 == 0</code></li>\r\n\t<li><code>0 &lt;= A[i] &lt;= 1000</code></li>\r\n</ol>\r\n\r\n<div>\r\n<p>&nbsp;</p>\r\n</div>\r\n",
    "tags": "",
    "difficulty": 1,
    "frontend_article_id": 922,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-two-pass\">Approach 1: Two Pass</a></li> \n      <li><a href=\"#approach-2-read-write-heads\">Approach 2: Read / Write Heads</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-two-pass\">Approach 1: Two Pass</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Read all the even integers and put them into places <code>ans[0]</code>, <code>ans[2]</code>, <code>ans[4]</code>, and so on.</p> \n  <p>Then, read all the odd integers and put them into places <code>ans[1]</code>, <code>ans[3]</code>, <code>ans[5]</code>, etc.</p> \n  <iframe src=\"https://leetcode.com/playground/sV3wKPcR/shared\" frameborder=\"0\" width=\"100%\" height=\"429\" name=\"sV3wKPcR\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>A</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-read-write-heads\">Approach 2: Read / Write Heads</h4> \n  <p><strong>Intuition</strong></p> \n  <p>We are motivated (perhaps by the interviewer) to pursue a solution where we modify the original array <code>A</code> in place.</p> \n  <p>First, it is enough to put all even elements in the correct place, since all odd elements will be in the correct place too. So let's only focus on <code>A[0], A[2], A[4], ...</code></p> \n  <p>Ideally, we would like to have some partition where everything to the left is already correct, and everything to the right is undecided.</p> \n  <p>Indeed, this idea works if we separate it into two slices <code>even = A[0], A[2], A[4], ...</code> and <code>odd = A[1], A[3], A[5], ...</code>. Our invariant will be that everything less than <code>i</code> in the even slice is correct, and everything less than <code>j</code> in the odd slice is correct.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>For each even <code>i</code>, let's make <code>A[i]</code> even. To do it, we will draft an element from the odd slice. We pass <code>j</code> through the odd slice until we find an even element, then swap. Our invariant is maintained, so the algorithm is correct.</p> \n  <iframe src=\"https://leetcode.com/playground/aWm3c7PK/shared\" frameborder=\"0\" width=\"100%\" height=\"344\" name=\"aWm3c7PK\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>A</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 921,
    "article_live": true,
    "article_slug": "minimum-add-to-make-parentheses-valid",
    "title": "Minimum Add to Make Parentheses Valid",
    "title_slug": "minimum-add-to-make-parentheses-valid",
    "content": "<p>Given a string&nbsp;<code>S</code> of <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code> parentheses, we add the minimum number of parentheses ( <code>&#39;(&#39;</code> or <code>&#39;)&#39;</code>, and in any positions ) so that the resulting parentheses string is valid.</p>\r\n\r\n<p>Formally, a parentheses string is valid if and only if:</p>\r\n\r\n<ul>\r\n\t<li>It is the empty string, or</li>\r\n\t<li>It can be written as <code>AB</code>&nbsp;(<code>A</code> concatenated with <code>B</code>), where <code>A</code> and <code>B</code> are valid strings, or</li>\r\n\t<li>It can be written as <code>(A)</code>, where <code>A</code> is a valid string.</li>\r\n</ul>\r\n\r\n<p>Given a parentheses string, return the minimum number of parentheses we must add to make the resulting string valid.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">&quot;())&quot;</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">1</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">&quot;(((&quot;</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">3</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-3-1\">&quot;()&quot;</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">0</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 4:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-4-1\">&quot;()))((&quot;</span>\r\n<strong>Output: </strong><span id=\"example-output-4\">4</span></pre>\r\n\r\n<p>&nbsp;</p>\r\n</div>\r\n</div>\r\n</div>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>S.length &lt;= 1000</code></li>\r\n\t<li><code>S</code> only consists of <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code> characters.</li>\r\n</ol>\r\n\r\n<div>\r\n<div>\r\n<div>\r\n<div>&nbsp;</div>\r\n</div>\r\n</div>\r\n</div>\r\n",
    "tags": "",
    "difficulty": 2,
    "frontend_article_id": 921,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-balance\">Approach 1: Balance</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-balance\">Approach 1: Balance</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Keep track of the <em>balance</em> of the string: the number of <code>'('</code>'s minus the number of <code>')'</code>'s. A string is valid if its balance is 0, plus every prefix has non-negative balance.</p> \n  <p>The above idea is common with matching brackets problems, but could be difficult to find if you haven't seen it before.</p> \n  <p>Now, consider the balance of every prefix of <code>S</code>. If it is ever negative (say, -1), we must add a '(' bracket. Also, if the balance of <code>S</code> is positive (say, <code>+B</code>), we must add <code>B</code> ')' brackets at the end.</p> \n  <iframe src=\"https://leetcode.com/playground/mbE7BCSV/shared\" frameborder=\"0\" width=\"100%\" height=\"310\" name=\"mbE7BCSV\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>S</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 920,
    "article_live": true,
    "article_slug": "number-of-music-playlists",
    "title": "Number of Music Playlists",
    "title_slug": "number-of-music-playlists",
    "content": "<p>Your music player contains <code>N</code>&nbsp;different songs and she wants to listen to <code>L</code><strong> </strong>(not necessarily different) songs during your trip. &nbsp;You&nbsp;create&nbsp;a playlist so&nbsp;that:</p>\r\n\r\n<ul>\r\n\t<li>Every song is played at least once</li>\r\n\t<li>A song can only be played again only if&nbsp;<code>K</code>&nbsp;other songs have been played</li>\r\n</ul>\r\n\r\n<p>Return the number of possible playlists.&nbsp; <strong>As the answer can be very large, return it modulo <code>10^9 + 7</code></strong>.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<div>\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>N = <span id=\"example-input-1-1\">3</span>, L = <span id=\"example-input-1-2\">3</span>, K = <span id=\"example-input-1-3\">1</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">6\r\n<strong>Explanation</strong>: </span><span>There are 6 possible playlists. [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1].</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>N = <span id=\"example-input-2-1\">2</span>, L = <span id=\"example-input-2-2\">3</span>, K = <span id=\"example-input-2-3\">0</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">6\r\n</span><span id=\"example-output-1\"><strong>Explanation</strong>: </span><span>There are 6 possible playlists. [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2, 1], [2, 1, 2], [1, 2, 2]</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>N = <span id=\"example-input-3-1\">2</span>, L = <span id=\"example-input-3-2\">3</span>, K = <span id=\"example-input-3-3\">1</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">2\r\n<strong>Explanation</strong>: </span><span>There are 2 possible playlists. [1, 2, 1], [2, 1, 2]</span>\r\n</pre>\r\n</div>\r\n</div>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>0 &lt;= K &lt; N &lt;= L &lt;= 100</code></li>\r\n</ol>\r\n</div>\r\n</div>\r\n</div>\r\n",
    "tags": "",
    "difficulty": 3,
    "frontend_article_id": 920,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-dynamic-programming\">Approach 1: Dynamic Programming</a></li> \n      <li><a href=\"#approach-2-partitions-dynamic-programming\">Approach 2: Partitions + Dynamic Programming</a></li> \n      <li><a href=\"#approach-3-generating-functions\">Approach 3: Generating Functions</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-dynamic-programming\">Approach 1: Dynamic Programming</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Let <code>dp[i][j]</code> be the number of playlists of length <code>i</code> that have exactly <code>j</code> unique songs. We want <code>dp[L][N]</code>, and it seems likely we can develop a recurrence for <code>dp</code>.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Consider <code>dp[i][j]</code>. Last song, we either played a song for the first time or we didn't. If we did, then we had <code>dp[i-1][j-1] * (N-j)</code> ways to choose it. If we didn't, then we repeated a previous song in <code>dp[i-1][j] * max(j-K, 0)</code> ways (<code>j</code> of them, except the last <code>K</code> ones played are banned.)</p> \n  <iframe src=\"https://leetcode.com/playground/9tJ8LAAB/shared\" frameborder=\"0\" width=\"100%\" height=\"327\" name=\"9tJ8LAAB\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(NL)</script>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(NL)</script>. (However, we can adapt this algorithm to only store the last row of <code>dp</code> to easily get <script type=\"math/tex; mode=display\">O(L)</script> space complexity.) <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-partitions-dynamic-programming\">Approach 2: Partitions + Dynamic Programming</h4> \n  <p>(<em>Note: This solution is extremely challenging, but is a natural consequence of trying to enumerate the playlists in this manner.</em>)</p> \n  <p><strong>Intuition</strong></p> \n  <p>Since we are interested in playing every song at least once, let's keep track of what times <script type=\"math/tex; mode=display\">x = (x_1, x_2, \\cdots)</script> a song was played that wasn't yet played before. For example, if we have 5 songs <code>abcde</code>, and we play <code>abacabdcbaeacbd</code>, then <script type=\"math/tex; mode=display\">x = (1, 2, 4, 7, 11)</script> as these are the first occurrences of a unique song. For convenience, we'll also put <script type=\"math/tex; mode=display\">x_{N+1} = L+1</script>. Our strategy is to count the number of playlists <script type=\"math/tex; mode=display\">\\#_x</script> that satisfy this <script type=\"math/tex; mode=display\">x</script>, so that our final answer will be <script type=\"math/tex; mode=display\">\\sum \\#_x</script>. </p> \n  <p>Doing a direct count,</p> \n  <p> <script type=\"math/tex; mode=display\">\n\\#_x = N * (N-1) * \\cdots * (N-K+1) 1^{x_{K+1} - x_K - 1} * (N-K+2)  2^{x_{K+2} - x_{K+1}} * \\cdots\n</script> </p> \n  <p> <script type=\"math/tex; mode=display\">\n\\Rightarrow \\#_x = N! \\prod_{j=1}^{N-K+1} j^{x_{K+j} - x_{K+j-1} - 1}\n</script> </p> \n  <p>Now, let <script type=\"math/tex; mode=display\">\\delta_i = x_{K+i} - x_{K+i-1} - 1</script>, so that <script type=\"math/tex; mode=display\">\\sum \\delta_i = L-N</script>. To recap, the final answer will be (for <script type=\"math/tex; mode=display\">S = L-N, P = N-K+1</script>):</p> \n  <p> <script type=\"math/tex; mode=display\">\nN! \\Big(\\sum\\limits_{\\delta : \\sum\\limits_{0 \\leq i \\leq P} \\delta_i = S} \\prod\\limits_{j=1}^P j^{\\delta_j} \\Big)\n</script> </p> \n  <p>For convenience, let's denote the stuff in the large brackets as <script type=\"math/tex; mode=display\">\\langle S, P\\rangle</script>.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>We can develop a recurrence for <script type=\"math/tex; mode=display\">\\langle S, P\\rangle</script> mathematically, by factoring out the <script type=\"math/tex; mode=display\">P^{\\delta_P}</script> term.</p> \n  <p> <script type=\"math/tex; mode=display\">\n\\langle S, P\\rangle = \\sum_{\\delta_P = 0}^S P^{\\delta_P} \\sum_{\\sum\\limits_{0\\leq i < P} \\delta_i = S - \\delta_P} \\prod\\limits_{j=1}^{P-1} j^{\\delta_j}\n</script> </p> \n  <p> <script type=\"math/tex; mode=display\">\n\\Rightarrow \\langle S, P\\rangle = \\sum_{\\delta_P = 0}^S P^{\\delta_P} \\langle S - \\delta_P, P-1\\rangle\n</script> </p> \n  <p>so that it can be shown through algebraic manipulation that: <script type=\"math/tex; mode=display\">\n\\langle S, P \\rangle = P \\langle S-1, P-1 \\rangle + \\langle S, P-1 \\rangle\n</script> </p> \n  <p>With this recurrence, we can perform dynamic programming similar to Approach 1. The final answer is <script type=\"math/tex; mode=display\">N! \\langle L-N, N-K+1 \\rangle</script>.</p> \n  <iframe src=\"https://leetcode.com/playground/KdGurUUX/shared\" frameborder=\"0\" width=\"100%\" height=\"395\" name=\"KdGurUUX\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(NL)</script>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(L)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-generating-functions\">Approach 3: Generating Functions</h4> \n  <p>(<em>Note: This solution is extremely challenging and not recommended for interviews, but is included here for completeness.</em>)</p> \n  <p><strong>Analysis</strong></p> \n  <p>Following the terminology of Approach 2, we would like to compute <script type=\"math/tex; mode=display\">\\langle S, P \\rangle</script> quickly. We can use generating functions.</p> \n  <p>For a fixed <script type=\"math/tex; mode=display\">P</script>, consider the function:</p> \n  <p> <script type=\"math/tex; mode=display\">\nf(x) = (1^0x^0 + 1^1x^1 + 1^2x^2 + 1^3x^3 + \\cdots) * (2^0x^0 + 2^1x^1 + 2^2x^2 + 2^3x^3 + \\cdots)\n</script> <script type=\"math/tex; mode=display\">\n\\cdots * (P^0x^0 + P^1x^1 + P^2x^2 + P^3x^3 + \\cdots)\n</script> </p> \n  <p> <script type=\"math/tex; mode=display\">\n\\Leftrightarrow f(x) = \\prod_{k=1}^{P} (\\sum_{j \\geq 0} k^j x^j) = \\prod_{k=1}^P \\frac{1}{1-kx}\n</script> </p> \n  <p>The coefficient of <script type=\"math/tex; mode=display\">x^S</script> in <script type=\"math/tex; mode=display\">f</script> (denoted <script type=\"math/tex; mode=display\">[x^S]f</script>) is the desired <script type=\"math/tex; mode=display\">\\langle S, P \\rangle</script>.</p> \n  <p>By the Chinese Remainder theorem on polynomials, this product can be written as a partial fraction decomposition:</p> \n  <p> <script type=\"math/tex; mode=display\">\n\\prod_{k=1}^P \\frac{1}{1-kx} = \\sum_{k=1}^P \\frac{A_k}{1-kx}\n</script> </p> \n  <p>for some rational coefficients <script type=\"math/tex; mode=display\">A_k</script>. We can solve for these coefficients by clearing denominators and setting <script type=\"math/tex; mode=display\">x = 1/m</script> for <script type=\"math/tex; mode=display\">1 \\leq m \\leq P</script>. Then for a given <script type=\"math/tex; mode=display\">m</script>, all the terms except the <script type=\"math/tex; mode=display\">m</script>-th vanish, and:</p> \n  <p> <script type=\"math/tex; mode=display\">\nA_m = \\frac{1}{\\prod\\limits_{\\substack{1 \\leq j \\leq P\\\\j \\neq m}} 1 - j/m} = \\prod_{j \\neq m} \\frac{m}{m-j}\n</script> </p> \n  <p>Since a geometric series has sum <script type=\"math/tex; mode=display\">\\sum_{j \\geq 0} (kx)^j = \\frac{1}{1-kx}</script>, altogether it implies:</p> \n  <p> <script type=\"math/tex; mode=display\">\n[x^S]f = \\sum_{k=1}^P A_k * k^S\n</script> </p> \n  <p>so that the final answer is</p> \n  <p> <script type=\"math/tex; mode=display\">\n\\text{answer} = N! \\sum_{k=1}^{N-K} k^{L-N} \\prod_{\\substack{1 \\leq j \\leq N-K\\\\j \\neq k}} \\frac{k}{k-j}\n</script> </p> \n  <p> <script type=\"math/tex; mode=display\">\n\\Rightarrow \\text{answer} = N! \\sum_k k^{L-K-1} \\prod_{j \\neq k} \\frac{1}{k-j}\n</script> </p> \n  <p>We only need a quick way to compute <script type=\"math/tex; mode=display\">C_k = \\prod\\limits_{j \\neq k} \\frac{1}{k-j}</script>. Indeed,</p> \n  <p> <script type=\"math/tex; mode=display\">\nC_{k+1} = C_k * \\frac{k - (N-K)}{k}\n</script> </p> \n  <p>so that we now have everything we need to compute the answer quickly.</p> \n  <iframe src=\"https://leetcode.com/playground/ypP5xqYU/shared\" frameborder=\"0\" width=\"100%\" height=\"395\" name=\"ypP5xqYU\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N \\log L)</script>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 919,
    "article_live": true,
    "article_slug": "complete-binary-tree-inserter",
    "title": "Complete Binary Tree Inserter",
    "title_slug": "complete-binary-tree-inserter",
    "content": "<p>A <em>complete</em> binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible.</p>\r\n\r\n<p>Write a data structure&nbsp;<code>CBTInserter</code>&nbsp;that is initialized with a complete binary tree and supports the following operations:</p>\r\n\r\n<ul>\r\n\t<li><code>CBTInserter(TreeNode root)</code> initializes the data structure on a given tree&nbsp;with head node <code>root</code>;</li>\r\n\t<li><code>CBTInserter.insert(int v)</code> will insert a <code>TreeNode</code>&nbsp;into the tree with value <code>node.val =&nbsp;v</code>&nbsp;so that the tree remains complete, <strong>and returns the value of the parent of the inserted <code>TreeNode</code></strong>;</li>\r\n\t<li><code>CBTInserter.get_root()</code> will return the head node of the tree.</li>\r\n</ul>\r\n\r\n<ol>\r\n</ol>\r\n\r\n<div>\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>inputs = <span id=\"example-input-1-1\">[&quot;CBTInserter&quot;,&quot;insert&quot;,&quot;get_root&quot;]</span>, inputs = <span id=\"example-input-1-2\">[[[1]],[2],[]]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">[null,1,[1,2]]</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>inputs = <span id=\"example-input-2-1\">[&quot;CBTInserter&quot;,&quot;insert&quot;,&quot;insert&quot;,&quot;get_root&quot;]</span>, inputs = <span id=\"example-input-2-2\">[[[1,2,3,4,5,6]],[7],[8],[]]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">[null,3,4,[1,2,3,4,5,6,7,8]]</span></pre>\r\n</div>\r\n\r\n<div>\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li>The initial given tree is complete and contains between <code>1</code> and <code>1000</code> nodes.</li>\r\n\t<li><code>CBTInserter.insert</code> is called at most <code>10000</code> times per test case.</li>\r\n\t<li>Every value of a given or inserted node is between <code>0</code> and <code>5000</code>.</li>\r\n</ol>\r\n</div>\r\n</div>\r\n\r\n<div>\r\n<p>&nbsp;</p>\r\n\r\n<div>&nbsp;</div>\r\n</div>\r\n",
    "tags": "",
    "difficulty": 2,
    "frontend_article_id": 919,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-deque\">Approach 1: Deque</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-deque\">Approach 1: Deque</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Consider all the nodes numbered first by level and then left to right. Call this the \"number order\" of the nodes.</p> \n  <p>At each insertion step, we want to insert into the node with the lowest number (that still has 0 or 1 children).</p> \n  <p>By maintaining a <code>deque</code> (double ended queue) of these nodes in number order, we can solve the problem. After inserting a node, that node now has the highest number and no children, so it goes at the end of the deque. To get the node with the lowest number, we pop from the beginning of the deque.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>First, perform a breadth-first search to populate the <code>deque</code> with nodes that have 0 or 1 children, in number order.</p> \n  <p>Now when inserting a node, the parent is the first element of <code>deque</code>, and we add this new node to our <code>deque</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/vJC78XQe/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"vJC78XQe\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: The preprocessing is <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of nodes in the tree. Each insertion operation thereafter is <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N_{\\text{cur}})</script> space complexity, when the size of the tree during the current insertion operation is <script type=\"math/tex; mode=display\">N_{\\text{cur}}</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 918,
    "article_live": true,
    "article_slug": "maximum-sub-circular-subarray",
    "title": "Maximum Sum Circular Subarray",
    "title_slug": "maximum-sum-circular-subarray",
    "content": "<p>Given a <strong>circular&nbsp;array</strong>&nbsp;<strong>C</strong> of integers represented by&nbsp;<code>A</code>, find the maximum possible sum of a non-empty subarray of <strong>C</strong>.</p>\r\n\r\n<p>Here, a&nbsp;<em>circular&nbsp;array</em> means the end of the array connects to the beginning of the array.&nbsp; (Formally, <code>C[i] = A[i]</code> when <code>0 &lt;= i &lt; A.length</code>, and <code>C[i+A.length] = C[i]</code>&nbsp;when&nbsp;<code>i &gt;= 0</code>.)</p>\r\n\r\n<p>Also, a subarray may only include each element of the fixed buffer <code>A</code> at most once.&nbsp; (Formally, for a subarray <code>C[i], C[i+1], ..., C[j]</code>, there does not exist <code>i &lt;= k1, k2 &lt;= j</code> with <code>k1 % A.length&nbsp;= k2 % A.length</code>.)</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[1,-2,3,-2]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">3\r\n<strong>Explanation: </strong>Subarray [3] has maximum sum 3</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">[5,-3,5]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">10\r\n</span><span id=\"example-output-3\"><strong>Explanation:</strong>&nbsp;</span><span id=\"example-output-1\">Subarray [5,5] has maximum sum </span><span>5 + 5 = 10</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-3-1\">[3,-1,2,-1]</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">4\r\n<strong>Explanation:</strong>&nbsp;</span><span id=\"example-output-1\">Subarray [2,-1,3] has maximum sum </span><span>2 + (-1) + 3 = 4</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 4:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-4-1\">[3,-2,2,-3]</span>\r\n<strong>Output: </strong><span id=\"example-output-4\">3\r\n</span><span id=\"example-output-3\"><strong>Explanation:</strong>&nbsp;</span><span id=\"example-output-1\">Subarray [3] and [3,-2,2] both have maximum sum </span><span>3</span>\r\n</pre>\r\n\r\n<p><strong>Example 5:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-5-1\">[-2,-3,-1]</span>\r\n<strong>Output: </strong><span id=\"example-output-5\">-1\r\n</span><span id=\"example-output-3\"><strong>Explanation:</strong>&nbsp;</span><span id=\"example-output-1\">Subarray [-1] has maximum sum -1</span>\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note: </strong></p>\r\n\r\n<ol>\r\n\t<li><code>-30000 &lt;= A[i] &lt;= 30000</code></li>\r\n\t<li><code>1 &lt;= A.length &lt;= 30000</code></li>\r\n</ol>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n",
    "tags": "",
    "difficulty": 2,
    "frontend_article_id": 918,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#notes-and-a-primer-on-kadanes-algorithm\">Notes and A Primer on Kadane's Algorithm</a></li> \n      <li><a href=\"#approach-1-next-array\">Approach 1: Next Array</a></li> \n      <li><a href=\"#approach-2-prefix-sums-monoqueue\">Approach 2: Prefix Sums + Monoqueue</a></li> \n      <li><a href=\"#approach-3-kadanes-sign-variant\">Approach 3: Kadane's (Sign Variant)</a></li> \n      <li><a href=\"#approach-4-kadanes-min-variant\">Approach 4: Kadane's (Min Variant)</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"notes-and-a-primer-on-kadanes-algorithm\">Notes and A Primer on Kadane's Algorithm</h4> \n  <p><strong>About the Approaches</strong></p> \n  <p>In both Approach 1 and Approach 2, \"grindy\" solutions are presented that require less insight, but may be more intuitive to those with a solid grasp of the techniques in those approaches. Without prior experience, these approaches would be very challenging to emulate.</p> \n  <p>Approaches 3 and 4 are much easier to implement, but require some insight.</p> \n  <p><strong>Explanation of Kadane's Algorithm</strong></p> \n  <p>To understand the solutions in this article, we need some familiarity with Kadane's algorithm. In this section, we will explain the core idea behind it.</p> \n  <p>For a given array <code>A</code>, Kadane's algorithm can be used to find the maximum sum of the subarrays of <code>A</code>. Here, we only consider non-empty subarrays.</p> \n  <p>Kadane's algorithm is based on dynamic programming. Let <code>dp[j]</code> be the maximum sum of a subarray that ends in <code>A[j]</code>. That is,</p> \n  <p> <script type=\"math/tex; mode=display\">\n\\text{dp}[j] = \\max\\limits_i (A[i] + A[i+1] + \\cdots + A[j])\n</script> </p> \n  <p>Then, a subarray ending in <code>j+1</code> (such as <code>A[i], A[i+1] + ... + A[j+1]</code>) maximizes the <code>A[i] + ... + A[j]</code> part of the sum by being equal to <code>dp[j]</code> if it is non-empty, and <code>0</code> if it is. Thus, we have the recurrence:</p> \n  <p> <script type=\"math/tex; mode=display\">\n\\text{dp}[j+1] = A[j+1] + \\max(\\text{dp}[j], 0)\n</script> </p> \n  <p>Since a subarray must end somewhere, <script type=\"math/tex; mode=display\">\\max\\limits_j dp[j]</script> must be the desired answer.</p> \n  <p>To compute <code>dp</code> efficiently, Kadane's algorithm is usually written in the form that reduces space complexity. We maintain two variables: <code>ans</code> as <script type=\"math/tex; mode=display\">\\max\\limits_j dp[j]</script>, and <code>cur</code> as <script type=\"math/tex; mode=display\">dp[j]</script>; and update them as <script type=\"math/tex; mode=display\">j</script> iterates from <script type=\"math/tex; mode=display\">0</script> to <script type=\"math/tex; mode=display\">A\\text{.length} - 1</script>.</p> \n  <p>Then, Kadane's algorithm is given by the following psuedocode:</p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"c1\">#Kadane's algorithm</span>\n<span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"n\">cur</span> <span class=\"o\">=</span> <span class=\"bp\">None</span>\n<span class=\"k\">for</span> <span class=\"n\">x</span> <span class=\"ow\">in</span> <span class=\"n\">A</span><span class=\"p\">:</span>\n    <span class=\"n\">cur</span> <span class=\"o\">=</span> <span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">cur</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">ans</span><span class=\"p\">,</span> <span class=\"n\">cur</span><span class=\"p\">)</span>\n<span class=\"k\">return</span> <span class=\"n\">ans</span>\n</pre>\n  </div> \n  <hr> \n  <h4 id=\"approach-1-next-array\">Approach 1: Next Array</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Subarrays of circular arrays can be classified as either as <em>one-interval</em> subarrays, or <em>two-interval</em> subarrays, depending on how many intervals of the fixed-size buffer <code>A</code> are required to represent them.</p> \n  <p>For example, if <code>A = [0, 1, 2, 3, 4, 5, 6]</code> is the underlying buffer of our circular array, we could represent the subarray <code>[2, 3, 4]</code> as one interval <script type=\"math/tex; mode=display\">[2, 4]</script>, but we would represent the subarray <code>[5, 6, 0, 1]</code> as two intervals <script type=\"math/tex; mode=display\">[5, 6], [0, 1]</script>.</p> \n  <p>Using Kadane's algorithm, we know how to get the maximum of <em>one-interval</em> subarrays, so it only remains to consider <em>two-interval</em> subarrays.</p> \n  <p>Let's say the intervals are <script type=\"math/tex; mode=display\">[0, i], [j, A\\text{.length} - 1]</script>. Let's try to compute the <em>i-th candidate</em>: the largest possible sum of a two-interval subarray for a given <script type=\"math/tex; mode=display\">i</script>. Computing the <script type=\"math/tex; mode=display\">[0, i]</script> part of the sum is easy. Let's write</p> \n  <p> <script type=\"math/tex; mode=display\">\nT_j = A[j] + A[j+1] + \\cdots + A[A\\text{.length} - 1]\n</script> </p> \n  <p>and</p> \n  <p> <script type=\"math/tex; mode=display\">\nR_j = \\max\\limits_{k \\geq j} T_k\n</script> </p> \n  <p>so that the desired i-th candidate is:</p> \n  <p> <script type=\"math/tex; mode=display\">\n(A[0] + A[1] + \\cdots + A[i]) + R_{i+2}\n</script> </p> \n  <p>Since we can compute <script type=\"math/tex; mode=display\">T_j</script> and <script type=\"math/tex; mode=display\">R_j</script> in linear time, the answer is straightforward after this setup.</p> \n  <iframe src=\"https://leetcode.com/playground/N59534xu/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"N59534xu\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>A</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-prefix-sums-monoqueue\">Approach 2: Prefix Sums + Monoqueue</h4> \n  <p><strong>Intuition</strong></p> \n  <p>First, we can frame the problem as a problem on a fixed array.</p> \n  <p>We can consider any subarray of the circular array with buffer <code>A</code>, to be a subarray of the fixed array <code>A+A</code>.</p> \n  <p>For example, if <code>A = [0,1,2,3,4,5]</code> represents a circular array, then the subarray <code>[4,5,0,1]</code> is also a subarray of fixed array <code>[0,1,2,3,4,5,0,1,2,3,4,5]</code>. Let <code>B = A+A</code> be this fixed array.</p> \n  <p>Now say <script type=\"math/tex; mode=display\">N = A\\text{.length}</script>, and consider the prefix sums</p> \n  <p> <script type=\"math/tex; mode=display\">\nP_k = B[0] + B[1] + \\cdots + B[k-1]\n</script> </p> \n  <p>Then, we want the largest <script type=\"math/tex; mode=display\">P_j - P_i</script> where <script type=\"math/tex; mode=display\">j - i \\leq N</script>.</p> \n  <p>Now, consider the j-th candidate answer: the best possible <script type=\"math/tex; mode=display\">P_j - P_i</script> for a fixed <script type=\"math/tex; mode=display\">j</script>. We want the <script type=\"math/tex; mode=display\">i</script> so that <script type=\"math/tex; mode=display\">P_i</script> is smallest, with <script type=\"math/tex; mode=display\">j - N \\leq i < j</script>. Let's call this the <em>optimal i for the j-th candidate answer</em>. We can use a monoqueue to manage this.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Iterate forwards through <script type=\"math/tex; mode=display\">j</script>, computing the <script type=\"math/tex; mode=display\">j</script>-th candidate answer at each step. We'll maintain a <code>queue</code> of potentially optimal <script type=\"math/tex; mode=display\">i</script>'s.</p> \n  <p>The main idea is that if <script type=\"math/tex; mode=display\">i_1 < i_2</script> and <script type=\"math/tex; mode=display\">P_{i_1} \\geq P_{i_2}</script>, then we don't need to remember <script type=\"math/tex; mode=display\">i_1</script> anymore.</p> \n  <p>Please see the inline comments for more algorithmic details about managing the queue.</p> \n  <iframe src=\"https://leetcode.com/playground/qZ9ttQZM/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"qZ9ttQZM\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>A</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-kadanes-sign-variant\">Approach 3: Kadane's (Sign Variant)</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>As in Approach 1, subarrays of circular arrays can be classified as either as <em>one-interval</em> subarrays, or <em>two-interval</em> subarrays.</p> \n  <p>Using Kadane's algorithm <code>kadane</code> for finding the maximum sum of non-empty subarrays, the answer for one-interval subarrays is <code>kadane(A)</code>.</p> \n  <p>Now, let <script type=\"math/tex; mode=display\">N = A\\text{.length}</script>. For a two-interval subarray like:</p> \n  <p> <script type=\"math/tex; mode=display\">\n(A_0 + A_1 + \\cdots + A_i) + (A_j + A_{j+1} + \\cdots + A_{N - 1})\n</script> </p> \n  <p>we can write this as</p> \n  <p> <script type=\"math/tex; mode=display\">\n(\\sum_{k=0}^{N-1} A_k) - (A_{i+1} + A_{i+2} + \\cdots + A_{j-1})\n</script> </p> \n  <p>For two-interval subarrays, let <script type=\"math/tex; mode=display\">B</script> be the array <script type=\"math/tex; mode=display\">A</script> with each element multiplied by <script type=\"math/tex; mode=display\">-1</script>. Then the answer for two-interval subarrays is <script type=\"math/tex; mode=display\">\\text{sum}(A) + \\text{kadane}(B)</script>.</p> \n  <p>Except, this isn't quite true, as if the subarray of <script type=\"math/tex; mode=display\">B</script> we choose is the entire array, the resulting two interval subarray <script type=\"math/tex; mode=display\">[0, i] + [j, N-1]</script> would be empty.</p> \n  <p>We can remedy this problem by doing Kadane twice: once on <script type=\"math/tex; mode=display\">B</script> with the first element removed, and once on <script type=\"math/tex; mode=display\">B</script> with the last element removed.</p> \n  <iframe src=\"https://leetcode.com/playground/pVGZH9TH/shared\" frameborder=\"0\" width=\"100%\" height=\"463\" name=\"pVGZH9TH\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>A</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script> in additional space complexity. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-4-kadanes-min-variant\">Approach 4: Kadane's (Min Variant)</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>As in Approach 3, subarrays of circular arrays can be classified as either as <em>one-interval</em> subarrays (which we can use Kadane's algorithm), or <em>two-interval</em> subarrays.</p> \n  <p>We can modify Kadane's algorithm to use <code>min</code> instead of <code>max</code>. All the math in our explanation of Kadane's algorithm remains the same, but the algorithm lets us find the minimum sum of a subarray instead.</p> \n  <p>For a two interval subarray written as <script type=\"math/tex; mode=display\">(\\sum_{k=0}^{N-1} A_k) - (\\sum_{k=i+1}^{j-1} A_k)</script>, we can use our <code>kadane-min</code> algorithm to minimize the \"interior\" <script type=\"math/tex; mode=display\">(\\sum_{k=i+1}^{j-1} A_k)</script> part of the sum.</p> \n  <p>Again, because the interior <script type=\"math/tex; mode=display\">[i+1, j-1]</script> must be non-empty, we can break up our search into a search on <code>A[1:]</code> and on <code>A[:-1]</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/RkbHxhiP/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"RkbHxhiP\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>A</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script> in additional space complexity. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 917,
    "article_live": true,
    "article_slug": "reverse-only-letters",
    "title": "Reverse Only Letters",
    "title_slug": "reverse-only-letters",
    "content": "<p>Given a string <code>S</code>, return the &quot;reversed&quot; string where all characters that are not a letter&nbsp;stay in the same place, and all letters reverse their positions.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<div>\r\n<div>\r\n<ol>\r\n</ol>\r\n</div>\r\n</div>\r\n</div>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">&quot;ab-cd&quot;</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">&quot;dc-ba&quot;</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">&quot;a-bC-dEf-ghIj&quot;</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">&quot;j-Ih-gfE-dCba&quot;</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-3-1\">&quot;Test1ng-Leet=code-Q!&quot;</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">&quot;Qedo1ct-eeLg=ntse-T!&quot;</span>\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<p><strong><span>Note:</span></strong></p>\r\n\r\n<ol>\r\n\t<li><code>S.length &lt;= 100</code></li>\r\n\t<li><code>33 &lt;= S[i].ASCIIcode &lt;= 122</code>&nbsp;</li>\r\n\t<li><code>S</code> doesn&#39;t contain <code>\\</code> or <code>&quot;</code></li>\r\n</ol>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n",
    "tags": "",
    "difficulty": 1,
    "frontend_article_id": 917,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-stack-of-letters\">Approach 1: Stack of Letters</a></li> \n      <li><a href=\"#approach-2-reverse-pointer\">Approach 2: Reverse Pointer</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-stack-of-letters\">Approach 1: Stack of Letters</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Collect the letters of <code>S</code> separately into a stack, so that popping the stack reverses the letters. (Alternatively, we could have collected the letters into an array and reversed the array.)</p> \n  <p>Then, when writing the characters of <code>S</code>, any time we need a letter, we use the one we have prepared instead.</p> \n  <iframe src=\"https://leetcode.com/playground/sjoBo2tV/shared\" frameborder=\"0\" width=\"100%\" height=\"361\" name=\"sjoBo2tV\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>S</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-reverse-pointer\">Approach 2: Reverse Pointer</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Write the characters of <code>S</code> one by one. When we encounter a letter, we want to write the next letter that occurs if we iterated through the string backwards.</p> \n  <p>So we do just that: keep track of a pointer <code>j</code> that iterates through the string backwards. When we need to write a letter, we use it.</p> \n  <iframe src=\"https://leetcode.com/playground/Nig3qepj/shared\" frameborder=\"0\" width=\"100%\" height=\"344\" name=\"Nig3qepj\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>S</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 916,
    "article_live": true,
    "article_slug": "word-subsets",
    "title": "Word Subsets",
    "title_slug": "word-subsets",
    "content": "<p>We are given two arrays <code>A</code> and <code>B</code> of words.&nbsp; Each word is a string of lowercase letters.</p>\r\n\r\n<p>Now, say that&nbsp;word <code>b</code> is a subset of word <code>a</code><strong>&nbsp;</strong>if every letter in <code>b</code> occurs in <code>a</code>, <strong>including multiplicity</strong>.&nbsp; For example, <code>&quot;wrr&quot;</code> is a subset of <code>&quot;warrior&quot;</code>, but is not a subset of <code>&quot;world&quot;</code>.</p>\r\n\r\n<p>Now say a word <code>a</code> from <code>A</code> is <em>universal</em> if for every <code>b</code> in <code>B</code>, <code>b</code>&nbsp;is a subset of <code>a</code>.&nbsp;</p>\r\n\r\n<p>Return a list of all universal words in <code>A</code>.&nbsp; You can return the words in any order.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<ol>\r\n</ol>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>A = <span id=\"example-input-1-1\">[&quot;amazon&quot;,&quot;apple&quot;,&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;]</span>, B = <span id=\"example-input-1-2\">[&quot;e&quot;,&quot;o&quot;]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">[&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;]</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>A = <span id=\"example-input-2-1\">[&quot;amazon&quot;,&quot;apple&quot;,&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;]</span>, B = <span id=\"example-input-2-2\">[&quot;l&quot;,&quot;e&quot;]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">[&quot;apple&quot;,&quot;google&quot;,&quot;leetcode&quot;]</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>A = <span id=\"example-input-3-1\">[&quot;amazon&quot;,&quot;apple&quot;,&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;]</span>, B = <span id=\"example-input-3-2\">[&quot;e&quot;,&quot;oo&quot;]</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">[&quot;facebook&quot;,&quot;google&quot;]</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 4:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>A = <span id=\"example-input-4-1\">[&quot;amazon&quot;,&quot;apple&quot;,&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;]</span>, B = <span id=\"example-input-4-2\">[&quot;lo&quot;,&quot;eo&quot;]</span>\r\n<strong>Output: </strong><span id=\"example-output-4\">[&quot;google&quot;,&quot;leetcode&quot;]</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 5:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>A = <span id=\"example-input-5-1\">[&quot;amazon&quot;,&quot;apple&quot;,&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;]</span>, B = <span id=\"example-input-5-2\">[&quot;ec&quot;,&quot;oc&quot;,&quot;ceo&quot;]</span>\r\n<strong>Output: </strong><span id=\"example-output-5\">[&quot;facebook&quot;,&quot;leetcode&quot;]</span>\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= A.length, B.length &lt;= 10000</code></li>\r\n\t<li><code>1 &lt;= A[i].length, B[i].length&nbsp;&lt;= 10</code></li>\r\n\t<li><code>A[i]</code> and <code>B[i]</code> consist only of lowercase letters.</li>\r\n\t<li>All words in <code>A[i]</code> are unique: there isn&#39;t <code>i != j</code> with <code>A[i] == A[j]</code>.</li>\r\n</ol>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n",
    "tags": "String",
    "difficulty": 2,
    "frontend_article_id": 916,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-reduce-to-single-word-in-b\">Approach 1: Reduce to Single Word in B</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-reduce-to-single-word-in-b\">Approach 1: Reduce to Single Word in B</h4> \n  <p><strong>Intuition</strong></p> \n  <p>If <code>b</code> is a subset of <code>a</code>, then say <code>a</code> is a superset of <code>b</code>. Also, say <script type=\"math/tex; mode=display\">N_{\\text{\"a\"}}(\\text{word})</script> is the count of the number of <script type=\"math/tex; mode=display\">\\text{\"a\"}</script>'s in the word.</p> \n  <p>When we check whether a word <code>wordA</code> in <code>A</code> is a superset of <code>wordB</code>, we are individually checking the counts of letters: that for each <script type=\"math/tex; mode=display\">\\text{letter}</script>, we have <script type=\"math/tex; mode=display\">N_{\\text{letter}}(\\text{wordA}) \\geq N_{\\text{letter}}(\\text{wordB})</script>.</p> \n  <p>Now, if we check whether a word <code>wordA</code> is a superset of all words <script type=\"math/tex; mode=display\">\\text{wordB}_i</script>, we will check for each letter and each <script type=\"math/tex; mode=display\">i</script>, that <script type=\"math/tex; mode=display\">N_{\\text{letter}}(\\text{wordA}) \\geq N_{\\text{letter}}(\\text{wordB}_i)</script>. This is the same as checking <script type=\"math/tex; mode=display\">N_{\\text{letter}}(\\text{wordA}) \\geq \\max\\limits_i(N_{\\text{letter}}(\\text{wordB}_i))</script>.</p> \n  <p>For example, when checking whether <code>\"warrior\"</code> is a superset of words <code>B = [\"wrr\", \"wa\", \"or\"]</code>, we can combine these words in <code>B</code> to form a \"maximum\" word <code>\"arrow\"</code>, that has the maximum count of every letter in each word in <code>B</code>.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Reduce <code>B</code> to a single word <code>bmax</code> as described above, then compare the counts of letters between words <code>a</code> in <code>A</code>, and <code>bmax</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/arU2pN5v/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"arU2pN5v\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(\\mathcal{A} + \\mathcal{B})</script>, where <script type=\"math/tex; mode=display\">\\mathcal{A}</script> and <script type=\"math/tex; mode=display\">\\mathcal{B}</script> is the total amount of information in <code>A</code> and <code>B</code> respectively.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(A\\text{.length} + B\\text{.length})</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 915,
    "article_live": true,
    "article_slug": "parition-array-into-disjoint-intervals",
    "title": "Partition Array into Disjoint Intervals",
    "title_slug": "partition-array-into-disjoint-intervals",
    "content": "<p>Given an array <code>A</code>, partition it&nbsp;into two (contiguous) subarrays&nbsp;<code>left</code>&nbsp;and <code>right</code>&nbsp;so that:</p>\r\n\r\n<ul>\r\n\t<li>Every element in <code>left</code>&nbsp;is less than or equal to every element in <code>right</code>.</li>\r\n\t<li><code>left</code> and <code>right</code> are non-empty.</li>\r\n\t<li><code>left</code>&nbsp;has the smallest possible size.</li>\r\n</ul>\r\n\r\n<p>Return the <strong>length</strong> of <code>left</code> after such a partitioning.&nbsp; It is guaranteed that such a partitioning exists.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[5,0,3,8,6]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">3</span>\r\n<strong>Explanation: </strong>left = [5,0,3], right = [8,6]\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">[1,1,1,0,6,12]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">4</span>\r\n<strong>Explanation: </strong>left = [1,1,1,0], right = [6,12]\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n</div>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>2 &lt;= A.length&nbsp;&lt;= 30000</code></li>\r\n\t<li><code>0 &lt;= A[i] &lt;= 10^6</code></li>\r\n\t<li>It is guaranteed there is at least one way to partition <code>A</code> as described.</li>\r\n</ol>\r\n\r\n<div>\r\n<div>&nbsp;</div>\r\n</div>\r\n",
    "tags": "Array",
    "difficulty": 2,
    "frontend_article_id": 915,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-next-array\">Approach 1: Next Array</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-next-array\">Approach 1: Next Array</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Instead of checking whether <code>all(L &lt;= R for L in left for R in right)</code>, let's check whether <code>max(left) &lt;= min(right)</code>.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Let's try to find <code>max(left)</code> for subarrays <code>left = A[:1], left = A[:2], left = A[:3], ...</code> etc. Specifically, <code>maxleft[i]</code> will be the maximum of subarray <code>A[:i]</code>. They are related to each other: <code>max(A[:4]) = max(max(A[:3]), A[3])</code>, so <code>maxleft[4] = max(maxleft[3], A[3])</code>.</p> \n  <p>Similarly, <code>min(right)</code> for every possible <code>right</code> can be found in linear time.</p> \n  <p>After we have a way to query <code>max(left)</code> and <code>min(right)</code> quickly, the solution is straightforward.</p> \n  <iframe src=\"https://leetcode.com/playground/icvccGCi/shared\" frameborder=\"0\" width=\"100%\" height=\"480\" name=\"icvccGCi\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>A</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 914,
    "article_live": true,
    "article_slug": "x-of-a-kind-in-a-deck-of-cards",
    "title": "X of a Kind in a Deck of Cards",
    "title_slug": "x-of-a-kind-in-a-deck-of-cards",
    "content": "<p>In a deck of cards, each card has an integer written on it.</p>\r\n\r\n<p>Return <code>true</code> if and only if you can choose&nbsp;<code>X &gt;= 2</code> such that&nbsp;it is possible to split the entire deck&nbsp;into 1 or more groups of cards, where:</p>\r\n\r\n<ul>\r\n\t<li>Each group has exactly <code>X</code> cards.</li>\r\n\t<li>All the cards in each group have the same integer.</li>\r\n</ul>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[1,2,3,4,4,3,2,1]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">true\r\n<strong>Explanation</strong>: Possible partition [1,1],[2,2],[3,3],[4,4]</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">[1,1,1,2,2,2,3,3]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">false\r\n</span><span id=\"example-output-1\"><strong>Explanation</strong>: No possible partition.</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-3-1\">[1]</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">false\r\n</span><span id=\"example-output-1\"><strong>Explanation</strong>: No possible partition.</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 4:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-4-1\">[1,1]</span>\r\n<strong>Output: </strong><span id=\"example-output-4\">true\r\n</span><span id=\"example-output-1\"><strong>Explanation</strong>: Possible partition [1,1]</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 5:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-5-1\">[1,1,2,2,2,2]</span>\r\n<strong>Output: </strong><span id=\"example-output-5\">true\r\n</span><span id=\"example-output-1\"><strong>Explanation</strong>: Possible partition [1,1],[2,2],[2,2]</span>\r\n</pre>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n\r\n<p><br />\r\n<strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= deck.length &lt;= 10000</code></li>\r\n\t<li><code>0 &lt;= deck[i] &lt;&nbsp;10000</code></li>\r\n</ol>\r\n\r\n<div>\r\n<div>\r\n<div>\r\n<div>\r\n<div>&nbsp;</div>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n",
    "tags": "Array, Math",
    "difficulty": 1,
    "frontend_article_id": 914,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force\">Approach 1: Brute Force</a></li> \n      <li><a href=\"#approach-2-greatest-common-divisor\">Approach 2: Greatest Common Divisor</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force\">Approach 1: Brute Force</h4> \n  <p><strong>Intuition</strong></p> \n  <p>We can try every possible <code>X</code>. </p> \n  <p><strong>Algorithm</strong></p> \n  <p>Since we divide the deck of <code>N</code> cards into say, <code>K</code> piles of <code>X</code> cards each, we must have <code>N % X == 0</code>.</p> \n  <p>Then, say the deck has <code>C_i</code> copies of cards with number <code>i</code>. Each group with number <code>i</code> has <code>X</code> copies, so we must have <code>C_i % X == 0</code>. These are necessary and sufficient conditions.</p> \n  <iframe src=\"https://leetcode.com/playground/FCdXEDEB/shared\" frameborder=\"0\" width=\"100%\" height=\"446\" name=\"FCdXEDEB\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2 \\log \\log N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of cards. It is outside the scope of this article to prove that the number of divisors of <script type=\"math/tex; mode=display\">N</script> is bounded by <script type=\"math/tex; mode=display\">O(N \\log \\log N)</script>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-greatest-common-divisor\">Approach 2: Greatest Common Divisor</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Again, say there are <code>C_i</code> cards of number <code>i</code>. These must be broken down into piles of <code>X</code> cards each, ie. <code>C_i % X == 0</code> for all <code>i</code>.</p> \n  <p>Thus, <code>X</code> must divide the greatest common divisor of <code>C_i</code>. If this greatest common divisor <code>g</code> is greater than <code>1</code>, then <code>X = g</code> will satisfy. Otherwise, it won't.</p> \n  <iframe src=\"https://leetcode.com/playground/biA9HRs5/shared\" frameborder=\"0\" width=\"100%\" height=\"429\" name=\"biA9HRs5\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N \\log^2 N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of votes. If there are <script type=\"math/tex; mode=display\">C_i</script> cards with number <script type=\"math/tex; mode=display\">i</script>, then each <code>gcd</code> operation is naively <script type=\"math/tex; mode=display\">O(\\log^2 C_i)</script>. Better bounds exist, but are outside the scope of this article to develop.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 913,
    "article_live": true,
    "article_slug": "cat-and-mouse-game",
    "title": "Cat and Mouse",
    "title_slug": "cat-and-mouse",
    "content": "<p>A game on an <strong>undirected</strong> graph is played by two players, Mouse and Cat, who alternate turns.</p>\r\n\r\n<p>The graph is given as follows: <code>graph[a]</code> is a list of all nodes <code>b</code> such that <code>ab</code> is an edge of the graph.</p>\r\n\r\n<p>Mouse starts at node 1 and goes first, Cat starts at node 2 and goes second, and there is a Hole at node 0.</p>\r\n\r\n<p>During each player&#39;s turn, they <strong>must</strong> travel along one&nbsp;edge of the graph that meets where they are.&nbsp; For example, if the Mouse is at node <code>1</code>, it <strong>must</strong> travel to any node in <code>graph[1]</code>.</p>\r\n\r\n<p>Additionally, it is not allowed for the Cat to travel to the Hole (node 0.)</p>\r\n\r\n<p>Then, the game can end in 3 ways:</p>\r\n\r\n<ul>\r\n\t<li>If ever the Cat occupies the same node as the Mouse, the Cat wins.</li>\r\n\t<li>If ever the Mouse reaches the Hole, the Mouse wins.</li>\r\n\t<li>If ever a position is repeated (ie.&nbsp;the players are in the same position as a previous turn, and&nbsp;it is the same player&#39;s turn to move), the game is a draw.</li>\r\n</ul>\r\n\r\n<p>Given a <code>graph</code>, and assuming both players play optimally, return <code>1</code>&nbsp;if the game is won by Mouse, <code>2</code>&nbsp;if the game is won by Cat, and <code>0</code>&nbsp;if the game is a draw.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<ol>\r\n</ol>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">0\r\n<strong>Explanation:</strong>\r\n</span>4---3---1\r\n|&nbsp; &nbsp;|\r\n2---5\r\n&nbsp;\\&nbsp;/\r\n&nbsp; 0\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>3 &lt;= graph.length &lt;= 50</code></li>\r\n\t<li>It is guaranteed that <code>graph[1]</code> is non-empty.</li>\r\n\t<li>It is guaranteed that <code>graph[2]</code> contains a non-zero element.&nbsp;</li>\r\n</ol>\r\n</div>\r\n",
    "tags": "Breadth-first Search, Minimax",
    "difficulty": 3,
    "frontend_article_id": 913,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-minimax-percolate-from-resolved-states\">Approach 1: Minimax / Percolate from Resolved States</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-minimax-percolate-from-resolved-states\">Approach 1: Minimax / Percolate from Resolved States</h4> \n  <p><strong>Intuition</strong></p> \n  <p>The state of the game can be represented as <code>(m, c, t)</code> where <code>m</code> is the location of the mouse, <code>c</code> is the location of the cat, and <code>t</code> is <code>1</code> if it is the mouse's move, else <code>2</code>. Let's call these states <em>nodes</em>. These states form a directed graph: the player whose turn it is has various moves which can be considered as outgoing edges from this node to other nodes.</p> \n  <p>Some of these nodes are already resolved: if the mouse is at the hole <code>(m = 0)</code>, then the mouse wins; if the cat is where the mouse is <code>(c = m)</code>, then the cat wins. Let's say that nodes will either be colored <script type=\"math/tex; mode=display\">\\small\\text{MOUSE}</script>, <script type=\"math/tex; mode=display\">\\small\\text{CAT}</script>, or <script type=\"math/tex; mode=display\">\\small\\text{DRAW}</script> depending on which player is assured victory.</p> \n  <p>As in a standard minimax algorithm, the Mouse player will prefer <script type=\"math/tex; mode=display\">\\small\\text{MOUSE}</script> nodes first, <script type=\"math/tex; mode=display\">\\small\\text{DRAW}</script> nodes second, and <script type=\"math/tex; mode=display\">\\small\\text{CAT}</script> nodes last, and the Cat player prefers these nodes in the opposite order.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>We will color each <code>node</code> marked <script type=\"math/tex; mode=display\">\\small\\text{DRAW}</script> according to the following rule. (We'll suppose the <code>node</code> has <code>node.turn = Mouse</code>: the other case is similar.)</p> \n  <ul> \n   <li> <p>(\"Immediate coloring\"): If there is a child that is colored <script type=\"math/tex; mode=display\">\\small\\text{MOUSE}</script>, then this node will also be colored <script type=\"math/tex; mode=display\">\\small\\text{MOUSE}</script>.</p> </li> \n   <li> <p>(\"Eventual coloring\"): If all children are colored <script type=\"math/tex; mode=display\">\\small\\text{CAT}</script>, then this node will also be colored <script type=\"math/tex; mode=display\">\\small\\text{CAT}</script>.</p> </li> \n  </ul> \n  <p>We will repeatedly do this kind of coloring until no <code>node</code> satisfies the above conditions. To perform this coloring efficiently, we will use a queue and perform a <em>bottom-up percolation</em>:</p> \n  <ul> \n   <li> <p>Enqueue any node initially colored (because the Mouse is at the Hole, or the Cat is at the Mouse.)</p> </li> \n   <li> <p>For every <code>node</code> in the queue, for each <code>parent</code> of that <code>node</code>:</p> </li> \n   <li> <p>Do an immediate coloring of <code>parent</code> if you can.</p> </li> \n   <li> <p>If you can't, then decrement the side-count of the number of children marked <script type=\"math/tex; mode=display\">\\small\\text{DRAW}</script>. If it becomes zero, then do an \"eventual coloring\" of this parent.</p> </li> \n   <li> <p>All <code>parents</code> that were colored in this manner get enqueued to the queue.</p> </li> \n  </ul> \n  <p><strong>Proof of Correctness</strong></p> \n  <p>Our proof is similar to a proof that minimax works.</p> \n  <p>Say we cannot color any nodes any more, and say from any node colored <script type=\"math/tex; mode=display\">\\small\\text{CAT}</script> or <script type=\"math/tex; mode=display\">\\small\\text{MOUSE}</script> we need at most <script type=\"math/tex; mode=display\">K</script> moves to win. If say, some node marked <script type=\"math/tex; mode=display\">\\small\\text{DRAW}</script> is actually a win for Mouse, it must have been with <script type=\"math/tex; mode=display\">> K</script> moves. Then, a path along optimal play (that tries to prolong the loss as long as possible) must arrive at a node colored <script type=\"math/tex; mode=display\">\\small\\text{MOUSE}</script> (as eventually the Mouse reaches the Hole.) Thus, there must have been some transition <script type=\"math/tex; mode=display\">\\small\\text{DRAW} \\rightarrow \\small\\text{MOUSE}</script> along this path.</p> \n  <p>If this transition occurred at a <code>node</code> with <code>node.turn = Mouse</code>, then it breaks our immediate coloring rule. If it occured with <code>node.turn = Cat</code>, and all children of <code>node</code> have color <script type=\"math/tex; mode=display\">\\small\\text{MOUSE}</script>, then it breaks our eventual coloring rule. If some child has color <script type=\"math/tex; mode=display\">\\small\\text{CAT}</script>, then it breaks our immediate coloring rule. Thus, in this case <code>node</code> will have some child with <script type=\"math/tex; mode=display\">\\small\\text{DRAW}</script>, which breaks our optimal play assumption, as moving to this child ends the game in <script type=\"math/tex; mode=display\">> K</script> moves, whereas moving to the colored neighbor ends the game in <script type=\"math/tex; mode=display\">\\leq K</script> moves.</p> \n  <iframe src=\"https://leetcode.com/playground/sEZarXgw/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"sEZarXgw\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^3)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of nodes in the graph. There are <script type=\"math/tex; mode=display\">O(N^2)</script> states, and each state has an outdegree of <script type=\"math/tex; mode=display\">N</script>, as there are at most <script type=\"math/tex; mode=display\">N</script> different moves.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 911,
    "article_live": true,
    "article_slug": "online-election",
    "title": "Online Election",
    "title_slug": "online-election",
    "content": "<p>In an election, the <code>i</code>-th&nbsp;vote was cast for <code>persons[i]</code> at time <code>times[i]</code>.</p>\r\n\r\n<p>Now, we would like to implement the following query function: <code>TopVotedCandidate.q(int t)</code> will return the number of the person that was leading the election at time <code>t</code>.&nbsp;&nbsp;</p>\r\n\r\n<p>Votes cast at time <code>t</code> will count towards our query.&nbsp; In the case of a tie, the most recent vote (among tied candidates) wins.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[&quot;TopVotedCandidate&quot;,&quot;q&quot;,&quot;q&quot;,&quot;q&quot;,&quot;q&quot;,&quot;q&quot;,&quot;q&quot;]</span>, <span id=\"example-input-1-2\">[[[0,1,1,0,0,1,0],[0,5,10,15,20,25,30]],[3],[12],[25],[15],[24],[8]]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">[null,0,1,1,0,0,1]</span>\r\n<strong>Explanation: </strong>\r\nAt time 3, the votes are [0], and 0 is leading.\r\nAt time 12, the votes are [0,1,1], and 1 is leading.\r\nAt time 25, the votes are [0,1,1,0,0,1], and 1 is leading (as ties go to the most recent vote.)\r\nThis continues for 3 more queries at time 15, 24, and 8.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= persons.length = times.length &lt;= 5000</code></li>\r\n\t<li><code>0 &lt;= persons[i] &lt;= persons.length</code></li>\r\n\t<li><code>times</code>&nbsp;is a strictly increasing array with all elements in <code>[0, 10^9]</code>.</li>\r\n\t<li><code>TopVotedCandidate.q</code> is called at most <code>10000</code> times per test case.</li>\r\n\t<li><code>TopVotedCandidate.q(int t)</code> is always called with <code>t &gt;= times[0]</code>.</li>\r\n</ol>\r\n</div>\r\n",
    "tags": "",
    "difficulty": 2,
    "frontend_article_id": 911,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-list-of-lists-binary-search\">Approach 1: List of Lists + Binary Search</a></li> \n      <li><a href=\"#approach-2-precomputed-answer-binary-search\">Approach 2: Precomputed Answer + Binary Search</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-list-of-lists-binary-search\">Approach 1: List of Lists + Binary Search</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>We can store the votes in a list <code>A</code> of lists of votes. Each vote has a person and a timestamp, and <code>A[count]</code> is a list of the <code>count</code>-th votes received for that person.</p> \n  <p>Then, <code>A[i][0]</code> and <code>A[i]</code> are monotone increasing, so we can binary search on them to find the most recent vote by time.</p> \n  <iframe src=\"https://leetcode.com/playground/vXWSxDmZ/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"vXWSxDmZ\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N + Q \\log^2 N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of votes, and <script type=\"math/tex; mode=display\">Q</script> is the number of queries.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-precomputed-answer-binary-search\">Approach 2: Precomputed Answer + Binary Search</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>As the votes come in, we can remember every event <code>(winner, time)</code> when the winner changes. After, we have a sorted list of these events that we can binary search for the answer.</p> \n  <iframe src=\"https://leetcode.com/playground/fWa6yR8V/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"fWa6yR8V\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N + Q \\log N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of votes, and <script type=\"math/tex; mode=display\">Q</script> is the number of queries.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 910,
    "article_live": true,
    "article_slug": "smallest-range-ii",
    "title": "Smallest Range II",
    "title_slug": "smallest-range-ii",
    "content": "<p>Given an array <code>A</code> of integers, for each integer <code>A[i]</code> we need to choose <strong>either&nbsp;<code>x = -K</code>&nbsp;or <code>x = K</code></strong>, and add <code>x</code> to <code>A[i] <strong>(only once)</strong></code>.</p>\r\n\r\n<p>After this process, we have some array <code>B</code>.</p>\r\n\r\n<p>Return the smallest possible difference between the maximum value of <code>B</code>&nbsp;and the minimum value of <code>B</code>.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<ol>\r\n</ol>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>A = <span id=\"example-input-1-1\">[1]</span>, K = <span id=\"example-input-1-2\">0</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">0</span>\r\n<span><strong>Explanation</strong>: B = [1]</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>A = <span id=\"example-input-2-1\">[0,10]</span>, K = <span id=\"example-input-2-2\">2</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">6\r\n</span><span><strong>Explanation</strong>: B = [2,8]</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>A = <span id=\"example-input-3-1\">[1,3,6]</span>, K = <span id=\"example-input-3-2\">3</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">3</span>\r\n<span><strong>Explanation</strong>: B = [4,6,3]</span>\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= A.length &lt;= 10000</code></li>\r\n\t<li><code>0 &lt;= A[i] &lt;= 10000</code></li>\r\n\t<li><code>0 &lt;= K &lt;= 10000</code></li>\r\n</ol>\r\n</div>\r\n</div>\r\n</div>\r\n",
    "tags": "",
    "difficulty": 2,
    "frontend_article_id": 910,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-linear-scan\">Approach 1: Linear Scan</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-linear-scan\">Approach 1: Linear Scan</h4> \n  <p><strong>Intuition</strong></p> \n  <p>As in <em>Smallest Range I</em>, smaller <code>A[i]</code> will choose to increase their value (\"go up\"), and bigger <code>A[i]</code> will decrease their value (\"go down\").</p> \n  <p><strong>Algorithm</strong></p> \n  <p>We can formalize the above concept: if <code>A[i] &lt; A[j]</code>, we don't need to consider when <code>A[i]</code> goes down while <code>A[j]</code> goes up. This is because the interval <code>(A[i] + K, A[j] - K)</code> is a subset of <code>(A[i] - K, A[j] + K)</code> (here, <code>(a, b)</code> for <code>a &gt; b</code> denotes <code>(b, a)</code> instead.)</p> \n  <p>That means that it is never worse to choose <code>(up, down)</code> instead of <code>(down, up)</code>. We can prove this claim that one interval is a subset of another, by showing both <code>A[i] + K</code> and <code>A[j] - K</code> are between <code>A[i] - K</code> and <code>A[j] + K</code>.</p> \n  <p>For sorted <code>A</code>, say <code>A[i]</code> is the largest <code>i</code> that goes up. Then <code>A[0] + K, A[i] + K, A[i+1] - K, A[A.length - 1] - K</code> are the only relevant values for calculating the answer: every other value is between one of these extremal values.</p> \n  <iframe src=\"https://leetcode.com/playground/cCvupdgy/shared\" frameborder=\"0\" width=\"100%\" height=\"310\" name=\"cCvupdgy\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N \\log N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of the <code>A</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>, plus the space used by the builtin sorting algorithm. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 909,
    "article_live": true,
    "article_slug": "snakes-and-ladders",
    "title": "Snakes and Ladders",
    "title_slug": "snakes-and-ladders",
    "content": "<p>On an N x N <code>board</code>, the numbers from <code>1</code> to <code>N*N</code> are written&nbsp;<em>boustrophedonically</em>&nbsp;<strong>starting from the bottom&nbsp;left of the board</strong>, and alternating direction each row.&nbsp; For example, for a 6 x 6 board, the numbers are written as follows:</p>\r\n\r\n<pre>\r\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/09/23/snakes.png\" style=\"width: 254px; height: 200px;\" />\r\n</pre>\r\n\r\n<p>You start on square <code>1</code> of the board (which is always in the last row and&nbsp;first column).&nbsp; Each move, starting from square <code>x</code>, consists of the following:</p>\r\n\r\n<ul>\r\n\t<li>You choose a destination square <code>S</code> with number&nbsp;<code>x+1</code>, <code>x+2</code>, <code>x+3</code>, <code>x+4</code>, <code>x+5</code>, or <code>x+6</code>, provided this&nbsp;number is&nbsp;<code>&lt;=&nbsp;N*N</code>.\r\n\r\n\t<ul>\r\n\t\t<li>(This choice simulates the result of a standard 6-sided die roll: ie., there are always at most 6 destinations.)</li>\r\n\t</ul>\r\n\t</li>\r\n\t<li>If <code>S</code>&nbsp;has a snake or ladder, you move to the destination of that snake or ladder.&nbsp; Otherwise, you move to <code>S</code>.</li>\r\n</ul>\r\n\r\n<p>A board square on row <code>r</code> and column <code>c</code>&nbsp;has a &quot;snake or ladder&quot; if <code>board[r][c] != -1</code>.&nbsp; The destination of that snake or ladder is <code>board[r][c]</code>.</p>\r\n\r\n<p>Note that you only take a snake or ladder at most once per move: if the destination to a snake or ladder is the start of another&nbsp;snake or ladder, you do <strong>not</strong> continue moving.&nbsp; (For example, if the board is `[[4,-1],[-1,3]]`, and on the first move your destination square is `2`, then you finish your first move at&nbsp;`3`, because you do <strong>not</strong> continue moving to `4`.)</p>\r\n\r\n<p>Return the least number of moves required to reach square <font face=\"monospace\">N*N</font>.&nbsp; If it is not possible, return <code>-1</code>.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>[\r\n[-1,-1,-1,-1,-1,-1],\r\n[-1,-1,-1,-1,-1,-1],\r\n[-1,-1,-1,-1,-1,-1],\r\n[-1,35,-1,-1,13,-1],\r\n[-1,-1,-1,-1,-1,-1],\r\n[-1,15,-1,-1,-1,-1]]\r\n<strong>Output: </strong>4\r\n<strong>Explanation: </strong>\r\nAt the beginning, you start at square 1 [at row 5, column 0].\r\nYou decide to move to square 2, and must take the ladder to square 15.\r\nYou then decide to move to square 17 (row 3, column 5), and must take the snake to square 13.\r\nYou then decide to move to square 14, and must take the ladder to square 35.\r\nYou then decide to move to square 36, ending the game.\r\nIt can be shown that you need at least 4 moves to reach the N*N-th square, so the answer is 4.\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>2 &lt;= board.length = board[0].length&nbsp;&lt;= 20</code></li>\r\n\t<li><code>board[i][j]</code>&nbsp;is between <code>1</code> and <code>N*N</code> or is equal to <code>-1</code>.</li>\r\n\t<li>The board&nbsp;square with number <code>1</code> has no snake or ladder.</li>\r\n\t<li>The board square with number <code>N*N</code> has no snake or ladder.</li>\r\n</ol>\r\n",
    "tags": "",
    "difficulty": 2,
    "frontend_article_id": 909,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-breadth-first-search\">Approach 1: Breadth-First Search</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-breadth-first-search\">Approach 1: Breadth-First Search</h4> \n  <p><strong>Intuition</strong></p> \n  <p>As we are looking for a shortest path, a breadth-first search is ideal. The main difficulty is to handle enumerating all possible moves from each square.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Suppose we are on a square with number <code>s</code>. We would like to know all final destinations with number <code>s2</code> after making one move.</p> \n  <p>This requires knowing the coordinates <code>get(s2)</code> of square <code>s2</code>. This is a small puzzle in itself: we know that the row changes every <code>N</code> squares, and so is only based on <code>quot = (s2-1) / N</code>; also the column is only based on <code>rem = (s2-1) % N</code> and what row we are on (forwards or backwards.)</p> \n  <p>From there, we perform a breadth first search, where the nodes are the square numbers <code>s</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/RZ7eqY32/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"RZ7eqY32\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of the <code>board</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 908,
    "article_live": true,
    "article_slug": "smallest-range-i",
    "title": "Smallest Range I",
    "title_slug": "smallest-range-i",
    "content": "<p>Given an array <code>A</code> of integers, for each integer <code>A[i]</code> we may choose any <code>x</code> with <code>-K &lt;= x &lt;= K</code>, and add <code>x</code> to <code>A[i]</code>.</p>\r\n\r\n<p>After this process, we have some array <code>B</code>.</p>\r\n\r\n<p>Return the smallest possible difference between the maximum value of <code>B</code>&nbsp;and the minimum value of <code>B</code>.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<ol>\r\n</ol>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>A = <span id=\"example-input-1-1\">[1]</span>, K = <span id=\"example-input-1-2\">0</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">0\r\n<strong>Explanation</strong>: B = [1]</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>A = <span id=\"example-input-2-1\">[0,10]</span>, K = <span id=\"example-input-2-2\">2</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">6\r\n</span><span id=\"example-output-1\"><strong>Explanation</strong>: B = [2,8]</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>A = <span id=\"example-input-3-1\">[1,3,6]</span>, K = <span id=\"example-input-3-2\">3</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">0\r\n</span><span id=\"example-output-1\"><strong>Explanation</strong>: B = [3,3,3] or B = [4,4,4]</span>\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= A.length &lt;= 10000</code></li>\r\n\t<li><code>0 &lt;= A[i] &lt;= 10000</code></li>\r\n\t<li><code>0 &lt;= K &lt;= 10000</code></li>\r\n</ol>\r\n</div>\r\n</div>\r\n</div>\r\n",
    "tags": "",
    "difficulty": 1,
    "frontend_article_id": 908,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-mathematical\">Approach 1: Mathematical</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-mathematical\">Approach 1: Mathematical</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Let <code>A</code> be the original array, and <code>B</code> be the array after all our modifications. Towards trying to minimize <code>max(B) - min(B)</code>, let's try to minimize <code>max(B)</code> and maximize <code>min(B)</code> separately.</p> \n  <p>The smallest possible value of <code>max(B)</code> is <code>max(A) - K</code>, as the value <code>max(A)</code> cannot go lower. Similarly, the largest possible value of <code>min(B)</code> is <code>min(A) + K</code>. So the quantity <code>max(B) - min(B)</code> is at least <code>ans = (max(A) - K) - (min(A) + K)</code>.</p> \n  <p>We can attain this value (if <code>ans &gt;= 0</code>), by the following modifications:</p> \n  <ul> \n   <li>If <script type=\"math/tex; mode=display\">A[i] \\leq \\min(A) + K</script>, then <script type=\"math/tex; mode=display\">B[i] = \\min(A) + K</script> </li> \n   <li>Else, if <script type=\"math/tex; mode=display\">A[i] \\geq \\max(A) - K</script>, then <script type=\"math/tex; mode=display\">B[i] = \\max(A) - K</script> </li> \n   <li>Else, <script type=\"math/tex; mode=display\">B[i] = A[i]</script>.</li> \n  </ul> \n  <p>If <code>ans &lt; 0</code>, the best answer we could have is <code>ans = 0</code>, also using the same modification.</p> \n  <iframe src=\"https://leetcode.com/playground/hn3nSh7u/shared\" frameborder=\"0\" width=\"100%\" height=\"225\" name=\"hn3nSh7u\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>A</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 907,
    "article_live": true,
    "article_slug": "sum-of-subarray-minimums",
    "title": "Sum of Subarray Minimums",
    "title_slug": "sum-of-subarray-minimums",
    "content": "<p>Given an array of integers <code>A</code>, find the sum of <code>min(B)</code>, where <code>B</code> ranges over&nbsp;every (contiguous) subarray of <code>A</code>.</p>\r\n\r\n<p>Since the answer may be large, <strong>return the answer modulo <code>10^9 + 7</code>.</strong></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[3,1,2,4]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">17</span>\r\n<strong>Explanation:</strong> Subarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4]. \r\nMinimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.&nbsp; Sum is 17.</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= A.length &lt;= 30000</code></li>\r\n\t<li><code>1 &lt;= A[i] &lt;= 30000</code></li>\r\n</ol>\r\n\r\n<div>\r\n<p>&nbsp;</p>\r\n</div>\r\n",
    "tags": "Array, Stack",
    "difficulty": 2,
    "frontend_article_id": 907,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-prevnext-array\">Approach 1: Prev/Next Array</a></li> \n      <li><a href=\"#approach-2-maintain-stack-of-minimums\">Approach 2: Maintain Stack of Minimums</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-prevnext-array\">Approach 1: Prev/Next Array</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Let's try to count the number of subarrays <code>#(j)</code> for which <code>A[j]</code> is the <em>right-most</em> minimum. Then, the answer will be <code>sum #(j) * A[j]</code>. (We must say <em>right-most</em> so that we form disjoint sets of subarrays and do not double count any, as the minimum of an array may not be unique.)</p> \n  <p>This in turn brings us the question of knowing the smallest index <code>i &lt;= j</code> for which <code>A[i], A[i+1], ..., A[j]</code> are all <code>&lt;= A[j]</code>; and the largest index <code>k &gt;= j</code> for which <code>A[j+1], A[j+2], ..., A[k]</code> are all <code>&lt; A[j]</code>.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>For example, if <code>A = [10, 3, 4, 5, _3_, 2, 3, 10]</code> and we would like to know <code>#(j = 4)</code> [the count of the second <code>3</code>, which is marked], we would find <code>i = 1</code> and <code>k = 5</code>.</p> \n  <p>From there, the actual count is <code>#(j) = (j - i + 1) * (k - j + 1)</code>, as there are <code>j - i + 1</code> choices <code>i, i+1, ..., j</code> for the left index of the subarray, and <code>k - j + 1</code> choices <code>j, j+1, ..., k</code> for the right index of the subarray.</p> \n  <p>Answering these queries (ie. determining <code>(i, k)</code> given <code>j</code>) is a classic problem that can be answered with a stack. We'll focus on the problem of finding <code>i</code>: the problem of finding <code>k</code> is similar.</p> \n  <p><strong>Making a Prev Array</strong></p> \n  <p>The idea is to maintain <code>stack</code>, a monotone decreasing subsequence of <code>A</code> (actually, indices of <code>A</code> in implementation). These represent candidate boundaries <code>i* - 1</code> for the next query, stored in increasing order of <code>A[i*]</code>.</p> \n  <p>Now considering <code>j</code> in increasing order, we can remove candidates for which <code>A[i*] &lt;= A[j]</code> in decreasing order of <code>i*</code>.</p> \n  <p>For example, if <code>A = [10, 5, 3, 7, 0, 4, 5, 2, 1, _8_]</code>, then when considering <code>j = 9</code> <code>(A[j] = 8)</code>, we have a stack of boundaries like <code>[-1, 0, 3, 6]</code> (representing <code>A[i*] = -inf, 10, 7, 5</code>). We pop <code>6</code> and <code>3</code> from the stack, as <code>5 &lt;= 8</code> and <code>7 &lt;= 8</code>, and we get the answer boundary <code>i* - 1 = 0</code>.</p> \n  <p>Note that this process is linear, since we do a linear amount of pushes and pops of the stack in total.</p> \n  <p>This is quite difficult to figure out, but this type of technique occurs often in many other problems, so it is worth learning in detail.</p> \n  <iframe src=\"https://leetcode.com/playground/weMChV97/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"weMChV97\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>A</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-maintain-stack-of-minimums\">Approach 2: Maintain Stack of Minimums</h4> \n  <p><strong>Intuition</strong></p> \n  <p>For a specific <code>j</code>, let's try to count the minimum of each subarray <code>[i, j]</code>. The intuition is that as we increment <code>j++</code>, these minimums may be related to each other. Indeed, <code>min(A[i:j+1]) = min(A[i:j], A[j])</code>.</p> \n  <p>Playing with some array like <code>A = [1,7,5,2,4,3,9]</code>, with <code>j = 6</code> the minimum of each subarray <code>[i, j]</code> is <code>B = [1,2,2,2,3,3,9]</code>. We can see that there are critical points <code>i = 0, i = 3, i = 5, i = 6</code> where a minimum is reached for the first time when walking left from <code>j</code>.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Let's try to maintain an RLE (run length encoding) of these critical points <code>B</code>. More specifically, for the above <code>(A, j)</code>, we will maintain <code>stack = [(val=1, count=1), (val=2, count=3), (val=3, count=2), (val=9, count=1)]</code>, that represents a run length encoding of the subarray minimums <code>B = [1,2,2,2,3,3,9]</code>. For each <code>j</code>, we want <code>sum(B)</code>. </p> \n  <p>As we increment <code>j</code>, we will have to update this stack to include the newest element <code>(val=x, count=1)</code>. We need to pop off all values <code>&gt;= x</code> before, as the minimum of the associated subarray <code>[i, j]</code> will now be <code>A[j]</code> instead of what it was before.</p> \n  <p>At the end, the answer is the dot product of this stack: <script type=\"math/tex; mode=display\">\\sum\\limits_{e\\text{ } \\in \\text{ stack}} e\\text{.val} * e\\text{.count}</script>, which we also maintain on the side as the variable <code>dot</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/m9f4Vck6/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"m9f4Vck6\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>A</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>. Approach 2 inspired by <a href=\"https://leetcode.com/aakarshmadhavan\">@aakarshmadhavan</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 906,
    "article_live": true,
    "article_slug": "super-palindromes",
    "title": "Super Palindromes",
    "title_slug": "super-palindromes",
    "content": "<p>Let&#39;s say a positive integer is a&nbsp;<em>superpalindrome</em>&nbsp;if it is a palindrome, and it is also the square of a palindrome.</p>\r\n\r\n<p>Now, given two positive&nbsp;integers <code>L</code> and <code>R</code> (represented as strings), return the number of superpalindromes in the inclusive range <code>[L, R]</code>.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>L = <span id=\"example-input-1-1\">&quot;4&quot;</span>, R = <span id=\"example-input-1-2\">&quot;1000&quot;</span>\r\n<strong>Output: </strong>4\r\n<span><strong>Explanation</strong>: </span>4, 9, 121, and 484 are superpalindromes.\r\nNote that 676 is not a superpalindrome: 26 * 26 = 676, but 26 is not a palindrome.</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= len(L) &lt;= 18</code></li>\r\n\t<li><code>1 &lt;= len(R) &lt;= 18</code></li>\r\n\t<li><code>L</code> and <code>R</code> are strings representing integers in the range <code>[1, 10^18)</code>.</li>\r\n\t<li><code>int(L) &lt;= int(R)</code></li>\r\n</ol>\r\n\r\n<div>\r\n<p>&nbsp;</p>\r\n</div>\r\n",
    "tags": "Math",
    "difficulty": 3,
    "frontend_article_id": 906,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-mathematical\">Approach 1: Mathematical</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-mathematical\">Approach 1: Mathematical</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Say <script type=\"math/tex; mode=display\">P = R^2</script> is a superpalindrome.</p> \n  <p>Because <script type=\"math/tex; mode=display\">R</script> is a palindrome, the first half of the digits in <script type=\"math/tex; mode=display\">R</script> determine <script type=\"math/tex; mode=display\">R</script> up to two possibilities. We can iterate through these digits: let <script type=\"math/tex; mode=display\">k</script> be the first half of the digits in <script type=\"math/tex; mode=display\">R</script>. For example, if <script type=\"math/tex; mode=display\">k = 1234</script>, then <script type=\"math/tex; mode=display\">R = 1234321</script> or <script type=\"math/tex; mode=display\">R = 12344321</script>. Each possibility has either an odd or an even number of digits in <script type=\"math/tex; mode=display\">R</script>.</p> \n  <p>Notice because <script type=\"math/tex; mode=display\">P < 10^{18}</script>, <script type=\"math/tex; mode=display\">R < (10^{18})^{\\frac{1}{2}} = 10^9</script>, and <script type=\"math/tex; mode=display\">R = k \\| k'</script> (concatenation), where <script type=\"math/tex; mode=display\">k'</script> is <script type=\"math/tex; mode=display\">k</script> reversed (and also possibly truncated by one digit); so that <script type=\"math/tex; mode=display\">k < 10^5 = \\small\\text{MAGIC}</script>, our magic constant.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>For each <script type=\"math/tex; mode=display\">1 \\leq k < \\small\\text{MAGIC}</script>, let's create the associated palindrome <script type=\"math/tex; mode=display\">R</script>, and check whether <script type=\"math/tex; mode=display\">R^2</script> is a palindrome.</p> \n  <p>We should handle the odd and even possibilities separately, as we would like to break early so as not to do extra work.</p> \n  <p>To check whether an integer is a palindrome, we could check whether it is equal to its reverse. To create the reverse of an integer, we can do it digit by digit.</p> \n  <iframe src=\"https://leetcode.com/playground/ZRTHqoUW/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"ZRTHqoUW\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(W^{\\frac{1}{4}} * \\log W)</script>, where <script type=\"math/tex; mode=display\">W = 10^{18}</script> is our upper limit for <script type=\"math/tex; mode=display\">R</script>. The <script type=\"math/tex; mode=display\">\\log W</script> term comes from checking whether each candidate is the root of a palindrome.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(\\log W)</script>, the space used to create the candidate palindrome. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 905,
    "article_live": true,
    "article_slug": "sort-array-by-parity",
    "title": "Sort Array By Parity",
    "title_slug": "sort-array-by-parity",
    "content": "<p>Given an array <code>A</code> of non-negative integers, return an array consisting of all the even elements of <code>A</code>, followed by all the odd elements of <code>A</code>.</p>\r\n\r\n<p>You may return any answer array that satisfies this condition.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[3,1,2,4]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">[2,4,3,1]</span>\r\nThe outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= A.length &lt;= 5000</code></li>\r\n\t<li><code>0 &lt;= A[i] &lt;= 5000</code></li>\r\n</ol>\r\n</div>\r\n",
    "tags": "Array",
    "difficulty": 1,
    "frontend_article_id": 905,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-sort\">Approach 1: Sort</a></li> \n      <li><a href=\"#approach-2-two-pass\">Approach 2: Two Pass</a></li> \n      <li><a href=\"#approach-2-two-pass_1\">Approach 2: Two Pass</a></li> \n      <li><a href=\"#approach-3-in-place\">Approach 3: In-Place</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-sort\">Approach 1: Sort</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Use a custom comparator when sorting, to sort by parity.</p> \n  <iframe src=\"https://leetcode.com/playground/bcMSW6MA/shared\" frameborder=\"0\" width=\"100%\" height=\"412\" name=\"bcMSW6MA\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N \\log N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>A</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script> for the sort, depending on the built-in implementation of <code>sort</code>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-two-pass\">Approach 2: Two Pass</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Write all the even elements first, then write all the odd elements.</p> \n  <iframe src=\"https://leetcode.com/playground/uepE6ksC/shared\" frameborder=\"0\" width=\"100%\" height=\"327\" name=\"uepE6ksC\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>A</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script> for the sort, depending on the built-in implementation of <code>sort</code>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-two-pass_1\">Approach 2: Two Pass</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Write all the even elements first, then write all the odd elements.</p> \n  <iframe src=\"https://leetcode.com/playground/AjwfiQ8K/shared\" frameborder=\"0\" width=\"100%\" height=\"327\" name=\"AjwfiQ8K\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>A</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the space used by the answer. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-in-place\">Approach 3: In-Place</h4> \n  <p><strong>Intuition</strong></p> \n  <p>If we want to do the sort in-place, we can use quicksort, a standard textbook algorithm.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>We'll maintain two pointers <code>i</code> and <code>j</code>. The loop invariant is everything below <code>i</code> has parity <code>0</code> (ie. <code>A[k] % 2 == 0</code> when <code>k &lt; i</code>), and everything above <code>j</code> has parity <code>1</code>.</p> \n  <p>Then, there are 4 cases for <code>(A[i] % 2, A[j] % 2)</code>:</p> \n  <ul> \n   <li> <p>If it is <code>(0, 1)</code>, then everything is correct: <code>i++</code> and <code>j--</code>.</p> </li> \n   <li> <p>If it is <code>(1, 0)</code>, we swap them so they are correct, then continue.</p> </li> \n   <li> <p>If it is <code>(0, 0)</code>, only the <code>i</code> place is correct, so we <code>i++</code> and continue.</p> </li> \n   <li> <p>If it is <code>(1, 1)</code>, only the <code>j</code> place is correct, so we <code>j--</code> and continue.</p> </li> \n  </ul> \n  <p>Throughout all 4 cases, the loop invariant is maintained, and <code>j-i</code> is getting smaller. So eventually we will be done with the array sorted as desired.</p> \n  <iframe src=\"https://leetcode.com/playground/SCAvRwWS/shared\" frameborder=\"0\" width=\"100%\" height=\"344\" name=\"SCAvRwWS\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>A</code>. Each step of the while loop makes <code>j-i</code> decrease by at least one. (Note that while quicksort is <script type=\"math/tex; mode=display\">O(N \\log N)</script> normally, this is <script type=\"math/tex; mode=display\">O(N)</script> because we only need one pass to sort the elements.)</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script> in additional space complexity. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 904,
    "article_live": true,
    "article_slug": "fruit-into-baskets",
    "title": "Fruit Into Baskets",
    "title_slug": "fruit-into-baskets",
    "content": "<p>In a row of trees, the <code>i</code>-th tree&nbsp;produces&nbsp;fruit with type&nbsp;<code>tree[i]</code>.</p>\r\n\r\n<p>You <strong>start at any tree&nbsp;of your choice</strong>, then repeatedly perform the following steps:</p>\r\n\r\n<ol>\r\n\t<li>Add one piece of fruit from this tree to your baskets.&nbsp; If you cannot, stop.</li>\r\n\t<li>Move to the next tree to the right of the current tree.&nbsp; If there is no tree to the right, stop.</li>\r\n</ol>\r\n\r\n<p>Note that you do not have any choice after the initial choice of starting tree:&nbsp;you must perform step 1, then step 2, then back to step 1, then step 2, and so on until you stop.</p>\r\n\r\n<p>You have two baskets, and each basket can carry any quantity of fruit, but you want each basket to only carry one type of fruit each.</p>\r\n\r\n<p>What is the total amount of fruit you can collect with this procedure?</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[1,2,1]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">3</span>\r\n<strong><span>Explanation: </span></strong><span>We can collect [1,2,1].</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">[0,1,2,2]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">3\r\n</span><strong><span>Explanation: </span></strong><span>We can collect [1,2,2].\r\nIf we started at the first tree, we would only collect [0, 1].</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-3-1\">[1,2,3,2,2]</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">4\r\n</span><strong><span>Explanation: </span></strong><span>We can collect [2,3,2,2].</span>\r\n<span>If we started at the first tree, we would only collect [1, 2].</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 4:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-4-1\">[3,3,3,1,2,1,1,2,3,3,4]</span>\r\n<strong>Output: </strong>5<span id=\"example-output-4\">\r\n</span><strong><span>Explanation: </span></strong><span>We can collect [1,2,1,1,2].</span>\r\n<span>If we started at the first tree or the eighth tree, we would only collect 4 fruits.</span>\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n</div>\r\n</div>\r\n</div>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= tree.length &lt;= 40000</code></li>\r\n\t<li><code>0 &lt;= tree[i] &lt; tree.length</code></li>\r\n</ol>\r\n",
    "tags": "Two Pointers",
    "difficulty": 2,
    "frontend_article_id": 904,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-scan-through-blocks\">Approach 1: Scan Through Blocks</a></li> \n      <li><a href=\"#approach-2-sliding-window\">Approach 2: Sliding Window</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-scan-through-blocks\">Approach 1: Scan Through Blocks</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Equivalently, we want the longest subarray with at most two \"types\" (values of <code>tree[i]</code>).</p> \n  <p>Instead of considering each element individually, we can consider blocks of adjacent elements of the same type.</p> \n  <p>For example, instead of <code>tree = [1, 1, 1, 1, 2, 2, 3, 3, 3]</code>, we can say this is <code>blocks = [(1, weight = 4), (2, weight = 2), (3, weight = 3)]</code>.</p> \n  <p>Now say we brute forced, scanning from left to right. We'll have something like <code>blocks = [1, _2_, 1, 2, 1, 2, _1_, 3, ...]</code> (with various weights).</p> \n  <p>The key insight is that when we encounter a <code>3</code>, we do not need to start from the second element <code>2</code> (marked <code>_2_</code> for convenience); we can start from the first element (<code>_1_</code>) before the <code>3</code>. This is because if we started two or more elements before, the sequence must have types <code>1</code> and <code>2</code>, and that sequence is going to end at the <code>3</code>, and thus be shorter than anything we've already considered.</p> \n  <p>Since every starting point (that is the left-most index of a block) was considered, this solution is correct.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>As the notation and strategy around implementing this differs between Python and Java, please see the inline comments for more details.</p> \n  <iframe src=\"https://leetcode.com/playground/pvsyyXLb/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"pvsyyXLb\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>tree</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-sliding-window\">Approach 2: Sliding Window</h4> \n  <p><strong>Intuition</strong></p> \n  <p>As in <em>Approach 1</em>, we want the longest subarray with at most two different \"types\" (values of <code>tree[i]</code>). Call these subarrays <em>valid</em>.</p> \n  <p>Say we consider all valid subarrays that end at index <code>j</code>. There must be one with the smallest possible starting index <code>i</code>: lets say <code>opt(j) = i</code>.</p> \n  <p>Now the key idea is that <code>opt(j)</code> is a monotone increasing function. This is because any subarray of a valid subarray is valid.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Let's perform a sliding window, keeping the loop invariant that <code>i</code> will be the smallest index for which <code>[i, j]</code> is a valid subarray.</p> \n  <p>We'll maintain <code>count</code>, the count of all the elements in the subarray. This allows us to quickly query whether there are 3 types in the subarray or not.</p> \n  <iframe src=\"https://leetcode.com/playground/tZWTV9pU/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"tZWTV9pU\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>tree</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 903,
    "article_live": true,
    "article_slug": "valid-permutations-for-di-sequence",
    "title": "Valid Permutations for DI Sequence",
    "title_slug": "valid-permutations-for-di-sequence",
    "content": "<p>We are given <code>S</code>, a length <code>n</code> string of characters from the set <code>{&#39;D&#39;, &#39;I&#39;}</code>. (These letters stand for &quot;decreasing&quot; and &quot;increasing&quot;.)</p>\r\n\r\n<p>A&nbsp;<em>valid permutation</em>&nbsp;is a permutation <code>P[0], P[1], ..., P[n]</code> of integers&nbsp;<code>{0, 1, ..., n}</code>, such that for all <code>i</code>:</p>\r\n\r\n<ul>\r\n\t<li>If <code>S[i] == &#39;D&#39;</code>, then <code>P[i] &gt; P[i+1]</code>, and;</li>\r\n\t<li>If <code>S[i] == &#39;I&#39;</code>, then <code>P[i] &lt; P[i+1]</code>.</li>\r\n</ul>\r\n\r\n<p>How many valid permutations are there?&nbsp; Since the answer may be large, <strong>return your answer modulo <code>10^9 + 7</code></strong>.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">&quot;DID&quot;</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">5</span>\r\n<strong>Explanation: </strong>\r\nThe 5 valid permutations of (0, 1, 2, 3) are:\r\n(1, 0, 3, 2)\r\n(2, 0, 3, 1)\r\n(2, 1, 3, 0)\r\n(3, 0, 2, 1)\r\n(3, 1, 2, 0)\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= S.length &lt;= 200</code></li>\r\n\t<li><code>S</code> consists only of characters from the set <code>{&#39;D&#39;, &#39;I&#39;}</code>.</li>\r\n</ol>\r\n\r\n<div>\r\n<p>&nbsp;</p>\r\n</div>\r\n",
    "tags": "Divide and Conquer, Dynamic Programming",
    "difficulty": 3,
    "frontend_article_id": 903,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-dynamic-programming\">Approach 1: Dynamic Programming</a></li> \n      <li><a href=\"#approach-2-divide-and-conquer\">Approach 2: Divide and Conquer</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-dynamic-programming\">Approach 1: Dynamic Programming</h4> \n  <p><strong>Intuition</strong></p> \n  <p>When writing the permutation <code>P = P_0, P_1, ..., P_N</code> from left to right, we only care about the relative rank of the last element placed. For example, if <code>N = 5</code> (so that we have elements <code>{0, 1, 2, 3, 4, 5}</code>), and our permutation starts <code>2, 3, 4</code>, then it is similar to a situation where we have placed <code>?, ?, 2</code> and the remaining elements are <code>{0, 1, 3}</code>, in terms of how many possibilities there are to place the remaining elements in a valid way.</p> \n  <p>To this end, let <code>dp(i, j)</code> be the number of ways to place every number up to and inlcuding <code>P_i</code>, such that <code>P_i</code> when placed had relative rank <code>j</code>. (Namely, there are <code>j</code> remaining numbers less than <code>P_i</code>.)</p> \n  <p><strong>Algorithm</strong></p> \n  <p>When placing <code>P_i</code> following a decreasing instruction <code>S[i-1] == 'D'</code>, we want <code>P_{i-1}</code> to have a higher value. When placing <code>P_i</code> following an increasing instruction, we want <code>P_{i-1}</code> to have a lower value. It is relatively easy to deduce the recursion from this fact.</p> \n  <iframe src=\"https://leetcode.com/playground/ymMfbxds/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"ymMfbxds\"></iframe> \n  <p><strong>Optimization</strong></p> \n  <p>Actually, we can do better than this. For any given <code>i</code>, let's look at how the sum of <code>D_k = dp(i-1, k)</code> is queried. Assuming <code>S[i-1] == 'I'</code>, we query <code>D_0, D_0 + D_1, D_0 + D_1 + D_2, ...</code> etc. The case for <code>S[i-1] == 'D'</code> is similar.</p> \n  <p>Thus, we don't need to query the sum every time. Instead, we could use (for <code>S[i-1] == 'I'</code>) the fact that <code>dp(i, j) = dp(i, j-1) + dp(i-1, j-1)</code>. For <code>S[i-1] == 'D'</code>, we have the similar fact that <code>dp(i, j) = dp(i, j+1) + dp(i-1, j)</code>. </p> \n  <p>These two facts make the work done for each state of <code>dp</code> have <script type=\"math/tex; mode=display\">O(1)</script> (amortized) complexity, leading to a total time complexity of <script type=\"math/tex; mode=display\">O(N^2)</script> for this solution.</p> \n  <iframe src=\"https://leetcode.com/playground/yKpXsoX7/shared\" frameborder=\"0\" width=\"100%\" height=\"395\" name=\"yKpXsoX7\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^3)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>S</code>, or <script type=\"math/tex; mode=display\">O(N^2)</script> with the optimized version.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-divide-and-conquer\">Approach 2: Divide and Conquer</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Let's place the zero of the permutation first. It either goes between a <code>'DI'</code> part of the sequence, or it could go on the ends (the left end if it starts with <code>'I'</code>, and the right end if it ends in <code>'D'</code>.) Afterwards, this splits the problem into two disjoint subproblems that we can solve with similar logic.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Let <code>dp(i, j)</code> be the number of valid permutations (of <code>n = j-i+2</code> total integers from <code>0</code> to <code>n-1</code>) corresponding to the DI sequence <code>S[i], S[i+1], ..., S[j]</code>. If we can successfully place a zero between <code>S[k-1]</code> and <code>S[k]</code>, then there are two disjoint problems <code>S[i], ..., S[k-2]</code> and <code>S[k+1], ..., S[j]</code>.</p> \n  <p>To count the number of valid permutations in this case, we should choose <code>k-i</code> elements from <code>n-1</code> (<code>n</code> total integers, minus the zero) to put in the left group; then the answer is this, times the number of ways to arrange the left group [<code>dp(i, k-2)</code>], times the number of ways to arrange the right group [<code>dp(k+1, j)</code>].</p> \n  <iframe src=\"https://leetcode.com/playground/KreEbZYZ/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"KreEbZYZ\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>S</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 902,
    "article_live": true,
    "article_slug": "numbers-at-most-n-given-digit-set",
    "title": "Numbers At Most N Given Digit Set",
    "title_slug": "numbers-at-most-n-given-digit-set",
    "content": "<p>We have a <strong>sorted</strong> set of digits <code>D</code>, a non-empty subset of <code>{&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;,&#39;6&#39;,&#39;7&#39;,&#39;8&#39;,&#39;9&#39;}</code>.&nbsp; (Note that <code>&#39;0&#39;</code> is not included.)</p>\r\n\r\n<p>Now, we write numbers using these digits, using each digit as many times as we want.&nbsp; For example, if <code>D = {&#39;1&#39;,&#39;3&#39;,&#39;5&#39;}</code>, we may write numbers such as <code>&#39;13&#39;, &#39;551&#39;, &#39;1351315&#39;</code>.</p>\r\n\r\n<p>Return the number of positive integers that can be written (using the digits of <code>D</code>) that are less than or equal to <code>N</code>.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>D = <span id=\"example-input-1-1\">[&quot;1&quot;,&quot;3&quot;,&quot;5&quot;,&quot;7&quot;]</span>, N = <span id=\"example-input-1-2\">100</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">20</span>\r\n<strong>Explanation: </strong>\r\nThe 20 numbers that can be written are:\r\n1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>D = <span id=\"example-input-2-1\">[&quot;1&quot;,&quot;4&quot;,&quot;9&quot;]</span>, N = <span id=\"example-input-2-2\">1000000000</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">29523</span>\r\n<strong>Explanation: </strong>\r\nWe can write 3 one digit numbers, 9 two digit numbers, 27 three digit numbers,\r\n81 four digit numbers, 243 five digit numbers, 729 six digit numbers,\r\n2187 seven digit numbers, 6561 eight digit numbers, and 19683 nine digit numbers.\r\nIn total, this is 29523 integers that can be written using the digits of D.</pre>\r\n</div>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>D</code> is a&nbsp;subset of digits <code>&#39;1&#39;-&#39;9&#39;</code> in sorted order.</li>\r\n\t<li><code>1 &lt;= N &lt;= 10^9</code></li>\r\n</ol>\r\n",
    "tags": "Math, Dynamic Programming",
    "difficulty": 3,
    "frontend_article_id": 902,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-dynamic-programming-counting\">Approach 1: Dynamic Programming + Counting</a></li> \n      <li><a href=\"#approach-2-mathematical\">Approach 2: Mathematical</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-dynamic-programming-counting\">Approach 1: Dynamic Programming + Counting</h4> \n  <p><strong>Intuition</strong></p> \n  <p>First, call a positive integer <code>X</code> <em>valid</em> if <code>X &lt;= N</code> and <code>X</code> only consists of digits from <code>D</code>. Our goal is to find the number of valid integers.</p> \n  <p>Say <code>N</code> has <code>K</code> digits. If we write a valid number with <code>k</code> digits (<code>k &lt; K</code>), then there are <script type=\"math/tex; mode=display\">(D\\text{.length})^k</script> possible numbers we could write, since all of them will definitely be less than <code>N</code>.</p> \n  <p>Now, say we are to write a valid <code>K</code> digit number from left to right. For example, <code>N = 2345</code>, <code>K = 4</code>, and <code>D = '1', '2', ..., '9'</code>. Let's consider what happens when we write the first digit.</p> \n  <ul> \n   <li> <p>If the first digit we write is less than the first digit of <code>N</code>, then we could write any numbers after, for a total of <script type=\"math/tex; mode=display\">(D\\text{.length})^{K-1}</script> valid numbers from this one-digit prefix. In our example, if we start with <code>1</code>, we could write any of the numbers <code>1111</code> to <code>1999</code> from this prefix.</p> </li> \n   <li> <p>If the first digit we write is the same, then we require that the next digit we write is equal to or lower than the next digit in <code>N</code>. In our example (with <code>N = 2345</code>), if we start with <code>2</code>, the next digit we write must be <code>3</code> or less.</p> </li> \n   <li> <p>We can't write a larger digit, because if we started with eg. <code>3</code>, then even a number of <code>3000</code> is definitely larger than <code>N</code>.</p> </li> \n  </ul> \n  <p><strong>Algorithm</strong></p> \n  <p>Let <code>dp[i]</code> be the number of ways to write a valid number if <code>N</code> became <code>N[i], N[i+1], ...</code>. For example, if <code>N = 2345</code>, then <code>dp[0]</code> would be the number of valid numbers at most <code>2345</code>, <code>dp[1]</code> would be the ones at most <code>345</code>, <code>dp[2]</code> would be the ones at most <code>45</code>, and <code>dp[3]</code> would be the ones at most <code>5</code>.</p> \n  <p>Then, by our reasoning above, <code>dp[i] = (number of d in D with d &lt; S[i]) * ((D.length) ** (K-i-1))</code>, plus <code>dp[i+1]</code> if <code>S[i]</code> is in <code>D</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/en4D5WXi/shared\" frameborder=\"0\" width=\"100%\" height=\"446\" name=\"en4D5WXi\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(\\log N)</script>, and assuming <script type=\"math/tex; mode=display\">D\\text{.length}</script> is constant. (We could make this better by pre-calculating the number of <code>d &lt; S[i]</code> for all possible digits <code>S[i]</code>, but this isn't necessary.)</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(\\log N)</script>, the space used by <code>S</code> and <code>dp</code>. (Actually, we could store only the last 2 entries of <code>dp</code>, but this isn't necessary.) <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-mathematical\">Approach 2: Mathematical</h4> \n  <p><strong>Intuition</strong></p> \n  <p>As in <em>Approach #1</em>, call a positive integer <code>X</code> <em>valid</em> if <code>X &lt;= N</code> and <code>X</code> only consists of digits from <code>D</code>.</p> \n  <p>Now let <code>B = D.length</code>. There is a bijection between valid integers and so called \"bijective-base-<code>B</code>\" numbers. For example, if <code>D = ['1', '3', '5', '7']</code>, then we could write the numbers <code>'1', '3', '5', '7', '11', '13', '15', '17', '31', ...</code> as (bijective-base-<code>B</code>) numbers <code>'1', '2', '3', '4', '11', '12', '13', '14', '21', ...</code>.</p> \n  <p>It is clear that both of these sequences are increasing, which means that the first sequence is a contiguous block of valid numbers, followed by invalid numbers.</p> \n  <p>Our approach is to find the largest valid integer, and convert it into bijective-base-<code>B</code> from which it is easy to find its rank (position in the sequence.) Because of the bijection, the rank of this element must be the number of valid integers.</p> \n  <p>Continuing our example, if <code>N = 64</code>, then the valid numbers are <code>'1', '3', ..., '55', '57'</code>, which can be written as bijective-base-4 numbers <code>'1', '2', ..., '33', '34'</code>. Converting this last entry <code>'34'</code> to decimal, the answer is <code>16</code> (3 * 4 + 4).</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Let's convert <code>N</code> into the largest possible valid integer <code>X</code>, convert <code>X</code> to bijective-base-B, then convert that result to a decimal answer. The last two conversions are relatively straightforward, so let's focus on the first part of the task.</p> \n  <p>Let's try to write <code>X</code> one digit at a time. Let's walk through an example where <code>D = ['2', '4', '6', '8']</code>. There are some cases:</p> \n  <ul> \n   <li> <p>If the first digit of <code>N</code> is in <code>D</code>, we write that digit and continue. For example, if <code>N = 25123</code>, then we will write <code>2</code> and continue.</p> </li> \n   <li> <p>If the first digit of <code>N</code> is larger than <code>min(D)</code>, then we write the largest possible number from <code>D</code> less than that digit, and the rest of the numbers will be big. For example, if <code>N = 5123</code>, then we will write <code>4888</code> (<code>4</code> then <code>888</code>).</p> </li> \n   <li> <p>If the first digit of <code>N</code> is smaller than <code>min(D)</code>, then we must \"subtract 1\" (in terms of <code>X</code>'s bijective-base-B representation), and the rest of the numbers will be big.</p> <p>For example, if <code>N = 123</code>, we will write <code>88</code>. If <code>N = 4123</code>, we will write <code>2888</code>. And if <code>N = 22123</code>, we will write <code>8888</code>. This is because \"subtracting 1\" from <code>'', '4', '22'</code> yields <code>'', '2', '8'</code> (can't go below 0).</p> </li> \n  </ul> \n  <p>Actually, in our solution, it is easier to write in bijective-base-B, so instead of writing digits of <code>D</code>, we'll write the index of those digits (1-indexed). For example, <code>X = 24888</code> will be <code>A = [1, 2, 4, 4, 4]</code>. Afterwards, we convert this to decimal.</p> \n  <iframe src=\"https://leetcode.com/playground/bVuoAcr9/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"bVuoAcr9\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(\\log N)</script>, and assuming <script type=\"math/tex; mode=display\">D\\text{.length}</script> is constant.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(\\log N)</script>, the space used by <code>A</code>. <br> <br></p> </li> \n  </ul> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 901,
    "article_live": true,
    "article_slug": "online-stock-span",
    "title": "Online Stock Span",
    "title_slug": "online-stock-span",
    "content": "<p>Write a class <code>StockSpanner</code> which collects daily price quotes for some stock, and returns the <em>span</em>&nbsp;of that stock&#39;s price for the current day.</p>\r\n\r\n<p>The span of the stock&#39;s price today&nbsp;is defined as the maximum number of consecutive days (starting from today and going backwards)&nbsp;for which the price of the stock was less than or equal to today&#39;s price.</p>\r\n\r\n<p>For example, if the price of a stock over the next 7 days were <code>[100, 80, 60, 70, 60, 75, 85]</code>, then the stock spans would be <code>[1, 1, 1, 2, 1, 4, 6]</code>.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[&quot;StockSpanner&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;]</span>, <span id=\"example-input-1-2\">[[],[100],[80],[60],[70],[60],[75],[85]]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">[null,1,1,1,2,1,4,6]</span>\r\n<strong>Explanation: </strong>\r\nFirst, S = StockSpanner() is initialized.  Then:\r\nS.next(100) is called and returns 1,\r\nS.next(80) is called and returns 1,\r\nS.next(60) is called and returns 1,\r\nS.next(70) is called and returns 2,\r\nS.next(60) is called and returns 1,\r\nS.next(75) is called and returns 4,\r\nS.next(85) is called and returns 6.\r\n\r\nNote that (for example) S.next(75) returned 4, because the last 4 prices\r\n(including today&#39;s price of 75) were less than or equal to today&#39;s price.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li>Calls to <code>StockSpanner.next(int price)</code> will have <code>1 &lt;= price &lt;= 10^5</code>.</li>\r\n\t<li>There will be at most <code>10000</code> calls to <code>StockSpanner.next</code>&nbsp;per test case.</li>\r\n\t<li>There will be at most <code>150000</code> calls to <code>StockSpanner.next</code> across all test cases.</li>\r\n\t<li>The total&nbsp;time limit for this problem has been reduced by 75% for&nbsp;C++, and 50% for all other languages.</li>\r\n</ol>\r\n</div>\r\n",
    "tags": "Stack",
    "difficulty": 2,
    "frontend_article_id": 901,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-stack\">Approach 1: Stack</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-stack\">Approach 1: Stack</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Clearly, we need to focus on how to make each query faster than a linear scan. In a typical case, we get a new element like <code>7</code>, and there are some previous elements like <code>11, 3, 9, 5, 6, 4</code>. Let's try to create some relationship between this query and the next query.</p> \n  <p>If (after getting <code>7</code>) we get an element like <code>2</code>, then the answer is <code>1</code>. So in general, whenever we get a smaller element, the answer is 1.</p> \n  <p>If we get an element like <code>8</code>, the answer is 1 plus the previous answer (for <code>7</code>), as the <code>8</code> \"stops\" on the same value that <code>7</code> does (namely, <code>9</code>).</p> \n  <p>If we get an element like <code>10</code>, the answer is 1 plus the previous answer, plus the answer for <code>9</code>.</p> \n  <p>Notice throughout this evaluation, we only care about elements that occur in increasing order - we \"shortcut\" to them. That is, from adding an element like <code>10</code>, we cut to <code>7</code> [with \"weight\" 4], then to <code>9</code> [with weight 2], then cut to <code>11</code> [with weight 1].</p> \n  <p>A stack is the ideal data structure to maintain what we care about efficiently.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Let's maintain a weighted stack of decreasing elements. The size of the weight will be the total number of elements skipped. For example, <code>11, 3, 9, 5, 6, 4, 7</code> will be <code>(11, weight=1), (9, weight=2), (7, weight=4)</code>.</p> \n  <p>When we get a new element like <code>10</code>, this helps us count the previous values faster by popping weighted elements off the stack. The new stack at the end will look like <code>(11, weight=1), (10, weight=7)</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/5aJytT6D/shared\" frameborder=\"0\" width=\"100%\" height=\"395\" name=\"5aJytT6D\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(Q)</script>, where <script type=\"math/tex; mode=display\">Q</script> is the number of calls to <code>StockSpanner.next</code>. In total, there are <script type=\"math/tex; mode=display\">Q</script> pushes to the stack, and at most <script type=\"math/tex; mode=display\">Q</script> pops.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(Q)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 900,
    "article_live": true,
    "article_slug": "rle-iterator",
    "title": "RLE Iterator",
    "title_slug": "rle-iterator",
    "content": "<p>Write an iterator that iterates through a run-length encoded sequence.</p>\r\n\r\n<p>The iterator is initialized by <code>RLEIterator(int[] A)</code>, where <code>A</code> is a run-length encoding of some&nbsp;sequence.&nbsp; More specifically,&nbsp;for all even <code>i</code>,&nbsp;<code>A[i]</code> tells us the number of times that the non-negative integer value <code>A[i+1]</code> is repeated in the sequence.</p>\r\n\r\n<p>The iterator supports one function:&nbsp;<code>next(int n)</code>, which exhausts the next <code>n</code> elements&nbsp;(<code>n &gt;= 1</code>) and returns the last element exhausted in this way.&nbsp; If there is no element left to exhaust, <code>next</code>&nbsp;returns <code>-1</code> instead.</p>\r\n\r\n<p>For example, we start with <code>A = [3,8,0,9,2,5]</code>, which is a run-length encoding of the sequence <code>[8,8,8,5,5]</code>.&nbsp; This is because the sequence can be read as&nbsp;&quot;three eights, zero nines, two fives&quot;.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[&quot;RLEIterator&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;]</span>, <span id=\"example-input-1-2\">[[[3,8,0,9,2,5]],[2],[1],[1],[2]]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">[null,8,8,5,-1]</span>\r\n<strong>Explanation: </strong>\r\nRLEIterator is initialized with RLEIterator([3,8,0,9,2,5]).\r\nThis maps to the sequence [8,8,8,5,5].\r\nRLEIterator.next is then called 4 times:\r\n\r\n.next(2) exhausts 2 terms of the sequence, returning 8.  The remaining sequence is now [8, 5, 5].\r\n\r\n.next(1) exhausts 1 term of the sequence, returning 8.  The remaining sequence is now [5, 5].\r\n\r\n.next(1) exhausts 1 term of the sequence, returning 5.  The remaining sequence is now [5].\r\n\r\n.next(2) exhausts 2 terms, returning -1.  This is because the first term exhausted was 5,\r\nbut the second term did not exist.  Since the last term exhausted does not exist, we return -1.\r\n\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>0 &lt;= A.length &lt;= 1000</code></li>\r\n\t<li><code>A.length</code>&nbsp;is an even integer.</li>\r\n\t<li><code>0 &lt;= A[i] &lt;= 10^9</code></li>\r\n\t<li>There are at most <code>1000</code> calls to <code>RLEIterator.next(int n)</code> per test case.</li>\r\n\t<li>Each call to&nbsp;<code>RLEIterator.next(int n)</code>&nbsp;will have <code>1 &lt;= n &lt;= 10^9</code>.</li>\r\n</ol>\r\n",
    "tags": "Array",
    "difficulty": 2,
    "frontend_article_id": 900,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-store-exhausted-position-and-quantity\">Approach 1: Store Exhausted Position and Quantity</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-store-exhausted-position-and-quantity\">Approach 1: Store Exhausted Position and Quantity</h4> \n  <p><strong>Intuition</strong></p> \n  <p>We can store an index <code>i</code> and quantity <code>q</code> which represents that <code>q</code> elements of <code>A[i]</code> (repeated <code>A[i+1]</code> times) are exhausted.</p> \n  <p>For example, if we have <code>A = [1,2,3,4]</code> (mapping to the sequence <code>[2,4,4,4]</code>) then <code>i = 0, q = 0</code> represents that nothing is exhausted; <code>i = 0, q = 1</code> represents that <code>[2]</code> is exhausted, <code>i = 2, q = 1</code> will represent that we have currently exhausted <code>[2, 4]</code>, and so on.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Say we want to exhaust <code>n</code> more elements. There are currently <code>D = A[i] - q</code> elements left to exhaust (of value <code>A[i+1]</code>).</p> \n  <p>If <code>n &gt; D</code>, then we should exhaust all of them and continue: <code>n -= D; i += 2; q = 0</code>.</p> \n  <p>Otherwise, we should exhaust some of them and return the current element's value: <code>q += D; return A[i+1]</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/YThfYaPX/shared\" frameborder=\"0\" width=\"100%\" height=\"480\" name=\"YThfYaPX\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N + Q)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>A</code>, and <script type=\"math/tex; mode=display\">Q</script> is the number of calls to <code>RLEIterator.next</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 899,
    "article_live": true,
    "article_slug": "orderly-queue",
    "title": "Orderly Queue",
    "title_slug": "orderly-queue",
    "content": "<p>A string <code>S</code> of lowercase letters is given.&nbsp; Then, we may make any number of <em>moves</em>.</p>\r\n\r\n<p>In each move, we&nbsp;choose one&nbsp;of the first <code>K</code> letters (starting from the left), remove it,&nbsp;and place it at the end of the string.</p>\r\n\r\n<p>Return the lexicographically smallest string we could have after any number of moves.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>S = <span id=\"example-input-1-1\">&quot;cba&quot;</span>, K = <span id=\"example-input-1-2\">1</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">&quot;acb&quot;</span>\r\n<strong>Explanation: </strong>\r\nIn the first move, we move the 1st character (&quot;c&quot;) to the end, obtaining the string &quot;bac&quot;.\r\nIn the second move, we move the 1st character (&quot;b&quot;) to the end, obtaining the final result &quot;acb&quot;.\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>S = <span id=\"example-input-2-1\">&quot;baaca&quot;</span>, K = <span id=\"example-input-2-2\">3</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">&quot;aaabc&quot;</span>\r\n<strong>Explanation: </strong>\r\nIn the first move, we move the 1st character (&quot;b&quot;) to the end, obtaining the string &quot;aacab&quot;.\r\nIn the second move, we move the 3rd character (&quot;c&quot;) to the end, obtaining the final result &quot;aaabc&quot;.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= K &lt;= S.length&nbsp;&lt;= 1000</code></li>\r\n\t<li><code>S</code>&nbsp;consists of lowercase letters only.</li>\r\n</ol>\r\n</div>\r\n</div>\r\n",
    "tags": "Math, String",
    "difficulty": 3,
    "frontend_article_id": 899,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-mathematical\">Approach 1: Mathematical</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-mathematical\">Approach 1: Mathematical</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Call the move that takes the <code>K</code>th letter from the beginning and puts it on the end, a \"<em><code>K</code>-kick</em>\" move.</p> \n  <p>Examining 1-kick moves, they let us consider the string as a \"necklace\" that may be rotated freely, where each bead of the necklace corresponds to a letter in the string. (Formally, this is the equivalence class under 1-kick moves.)</p> \n  <p>Examining 2-kick moves (in the context of treating the string as a necklace), they allow us to swap the positions of two adjacent beads. Thus, with 2-kick moves, every permutation of necklace is possible. (To actually construct the necklace, we bring the second smallest bead to be after the smallest, then the third smallest to be after the second smallest, and so on.)</p> \n  <p>The previous insight may be difficult to find. Another strategy is to write a brute force program to examine the result of 2-kick moves - then we might notice that 2-kick moves allow any permutation of the string.</p> \n  <p>Yet another strategy might be to explicitly construct new moves based on previous moves. If we perform a 2 kick move followed by many 1 kick moves, we can move a string like <code>\"xyzzzzzz\" -&gt; \"xzzzzzzy\" -&gt; \"yxzzzzzz\"</code>, proving we can swap the positions of any two adjacent letters.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>If <code>K = 1</code>, only rotations of <code>S</code> are possible, and the answer is the smallest rotation.</p> \n  <p>If <code>K &gt; 1</code>, any permutation of <code>S</code> is possible, and the answer is the letters of <code>S</code> written in lexicographic order.</p> \n  <iframe src=\"https://leetcode.com/playground/DCwCw7ZJ/shared\" frameborder=\"0\" width=\"100%\" height=\"327\" name=\"DCwCw7ZJ\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>S</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 898,
    "article_live": true,
    "article_slug": "bitwise-ors-of-subarrays",
    "title": "Bitwise ORs of Subarrays",
    "title_slug": "bitwise-ors-of-subarrays",
    "content": "<p>We have an array <code>A</code> of non-negative integers.</p>\r\n\r\n<p>For every (contiguous) subarray <code>B =&nbsp;[A[i], A[i+1], ..., A[j]]</code> (with <code>i &lt;= j</code>), we take the bitwise OR of all the elements in <code>B</code>, obtaining a result <font face=\"monospace\"><code>A[i] | A[i+1] | ... | A[j]</code>.</font></p>\r\n\r\n<p>Return the number of possible&nbsp;results.&nbsp; (Results that occur more than once are only counted once in the final answer.)</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[0]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">1</span>\r\n<strong>Explanation: </strong>\r\nThere is only one possible result: 0.\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">[1,1,2]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">3</span>\r\n<strong>Explanation: </strong>\r\nThe possible subarrays are [1], [1], [2], [1, 1], [1, 2], [1, 1, 2].\r\nThese yield the results 1, 1, 2, 1, 3, 3.\r\nThere are 3 unique values, so the answer is 3.\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-3-1\">[1,2,4]</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">6</span>\r\n<strong>Explanation: </strong>\r\nThe possible results are 1, 2, 3, 4, 6, and 7.\r\n</pre>\r\n</div>\r\n</div>\r\n</div>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= A.length &lt;= 50000</code></li>\r\n\t<li><code>0 &lt;= A[i] &lt;= 10^9</code></li>\r\n</ol>\r\n",
    "tags": "Dynamic Programming, Bit Manipulation",
    "difficulty": 2,
    "frontend_article_id": 898,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-frontier-set\">Approach 1: Frontier Set</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-frontier-set\">Approach 1: Frontier Set</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Let's try to speed up a brute force answer. Evidently, the brute force approach is to calculate every result <code>result(i, j) = A[i] | A[i+1] | ... | A[j]</code>. We can speed this up by taking note of the fact that <code>result(i, j+1) = result(i, j) | A[j+1]</code>. Naively, this approach has time complexity <script type=\"math/tex; mode=display\">O(N^2)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of the array.</p> \n  <p>Actually, this approach can be better than that. At the <code>k</code>th step, say we have all the <code>result(i, k)</code> in some set <code>cur</code>. Then we can find the next <code>cur</code> set (for <code>k -&gt; k+1</code>) by using <code>result(i, k+1) = result(i, k) | A[k+1]</code>.</p> \n  <p>However, the number of unique values in this set <code>cur</code> is at most 32, since the list <code>result(k, k), result(k-1, k), result(k-2, k), ...</code> is monotone increasing, and any subsequent values that are different must have more 1s in it's binary representation (to a maximum of 32 ones).</p> \n  <p><strong>Algorithm</strong></p> \n  <p>In the <code>k</code>th step, we'll maintain <code>cur</code>: the set of results <code>A[i] | ... | A[k]</code> for all <code>i</code>. These results will be included in our final answer set.</p> \n  <iframe src=\"https://leetcode.com/playground/rDNmUE84/shared\" frameborder=\"0\" width=\"100%\" height=\"344\" name=\"rDNmUE84\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N \\log W)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>A</code>, and <script type=\"math/tex; mode=display\">W</script> is the maximum size of elements in <code>A</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N \\log W)</script>, the size of the answer. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 897,
    "article_live": true,
    "article_slug": "increasing-order-search-tree",
    "title": "Increasing Order Search Tree",
    "title_slug": "increasing-order-search-tree",
    "content": "<p>Given a tree, rearrange the tree in <strong>in-order</strong> so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only 1 right child.</p>\r\n\r\n<pre>\r\n<strong>Example 1:</strong>\r\n<strong>Input:</strong> [5,3,6,2,4,null,8,1,null,null,null,7,9]\r\n\r\n       5\r\n      / \\\r\n    3    6\r\n   / \\    \\\r\n  2   4    8\r\n&nbsp;/        / \\ \r\n1        7   9\r\n\r\n<strong>Output:</strong> [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]\r\n\r\n 1\r\n&nbsp; \\\r\n&nbsp;  2\r\n&nbsp;   \\\r\n&nbsp;    3\r\n&nbsp;     \\\r\n&nbsp;      4\r\n&nbsp;       \\\r\n&nbsp;        5\r\n&nbsp;         \\\r\n&nbsp;          6\r\n&nbsp;           \\\r\n&nbsp;            7\r\n&nbsp;             \\\r\n&nbsp;              8\r\n&nbsp;               \\\r\n                 9  </pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li>The number of nodes in the given tree will be between 1 and 100.</li>\r\n\t<li>Each node will have a unique integer value from 0 to 1000.</li>\r\n</ol>\r\n",
    "tags": "Tree, Depth-first Search",
    "difficulty": 1,
    "frontend_article_id": 897,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-in-order-traversal\">Approach 1: In-Order Traversal</a></li> \n      <li><a href=\"#approach-2-traversal-with-relinking\">Approach 2: Traversal with Relinking</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-in-order-traversal\">Approach 1: In-Order Traversal</h4> \n  <p><strong>Intuition</strong></p> \n  <p>The definition of a binary search tree is that for every node, all the values of the left branch are less than the value at the root, and all the values of the right branch are greater than the value at the root.</p> \n  <p>Because of this, an <em>in-order traversal</em> of the nodes will yield all the values in increasing order.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Once we have traversed all the nodes in increasing order, we can construct new nodes using those values to form the answer.</p> \n  <iframe src=\"https://leetcode.com/playground/RonWhYrN/shared\" frameborder=\"0\" width=\"100%\" height=\"378\" name=\"RonWhYrN\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of nodes in the given tree.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the size of the answer. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-traversal-with-relinking\">Approach 2: Traversal with Relinking</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>We can perform the same in-order traversal as in <em>Approach 1</em>. During the traversal, we'll construct the answer on the fly, reusing the nodes of the given tree by cutting their left child and adjoining them to the answer.</p> \n  <iframe src=\"https://leetcode.com/playground/5M7CYgmK/shared\" frameborder=\"0\" width=\"100%\" height=\"361\" name=\"5M7CYgmK\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of nodes in the given tree.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(H)</script> in <em>additional</em> space complexity, where <script type=\"math/tex; mode=display\">H</script> is the height of the given tree, and the size of the implicit call stack in our in-order traversal. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 896,
    "article_live": true,
    "article_slug": "monotonic-array",
    "title": "Monotonic Array",
    "title_slug": "monotonic-array",
    "content": "<p>An array is <em>monotonic</em> if it is either monotone increasing or monotone decreasing.</p>\r\n\r\n<p>An array <code>A</code> is monotone increasing if for all <code>i &lt;= j</code>, <code>A[i] &lt;= A[j]</code>.&nbsp; An array <code>A</code> is monotone decreasing if for all <code>i &lt;= j</code>, <code>A[i] &gt;= A[j]</code>.</p>\r\n\r\n<p>Return <code>true</code> if and only if the given array <code>A</code> is monotonic.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<ol>\r\n</ol>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[1,2,2,3]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">true</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">[6,5,4,4]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">true</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-3-1\">[1,3,2]</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">false</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 4:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-4-1\">[1,2,4,5]</span>\r\n<strong>Output: </strong><span id=\"example-output-4\">true</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 5:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-5-1\">[1,1,1]</span>\r\n<strong>Output: </strong><span id=\"example-output-5\">true</span>\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= A.length &lt;= 50000</code></li>\r\n\t<li><code>-100000 &lt;= A[i] &lt;= 100000</code></li>\r\n</ol>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n",
    "tags": "Array",
    "difficulty": 1,
    "frontend_article_id": 896,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-two-pass\">Approach 1: Two Pass</a></li> \n      <li><a href=\"#approach-2-one-pass\">Approach 2: One Pass</a></li> \n      <li><a href=\"#approach-3-one-pass-simple-variant\">Approach 3: One Pass (Simple Variant)</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-two-pass\">Approach 1: Two Pass</h4> \n  <p><strong>Intuition</strong></p> \n  <p>An array is <em>monotonic</em> if it is monotone increasing, or monotone decreasing. Since <code>a &lt;= b</code> and <code>b &lt;= c</code> implies <code>a &lt;= c</code>, we only need to check adjacent elements to determine if the array is monotone increasing (or decreasing, respectively). We can check each of these properties in one pass.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>To check whether an array <code>A</code> is monotone increasing, we'll check <code>A[i] &lt;= A[i+1]</code> for all <code>i</code>. The check for monotone decreasing is similar.</p> \n  <iframe src=\"https://leetcode.com/playground/45YrvCAw/shared\" frameborder=\"0\" width=\"100%\" height=\"344\" name=\"45YrvCAw\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>A</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-one-pass\">Approach 2: One Pass</h4> \n  <p><strong>Intuition</strong></p> \n  <p>To perform this check in one pass, we want to handle a stream of comparisons from <script type=\"math/tex; mode=display\">\\{-1, 0, 1\\}</script>, corresponding to <code>&lt;</code>, <code>==</code>, or <code>&gt;</code>. For example, with the array <code>[1, 2, 2, 3, 0]</code>, we will see the stream <code>(-1, 0, -1, 1)</code>.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Keep track of <code>store</code>, equal to the first non-zero comparison seen (if it exists.) If we see the opposite comparison, the answer is <code>False</code>.</p> \n  <p>Otherwise, every comparison was (necessarily) in the set <script type=\"math/tex; mode=display\">\\{-1, 0\\}</script>, or every comparison was in the set <script type=\"math/tex; mode=display\">\\{0, 1\\}</script>, and therefore the array is monotonic.</p> \n  <iframe src=\"https://leetcode.com/playground/qcBYT2JK/shared\" frameborder=\"0\" width=\"100%\" height=\"310\" name=\"qcBYT2JK\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>A</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-one-pass-simple-variant\">Approach 3: One Pass (Simple Variant)</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>To perform this check in one pass, we want to remember if it is monotone increasing or monotone decreasing.</p> \n  <p>It's monotone increasing if there aren't some adjacent values <code>A[i], A[i+1]</code> with <code>A[i] &gt; A[i+1]</code>, and similarly for monotone decreasing.</p> \n  <p>If it is either monotone increasing or monotone decreasing, then <code>A</code> is monotonic.</p> \n  <iframe src=\"https://leetcode.com/playground/FnWYKTw8/shared\" frameborder=\"0\" width=\"100%\" height=\"293\" name=\"FnWYKTw8\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>A</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 895,
    "article_live": true,
    "article_slug": "maximum-frequency-stack",
    "title": "Maximum Frequency Stack",
    "title_slug": "maximum-frequency-stack",
    "content": "<p>Implement <code>FreqStack</code>, a class which simulates the operation of a stack-like data structure.</p>\r\n\r\n<p><code>FreqStack</code>&nbsp;has two functions:</p>\r\n\r\n<ul>\r\n\t<li><code>push(int x)</code>, which pushes an integer <code>x</code> onto the stack.</li>\r\n\t<li><code>pop()</code>, which <strong>removes</strong> and returns the most frequent element in the stack.\r\n\t<ul>\r\n\t\t<li>If there is a tie for most frequent element, the element closest to the top of the stack is removed and returned.</li>\r\n\t</ul>\r\n\t</li>\r\n</ul>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>\r\n<span id=\"example-input-1-1\">[&quot;FreqStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;]</span>,\r\n<span id=\"example-input-1-2\">[[],[5],[7],[5],[7],[4],[5],[],[],[],[]]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">[null,null,null,null,null,null,null,5,7,5,4]</span>\r\n<strong>Explanation</strong>:\r\nAfter making six .push operations, the stack is [5,7,5,7,4,5] from bottom to top.  Then:\r\n\r\npop() -&gt; returns 5, as 5 is the most frequent.\r\nThe stack becomes [5,7,5,7,4].\r\n\r\npop() -&gt; returns 7, as 5 and 7 is the most frequent, but 7 is closest to the top.\r\nThe stack becomes [5,7,5,4].\r\n\r\npop() -&gt; returns 5.\r\nThe stack becomes [5,7,4].\r\n\r\npop() -&gt; returns 4.\r\nThe stack becomes [5,7].\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>Calls to <code>FreqStack.push(int x)</code>&nbsp;will be such that <code>0 &lt;= x &lt;= 10^9</code>.</li>\r\n\t<li>It is guaranteed that <code>FreqStack.pop()</code> won&#39;t be called if the stack has zero elements.</li>\r\n\t<li>The total number of <code>FreqStack.push</code> calls will not exceed <code>10000</code> in a single test case.</li>\r\n\t<li>The total number of <code>FreqStack.pop</code>&nbsp;calls will not exceed <code>10000</code> in a single test case.</li>\r\n\t<li>The total number of <code>FreqStack.push</code> and <code>FreqStack.pop</code> calls will not exceed <code>150000</code> across all test cases.</li>\r\n</ul>\r\n\r\n<div>\r\n<p>&nbsp;</p>\r\n</div>\r\n",
    "tags": "Hash Table, Stack",
    "difficulty": 3,
    "frontend_article_id": 895,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-stack-of-stacks\">Approach 1: Stack of Stacks</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-stack-of-stacks\">Approach 1: Stack of Stacks</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Evidently, we care about the frequency of an element. Let <code>freq</code> be a <code>Map</code> from <script type=\"math/tex; mode=display\">x</script> to the number of occurrences of <script type=\"math/tex; mode=display\">x</script>.</p> \n  <p>Also, we (probably) care about <code>maxfreq</code>, the current maximum frequency of any element in the stack. This is clear because we must pop the element with the maximum frequency.</p> \n  <p>The main question then becomes: among elements with the same (maximum) frequency, how do we know which element is most recent? We can use a stack to query this information: the top of the stack is the most recent.</p> \n  <p>To this end, let <code>group</code> be a map from frequency to a stack of elements with that frequency. We now have all the required components to implement <code>FreqStack</code>.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Actually, as an implementation level detail, if <code>x</code> has frequency <code>f</code>, then we'll have <code>x</code> in all <code>group[i] (i &lt;= f)</code>, not just the top. This is because each <code>group[i]</code> will store information related to the <code>i</code>th copy of <code>x</code>.</p> \n  <p>Afterwards, our goal is just to maintain <code>freq</code>, <code>group</code>, and <code>maxfreq</code> as described above.</p> \n  <iframe src=\"https://leetcode.com/playground/jD2jBGjF/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"jD2jBGjF\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(1)</script> for both <code>push</code> and <code>pop</code> operations.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <code>N</code> is the number of elements in the <code>FreqStack</code>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 894,
    "article_live": true,
    "article_slug": "all-possible-full-binary-trees",
    "title": "All Possible Full Binary Trees",
    "title_slug": "all-possible-full-binary-trees",
    "content": "<p>A <em>full binary tree</em>&nbsp;is a binary tree where each node has exactly 0 or 2&nbsp;children.</p>\r\n\r\n<p>Return a list of all possible full binary trees with <code>N</code> nodes.&nbsp; Each element of the answer is the root node of one possible tree.</p>\r\n\r\n<p>Each <code>node</code> of each&nbsp;tree in the answer <strong>must</strong> have <code>node.val = 0</code>.</p>\r\n\r\n<p>You may return the final list of trees in any order.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">7</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">[[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]</span>\r\n<strong>Explanation:</strong>\r\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/22/fivetrees.png\" style=\"width: 700px; height: 400px;\" />\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= N &lt;= 20</code></li>\r\n</ul>\r\n",
    "tags": "Tree, Recursion",
    "difficulty": 2,
    "frontend_article_id": 894,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-recursion\">Approach 1: Recursion</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-recursion\">Approach 1: Recursion</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Let <script type=\"math/tex; mode=display\">\\text{FBT}(N)</script> be the list of all possible full binary trees with <script type=\"math/tex; mode=display\">N</script> nodes.</p> \n  <p>Every full binary tree <script type=\"math/tex; mode=display\">T</script> with 3 or more nodes, has 2 children at its root. Each of those children <code>left</code> and <code>right</code> are themselves full binary trees.</p> \n  <p>Thus, for <script type=\"math/tex; mode=display\">N \\geq 3</script>, we can formulate the recursion: <script type=\"math/tex; mode=display\">\\text{FBT}(N) =</script> [All trees with left child from <script type=\"math/tex; mode=display\">\\text{FBT}(x)</script> and right child from <script type=\"math/tex; mode=display\">\\text{FBT}(N-1-x)</script>, for all <script type=\"math/tex; mode=display\">x</script>].</p> \n  <p>Also, by a simple counting argument, there are no full binary trees with a positive, even number of nodes.</p> \n  <p>Finally, we should cache previous results of the function <script type=\"math/tex; mode=display\">\\text{FBT}</script> so that we don't have to recalculate them in our recursion.</p> \n  <iframe src=\"https://leetcode.com/playground/MNvnRoUP/shared\" frameborder=\"0\" width=\"100%\" height=\"497\" name=\"MNvnRoUP\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(2^N)</script>. For odd <script type=\"math/tex; mode=display\">N</script>, let <script type=\"math/tex; mode=display\">N = 2k + 1</script>. Then, <script type=\"math/tex; mode=display\">\\Big| \\text{FBT}(N) \\Big| = C_k</script>, the <script type=\"math/tex; mode=display\">k</script>-th catalan number; and <script type=\"math/tex; mode=display\">\\sum\\limits_{k < \\frac{N}{2}} C_k</script> (the complexity involved in computing intermediate results required) is bounded by <script type=\"math/tex; mode=display\">O(2^N)</script>. However, the proof is beyond the scope of this article.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(2^N)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 893,
    "article_live": true,
    "article_slug": "groups-of-special-equivalent-strings",
    "title": "Groups of Special-Equivalent Strings",
    "title_slug": "groups-of-special-equivalent-strings",
    "content": "<p>You are given an array <code>A</code> of strings.</p>\r\n\r\n<p>Two strings <code>S</code> and <code>T</code> are&nbsp;<em>special-equivalent</em>&nbsp;if after any number of <em>moves</em>, S == T.</p>\r\n\r\n<p>A <em>move</em> consists of choosing two indices <code>i</code> and <code>j</code> with <code>i % 2 == j % 2</code>, and swapping <code>S[i]</code> with <code>S[j]</code>.</p>\r\n\r\n<p>Now, a <em>group of special-equivalent strings from <code>A</code></em>&nbsp;is a&nbsp;non-empty subset S of <code>A</code>&nbsp;such that any string not in S&nbsp;is not special-equivalent with any string in S.</p>\r\n\r\n<p>Return the number of groups of special-equivalent strings from <code>A</code>.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<ul>\r\n</ul>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;a&quot;,&quot;c&quot;,&quot;c&quot;]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">3</span>\r\n<span><strong>Explanation</strong>: 3 groups [&quot;a&quot;,&quot;a&quot;], [&quot;b&quot;], [&quot;c&quot;,&quot;c&quot;,&quot;c&quot;]</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">[&quot;aa&quot;,&quot;bb&quot;,&quot;ab&quot;,&quot;ba&quot;]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">4</span>\r\n<strong>Explanation</strong>: 4 groups <span id=\"example-input-2-1\">[&quot;aa&quot;], [&quot;bb&quot;], [&quot;ab&quot;], [&quot;ba&quot;]</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-3-1\">[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">3</span>\r\n<strong>Explanation</strong>: 3 groups [&quot;abc&quot;,&quot;cba&quot;], [&quot;acb&quot;,&quot;bca&quot;], [&quot;bac&quot;,&quot;cab&quot;]\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 4:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-4-1\">[&quot;abcd&quot;,&quot;cdab&quot;,&quot;adcb&quot;,&quot;cbad&quot;]</span>\r\n<strong>Output: </strong><span id=\"example-output-4\">1</span>\r\n<strong>Explanation</strong>: 1 group <span id=\"example-input-4-1\">[&quot;abcd&quot;,&quot;cdab&quot;,&quot;adcb&quot;,&quot;cbad&quot;]</span>\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= A.length &lt;= 1000</code></li>\r\n\t<li><code>1 &lt;= A[i].length &lt;= 20</code></li>\r\n\t<li>All <code>A[i]</code> have the same length.</li>\r\n\t<li>All <code>A[i]</code> consist of only lowercase letters.</li>\r\n</ul>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n",
    "tags": "String",
    "difficulty": 1,
    "frontend_article_id": 893,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-counting\">Approach 1: Counting</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-counting\">Approach 1: Counting</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Let's try to characterize a special-equivalent string <script type=\"math/tex; mode=display\">S</script>, by finding a function <script type=\"math/tex; mode=display\">\\mathcal{C}</script> so that <script type=\"math/tex; mode=display\">S \\equiv T \\iff \\mathcal{C}(S) = \\mathcal{C}(T)</script>.</p> \n  <p>Through swapping, we can permute the even indexed letters, and the odd indexed letters. What characterizes these permutations is the count of the letters: all such permutations have the same count, and different counts have different permutations.</p> \n  <p>Thus, the function <script type=\"math/tex; mode=display\">\\mathcal{C}(S) =</script> (the count of the even indexed letters in S, followed by the count of the odd indexed letters in S) successfully characterizes the equivalence relation.</p> \n  <p>Afterwards, we count the number of unique <script type=\"math/tex; mode=display\">\\mathcal{C}(S)</script> for <script type=\"math/tex; mode=display\">S \\in A</script>.</p> \n  <iframe src=\"https://leetcode.com/playground/VUyxHYTk/shared\" frameborder=\"0\" width=\"100%\" height=\"259\" name=\"VUyxHYTk\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(\\sum\\limits_{i} (A_i)\\text{.length})</script> </p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>A</code>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 892,
    "article_live": true,
    "article_slug": "surface-area-of-3d-shapes",
    "title": "Surface Area of 3D Shapes",
    "title_slug": "surface-area-of-3d-shapes",
    "content": "<p>On a&nbsp;<code>N&nbsp;*&nbsp;N</code>&nbsp;grid, we place some&nbsp;<code>1 * 1 * 1&nbsp;</code>cubes.</p>\r\n\r\n<p>Each value&nbsp;<code>v = grid[i][j]</code>&nbsp;represents a tower of&nbsp;<code>v</code>&nbsp;cubes placed on top of grid cell&nbsp;<code>(i, j)</code>.</p>\r\n\r\n<p>Return the total surface area of the resulting shapes.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<div>\r\n<div>\r\n<ul>\r\n</ul>\r\n</div>\r\n</div>\r\n</div>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[[2]]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">10</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">[[1,2],[3,4]]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">34</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-3-1\">[[1,0],[0,2]]</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">16</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 4:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-4-1\">[[1,1,1],[1,0,1],[1,1,1]]</span>\r\n<strong>Output: </strong><span id=\"example-output-4\">32</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 5:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-5-1\">[[2,2,2],[2,1,2],[2,2,2]]</span>\r\n<strong>Output: </strong><span id=\"example-output-5\">46</span>\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= N &lt;= 50</code></li>\r\n\t<li><code>0 &lt;= grid[i][j] &lt;= 50</code></li>\r\n</ul>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n",
    "tags": "Math, Geometry",
    "difficulty": 1,
    "frontend_article_id": 892,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-square-by-square\">Approach 1: Square by Square</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-square-by-square\">Approach 1: Square by Square</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Let's try to count the surface area contributed by <code>v = grid[i][j]</code>.</p> \n  <p>When <code>v &gt; 0</code>, the top and bottom surface contributes an area of 2.</p> \n  <p>Then, for each side (west side, north side, east side, south side) of the column at <code>grid[i][j]</code>, the neighboring cell with value <code>nv</code> means our square contributes <code>max(v - nv, 0)</code>.</p> \n  <p>For example, for <code>grid = [[1, 5]]</code>, the contribution at <code>grid[0][1]</code> is 2 + 5 + 5 + 5 + 4. The 2 comes from the top and bottom side, the 5 comes from the north, east, and south side; and the 4 comes from the west side, of which 1 unit is covered by the adjacent column.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>For each <code>v = grid[r][c] &gt; 0</code>, count <code>ans += 2</code>, plus <code>ans += max(v - nv, 0)</code> for each neighboring value <code>nv</code> adjacent to <code>grid[r][c]</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/JqxzqTG3/shared\" frameborder=\"0\" width=\"100%\" height=\"497\" name=\"JqxzqTG3\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of rows (and columns) in the <code>grid</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 891,
    "article_live": true,
    "article_slug": "sum-of-subsequence-widths",
    "title": "Sum of Subsequence Widths",
    "title_slug": "sum-of-subsequence-widths",
    "content": "<p>Given an array of integers <code>A</code>, consider all non-empty subsequences of <code>A</code>.</p>\r\n\r\n<p>For any sequence S, let the&nbsp;<em>width</em>&nbsp;of S be the difference between the maximum and minimum element of S.</p>\r\n\r\n<p>Return the sum of the widths of all subsequences of A.&nbsp;</p>\r\n\r\n<p>As the answer may be very large, <strong>return the answer modulo 10^9 + 7</strong>.</p>\r\n\r\n<div>\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[2,1,3]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">6</span>\r\n<strong>Explanation:\r\n</strong>Subsequences are [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3].\r\nThe corresponding widths are 0, 0, 0, 1, 1, 2, 2.\r\nThe sum of these widths is 6.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= A.length &lt;= 20000</code></li>\r\n\t<li><code>1 &lt;= A[i] &lt;= 20000</code></li>\r\n</ul>\r\n</div>\r\n",
    "tags": "Array, Math",
    "difficulty": 3,
    "frontend_article_id": 891,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-mathematical\">Approach 1: Mathematical</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-mathematical\">Approach 1: Mathematical</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Let's try to count the number of subsequences with minimum <code>A[i]</code> and maximum <code>A[j]</code>.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>We can sort the array as it doesn't change the answer. After sorting the array, this allows us to know that the number of subsequences with minimum <code>A[i]</code> and maximum <code>A[j]</code> is <script type=\"math/tex; mode=display\">2^{j-i-1}</script>. Hence, the desired answer is:</p> \n  <p> <script type=\"math/tex; mode=display\">\n\\sum\\limits_{j > i} (2^{j-i-1}) (A_j - A_i)\n</script> </p> \n  <p> <script type=\"math/tex; mode=display\">\n= \\big( \\sum\\limits_{i = 0}^{n-2} \\sum\\limits_{j = i+1}^{n-1} (2^{j-i-1}) (A_j) \\big) - \\big( \\sum\\limits_{i = 0}^{n-2} \\sum\\limits_{j = i+1}^{n-1} (2^{j-i-1}) (A_i) \\big)\n</script> </p> \n  <p> <script type=\"math/tex; mode=display\">\n= \\big( (2^0 A_1 + 2^1 A_2 + 2^2 A_3 + \\cdots) + (2^0 A_2 + 2^1 A_3 + \\cdots) + (2^0 A_3 + 2^1 A_4 + \\cdots) + \\cdots \\big)\n</script> <script type=\"math/tex; mode=display\">\n - \\big( \\sum\\limits_{i = 0}^{n-2} (2^0 + 2^1 + \\cdots + 2^{N-i-2}) (A_i) \\big)\n</script> </p> \n  <p> <script type=\"math/tex; mode=display\">\n= \\big( \\sum\\limits_{j = 1}^{n-1} (2^j - 1) A_j \\big) - \\big( \\sum\\limits_{i = 0}^{n-2} (2^{N-i-1} - 1) A_i \\big)\n</script> </p> \n  <p> <script type=\"math/tex; mode=display\">\n= \\sum\\limits_{i = 0}^{n-1} \\big(((2^i - 1) A_i) - ((2^{N-i-1} - 1) A_i)\\big)\n</script> </p> \n  <p> <script type=\"math/tex; mode=display\">\n= \\sum\\limits_{i = 0}^{n-1} (2^i - 2^{N-i-1}) A_i\n</script> </p> \n  <iframe src=\"https://leetcode.com/playground/DmYZUfzN/shared\" frameborder=\"0\" width=\"100%\" height=\"361\" name=\"DmYZUfzN\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N \\log N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>A</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the space used by <code>pow2</code>. (We can improve this to <script type=\"math/tex; mode=display\">O(1)</script> space by calculating these powers on the fly.) <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 890,
    "article_live": true,
    "article_slug": "find-and-replace-pattern",
    "title": "Find and Replace Pattern",
    "title_slug": "find-and-replace-pattern",
    "content": "<p>You have a list of&nbsp;<code>words</code> and a <code>pattern</code>, and you want to know which words in <code>words</code> matches the pattern.</p>\r\n\r\n<p>A word matches the pattern if there exists a permutation of letters <code>p</code> so that after replacing every letter <code>x</code> in the pattern with <code>p(x)</code>, we get the desired word.</p>\r\n\r\n<p>(<em>Recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.</em>)</p>\r\n\r\n<p>Return a list of the words in <code>words</code>&nbsp;that match the given pattern.&nbsp;</p>\r\n\r\n<p>You may return the answer in any order.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>words = <span id=\"example-input-1-1\">[&quot;abc&quot;,&quot;deq&quot;,&quot;mee&quot;,&quot;aqq&quot;,&quot;dkd&quot;,&quot;ccc&quot;]</span>, pattern = <span id=\"example-input-1-2\">&quot;abb&quot;</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">[&quot;mee&quot;,&quot;aqq&quot;]</span>\r\n<strong><span>Explanation: </span></strong>&quot;mee&quot; matches the pattern because there is a permutation {a -&gt; m, b -&gt; e, ...}. \r\n&quot;ccc&quot; does not match the pattern because {a -&gt; c, b -&gt; c, ...} is not a permutation,\r\nsince a and b map to the same letter.</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= words.length &lt;= 50</code></li>\r\n\t<li><code>1 &lt;= pattern.length = words[i].length&nbsp;&lt;= 20</code></li>\r\n</ul>\r\n</div>\r\n",
    "tags": "String",
    "difficulty": 2,
    "frontend_article_id": 890,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-two-maps\">Approach 1: Two Maps</a></li> \n      <li><a href=\"#approach-2-one-map\">Approach 2: One Map</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-two-maps\">Approach 1: Two Maps</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>If say, the first letter of the pattern is <code>\"a\"</code>, and the first letter of the word is <code>\"x\"</code>, then in the permutation, <code>\"a\"</code> must map to <code>\"x\"</code>.</p> \n  <p>We can write this bijection using two maps: a forward map <script type=\"math/tex; mode=display\">\\text{m1}</script> and a backwards map <script type=\"math/tex; mode=display\">\\text{m2}</script>.</p> \n  <p> <script type=\"math/tex; mode=display\">\n\\text{m1} : \\text{\"a\"} \\rightarrow \\text{\"x\"}\n</script> <script type=\"math/tex; mode=display\">\n\\text{m2} : \\text{\"x\"} \\rightarrow \\text{\"a\"}\n</script> </p> \n  <p>Then, if there is a contradiction later, we can catch it via one of the two maps. For example, if the <code>(word, pattern)</code> is <code>(\"aa\", \"xy\")</code>, we will catch the mistake in <script type=\"math/tex; mode=display\">\\text{m1}</script> (namely, <script type=\"math/tex; mode=display\">\\text{m1}(\\text{\"a\"}) = \\text{\"x\"} = \\text{\"y\"}</script>). Similarly, with <code>(word, pattern) = (\"ab\", \"xx\")</code>, we will catch the mistake in <script type=\"math/tex; mode=display\">\\text{m2}</script>.</p> \n  <iframe src=\"https://leetcode.com/playground/9TL6xVWm/shared\" frameborder=\"0\" width=\"100%\" height=\"480\" name=\"9TL6xVWm\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N * K)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of words, and <script type=\"math/tex; mode=display\">K</script> is the length of each word.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N * K)</script>, the space used by the answer. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-one-map\">Approach 2: One Map</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>As in <em>Approach 1</em>, we can have some forward map <script type=\"math/tex; mode=display\">\\text{m1} : \\mathbb{L} \\rightarrow \\mathbb{L}</script>, where <script type=\"math/tex; mode=display\">\\mathbb{L}</script> is the set of letters. </p> \n  <p>However, instead of keeping track of the reverse map <script type=\"math/tex; mode=display\">\\text{m2}</script>, we could simply make sure that every value <script type=\"math/tex; mode=display\">\\text{m1}(x)</script> in the codomain is reached at most once. This would guarantee the desired permutation exists.</p> \n  <p>So our algorithm is this: after defining <script type=\"math/tex; mode=display\">\\text{m1}(x)</script> in the same way as <em>Approach 1</em> (the forward map of the permutation), afterwards we make sure it reaches distinct values.</p> \n  <iframe src=\"https://leetcode.com/playground/3vbeWuoq/shared\" frameborder=\"0\" width=\"100%\" height=\"497\" name=\"3vbeWuoq\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N * K)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of words, and <script type=\"math/tex; mode=display\">K</script> is the length of each word.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N * K)</script>, the space used by the answer. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 889,
    "article_live": true,
    "article_slug": "construct-binary-tree-from-preorder-and-postorder-",
    "title": "Construct Binary Tree from Preorder and Postorder Traversal",
    "title_slug": "construct-binary-tree-from-preorder-and-postorder-traversal",
    "content": "<p>Return any binary tree that matches the given preorder and postorder traversals.</p>\r\n\r\n<p>Values in the traversals&nbsp;<code>pre</code> and <code>post</code>&nbsp;are distinct&nbsp;positive integers.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>pre = <span id=\"example-input-1-1\">[1,2,4,5,3,6,7]</span>, post = <span id=\"example-input-1-2\">[4,5,2,6,7,3,1]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">[1,2,3,4,5,6,7]</span>\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong><span>Note:</span></strong></p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= pre.length == post.length &lt;= 30</code></li>\r\n\t<li><code>pre[]</code> and <code>post[]</code>&nbsp;are both permutations of <code>1, 2, ..., pre.length</code>.</li>\r\n\t<li>It is guaranteed an answer exists. If there exists multiple answers, you can return any of them.</li>\r\n</ul>\r\n</div>\r\n",
    "tags": "Tree",
    "difficulty": 2,
    "frontend_article_id": 889,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-recursion\">Approach 1: Recursion</a></li> \n      <li><a href=\"#approach-2-recursion-space-saving-variant\">Approach 2: Recursion (Space Saving Variant)</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-recursion\">Approach 1: Recursion</h4> \n  <p><strong>Intuition</strong></p> \n  <p>A preorder traversal is:</p> \n  <ul> \n   <li><code>(root node) (preorder of left branch) (preorder of right branch)</code></li> \n  </ul> \n  <p>While a postorder traversal is:</p> \n  <ul> \n   <li><code>(postorder of left branch) (postorder of right branch) (root node)</code></li> \n  </ul> \n  <p>For example, if the final binary tree is <code>[1, 2, 3, 4, 5, 6, 7]</code> (serialized), then the preorder traversal is <code>[1] + [2, 4, 5] + [3, 6, 7]</code>, while the postorder traversal is <code>[4, 5, 2] + [6, 7, 3] + [1]</code>.</p> \n  <p>If we knew how many nodes the left branch had, we could partition these arrays as such, and use recursion to generate each branch of the tree.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Let's say the left branch has <script type=\"math/tex; mode=display\">L</script> nodes. We know the head node of that left branch is <code>pre[1]</code>, but it also occurs last in the postorder representation of the left branch. So <code>pre[1] = post[L-1]</code> (because of uniqueness of the node values.) Hence, <code>L = post.indexOf(pre[1]) + 1</code>.</p> \n  <p>Now in our recursion step, the left branch is represnted by <code>pre[1 : L+1]</code> and <code>post[0 : L]</code>, while the right branch is represented by <code>pre[L+1 : N]</code> and <code>post[L : N-1]</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/ionmaXi9/shared\" frameborder=\"0\" width=\"100%\" height=\"378\" name=\"ionmaXi9\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of nodes.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-recursion-space-saving-variant\">Approach 2: Recursion (Space Saving Variant)</h4> \n  <p><strong>Explanation</strong></p> \n  <p>We present a variation of <em>Approach 1</em> that uses indexes to refer to the subarrays of <code>pre</code> and <code>post</code>, instead of passing copies of those subarrays. Here, <code>(i0, i1, N)</code> refers to <code>pre[i0:i0+N], post[i1:i1+N]</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/mDiypcXK/shared\" frameborder=\"0\" width=\"100%\" height=\"446\" name=\"mDiypcXK\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of nodes.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the space used by the answer. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 888,
    "article_live": true,
    "article_slug": "fair-candy-swap",
    "title": "Fair Candy Swap",
    "title_slug": "fair-candy-swap",
    "content": "<p>Alice and Bob have candy bars of different sizes: <code>A[i]</code> is the size of the <code>i</code>-th bar of candy that Alice has, and <code>B[j]</code> is the size of the <code>j</code>-th bar of candy that Bob has.</p>\r\n\r\n<p>Since they are friends, they would like to exchange one candy bar each so that after the exchange, they both have the same total&nbsp;amount of candy.&nbsp; (<em>The total amount of candy&nbsp;a person has is the sum of the sizes of candy&nbsp;bars they have.</em>)</p>\r\n\r\n<p>Return an integer array <code>ans</code>&nbsp;where <code>ans[0]</code> is the size of the candy bar that Alice must exchange, and <code>ans[1]</code> is the size of the candy bar that Bob must exchange.</p>\r\n\r\n<p>If there are multiple answers, you may return any one of them.&nbsp; It is guaranteed an answer exists.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>A = <span id=\"example-input-1-1\">[1,1]</span>, B = <span id=\"example-input-1-2\">[2,2]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">[1,2]</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>A = <span id=\"example-input-2-1\">[1,2]</span>, B = <span id=\"example-input-2-2\">[2,3]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">[1,2]</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>A = <span id=\"example-input-3-1\">[2]</span>, B = <span id=\"example-input-3-2\">[1,3]</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">[2,3]</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 4:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>A = <span id=\"example-input-4-1\">[1,2,5]</span>, B = <span id=\"example-input-4-2\">[2,4]</span>\r\n<strong>Output: </strong><span id=\"example-output-4\">[5,4]</span>\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong><span>Note:</span></strong></p>\r\n\r\n<ul>\r\n\t<li><span><code>1 &lt;= A.length &lt;= 10000</code></span></li>\r\n\t<li><span><code>1 &lt;= B.length &lt;= 10000</code></span></li>\r\n\t<li><code><span>1 &lt;= A[i] &lt;= 100000</span></code></li>\r\n\t<li><code><span>1 &lt;= B[i] &lt;= 100000</span></code></li>\r\n\t<li>It is guaranteed that Alice and Bob have different total amounts of&nbsp;candy.</li>\r\n\t<li>It is guaranteed there exists an&nbsp;answer.</li>\r\n</ul>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n",
    "tags": "Array",
    "difficulty": 1,
    "frontend_article_id": 888,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-solve-the-equation\">Approach 1: Solve the Equation</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-solve-the-equation\">Approach 1: Solve the Equation</h4> \n  <p><strong>Intuition</strong></p> \n  <p>If Alice swaps candy <code>x</code>, she expects some specific quantity of candy <code>y</code> back.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Say Alice and Bob have total candy <script type=\"math/tex; mode=display\">S_A, S_B</script> respectively.</p> \n  <p>If Alice gives candy <script type=\"math/tex; mode=display\">x</script>, and receives candy <script type=\"math/tex; mode=display\">y</script>, then Bob receives candy <script type=\"math/tex; mode=display\">x</script> and gives candy <script type=\"math/tex; mode=display\">y</script>. Then, we must have</p> \n  <p> <script type=\"math/tex; mode=display\">\nS_A - x + y = S_B - y + x\n</script> </p> \n  <p>for a fair candy swap. This implies</p> \n  <p> <script type=\"math/tex; mode=display\">\ny = x + \\frac{S_B - S_A}{2}\n</script> </p> \n  <p>Our strategy is simple. For every candy <script type=\"math/tex; mode=display\">x</script> that Alice has, if Bob has candy <script type=\"math/tex; mode=display\">y = x + \\frac{S_B - S_A}{2}</script>, we return <script type=\"math/tex; mode=display\">[x, y]</script>. We use a <code>Set</code> structure to check whether Bob has the desired candy <script type=\"math/tex; mode=display\">y</script> in constant time.</p> \n  <iframe src=\"https://leetcode.com/playground/WryKmFvR/shared\" frameborder=\"0\" width=\"100%\" height=\"361\" name=\"WryKmFvR\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(A\\text{.length} + B\\text{.length})</script>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(B\\text{.length})</script>, the space used by <code>setB</code>. (We can improve this to <script type=\"math/tex; mode=display\">\\min(A\\text{.length}, B\\text{.length})</script> by using an if statement.) <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 887,
    "article_live": true,
    "article_slug": "super-egg-drop",
    "title": "Super Egg Drop",
    "title_slug": "super-egg-drop",
    "content": "<p>You are given <code>K</code> eggs, and you have access to a building with <code>N</code> floors from <code>1</code> to <code>N</code>.&nbsp;</p>\r\n\r\n<p>Each egg is identical in function, and if an egg breaks, you cannot drop it&nbsp;again.</p>\r\n\r\n<p>You know that there exists a floor <code>F</code> with <code>0 &lt;= F &lt;= N</code> such that any egg dropped at a floor higher than <code>F</code> will break, and any egg dropped at or below floor <code>F</code> will not break.</p>\r\n\r\n<p>Each <em>move</em>, you may take an egg (if you have an unbroken one) and drop it from any floor <code>X</code> (with&nbsp;<code>1 &lt;= X &lt;= N</code>).&nbsp;</p>\r\n\r\n<p>Your goal is to know&nbsp;<strong>with certainty</strong>&nbsp;what the value of <code>F</code> is.</p>\r\n\r\n<p>What is the minimum number of moves that you need to know with certainty&nbsp;what <code>F</code> is, regardless of the initial value of <code>F</code>?</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<ol>\r\n</ol>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>K = <span id=\"example-input-1-1\">1</span>, N = <span id=\"example-input-1-2\">2</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">2</span>\r\n<strong>Explanation: </strong>\r\nDrop the egg from floor 1.  If it breaks, we know with certainty that F = 0.\r\nOtherwise, drop the egg from floor 2.  If it breaks, we know with certainty that F = 1.\r\nIf it didn&#39;t break, then we know with certainty F = 2.\r\nHence, we needed 2 moves in the worst case to know what F is with certainty.\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>K = <span id=\"example-input-2-1\">2</span>, N = 6\r\n<strong>Output: </strong><span id=\"example-output-2\">3</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>K = <span id=\"example-input-3-1\">3</span>, N = <span id=\"example-input-3-2\">14</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">4</span>\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= K &lt;= 100</code></li>\r\n\t<li><code>1 &lt;= N &lt;= 10000</code></li>\r\n</ol>\r\n</div>\r\n</div>\r\n</div>\r\n",
    "tags": "Math, Binary Search, Dynamic Programming",
    "difficulty": 3,
    "frontend_article_id": 887,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-dynamic-programming-with-binary-search\">Approach 1: Dynamic Programming with Binary Search</a></li> \n      <li><a href=\"#approach-2-dynamic-programming-with-optimality-criterion\">Approach 2: Dynamic Programming with Optimality Criterion</a></li> \n      <li><a href=\"#approach-3-mathematical\">Approach 3: Mathematical</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-dynamic-programming-with-binary-search\">Approach 1: Dynamic Programming with Binary Search</h4> \n  <p><strong>Intuition</strong></p> \n  <p>It's natural to attempt dynamic programming, as we encounter similar subproblems. Our state is <code>(K, N)</code>: <code>K</code> eggs and <code>N</code> floors left. When we drop an egg from floor <code>X</code>, it either survives and we have state <code>(K, N-X)</code>, or it breaks and we have state <code>(K-1, X-1)</code>.</p> \n  <p>This approach would lead to a <script type=\"math/tex; mode=display\">O(K N^2)</script> algorithm, but this is not efficient enough for the given constraints. However, we can try to speed it up. Let <code>dp(K, N)</code> be the maximum number of moves needed to solve the problem in state <code>(K, N)</code>. Then, by our reasoning above, we have:</p> \n  <p> <script type=\"math/tex; mode=display\">\n\\text{dp}(K, N) = \\min\\limits_{1 \\leq X \\leq N} \\Big( \\max(\\text{dp}(K-1, X-1), \\text{dp}(K, N-X)) \\Big)\n</script> </p> \n  <p>Now for the key insight: Because <script type=\"math/tex; mode=display\">\\text{dp}(K, N)</script> is a function that is increasing on <script type=\"math/tex; mode=display\">N</script>, the first term <script type=\"math/tex; mode=display\">\\mathcal{T_1} = \\text{dp}(K-1, X-1)</script> in our <script type=\"math/tex; mode=display\">\\max</script> expression is an increasing function on <script type=\"math/tex; mode=display\">X</script>, and the second term <script type=\"math/tex; mode=display\">\\mathcal{T_2} = \\text{dp}(K, N-X)</script> is a decreasing function on <script type=\"math/tex; mode=display\">X</script>. This means that we do not need to check every <script type=\"math/tex; mode=display\">X</script> to find the minimum -- instead, we can binary search for the best <script type=\"math/tex; mode=display\">X</script>.</p> \n  <p><strong>Algorithm</strong></p> \n  <p align=\"center\"> <img src=\"../Figures/891/sketch.png\" alt=\"T1, T2 diagram\" style=\"height: 300px;\"> </p> \n  <p>Continuing our discussion, if <script type=\"math/tex; mode=display\">\\mathcal{T_1} < \\mathcal{T_2}</script>, then the <script type=\"math/tex; mode=display\">X</script> value chosen is too small; and if <script type=\"math/tex; mode=display\">\\mathcal{T_1} > \\mathcal{T_2}</script>, then <script type=\"math/tex; mode=display\">X</script> is too big. However, this argument is not quite correct: when there are only two possible values of <script type=\"math/tex; mode=display\">X</script>, we need to check both.</p> \n  <p>Using the above fact, we can use a binary search to find the correct value of <script type=\"math/tex; mode=display\">X</script> more efficiently than checking all <script type=\"math/tex; mode=display\">N</script> of them.</p> \n  <iframe src=\"https://leetcode.com/playground/4RDYQYDJ/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"4RDYQYDJ\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(K * N \\log N)</script>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(K * N)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-dynamic-programming-with-optimality-criterion\">Approach 2: Dynamic Programming with Optimality Criterion</h4> \n  <p><strong>Intuition</strong></p> \n  <p>As in <em>Approach 1</em>, we try to speed up our <script type=\"math/tex; mode=display\">O(K N^2)</script> algorithm. Again, for a state of <script type=\"math/tex; mode=display\">K</script> eggs and <script type=\"math/tex; mode=display\">N</script> floors, where <script type=\"math/tex; mode=display\">\\text{dp}(K, N)</script> is the answer for that state, we have:</p> \n  <p> <script type=\"math/tex; mode=display\">\n\\text{dp}(K, N) = \\min\\limits_{1 \\leq X \\leq N} \\Big( \\max(\\text{dp}(K-1, X-1), \\text{dp}(K, N-X)) \\Big)\n</script> </p> \n  <p>Now, suppose <script type=\"math/tex; mode=display\">X_{\\emptyset} = \\text{opt}(K, N)</script> is the smallest <script type=\"math/tex; mode=display\">X</script> for which that minimum is attained: that is, the smallest value for which</p> \n  <p> <script type=\"math/tex; mode=display\">\n\\text{dp}(K, N) = \\Big( \\max(\\text{dp}(K-1, X_{\\emptyset}-1), \\text{dp}(K, N-X_{\\emptyset})) \\Big)\n</script> </p> \n  <p>The key insight that we will develop below, is that <script type=\"math/tex; mode=display\">\\text{opt}(K, N)</script> is an increasing function in <script type=\"math/tex; mode=display\">N</script>.</p> \n  <p align=\"center\"> <img src=\"../Figures/891/sketch2.png\" alt=\"T1, T2 diagram\" style=\"height: 300px;\"> </p> \n  <p>The first term of our <script type=\"math/tex; mode=display\">\\max</script> expression, <script type=\"math/tex; mode=display\">\\mathcal{T_1} = \\text{dp}(K-1, X-1)</script>, is increasing with respect to <script type=\"math/tex; mode=display\">X</script>, but constant with respect to <script type=\"math/tex; mode=display\">N</script>. The second term, <script type=\"math/tex; mode=display\">\\mathcal{T_2} = \\text{dp}(K, N-X)</script>, is decreasing with respect to <script type=\"math/tex; mode=display\">X</script>, but increasing with respect to <script type=\"math/tex; mode=display\">N</script>.</p> \n  <p>This means that as <script type=\"math/tex; mode=display\">N</script> increases, the intersection point <script type=\"math/tex; mode=display\">X_{\\emptyset} = \\text{opt}(K, N)</script> of these two lines is increasing, as we can see in the diagram.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Perform \"bottom up\" dynamic programming based on the recurrence below, keeping track of <script type=\"math/tex; mode=display\">X_{\\emptyset} = \\text{opt}(K, N)</script>. Again:</p> \n  <p> <script type=\"math/tex; mode=display\">\n\\text{dp}(K, N) = \\min\\limits_{1 \\leq X \\leq N} \\Big( \\max(\\text{dp}(K-1, X-1), \\text{dp}(K, N-X)) \\Big)\n</script> </p> \n  <p>When we want to find <script type=\"math/tex; mode=display\">\\text{dp}(K, N+1)</script>, instead of searching for <script type=\"math/tex; mode=display\">X</script> from <script type=\"math/tex; mode=display\">1 \\leq X \\leq N</script>, we only have to search through <script type=\"math/tex; mode=display\">X_{\\emptyset} \\leq X \\leq N</script>.</p> \n  <p>Actually, (as illustrated by the diagram,) if ever the next <script type=\"math/tex; mode=display\">X+1</script> is worse than the current <script type=\"math/tex; mode=display\">X</script>, then we've searched too far, and we know our current <script type=\"math/tex; mode=display\">X</script> is best for this <script type=\"math/tex; mode=display\">N</script>.</p> \n  <iframe src=\"https://leetcode.com/playground/w346npK6/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"w346npK6\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(K * N)</script>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-mathematical\">Approach 3: Mathematical</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Let's ask the question in reverse: given <script type=\"math/tex; mode=display\">T</script> moves (and <script type=\"math/tex; mode=display\">K</script> eggs), what is the most number of floors <script type=\"math/tex; mode=display\">f(T, K)</script> that we can still \"solve\" (find <script type=\"math/tex; mode=display\">0 \\leq F \\leq f(T, K)</script> with certainty)? Then, the problem is to find the least <script type=\"math/tex; mode=display\">T</script> for which <script type=\"math/tex; mode=display\">f(T, K) \\geq N</script>. Because more tries is always at least as good, <script type=\"math/tex; mode=display\">f</script> is increasing on <script type=\"math/tex; mode=display\">T</script>, which means we could binary search for the answer.</p> \n  <p>Now, we find a similar recurrence for <script type=\"math/tex; mode=display\">f</script> as in the other approaches. If in an optimal strategy we drop the egg from floor <script type=\"math/tex; mode=display\">X_{\\emptyset}</script>, then either it breaks and we can solve <script type=\"math/tex; mode=display\">f(T-1, K-1)</script> lower floors (floors <script type=\"math/tex; mode=display\">< X_{\\emptyset}</script>); or it doesn't break and we can solve <script type=\"math/tex; mode=display\">f(T-1, K)</script> higher floors (floors <script type=\"math/tex; mode=display\">\\geq X_{\\emptyset}</script>). In total,</p> \n  <p> <script type=\"math/tex; mode=display\">\nf(T, K) = 1 + f(T-1, K-1) + f(T-1, K)\n</script> </p> \n  <p>Also, it is easily seen that <script type=\"math/tex; mode=display\">f(t, 1) = t</script> when <script type=\"math/tex; mode=display\">t \\geq 1</script>, and <script type=\"math/tex; mode=display\">f(1, k) = 1</script> when <script type=\"math/tex; mode=display\">k \\geq 1</script>.</p> \n  <p align=\"center\"> <img src=\"../Figures/891/sketch3.png\" alt=\"T1, T2 diagram\" style=\"height: 300px;\" \"> </p> \n  <p>From here, we don't need to solve the recurrence mathematically - we could simply use it to generate all <script type=\"math/tex; mode=display\">O(K * \\max(T))</script> possible values of <script type=\"math/tex; mode=display\">f(T, K)</script>.</p> \n  <p>However, there is a mathematical solution to this recurrence. If <script type=\"math/tex; mode=display\">g(t, k) = f(t, k) - f(t, k-1)</script>, [the difference between the <script type=\"math/tex; mode=display\">k-1</script>th and <script type=\"math/tex; mode=display\">k</script>th term,] then subtracting the two equations:</p> \n  <p> <script type=\"math/tex; mode=display\">\nf(T, K) = 1 + f(T-1, K-1) + f(T-1, K)\n</script> </p> \n  <p> <script type=\"math/tex; mode=display\">\nf(T, K-1) = 1 + f(T-1, K-2) + f(T-1, K-1)\n</script> </p> \n  <p>we get:</p> \n  <p> <script type=\"math/tex; mode=display\">\ng(t, k) = g(t-1, k) + g(t-1, k-1)\n</script> </p> \n  <p>This is a binomial recurrence with solution <script type=\"math/tex; mode=display\">g(t, k) = \\binom{t}{k+1}</script>, so that indeed,</p> \n  <p> <script type=\"math/tex; mode=display\">\nf(t, k) = \\sum\\limits_{1 \\leq x \\leq K} g(t, x) = \\sum \\binom{t}{x}\n</script> </p> \n  <p><strong>Alternative Mathematical Derivation</strong></p> \n  <p>Alternatively, when we have <script type=\"math/tex; mode=display\">t</script> tries and <script type=\"math/tex; mode=display\">K</script> eggs, the result of our <script type=\"math/tex; mode=display\">t</script> throws must be a <script type=\"math/tex; mode=display\">t</script>-length sequence of successful and failed throws, with at most K failed throws. The number of sequences with <script type=\"math/tex; mode=display\">0</script> failed throws is <script type=\"math/tex; mode=display\">\\binom{t}{0}</script>, the number of sequences with <script type=\"math/tex; mode=display\">1</script> failed throw is <script type=\"math/tex; mode=display\">\\binom{t}{1}</script> etc., so that the number of such sequences is <script type=\"math/tex; mode=display\">\\sum\\limits_{0 \\leq x \\leq K} \\binom{t}{x}</script>.</p> \n  <p>Hence, we can only distinguish at most these many floors in <script type=\"math/tex; mode=display\">t</script> tries (as each sequence can only map to 1 answer per sequence.) This process includes distinguishing <script type=\"math/tex; mode=display\">F = 0</script>, so that the corresponding value of <script type=\"math/tex; mode=display\">N</script> is one less than this sum.</p> \n  <p>However, this is also a lower bound for the number of floors that can be distinguished, as the result of a throw on floor <script type=\"math/tex; mode=display\">X</script> will bound the answer to be either at most <script type=\"math/tex; mode=display\">X</script> or greater than <script type=\"math/tex; mode=display\">X</script>. Hence, in an optimal throwing strategy, each such sequence actually maps to a unique answer.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Recapping our algorithm, we have the increasing [wrt <script type=\"math/tex; mode=display\">t</script>] function <script type=\"math/tex; mode=display\">f(t, K) = \\sum\\limits_{1 \\leq x \\leq K} \\binom{t}{x}</script>, and we want the least <script type=\"math/tex; mode=display\">t</script> so that <script type=\"math/tex; mode=display\">f(t, K) \\geq N</script>. We binary search for the correct <script type=\"math/tex; mode=display\">t</script>.</p> \n  <p>To evaluate <script type=\"math/tex; mode=display\">f(t, K)</script> quickly, we can transform the previous binomial coefficient to the next (in the summand) by the formula <script type=\"math/tex; mode=display\">\\binom{n}{k} * \\frac{n-k}{k+1} = \\binom{n}{k+1}</script>.</p> \n  <iframe src=\"https://leetcode.com/playground/FXFk48xy/shared\" frameborder=\"0\" width=\"100%\" height=\"480\" name=\"FXFk48xy\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(K * \\log N)</script>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 886,
    "article_live": true,
    "article_slug": "possible-bipartition",
    "title": "Possible Bipartition",
    "title_slug": "possible-bipartition",
    "content": "<p>Given a set of <code>N</code>&nbsp;people (numbered <code>1, 2, ..., N</code>), we would like to split everyone into two groups of <strong>any</strong> size.</p>\r\n\r\n<p>Each person may dislike some other people, and they should not go into the same group.&nbsp;</p>\r\n\r\n<p>Formally, if <code>dislikes[i] = [a, b]</code>, it means it is not allowed to put the people numbered <code>a</code> and <code>b</code> into the same group.</p>\r\n\r\n<p>Return <code>true</code>&nbsp;if and only if it is possible to split everyone into two groups in this way.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<div>\r\n<ol>\r\n</ol>\r\n</div>\r\n</div>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>N = <span id=\"example-input-1-1\">4</span>, dislikes = <span id=\"example-input-1-2\">[[1,2],[1,3],[2,4]]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">true</span>\r\n<strong>Explanation</strong>: group1 [1,4], group2 [2,3]\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>N = <span id=\"example-input-2-1\">3</span>, dislikes = <span id=\"example-input-2-2\">[[1,2],[1,3],[2,3]]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">false</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>N = <span id=\"example-input-3-1\">5</span>, dislikes = <span id=\"example-input-3-2\">[[1,2],[2,3],[3,4],[4,5],[1,5]]</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">false</span>\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= N &lt;= 2000</code></li>\r\n\t<li><code>0 &lt;= dislikes.length &lt;= 10000</code></li>\r\n\t<li><code>1 &lt;= dislikes[i][j] &lt;= N</code></li>\r\n\t<li><code>dislikes[i][0] &lt; dislikes[i][1]</code></li>\r\n\t<li>There does not exist <code>i != j</code> for which <code>dislikes[i] == dislikes[j]</code>.</li>\r\n</ol>\r\n</div>\r\n</div>\r\n</div>\r\n",
    "tags": "Depth-first Search",
    "difficulty": 2,
    "frontend_article_id": 886,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-depth-first-search\">Approach 1: Depth-First Search</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-depth-first-search\">Approach 1: Depth-First Search</h4> \n  <p><strong>Intuition</strong></p> \n  <p>It's natural to try to assign everyone to a group. Let's say people in the first group are red, and people in the second group are blue.</p> \n  <p>If the first person is red, anyone disliked by this person must be blue. Then, anyone disliked by a blue person is red, then anyone disliked by a red person is blue, and so on.</p> \n  <p>If at any point there is a conflict, the task is impossible, as every step logically follows from the first step. If there isn't a conflict, then the coloring was valid, so the answer would be <code>true</code>.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Consider the graph on <code>N</code> people formed by the given \"dislike\" edges. We want to check that each connected component of this graph is bipartite.</p> \n  <p>For each connected component, we can check whether it is bipartite by just trying to coloring it with two colors. How to do this is as follows: color any node red, then all of it's neighbors blue, then all of those neighbors red, and so on. If we ever color a red node blue (or a blue node red), then we've reached a conflict.</p> \n  <iframe src=\"https://leetcode.com/playground/aD5rzLRZ/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"aD5rzLRZ\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N + E)</script>, where <script type=\"math/tex; mode=display\">E</script> is the length of <code>dislikes</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N + E)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 885,
    "article_live": true,
    "article_slug": "spiral-matrix-iii",
    "title": "Spiral Matrix III",
    "title_slug": "spiral-matrix-iii",
    "content": "<p>On a 2 dimensional grid with <code>R</code> rows and <code>C</code> columns, we start at <code>(r0, c0)</code> facing east.</p>\r\n\r\n<p>Here, the north-west corner of the grid is at the&nbsp;first row and column, and the south-east corner of the grid is at the last row and column.</p>\r\n\r\n<p>Now, we walk in a clockwise spiral shape to visit every position in this grid.&nbsp;</p>\r\n\r\n<p>Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.)&nbsp;</p>\r\n\r\n<p>Eventually, we reach all <code>R * C</code> spaces of the grid.</p>\r\n\r\n<p>Return a list of coordinates representing the positions of the grid in the order they were visited.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>R = <span id=\"example-input-1-1\">1</span>, C = <span id=\"example-input-1-2\">4</span>, r0 = <span id=\"example-input-1-3\">0</span>, c0 = <span id=\"example-input-1-4\">0</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">[[0,0],[0,1],[0,2],[0,3]]</span>\r\n\r\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/24/example_1.png\" style=\"width: 174px; height: 99px;\" />\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>R = <span id=\"example-input-2-1\">5</span>, C = <span id=\"example-input-2-2\">6</span>, r0 = <span id=\"example-input-2-3\">1</span>, c0 = <span id=\"example-input-2-4\">4</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">[[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]</span>\r\n\r\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/24/example_2.png\" style=\"width: 202px; height: 142px;\" />\r\n</pre>\r\n\r\n<div>\r\n<div>\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= R &lt;= 100</code></li>\r\n\t<li><code>1 &lt;= C &lt;= 100</code></li>\r\n\t<li><code>0 &lt;= r0 &lt; R</code></li>\r\n\t<li><code>0 &lt;= c0 &lt; C</code></li>\r\n</ol>\r\n</div>\r\n</div>\r\n",
    "tags": "Math",
    "difficulty": 2,
    "frontend_article_id": 885,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-walk-in-a-spiral\">Approach 1: Walk in a Spiral</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-walk-in-a-spiral\">Approach 1: Walk in a Spiral</h4> \n  <p><strong>Intuition</strong></p> \n  <p>We can walk in a spiral shape from the starting square, ignoring whether we stay in the grid or not. Eventually, we must have reached every square in the grid.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Examining the lengths of our walk in each direction, we find the following pattern: <code>1, 1, 2, 2, 3, 3, 4, 4, ...</code> That is, we walk 1 unit east, then 1 unit south, then 2 units west, then 2 units north, then 3 units east, etc. Because our walk is self-similar, this pattern repeats in the way we expect.</p> \n  <p>After, the algorithm is straightforward: perform the walk and record positions of the grid in the order we visit them. Please read the inline comments for more details.</p> \n  <iframe src=\"https://leetcode.com/playground/XTsQ5Bi8/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"XTsQ5Bi8\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O((\\max(R, C))^2)</script>. Potentially, our walk needs to spiral until we move <script type=\"math/tex; mode=display\">R</script> in one direction, and <script type=\"math/tex; mode=display\">C</script> in another direction, so as to reach every cell of the grid.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(R * C)</script>, the space used by the answer. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 884,
    "article_live": true,
    "article_slug": "uncommon-words-from-two-sentences",
    "title": "Uncommon Words from Two Sentences",
    "title_slug": "uncommon-words-from-two-sentences",
    "content": "<p>We are given two sentences <code>A</code> and <code>B</code>.&nbsp; (A <em>sentence</em>&nbsp;is a string of space separated words.&nbsp; Each <em>word</em> consists only of lowercase letters.)</p>\r\n\r\n<p>A word is <em>uncommon</em>&nbsp;if it appears exactly once in one of the sentences, and does not appear in the other sentence.</p>\r\n\r\n<p>Return a list of all uncommon words.&nbsp;</p>\r\n\r\n<p>You may return the list in any order.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<ol>\r\n</ol>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>A = <span id=\"example-input-1-1\">&quot;this apple is sweet&quot;</span>, B = <span id=\"example-input-1-2\">&quot;this apple is sour&quot;</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">[&quot;sweet&quot;,&quot;sour&quot;]</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>A = <span id=\"example-input-2-1\">&quot;apple apple&quot;</span>, B = <span id=\"example-input-2-2\">&quot;banana&quot;</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">[&quot;banana&quot;]</span>\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>0 &lt;= A.length &lt;= 200</code></li>\r\n\t<li><code>0 &lt;= B.length &lt;= 200</code></li>\r\n\t<li><code>A</code> and <code>B</code> both contain only spaces and lowercase letters.</li>\r\n</ol>\r\n</div>\r\n</div>\r\n",
    "tags": "Hash Table",
    "difficulty": 1,
    "frontend_article_id": 884,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-counting\">Approach 1: Counting</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-counting\">Approach 1: Counting</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Every uncommon word occurs exactly once in total. We can count the number of occurrences of every word, then return ones that occur exactly once.</p> \n  <iframe src=\"https://leetcode.com/playground/YwdvfZv6/shared\" frameborder=\"0\" width=\"100%\" height=\"327\" name=\"YwdvfZv6\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(M + N)</script>, where <script type=\"math/tex; mode=display\">M, N</script> are the lengths of <code>A</code> and <code>B</code> respectively.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(M + N)</script>, the space used by <code>count</code>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 883,
    "article_live": true,
    "article_slug": "projection-area-of-3d-shapes",
    "title": "Projection Area of 3D Shapes",
    "title_slug": "projection-area-of-3d-shapes",
    "content": "<p>On a&nbsp;<code>N&nbsp;*&nbsp;N</code> grid, we place some&nbsp;<code>1 * 1 * 1&nbsp;</code>cubes that are axis-aligned with the x, y, and z axes.</p>\r\n\r\n<p>Each value&nbsp;<code>v = grid[i][j]</code>&nbsp;represents a tower of&nbsp;<code>v</code>&nbsp;cubes placed on top of grid cell <code>(i, j)</code>.</p>\r\n\r\n<p>Now we view the&nbsp;<em>projection</em>&nbsp;of these cubes&nbsp;onto the xy, yz, and zx planes.</p>\r\n\r\n<p>A projection is like a shadow, that&nbsp;maps our 3 dimensional figure to a 2 dimensional plane.&nbsp;</p>\r\n\r\n<p>Here, we are viewing the &quot;shadow&quot; when looking at the cubes from the top, the front, and the side.</p>\r\n\r\n<p>Return the total area of all three projections.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<ul>\r\n</ul>\r\n</div>\r\n\r\n<div>\r\n<div>\r\n<ul>\r\n</ul>\r\n</div>\r\n</div>\r\n\r\n<div>\r\n<div>\r\n<div>\r\n<div>\r\n<ul>\r\n</ul>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n\r\n<div>\r\n<div>\r\n<div>\r\n<div>\r\n<div>\r\n<div>\r\n<div>\r\n<div>\r\n<ul>\r\n</ul>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[[2]]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">5</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">[[1,2],[3,4]]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">17</span>\r\n<strong>Explanation: </strong>\r\nHere are the three projections (&quot;shadows&quot;) of the shape made with each axis-aligned plane.\r\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/02/shadow.png\" style=\"width: 749px; height: 200px;\" />\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-3-1\">[[1,0],[0,2]]</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">8</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 4:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-4-1\">[[1,1,1],[1,0,1],[1,1,1]]</span>\r\n<strong>Output: </strong><span id=\"example-output-4\">14</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 5:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-5-1\">[[2,2,2],[2,1,2],[2,2,2]]</span>\r\n<strong>Output: </strong><span id=\"example-output-5\">21</span>\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<div>\r\n<div>\r\n<p><span><strong>Note:</strong></span></p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= grid.length = grid[0].length&nbsp;&lt;= 50</code></li>\r\n\t<li><code>0 &lt;= grid[i][j] &lt;= 50</code></li>\r\n</ul>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n",
    "tags": "Math",
    "difficulty": 1,
    "frontend_article_id": 883,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-mathematical\">Approach 1: Mathematical</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-mathematical\">Approach 1: Mathematical</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>From the top, the shadow made by the shape will be 1 square for each non-zero value.</p> \n  <p>From the side, the shadow made by the shape will be the largest value for each row in the grid.</p> \n  <p>From the front, the shadow made by the shape will be the largest value for each column in the grid.</p> \n  <p><strong>Example</strong></p> \n  <p>With the example <code>[[1,2],[3,4]]</code>:</p> \n  <ul> \n   <li> <p>The shadow from the top will be 4, since there are four non-zero values in the grid;</p> </li> \n   <li> <p>The shadow from the side will be <code>2 + 4</code>, since the maximum value of the first row is <code>2</code>, and the maximum value of the second row is <code>4</code>;</p> </li> \n   <li> <p>The shadow from the front will be <code>3 + 4</code>, since the maximum value of the first column is <code>3</code>, and the maximum value of the second column is <code>4</code>.</p> </li> \n  </ul> \n  <iframe src=\"https://leetcode.com/playground/unjtgTJT/shared\" frameborder=\"0\" width=\"100%\" height=\"429\" name=\"unjtgTJT\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>grid</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 882,
    "article_live": true,
    "article_slug": "reachable-nodes-in-subdivided-graph",
    "title": "Reachable Nodes In Subdivided Graph",
    "title_slug": "reachable-nodes-in-subdivided-graph",
    "content": "<p>Starting with an&nbsp;<strong>undirected</strong> graph (the &quot;original graph&quot;) with nodes from <code>0</code> to <code>N-1</code>, subdivisions are made to some of the edges.</p>\r\n\r\n<p>The graph is given as follows: <code>edges[k]</code> is a list of integer pairs <code>(i, j, n)</code> such that <code>(i, j)</code> is an edge of the original graph,</p>\r\n\r\n<p>and <code>n</code> is the total number of <strong>new</strong> nodes on that edge.&nbsp;</p>\r\n\r\n<p>Then, the edge <code>(i, j)</code> is deleted from the original graph,&nbsp;<code>n</code>&nbsp;new nodes <code>(x_1, x_2, ..., x_n)</code> are added to the original graph,</p>\r\n\r\n<p>and <code>n+1</code> new&nbsp;edges <code>(i, x_1), (x_1, x_2), (x_2, x_3), ..., (x_{n-1}, x_n), (x_n, j)</code>&nbsp;are added to the original&nbsp;graph.</p>\r\n\r\n<p>Now, you start at node <code>0</code>&nbsp;from the original graph, and in each move, you travel along one&nbsp;edge.&nbsp;</p>\r\n\r\n<p>Return how many nodes you can reach in at most <code>M</code> moves.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><code>edges </code>= <span id=\"example-input-1-1\">[[0,1,10],[0,2,1],[1,2,2]]</span>, M = <span id=\"example-input-1-2\">6</span>, N = <span id=\"example-input-1-3\">3</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">13</span>\r\n<strong>Explanation: </strong>\r\nThe nodes that are reachable in the final graph after M = 6 moves are indicated below.\r\n<span><img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/01/origfinal.png\" style=\"width: 487px; height: 200px;\" /></span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><code>edges </code>= <span id=\"example-input-2-1\">[[0,1,4],[1,2,6],[0,2,8],[1,3,1]]</span>, M = <span id=\"example-input-2-2\">10</span>, N = <span id=\"example-input-2-3\">4</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">23</span></pre>\r\n\r\n<p>&nbsp;</p>\r\n</div>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>0 &lt;= edges.length &lt;= 10000</code></li>\r\n\t<li><code>0 &lt;= edges[i][0] &lt;&nbsp;edges[i][1] &lt; N</code></li>\r\n\t<li>There does not exist any&nbsp;<code>i != j</code> for which <code>edges[i][0] == edges[j][0]</code> and <code>edges[i][1] == edges[j][1]</code>.</li>\r\n\t<li>The original graph&nbsp;has no parallel edges.</li>\r\n\t<li><code>0 &lt;= edges[i][2] &lt;= 10000</code></li>\r\n\t<li><code>0 &lt;= M &lt;= 10^9</code></li>\r\n\t<li><code><font face=\"monospace\">1 &lt;= N &lt;= 3000</font></code></li>\r\n\t<li>A reachable node is a node that can be travelled to&nbsp;using at most&nbsp;M moves starting from&nbsp;node 0.</li>\r\n</ol>\r\n\r\n<div>\r\n<div>&nbsp;</div>\r\n</div>\r\n",
    "tags": "Heap",
    "difficulty": 3,
    "frontend_article_id": 882,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-dijkstras\">Approach 1: Dijkstra's</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-dijkstras\">Approach 1: Dijkstra's</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Treating the original graph as a weighted, undirected graph, we can use Dijkstra's algorithm to find all reachable nodes in the original graph. However, this won't be enough to solve examples where subdivided edges are only used partially.</p> \n  <p>When we travel along an edge (in either direction), we can keep track of how much we use it. At the end, we want to know every node we reached in the original graph, plus the sum of the utilization of each edge.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>We use <em>Dijkstra's algorithm</em> to find the shortest distance from our source to all targets. This is a textbook algorithm, refer to <a href=\"https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\">this link</a> for more details.</p> \n  <p>Additionally, for each (directed) edge <code>(node, nei)</code>, we'll keep track of how many \"new\" nodes (new from subdivision of the original edge) were <code>used</code>. At the end, we'll sum up the utilization of each edge.</p> \n  <p>Please see the inline comments for more details.</p> \n  <iframe src=\"https://leetcode.com/playground/obqv6gh4/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"obqv6gh4\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(E \\log N)</script>, where <script type=\"math/tex; mode=display\">E</script> is the length of <code>edges</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 881,
    "article_live": true,
    "article_slug": "boats-to-save-people",
    "title": "Boats to Save People",
    "title_slug": "boats-to-save-people",
    "content": "<p>The <code>i</code>-th person has weight <code>people[i]</code>, and each boat can carry a maximum weight of <code>limit</code>.</p>\r\n\r\n<p>Each boat carries at most 2 people at the same time, provided the sum of the&nbsp;weight of those people is at most <code>limit</code>.</p>\r\n\r\n<p>Return the minimum number of boats to carry every given person.&nbsp; (It is guaranteed each person can be carried by a boat.)</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>people = <span id=\"example-input-1-1\">[1,2]</span>, limit = <span id=\"example-input-1-2\">3</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">1</span>\r\n<strong>Explanation: </strong>1 boat (1, 2)\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>people = <span id=\"example-input-2-1\">[3,2,2,1]</span>, limit = <span id=\"example-input-2-2\">3</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">3</span>\r\n<strong>Explanation</strong>: 3 boats (1, 2), (2) and (3)\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>people = <span id=\"example-input-3-1\">[3,5,3,4]</span>, limit = <span id=\"example-input-3-2\">5</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">4</span>\r\n<strong>Explanation</strong>: 4 boats (3), (3), (4), (5)</pre>\r\n\r\n<p><strong>Note</strong>:</p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;=&nbsp;people.length &lt;= 50000</code></li>\r\n\t<li><code>1 &lt;= people[i] &lt;=&nbsp;limit &lt;= 30000</code></li>\r\n</ul>\r\n</div>\r\n</div>\r\n</div>\r\n",
    "tags": "Two Pointers, Greedy",
    "difficulty": 2,
    "frontend_article_id": 881,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-greedy-two-pointer\">Approach 1: Greedy (Two Pointer)</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-greedy-two-pointer\">Approach 1: Greedy (Two Pointer)</h4> \n  <p><strong>Intuition</strong></p> \n  <p>If the heaviest person can share a boat with the lightest person, then do so. Otherwise, the heaviest person can't pair with anyone, so they get their own boat.</p> \n  <p>The reason this works is because if the lightest person can pair with anyone, they might as well pair with the heaviest person.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Let <code>people[i]</code> to the currently lightest person, and <code>people[j]</code> to the heaviest.</p> \n  <p>Then, as described above, if the heaviest person can share a boat with the lightest person (if <code>people[j] + people[i] &lt;= limit</code>) then do so; otherwise, the heaviest person sits in their own boat.</p> \n  <iframe src=\"https://leetcode.com/playground/Vy4ovfs7/shared\" frameborder=\"0\" width=\"100%\" height=\"344\" name=\"Vy4ovfs7\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N \\log N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>people</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 880,
    "article_live": true,
    "article_slug": "decoded-string-at-index",
    "title": "Decoded String at Index",
    "title_slug": "decoded-string-at-index",
    "content": "<p>An encoded string <code>S</code> is given.&nbsp; To find and write the <em>decoded</em> string to a tape, the encoded string is read <strong>one character at a time</strong>&nbsp;and the following steps are taken:</p>\r\n\r\n<ul>\r\n\t<li>If the character read is a letter, that letter is written onto the tape.</li>\r\n\t<li>If the character read is a digit (say <code>d</code>), the entire current tape is repeatedly written&nbsp;<code>d-1</code>&nbsp;more times in total.</li>\r\n</ul>\r\n\r\n<p>Now for some encoded string <code>S</code>, and an index <code>K</code>, find and return the <code>K</code>-th letter (1 indexed) in the decoded string.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>S = <span id=\"example-input-1-1\">&quot;leet2code3&quot;</span>, K = <span id=\"example-input-1-2\">10</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">&quot;o&quot;</span>\r\n<strong>Explanation: </strong>\r\nThe decoded string is &quot;leetleetcodeleetleetcodeleetleetcode&quot;.\r\nThe 10th letter in the string is &quot;o&quot;.\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>S = <span id=\"example-input-2-1\">&quot;ha22&quot;</span>, K = <span id=\"example-input-2-2\">5</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">&quot;h&quot;</span>\r\n<strong>Explanation: </strong>\r\nThe decoded string is &quot;hahahaha&quot;.  The 5th letter is &quot;h&quot;.\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>S = <span id=\"example-input-3-1\">&quot;a2345678999999999999999&quot;</span>, K = <span id=\"example-input-3-2\">1</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">&quot;a&quot;</span>\r\n<strong>Explanation: </strong>\r\nThe decoded string is &quot;a&quot; repeated 8301530446056247680 times.  The 1st letter is &quot;a&quot;.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>2 &lt;= S.length &lt;= 100</code></li>\r\n\t<li><code>S</code>&nbsp;will only contain lowercase letters and digits <code>2</code> through <code>9</code>.</li>\r\n\t<li><code>S</code>&nbsp;starts with a letter.</li>\r\n\t<li><code>1 &lt;= K &lt;= 10^9</code></li>\r\n\t<li>The decoded string is guaranteed to have less than <code>2^63</code> letters.</li>\r\n</ol>\r\n</div>\r\n</div>\r\n</div>\r\n",
    "tags": "Stack",
    "difficulty": 2,
    "frontend_article_id": 880,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-work-backwards\">Approach 1: Work Backwards</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-work-backwards\">Approach 1: Work Backwards</h4> \n  <p><strong>Intuition</strong></p> \n  <p>If we have a decoded string like <code>appleappleappleappleappleapple</code> and an index like <code>K = 24</code>, the answer is the same if <code>K = 4</code>.</p> \n  <p>In general, when a decoded string is equal to some word with <code>size</code> length repeated some number of times (such as <code>apple</code> with <code>size = 5</code> repeated 6 times), the answer is the same for the index <code>K</code> as it is for the index <code>K % size</code>.</p> \n  <p>We can use this insight by working backwards, keeping track of the size of the decoded string. Whenever the decoded string would equal some <code>word</code> repeated <code>d</code> times, we can reduce <code>K</code> to <code>K % (word.length)</code>.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>First, find the length of the decoded string. After, we'll work backwards, keeping track of <code>size</code>: the length of the decoded string after parsing symbols <code>S[0], S[1], ..., S[i]</code>.</p> \n  <p>If we see a digit <code>S[i]</code>, it means the size of the decoded string after parsing <code>S[0], S[1], ..., S[i-1]</code> will be <code>size / Integer(S[i])</code>. Otherwise, it will be <code>size - 1</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/HGcLTehJ/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"HGcLTehJ\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>S</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 478,
    "article_live": true,
    "article_slug": "generate-random-point-in-a-circle",
    "title": "Generate Random Point in a Circle",
    "title_slug": "generate-random-point-in-a-circle",
    "content": "<p>Given the radius and x-y positions of the center of a circle, write a function <code>randPoint</code>&nbsp;which&nbsp;generates a uniform random&nbsp;point in the circle.</p>\r\n\r\n<p>Note:</p>\r\n\r\n<ol>\r\n\t<li>input and output values are&nbsp;in&nbsp;<a href=\"https://www.webopedia.com/TERM/F/floating_point_number.html\" target=\"_blank\">floating-point</a>.</li>\r\n\t<li>radius and x-y position of the center of the circle is passed into the class constructor.</li>\r\n\t<li>a point on the circumference of the circle is considered to be&nbsp;in the circle.</li>\r\n\t<li><code>randPoint</code>&nbsp;returns&nbsp;a size 2 array containing x-position and y-position of the random point, in that order.</li>\r\n</ol>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: \r\n</strong><span id=\"example-input-1-1\">[&quot;Solution&quot;,&quot;randPoint&quot;,&quot;randPoint&quot;,&quot;randPoint&quot;]\r\n</span><span id=\"example-input-1-2\">[[1,0,0],[],[],[]]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">[null,[-0.72939,-0.65505],[-0.78502,-0.28626],[-0.83119,-0.19803]]</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: \r\n</strong><span id=\"example-input-2-1\">[&quot;Solution&quot;,&quot;randPoint&quot;,&quot;randPoint&quot;,&quot;randPoint&quot;]\r\n</span><span id=\"example-input-2-2\">[[10,5,-7.5],[],[],[]]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">[null,[11.52438,-8.33273],[2.46992,-16.21705],[11.13430,-12.42337]]</span></pre>\r\n</div>\r\n\r\n<p><strong>Explanation of Input Syntax:</strong></p>\r\n\r\n<p>The input is two lists:&nbsp;the subroutines called&nbsp;and their&nbsp;arguments.&nbsp;<code>Solution</code>&#39;s&nbsp;constructor has three arguments, the radius, x-position of the center, and y-position of the center of the circle. <code>randPoint</code> has no arguments.&nbsp;Arguments&nbsp;are&nbsp;always wrapped with a list, even if there aren&#39;t any.</p>\r\n</div>\r\n",
    "tags": "Math, Random, Rejection Sampling",
    "difficulty": 2,
    "frontend_article_id": 478,
    "article_content": ""
},
{
    "frontend_question_id": 497,
    "article_live": true,
    "article_slug": "random-point-in-non-overlapping-rectangles",
    "title": "Random Point in Non-overlapping Rectangles",
    "title_slug": "random-point-in-non-overlapping-rectangles",
    "content": "<p>Given a list of <strong>non-overlapping</strong>&nbsp;axis-aligned rectangles <code>rects</code>, write a function <code>pick</code> which randomly and uniformily picks an <strong>integer point</strong> in the space&nbsp;covered by the rectangles.</p>\r\n\r\n<p>Note:</p>\r\n\r\n<ol>\r\n\t<li>An <strong>integer point</strong>&nbsp;is a point that has integer coordinates.&nbsp;</li>\r\n\t<li>A point&nbsp;on the perimeter&nbsp;of a rectangle is&nbsp;<strong>included</strong> in the space covered by the rectangles.&nbsp;</li>\r\n\t<li><code>i</code>th rectangle = <code>rects[i]</code> =&nbsp;<code>[x1,y1,x2,y2]</code>, where <code>[x1, y1]</code>&nbsp;are the integer coordinates of the bottom-left corner, and <code>[x2, y2]</code>&nbsp;are the integer coordinates of the top-right corner.</li>\r\n\t<li>length and width of each rectangle does not exceed <code>2000</code>.</li>\r\n\t<li><code>1 &lt;= rects.length&nbsp;&lt;= 100</code></li>\r\n\t<li><code>pick</code> return a point as an array of integer coordinates&nbsp;<code>[p_x, p_y]</code></li>\r\n\t<li><code>pick</code> is called at most <code>10000</code>&nbsp;times.</li>\r\n</ol>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: \r\n</strong><span id=\"example-input-1-1\">[&quot;Solution&quot;,&quot;pick&quot;,&quot;pick&quot;,&quot;pick&quot;]\r\n</span><span id=\"example-input-1-2\">[[[[1,1,5,5]]],[],[],[]]</span>\r\n<strong>Output: \r\n</strong><span id=\"example-output-1\">[null,[4,1],[4,1],[3,3]]</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: \r\n</strong><span id=\"example-input-2-1\">[&quot;Solution&quot;,&quot;pick&quot;,&quot;pick&quot;,&quot;pick&quot;,&quot;pick&quot;,&quot;pick&quot;]\r\n</span><span id=\"example-input-2-2\">[[[[-2,-2,-1,-1],[1,0,3,0]]],[],[],[],[],[]]</span>\r\n<strong>Output: \r\n</strong><span id=\"example-output-2\">[null,[-1,-2],[2,0],[-2,-1],[3,0],[-2,-2]]</span></pre>\r\n</div>\r\n\r\n<div>\r\n<p><strong>Explanation of Input Syntax:</strong></p>\r\n\r\n<p>The input is two lists:&nbsp;the subroutines called&nbsp;and their&nbsp;arguments.&nbsp;<code>Solution</code>&#39;s&nbsp;constructor has one argument, the array of rectangles <code>rects</code>. <code>pick</code>&nbsp;has no arguments.&nbsp;Arguments&nbsp;are&nbsp;always wrapped with a list, even if there aren&#39;t any.</p>\r\n</div>\r\n</div>\r\n\r\n<div>\r\n<div>&nbsp;</div>\r\n</div>\r\n",
    "tags": "Binary Search, Random",
    "difficulty": 2,
    "frontend_article_id": 497,
    "article_content": ""
},
{
    "frontend_question_id": 519,
    "article_live": true,
    "article_slug": "random-flip-matrix",
    "title": "Random Flip Matrix",
    "title_slug": "random-flip-matrix",
    "content": "<p>You are given the number of rows <code>n_rows</code>&nbsp;and number of columns <code>n_cols</code>&nbsp;of a&nbsp;2D&nbsp;binary matrix&nbsp;where all values are initially 0.&nbsp;Write a function <code>flip</code>&nbsp;which chooses&nbsp;a 0 value&nbsp;<a href=\"https://en.wikipedia.org/wiki/Discrete_uniform_distribution\" target=\"_blank\">uniformly at random</a>,&nbsp;changes it to 1,&nbsp;and then returns the position <code>[row.id, col.id]</code> of that value. Also, write a function <code>reset</code> which sets all values back to 0.&nbsp;<strong>Try to minimize the number of calls to system&#39;s Math.random()</strong> and optimize the time and&nbsp;space complexity.</p>\r\n\r\n<p>Note:</p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= n_rows, n_cols&nbsp;&lt;= 10000</code></li>\r\n\t<li><code>0 &lt;= row.id &lt; n_rows</code> and <code>0 &lt;= col.id &lt; n_cols</code></li>\r\n\t<li><code>flip</code>&nbsp;will not be called when the matrix has no&nbsp;0 values left.</li>\r\n\t<li>the total number of calls to&nbsp;<code>flip</code>&nbsp;and <code>reset</code>&nbsp;will not exceed&nbsp;1000.</li>\r\n</ol>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: \r\n</strong><span id=\"example-input-1-1\">[&quot;Solution&quot;,&quot;flip&quot;,&quot;flip&quot;,&quot;flip&quot;,&quot;flip&quot;]\r\n</span><span id=\"example-input-1-2\">[[2,3],[],[],[],[]]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">[null,[0,1],[1,2],[1,0],[1,1]]</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: \r\n</strong><span id=\"example-input-2-1\">[&quot;Solution&quot;,&quot;flip&quot;,&quot;flip&quot;,&quot;reset&quot;,&quot;flip&quot;]\r\n</span><span id=\"example-input-2-2\">[[1,2],[],[],[],[]]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">[null,[0,0],[0,1],null,[0,0]]</span></pre>\r\n</div>\r\n\r\n<p><strong>Explanation of Input Syntax:</strong></p>\r\n\r\n<p>The input is two lists:&nbsp;the subroutines called&nbsp;and their&nbsp;arguments. <code>Solution</code>&#39;s constructor&nbsp;has two arguments, <code>n_rows</code> and <code>n_cols</code>.&nbsp;<code>flip</code>&nbsp;and <code>reset</code> have&nbsp;no&nbsp;arguments.&nbsp;Arguments&nbsp;are&nbsp;always wrapped with a list, even if there aren&#39;t any.</p>\r\n",
    "tags": "Random",
    "difficulty": 2,
    "frontend_article_id": 519,
    "article_content": ""
},
{
    "frontend_question_id": 528,
    "article_live": true,
    "article_slug": "random-pick-with-weight",
    "title": "Random Pick with Weight",
    "title_slug": "random-pick-with-weight",
    "content": "<p>Given an array <code>w</code> of positive integers, where <code>w[i]</code> describes the weight of index <code>i</code>,&nbsp;write a function <code>pickIndex</code>&nbsp;which randomly&nbsp;picks an index&nbsp;in proportion&nbsp;to its weight.</p>\r\n\r\n<p>Note:</p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= w.length &lt;= 10000</code></li>\r\n\t<li><code>1 &lt;= w[i] &lt;= 10^5</code></li>\r\n\t<li><code>pickIndex</code>&nbsp;will be called at most <code>10000</code> times.</li>\r\n</ol>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: \r\n</strong><span id=\"example-input-1-1\">[&quot;Solution&quot;,&quot;pickIndex&quot;]\r\n</span><span id=\"example-input-1-2\">[[[1]],[]]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">[null,0]</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: \r\n</strong><span id=\"example-input-2-1\">[&quot;Solution&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;]\r\n</span><span id=\"example-input-2-2\">[[[1,3]],[],[],[],[],[]]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">[null,0,1,1,1,0]</span></pre>\r\n</div>\r\n\r\n<p><strong>Explanation of Input Syntax:</strong></p>\r\n\r\n<p>The input is two lists:&nbsp;the subroutines called&nbsp;and their&nbsp;arguments.&nbsp;<code>Solution</code>&#39;s&nbsp;constructor has one argument, the&nbsp;array <code>w</code>. <code>pickIndex</code> has no arguments.&nbsp;Arguments&nbsp;are&nbsp;always wrapped with a list, even if there aren&#39;t any.</p>\r\n",
    "tags": "Binary Search, Random",
    "difficulty": 2,
    "frontend_article_id": 528,
    "article_content": ""
},
{
    "frontend_question_id": 879,
    "article_live": true,
    "article_slug": "profitable-schemes",
    "title": "Profitable Schemes",
    "title_slug": "profitable-schemes",
    "content": "<p>There are G people in a gang, and a list of various crimes they could commit.</p>\r\n\r\n<p>The <code>i</code>-th crime generates a <code>profit[i]</code> and requires <code>group[i]</code> gang members to participate.</p>\r\n\r\n<p>If a gang member participates in one crime, that member can&#39;t participate in another crime.</p>\r\n\r\n<p>Let&#39;s call a <em>profitable&nbsp;scheme</em>&nbsp;any subset of these crimes that generates at least <code>P</code> profit, and the total number of gang members participating in that subset of crimes is at most G.</p>\r\n\r\n<p>How many schemes can be chosen?&nbsp; Since the answer may be very&nbsp;large, <strong>return it modulo</strong> <code>10^9 + 7</code>.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>G = <span id=\"example-input-1-1\">5</span>, P = <span id=\"example-input-1-2\">3</span>, group = <span id=\"example-input-1-3\">[2,2]</span>, profit = <span id=\"example-input-1-4\">[2,3]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">2</span>\r\n<strong>Explanation: </strong>\r\nTo make a profit of at least 3, the gang could either commit crimes 0 and 1, or just crime 1.\r\nIn total, there are 2 schemes.\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>G = <span id=\"example-input-2-1\">10</span>, P = <span id=\"example-input-2-2\">5</span>, group = <span id=\"example-input-2-3\">[2,3,5]</span>, profit = <span id=\"example-input-2-4\">[6,7,8]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">7</span>\r\n<strong>Explanation: </strong>\r\nTo make a profit of at least 5, the gang could commit any crimes, as long as they commit one.\r\nThere are 7 possible schemes: (0), (1), (2), (0,1), (0,2), (1,2), and (0,1,2).\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n</div>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= G &lt;= 100</code></li>\r\n\t<li><code>0 &lt;= P &lt;= 100</code></li>\r\n\t<li><code>1 &lt;= group[i] &lt;= 100</code></li>\r\n\t<li><code>0 &lt;= profit[i] &lt;= 100</code></li>\r\n\t<li><code>1 &lt;= group.length = profit.length &lt;= 100</code></li>\r\n</ol>\r\n\r\n<div>\r\n<div>&nbsp;</div>\r\n</div>\r\n",
    "tags": "Dynamic Programming",
    "difficulty": 3,
    "frontend_article_id": 879,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-dynamic-programming\">Approach 1: Dynamic Programming</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-dynamic-programming\">Approach 1: Dynamic Programming</h4> \n  <p><strong>Intuition</strong></p> \n  <p>We don't care about the profit of the scheme if it is <script type=\"math/tex; mode=display\">\\geq P</script>, because it surely will be over the threshold of profitability required. Similarly, we don't care about the number of people required in the scheme if it is <script type=\"math/tex; mode=display\">> G</script>, since we know the scheme will be too big for the gang to execute.</p> \n  <p>As a result, the bounds are small enough to use dynamic programming. Let's keep track of <code>cur[p][g]</code>, the number of schemes with profitability <script type=\"math/tex; mode=display\">p</script> and requiring <script type=\"math/tex; mode=display\">g</script> gang members: except we'll say (without changing the answer) that all schemes that profit <em>at least</em> <code>P</code> dollars will instead profit <em>exactly</em> <code>P</code> dollars.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Keeping track of <code>cur[p][g]</code> as defined above, let's understand how it changes as we consider 1 extra crime that will profit <code>p0</code> and require <code>g0</code> gang members. We will put the updated counts into <code>cur2</code>.</p> \n  <p>For each possible scheme with profit <code>p1</code> and group size <code>g1</code>, that scheme plus the extra crime (<code>p0, g0</code>) being considered, has a profit of <code>p2 = min(p1 + p0, P)</code>, and uses a group size of <code>g2 = g1 + g0</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/gFHdtSWS/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"gFHdtSWS\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N * P * G)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of crimes available to the gang.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(P * G)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 878,
    "article_live": true,
    "article_slug": "nth-magical-number",
    "title": "Nth Magical Number",
    "title_slug": "nth-magical-number",
    "content": "<p>A positive integer&nbsp;is <em>magical</em>&nbsp;if it is divisible by either <font face=\"monospace\">A</font>&nbsp;or <font face=\"monospace\">B</font>.</p>\r\n\r\n<p>Return the <font face=\"monospace\">N</font>-th magical number.&nbsp; Since the answer may be very large, <strong>return it modulo </strong><code>10^9 + 7</code>.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<ol>\r\n</ol>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>N = <span id=\"example-input-1-1\">1</span>, A = <span id=\"example-input-1-2\">2</span>, B = <span id=\"example-input-1-3\">3</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">2</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>N = <span id=\"example-input-2-1\">4</span>, A = <span id=\"example-input-2-2\">2</span>, B = <span id=\"example-input-2-3\">3</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">6</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>N = <span id=\"example-input-3-1\">5</span>, A = <span id=\"example-input-3-2\">2</span>, B = <span id=\"example-input-3-3\">4</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">10</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 4:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>N = <span id=\"example-input-4-1\">3</span>, A = <span id=\"example-input-4-2\">6</span>, B = <span id=\"example-input-4-3\">4</span>\r\n<strong>Output: </strong><span id=\"example-output-4\">8</span>\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= N&nbsp;&lt;= 10^9</code></li>\r\n\t<li><code>2 &lt;= A&nbsp;&lt;= 40000</code></li>\r\n\t<li><code>2 &lt;= B&nbsp;&lt;= 40000</code></li>\r\n</ol>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n",
    "tags": "Math, Binary Search",
    "difficulty": 3,
    "frontend_article_id": 878,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-mathematical\">Approach 1: Mathematical</a></li> \n      <li><a href=\"#approach-2-binary-search\">Approach 2: Binary Search</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-mathematical\">Approach 1: Mathematical</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Let's try to count to the <script type=\"math/tex; mode=display\">N</script>-th magical number mathematically.</p> \n  <p>First, the pattern of magical numbers repeats. Let <script type=\"math/tex; mode=display\">L</script> be the least common multiple of <script type=\"math/tex; mode=display\">A</script> and <script type=\"math/tex; mode=display\">B</script>. If <script type=\"math/tex; mode=display\">X \\leq L</script> is magical, then <script type=\"math/tex; mode=display\">X + L</script> is magical, because (for example) <script type=\"math/tex; mode=display\">A \\| X</script> and <script type=\"math/tex; mode=display\">A \\| L</script> implies <script type=\"math/tex; mode=display\">A \\| (X + L)</script>, and similarly if <script type=\"math/tex; mode=display\">B</script> were the divisor.</p> \n  <p>There are <script type=\"math/tex; mode=display\">M = \\frac{L}{A} + \\frac{L}{B} - 1</script> magical numbers less than or equal to <script type=\"math/tex; mode=display\">L</script>: <script type=\"math/tex; mode=display\">\\frac{L}{A}</script> of them are divisible by <script type=\"math/tex; mode=display\">A</script>, <script type=\"math/tex; mode=display\">\\frac{L}{B}</script> of them are divisible by <script type=\"math/tex; mode=display\">B</script>, and <script type=\"math/tex; mode=display\">1</script> of them is divisible by both. So instead of counting one at a time, we can count by <script type=\"math/tex; mode=display\">M</script> at a time.</p> \n  <p>Now, suppose <script type=\"math/tex; mode=display\">N = M*q + r</script> (with <script type=\"math/tex; mode=display\">r < M</script>). The first <script type=\"math/tex; mode=display\">L*q</script> numbers contain <script type=\"math/tex; mode=display\">M*q</script> magical numbers, and within the next numbers <script type=\"math/tex; mode=display\">(L*q + 1, L*q + 2, \\cdots)</script> we want to find <script type=\"math/tex; mode=display\">r</script> more magical ones.</p> \n  <p>For this task, we can use brute force. The next magical number (less <script type=\"math/tex; mode=display\">L*q</script>) will either be <script type=\"math/tex; mode=display\">A</script> or <script type=\"math/tex; mode=display\">B</script>. If for example it is <script type=\"math/tex; mode=display\">A</script>, then the next number will either be <script type=\"math/tex; mode=display\">2*A</script> or <script type=\"math/tex; mode=display\">B</script>, and so on.</p> \n  <p>If the <script type=\"math/tex; mode=display\">r</script>-th such magical number is <script type=\"math/tex; mode=display\">Y</script>, then the final answer is <script type=\"math/tex; mode=display\">L*q + Y</script>. Care must also be taken in the case that <script type=\"math/tex; mode=display\">r</script> is <script type=\"math/tex; mode=display\">0</script>.</p> \n  <iframe src=\"https://leetcode.com/playground/noAa9JNU/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"noAa9JNU\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(A+B)</script>, assuming a model where integer math operations are <script type=\"math/tex; mode=display\">O(1)</script>. The calculation of <code>q * L</code> is <script type=\"math/tex; mode=display\">O(1)</script>. The calculation of the <script type=\"math/tex; mode=display\">r</script>-th magical number after <script type=\"math/tex; mode=display\">q*M</script> is <script type=\"math/tex; mode=display\">O(M)</script> which is <script type=\"math/tex; mode=display\">O(A+B)</script>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-binary-search\">Approach 2: Binary Search</h4> \n  <p><strong>Intuition</strong></p> \n  <p>The number of magical numbers less than or equal to <script type=\"math/tex; mode=display\">x</script> is a monotone increasing function in <script type=\"math/tex; mode=display\">x</script>, so we can binary search for the answer.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Say <script type=\"math/tex; mode=display\">L = \\text{lcm}(A, B)</script>, the <em>least common multiple</em> of <script type=\"math/tex; mode=display\">A</script> and <script type=\"math/tex; mode=display\">B</script>; and let <script type=\"math/tex; mode=display\">f(x)</script> be the number of magical numbers less than or equal to <script type=\"math/tex; mode=display\">x</script>. A well known result says that <script type=\"math/tex; mode=display\">L = \\frac{A * B}{\\text{gcd}(A, B)}</script>, and that we can calculate the function <script type=\"math/tex; mode=display\">\\gcd</script>. For more information on least common multiples and greatest common divisors, please visit <a href=\"https://en.wikipedia.org/wiki/Least_common_multiple\">Wikipedia - Lowest Common Multiple</a>.</p> \n  <p>Then <script type=\"math/tex; mode=display\">f(x) = \\lfloor \\frac{x}{A} \\rfloor + \\lfloor \\frac{x}{B} \\rfloor - \\lfloor \\frac{x}{L} \\rfloor</script>. Why? There are <script type=\"math/tex; mode=display\">\\lfloor \\frac{x}{A} \\rfloor</script> numbers <script type=\"math/tex; mode=display\">A,  2A,  3A,  \\cdots</script> that are divisible by <script type=\"math/tex; mode=display\">A</script>, there are <script type=\"math/tex; mode=display\">\\lfloor \\frac{x}{B} \\rfloor</script> numbers divisible by <script type=\"math/tex; mode=display\">B</script>, and we need to subtract the <script type=\"math/tex; mode=display\">\\lfloor \\frac{x}{L} \\rfloor</script> numbers divisible by <script type=\"math/tex; mode=display\">A</script> and <script type=\"math/tex; mode=display\">B</script> that we double counted.</p> \n  <p>Finally, the answer must be between <script type=\"math/tex; mode=display\">0</script> and <script type=\"math/tex; mode=display\">N * \\max(A, B)</script>. Without loss of generality, suppose <script type=\"math/tex; mode=display\">A \\geq B</script>, so that it remains to show</p> \n  <p> <script type=\"math/tex; mode=display\">\n\\lfloor \\frac{N * \\max(A, B)}{A} \\rfloor + \\lfloor \\frac{N * \\max(A, B)}{B} \\rfloor - \\lfloor \\frac{N * \\max(A, B)}{\\text{lcm}(A, B)} \\rfloor \\geq N\n</script> </p> \n  <p> <script type=\"math/tex; mode=display\">\n\\Leftrightarrow \\lfloor \\frac{N*A}{A} \\rfloor + \\lfloor \\frac{N*A}{B} \\rfloor - \\lfloor \\frac{N*A*\\gcd(A, B)}{A*B} \\rfloor \\geq N\n</script> </p> \n  <p> <script type=\"math/tex; mode=display\">\n\\Leftrightarrow \\lfloor \\frac{N*A}{B} \\rfloor \\geq \\lfloor \\frac{N*\\gcd(A, B)}{B} \\rfloor\n</script> </p> \n  <p> <script type=\"math/tex; mode=display\">\n\\Leftrightarrow A \\geq \\gcd(A, B)\n</script> </p> \n  <p>as desired.</p> \n  <p>Afterwards, the binary search on <script type=\"math/tex; mode=display\">f</script> is straightforward. For more information on binary search, please visit <a href=\"https://leetcode.com/explore/learn/card/binary-search/\">[LeetCode Explore - Binary Search]</a>.</p> \n  <iframe src=\"https://leetcode.com/playground/3erxMBCQ/shared\" frameborder=\"0\" width=\"100%\" height=\"480\" name=\"3erxMBCQ\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(\\log (N * \\max(A, B)))</script>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 877,
    "article_live": true,
    "article_slug": "stone-game",
    "title": "Stone Game",
    "title_slug": "stone-game",
    "content": "<p>Alex and Lee play a game with piles of stones.&nbsp; There are an even number of&nbsp;piles <strong>arranged in a row</strong>, and each pile has a positive integer number of stones <code>piles[i]</code>.</p>\r\n\r\n<p>The objective of the game is to end with the most&nbsp;stones.&nbsp; The total number of stones is odd, so there are no ties.</p>\r\n\r\n<p>Alex and Lee take turns, with Alex starting first.&nbsp; Each turn, a player&nbsp;takes the entire pile of stones from either the beginning or the end of the row.&nbsp; This continues until there are no more piles left, at which point the person with the most stones wins.</p>\r\n\r\n<p>Assuming Alex and Lee play optimally, return <code>True</code>&nbsp;if and only if Alex wins the game.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[5,3,4,5]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">true</span>\r\n<strong>Explanation: </strong>\r\nAlex starts first, and can only take the first 5 or the last 5.\r\nSay he takes the first 5, so that the row becomes [3, 4, 5].\r\nIf Lee takes 3, then the board is [4, 5], and Alex takes 5 to win with 10 points.\r\nIf Lee takes the last 5, then the board is [3, 4], and Alex takes 4 to win with 9 points.\r\nThis demonstrated that taking the first 5 was a winning move for Alex, so we return true.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>2 &lt;= piles.length &lt;= 500</code></li>\r\n\t<li><code>piles.length</code> is even.</li>\r\n\t<li><code>1 &lt;= piles[i] &lt;= 500</code></li>\r\n\t<li><code>sum(piles)</code> is odd.</li>\r\n</ol>\r\n",
    "tags": "Math, Dynamic Programming",
    "difficulty": 2,
    "frontend_article_id": 877,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-dynamic-programming\">Approach 1: Dynamic Programming</a></li> \n      <li><a href=\"#approach-2-mathematical\">Approach 2: Mathematical</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-dynamic-programming\">Approach 1: Dynamic Programming</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Let's change the game so that whenever Lee scores points, it deducts from Alex's score instead.</p> \n  <p>Let <code>dp(i, j)</code> be the largest score Alex can achieve where the piles remaining are <code>piles[i], piles[i+1], ..., piles[j]</code>. This is natural in games with scoring: we want to know what the value of each position of the game is.</p> \n  <p>We can formulate a recursion for <code>dp(i, j)</code> in terms of <code>dp(i+1, j)</code> and <code>dp(i, j-1)</code>, and we can use dynamic programming to not repeat work in this recursion. (This approach can output the correct answer, because the states form a DAG (directed acyclic graph).)</p> \n  <p><strong>Algorithm</strong></p> \n  <p>When the piles remaining are <code>piles[i], piles[i+1], ..., piles[j]</code>, the player who's turn it is has at most 2 moves.</p> \n  <p>The person who's turn it is can be found by comparing <code>j-i</code> to <code>N</code> modulo 2.</p> \n  <p>If the player is Alex, then she either takes <code>piles[i]</code> or <code>piles[j]</code>, increasing her score by that amount. Afterwards, the total score is either <code>piles[i] + dp(i+1, j)</code>, or <code>piles[j] + dp(i, j-1)</code>; and we want the maximum possible score.</p> \n  <p>If the player is Lee, then he either takes <code>piles[i]</code> or <code>piles[j]</code>, decreasing Alex's score by that amount. Afterwards, the total score is either <code>-piles[i] + dp(i+1, j)</code>, or <code>-piles[j] + dp(i, j-1)</code>; and we want the <em>minimum</em> possible score.</p> \n  <iframe src=\"https://leetcode.com/playground/4azVgCpr/shared\" frameborder=\"0\" width=\"100%\" height=\"412\" name=\"4azVgCpr\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of piles.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, the space used storing the intermediate results of each subgame. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-mathematical\">Approach 2: Mathematical</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Alex clearly always wins the 2 pile game. With some effort, we can see that she always wins the 4 pile game.</p> \n  <p>If Alex takes the first pile initially, she can always take the third pile. If she takes the fourth pile initially, she can always take the second pile. At least one of <code>first + third, second + fourth</code> is larger, so she can always win.</p> \n  <p>We can extend this idea to <code>N</code> piles. Say the first, third, fifth, seventh, etc. piles are white, and the second, fourth, sixth, eighth, etc. piles are black. Alex can always take either all white piles or all black piles, and one of the colors must have a sum number of stones larger than the other color.</p> \n  <p>Hence, Alex always wins the game.</p> \n  <iframe src=\"https://leetcode.com/playground/TdjR4pTJ/shared\" frameborder=\"0\" width=\"100%\" height=\"157\" name=\"TdjR4pTJ\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time and Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>. <br> <br></li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 876,
    "article_live": true,
    "article_slug": "middle-of-the-linked-list",
    "title": "Middle of the Linked List",
    "title_slug": "middle-of-the-linked-list",
    "content": "<p>Given a non-empty, singly&nbsp;linked list with head node <code>head</code>, return&nbsp;a&nbsp;middle node of linked list.</p>\r\n\r\n<p>If there are two middle nodes, return the second middle node.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[1,2,3,4,5]</span>\r\n<strong>Output: </strong>Node 3 from this list (Serialization: <span id=\"example-output-1\">[3,4,5]</span>)\r\nThe returned node has value 3.  (The judge&#39;s serialization of this node is [3,4,5]).\r\nNote that we returned a ListNode object ans, such that:\r\nans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL.\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">[1,2,3,4,5,6]</span>\r\n<strong>Output: </strong>Node 4 from this list (Serialization: <span id=\"example-output-2\">[4,5,6]</span>)\r\nSince the list has two middle nodes with values 3 and 4, we return the second one.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>The number of nodes in the given list will be between <code>1</code>&nbsp;and <code>100</code>.</li>\r\n</ul>\r\n</div>\r\n</div>\r\n",
    "tags": "Linked List",
    "difficulty": 1,
    "frontend_article_id": 876,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-output-to-array\">Approach 1: Output to Array</a></li> \n      <li><a href=\"#approach-2-fast-and-slow-pointer\">Approach 2: Fast and Slow Pointer</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-output-to-array\">Approach 1: Output to Array</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Put every node into an array <code>A</code> in order. Then the middle node is just <code>A[A.length // 2]</code>, since we can retrieve each node by index.</p> \n  <iframe src=\"https://leetcode.com/playground/fsou5N8T/shared\" frameborder=\"0\" width=\"100%\" height=\"242\" name=\"fsou5N8T\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of nodes in the given list.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the space used by <code>A</code>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-fast-and-slow-pointer\">Approach 2: Fast and Slow Pointer</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>When traversing the list with a pointer <code>slow</code>, make another pointer <code>fast</code> that traverses twice as fast. When <code>fast</code> reaches the end of the list, <code>slow</code> must be in the middle.</p> \n  <iframe src=\"https://leetcode.com/playground/brPhWpn3/shared\" frameborder=\"0\" width=\"100%\" height=\"259\" name=\"brPhWpn3\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of nodes in the given list.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>, the space used by <code>slow</code> and <code>fast</code>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 875,
    "article_live": true,
    "article_slug": "koko-eating-bananas",
    "title": "Koko Eating Bananas",
    "title_slug": "koko-eating-bananas",
    "content": "<p>Koko loves to eat bananas.&nbsp; There are <code>N</code>&nbsp;piles of bananas, the <code>i</code>-th&nbsp;pile has <code>piles[i]</code> bananas.&nbsp; The guards have gone and will come back in <code>H</code> hours.</p>\r\n\r\n<p>Koko can decide her bananas-per-hour eating speed of <code>K</code>.&nbsp; Each hour, she chooses some pile of bananas, and eats K bananas from that pile.&nbsp; If the pile has less than <code>K</code> bananas, she eats all of them instead, and won&#39;t eat any more bananas during this hour.</p>\r\n\r\n<p>Koko likes to eat slowly, but still wants to finish eating all the bananas before the guards come back.</p>\r\n\r\n<p>Return the minimum integer <code>K</code> such that she can eat all the bananas within <code>H</code> hours.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<ul>\r\n</ul>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>piles = <span id=\"example-input-1-1\">[3,6,7,11]</span>, H = <span id=\"example-input-1-2\">8</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">4</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>piles = <span id=\"example-input-2-1\">[30,11,23,4,20]</span>, H = <span id=\"example-input-2-2\">5</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">30</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>piles = <span id=\"example-input-3-1\">[30,11,23,4,20]</span>, H = <span id=\"example-input-3-2\">6</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">23</span>\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= piles.length &lt;= 10^4</code></li>\r\n\t<li><code>piles.length &lt;= H &lt;= 10^9</code></li>\r\n\t<li><code>1 &lt;= piles[i] &lt;= 10^9</code></li>\r\n</ul>\r\n</div>\r\n</div>\r\n</div>\r\n",
    "tags": "Binary Search",
    "difficulty": 2,
    "frontend_article_id": 875,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-binary-search\">Approach 1: Binary Search</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-binary-search\">Approach 1: Binary Search</h4> \n  <p><strong>Intuition</strong></p> \n  <p>If Koko can finish eating all the bananas (within <code>H</code> hours) with an eating speed of <code>K</code>, she can finish with a larger speed too.</p> \n  <p>If we let <code>possible(K)</code> be <code>true</code> if and only if Koko can finish with an eating speed of <code>K</code>, then there is some <code>X</code> such that <code>possible(K) = True</code> if and only if <code>K &gt;= X</code>.</p> \n  <p>For example, with <code>piles = [3, 6, 7, 11]</code> and <code>H = 8</code>, there is some <code>X = 4</code> so that <code>possible(1) = possible(2) = possible(3) = False</code>, and <code>possible(4) = possible(5) = ... = True</code>.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>We can binary search on the values of <code>possible(K)</code> to find the first <code>X</code> such that <code>possible(X)</code> is <code>True</code>: that will be our answer. Our loop invariant will be that <code>possible(hi)</code> is always <code>True</code>, and <code>lo</code> is always less than or equal to the answer. For more information on binary search, please visit <a href=\"https://leetcode.com/explore/learn/card/binary-search/\">[LeetCode Explore - Binary Search]</a>.</p> \n  <p>To find the value of <code>possible(K)</code>, (ie. whether <code>Koko</code> with an eating speed of <code>K</code> can eat all bananas in <code>H</code> hours), we simulate it. For each pile of size <code>p &gt; 0</code>, we can deduce that Koko finishes it in <code>Math.ceil(p / K) = ((p-1) // K) + 1</code> hours, and we add these times across all piles and compare it to <code>H</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/r7NHTXn2/shared\" frameborder=\"0\" width=\"100%\" height=\"446\" name=\"r7NHTXn2\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N \\log W)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of piles, and <script type=\"math/tex; mode=display\">W</script> is the maximum size of a pile.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 874,
    "article_live": true,
    "article_slug": "walking-robot-simulation",
    "title": "Walking Robot Simulation",
    "title_slug": "walking-robot-simulation",
    "content": "<p>A robot on an infinite grid starts at point (0, 0) and faces north.&nbsp; The robot can receive one of three possible types of commands:</p>\r\n\r\n<ul>\r\n\t<li><code>-2</code>: turn left 90 degrees</li>\r\n\t<li><code>-1</code>: turn right 90 degrees</li>\r\n\t<li><code>1 &lt;= x &lt;= 9</code>: move forward <code>x</code> units</li>\r\n</ul>\r\n\r\n<p>Some of the grid squares are obstacles.&nbsp;</p>\r\n\r\n<p>The <code>i</code>-th obstacle is at grid point <code>(obstacles[i][0], obstacles[i][1])</code></p>\r\n\r\n<p>If the robot would try to move onto them, the robot stays on the previous grid square instead (but still continues following the rest of the route.)</p>\r\n\r\n<p>Return the <strong>square</strong> of the maximum Euclidean distance that the robot will be from the origin.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>commands = <span id=\"example-input-1-1\">[4,-1,3]</span>, obstacles = <span id=\"example-input-1-2\">[]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">25</span>\r\n<span>Explanation: </span>robot will go to (3, 4)\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>commands = <span id=\"example-input-2-1\">[4,-1,4,-2,4]</span>, obstacles = <span id=\"example-input-2-2\">[[2,4]]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">65</span>\r\n<strong>Explanation</strong>: robot will be stuck at (1, 4) before turning left and going to (1, 8)\r\n</pre>\r\n</div>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>0 &lt;= commands.length &lt;= 10000</code></li>\r\n\t<li><code>0 &lt;= obstacles.length &lt;= 10000</code></li>\r\n\t<li><code>-30000 &lt;= obstacle[i][0] &lt;= 30000</code></li>\r\n\t<li><code>-30000 &lt;= obstacle[i][1] &lt;= 30000</code></li>\r\n\t<li>The answer is guaranteed to be less than <code>2 ^ 31</code>.</li>\r\n</ol>\r\n",
    "tags": "Greedy",
    "difficulty": 1,
    "frontend_article_id": 874,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-simulation\">Approach 1: Simulation</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-simulation\">Approach 1: Simulation</h4> \n  <p><strong>Intuition</strong></p> \n  <p>We simulate the path of the robot step by step. Since there are at most 90000 steps, this is efficient enough to pass the given input limits.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>We store the robot's position and direction. If we get a turning command, we update the direction; otherwise we walk the specified number of steps in the given direction.</p> \n  <p>Care must be made to use a <code>Set</code> data structure for the obstacles, so that we can check efficiently if our next step is obstructed. If we don't, our check <code>is point in obstacles</code> could be ~10,000 times slower.</p> \n  <p>In some languages, we need to encode the coordinates of each obstacle as a <code>long</code> integer so that it is a hashable key that we can put into a <code>Set</code> data structure. Alternatively, we could also encode the coordinates as a <code>string</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/BzLAA5NV/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"BzLAA5NV\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N + K)</script>, where <script type=\"math/tex; mode=display\">N, K</script> are the lengths of <code>commands</code> and <code>obstacles</code> respectively.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(K)</script>, the space used in storing the <code>obstacleSet</code>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 873,
    "article_live": true,
    "article_slug": "length-of-longest-fibonacci-subsequence",
    "title": "Length of Longest Fibonacci Subsequence",
    "title_slug": "length-of-longest-fibonacci-subsequence",
    "content": "<p>A sequence <code>X_1, X_2, ..., X_n</code>&nbsp;is <em>fibonacci-like</em> if:</p>\r\n\r\n<ul>\r\n\t<li><code>n &gt;= 3</code></li>\r\n\t<li><code>X_i + X_{i+1} = X_{i+2}</code>&nbsp;for all&nbsp;<code>i + 2 &lt;= n</code></li>\r\n</ul>\r\n\r\n<p>Given a <b>strictly increasing</b>&nbsp;array&nbsp;<code>A</code> of positive integers forming a sequence, find the <strong>length</strong> of the longest fibonacci-like subsequence of <code>A</code>.&nbsp; If one does not exist, return 0.</p>\r\n\r\n<p>(<em>Recall that a subsequence is derived from another sequence <code>A</code> by&nbsp;deleting any number of&nbsp;elements (including none)&nbsp;from <code>A</code>, without changing the order of the remaining elements.&nbsp; For example, <code>[3, 5, 8]</code> is a subsequence of <code>[3, 4, 5, 6, 7, 8]</code>.</em>)</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<ul>\r\n</ul>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>[1,2,3,4,5,6,7,8]\r\n<strong>Output: </strong>5\r\n<strong>Explanation:\r\n</strong>The longest subsequence that is fibonacci-like: [1,2,3,5,8].\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>[1,3,7,11,12,14,18]\r\n<strong>Output: </strong>3\r\n<strong>Explanation</strong>:\r\nThe longest subsequence that is fibonacci-like:\r\n[1,11,12], [3,11,14] or [7,11,18].\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>3 &lt;= A.length &lt;= 1000</code></li>\r\n\t<li><code>1 &lt;= A[0] &lt; A[1] &lt; ... &lt; A[A.length - 1] &lt;= 10^9</code></li>\r\n\t<li><em>(The time limit has been reduced by 50% for submissions in Java, C, and C++.)</em></li>\r\n</ul>\r\n",
    "tags": "Array, Dynamic Programming",
    "difficulty": 2,
    "frontend_article_id": 873,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-with-set\">Approach 1: Brute Force with Set</a></li> \n      <li><a href=\"#approach-2-dynamic-programming\">Approach 2: Dynamic Programming</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-with-set\">Approach 1: Brute Force with Set</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Every Fibonacci-like subsequence has each two adjacent terms determine the next expected term. For example, with <code>2, 5</code>, we expect that the sequence must continue <code>7, 12, 19, 31</code>, etc.</p> \n  <p>We can use a <code>Set</code> structure to determine quickly whether the next term is in the array <code>A</code> or not. Because of the exponential growth of these terms, there are at most 43 terms in any Fibonacci-like subsequence that has maximum value <script type=\"math/tex; mode=display\">\\leq 10^9</script>.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>For each starting pair <code>A[i], A[j]</code>, we maintain the next expected value <code>y = A[i] + A[j]</code> and the previously seen largest value <code>x = A[j]</code>. If <code>y</code> is in the array, then we can then update these values <code>(x, y) -&gt; (y, x+y)</code>.</p> \n  <p>Also, because subsequences are only fibonacci-like if they have length 3 or more, we must perform the check <code>ans &gt;= 3 ? ans : 0</code> at the end.</p> \n  <iframe src=\"https://leetcode.com/playground/HWTGNbV2/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"HWTGNbV2\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2 \\log M)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>A</code>, and <script type=\"math/tex; mode=display\">M</script> is the maximum value of <code>A</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the space used by the set <code>S</code>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-dynamic-programming\">Approach 2: Dynamic Programming</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Think of two consecutive terms <code>A[i], A[j]</code> in a fibonacci-like subsequence as a single node <code>(i, j)</code>, and the entire subsequence is a path between these consecutive nodes. For example, with the fibonacci-like subsequence <code>(A[1] = 2, A[2] = 3, A[4] = 5, A[7] = 8, A[10] = 13)</code>, we have the path between nodes <code>(1, 2) &lt;-&gt; (2, 4) &lt;-&gt; (4, 7) &lt;-&gt; (7, 10)</code>.</p> \n  <p>The motivation for this is that two nodes <code>(i, j)</code> and <code>(j, k)</code> are connected if and only if <code>A[i] + A[j] == A[k]</code>, and we needed this amount of information to know about this connection. Now we have a problem similar to <em>Longest Increasing Subsequence</em>.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Let <code>longest[i, j]</code> be the longest path ending in <code>[i, j]</code>. Then <code>longest[j, k] = longest[i, j] + 1</code> if <code>(i, j)</code> and <code>(j, k)</code> are connected. Since <code>i</code> is uniquely determined as <code>A.index(A[k] - A[j])</code>, this is efficient: we check for each <code>j &lt; k</code> what <code>i</code> is potentially, and update <code>longest[j, k]</code> accordingly.</p> \n  <iframe src=\"https://leetcode.com/playground/vEtztLgc/shared\" frameborder=\"0\" width=\"100%\" height=\"463\" name=\"vEtztLgc\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>A</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N \\log M)</script>, where <script type=\"math/tex; mode=display\">M</script> is the largest element of <code>A</code>. We can show that the number of elements in a subsequence is bounded by <script type=\"math/tex; mode=display\">O(\\log \\frac{M}{a})</script> where <script type=\"math/tex; mode=display\">a</script> is the minimum element in the subsequence. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 872,
    "article_live": true,
    "article_slug": "leaf-similar-trees",
    "title": "Leaf-Similar Trees",
    "title_slug": "leaf-similar-trees",
    "content": "<p>Consider all the leaves of a binary tree.&nbsp; From&nbsp;left to right order, the values of those&nbsp;leaves form a <em>leaf value sequence.</em></p>\r\n\r\n<p><img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/16/tree.png\" style=\"width: 300px; height: 240px;\" /></p>\r\n\r\n<p>For example, in the given tree above, the leaf value sequence is <code>(6, 7, 4, 9, 8)</code>.</p>\r\n\r\n<p>Two binary trees are considered <em>leaf-similar</em>&nbsp;if their leaf value sequence is the same.</p>\r\n\r\n<p>Return <code>true</code> if and only if the two given trees with head nodes <code>root1</code> and <code>root2</code> are leaf-similar.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>Both of the given trees will have between <code>1</code> and <code>100</code> nodes.</li>\r\n</ul>\r\n",
    "tags": "Tree, Depth-first Search",
    "difficulty": 1,
    "frontend_article_id": 872,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-depth-first-search\">Approach 1: Depth First Search</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-depth-first-search\">Approach 1: Depth First Search</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Let's find the leaf value sequence for both given trees. Afterwards, we can compare them to see if they are equal or not.</p> \n  <p>To find the leaf value sequence of a tree, we use a depth first search. Our <code>dfs</code> function writes the node's value if it is a leaf, and then recursively explores each child. This is guaranteed to visit each leaf in left-to-right order, as left-children are fully explored before right-children.</p> \n  <iframe src=\"https://leetcode.com/playground/2esZiYkH/shared\" frameborder=\"0\" width=\"100%\" height=\"378\" name=\"2esZiYkH\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(T_1 + T_2)</script>, where <script type=\"math/tex; mode=display\">T_1, T_2</script> are the lengths of the given trees.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(T_1 + T_2)</script>, the space used in storing the leaf values. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 470,
    "article_live": true,
    "article_slug": "implement-rand10-using-rand7",
    "title": "Implement Rand10() Using Rand7()",
    "title_slug": "implement-rand10-using-rand7",
    "content": "<p>Given a function <code>rand7</code> which generates a uniform random integer in the range 1 to 7, write a function <code>rand10</code>&nbsp;which generates a uniform random integer in the range 1 to 10.</p>\r\n\r\n<p>Do NOT use system&#39;s <code>Math.random()</code>.</p>\r\n\r\n<ol>\r\n</ol>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">1</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">[7]</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">2</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">[8,4]</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-3-1\">3</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">[8,1,10]</span>\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>rand7</code> is predefined.</li>\r\n\t<li>Each testcase has one argument:&nbsp;<code>n</code>, the number of times that <code>rand10</code> is called.</li>\r\n</ol>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Follow up:</strong></p>\r\n\r\n<ol>\r\n\t<li>What is the <a href=\"https://en.wikipedia.org/wiki/Expected_value\" target=\"_blank\">expected value</a>&nbsp;for the number of calls to&nbsp;<code>rand7()</code>&nbsp;function?</li>\r\n\t<li>Could you minimize the number of calls to <code>rand7()</code>?</li>\r\n</ol>\r\n</div>\r\n</div>\r\n</div>\r\n",
    "tags": "Random, Rejection Sampling",
    "difficulty": 2,
    "frontend_article_id": 470,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-rejection-sampling\">Approach 1: Rejection Sampling</a></li> \n      <li><a href=\"#approach-2-utilizing-out-of-range-samples\">Approach 2: Utilizing out-of-range samples</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-rejection-sampling\">Approach 1: Rejection Sampling</h4> \n  <p><strong>Intuition</strong></p> \n  <p>What if you could generate a random integer in the range 1 to 49? How would you generate a random integer in the range of 1 to 10? What would you do if the generated number is in the desired range? What if it is not?</p> \n  <p><strong>Algorithm</strong></p> \n  <p>This solution is based upon <a href=\"https://en.wikipedia.org/wiki/Rejection_sampling\">Rejection Sampling</a>. The main idea is when you generate a number in the desired range, output that number immediately. If the number is out of the desired range, reject it and re-sample again. As each number in the desired range has the same probability of being chosen, a uniform distribution is produced.</p> \n  <p>Obviously, we have to run rand7() function at least twice, as there are not enough numbers in the range of 1 to 10. By running rand7() twice, we can get integers from 1 to 49 uniformly. Why?</p> \n  <p><br></p> \n  <p align=\"center\"> <img src=\"../Figures/470/rejectionSamplingTable.png\" alt=\"rejectionSamplingTable\" style=\"height: 300px;\"> <br> A table is used to illustrate the concept of rejection sampling. Calling rand7() twice will get us row and column index that corresponds to a unique position in the table above. Imagine that you are choosing a number randomly from the table above. If you hit a number, you return that number immediately. If you hit a * , you repeat the process again until you hit a number. </p> \n  <p>Since 49 is not a multiple of 10, we have to use rejection sampling. Our desired range is integers from 1 to 40, which we can return the answer immediately. If not (the integer falls between 41 to 49), we reject it and repeat the whole process again.</p> \n  <iframe src=\"https://leetcode.com/playground/JbmdbBCo/shared\" frameborder=\"0\" width=\"100%\" height=\"259\" name=\"JbmdbBCo\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time Complexity: <script type=\"math/tex; mode=display\">O(1)</script> average, but <script type=\"math/tex; mode=display\">O(\\infty)</script> worst case.</li> \n  </ul> \n  <p>The <a href=\"https://en.wikipedia.org/wiki/Expected_value\">expected value</a> for the number of calls to rand7() can be computed as follows:</p> \n  <p> <script type=\"math/tex; mode=display\">\n\\begin{align}\nE\\left( \\text{# calls to rand7} \\right) =\n\\ & 2 \\cdot \\frac{40}{49} + \\\\\n& 4 \\cdot \\frac{9}{49} \\cdot \\frac{40}{49} + \\\\\n& 6 \\cdot \\left(\\frac{9}{49}\\right)^2 \\cdot \\frac{40}{49} + \\\\\n\\ \\\\\n& ...\\\\\n\\ \\\\\n=\\ & \\sum_{k=1}^{\\infty} \\left(\\frac{9}{49}\\right)^{k-1} \\cdot \\frac{40}{49} \\\\\n=\\ & \\frac{80}{49 \\cdot \\left(1 - \\dfrac{9}{49}\\right)^2} \\\\\n\\ \\\\\n=\\ & 2.45\n\\end{align}\n</script> </p> \n  <ul> \n   <li>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>.</li> \n  </ul> \n  <p><br></p> \n  <hr> \n  <h4 id=\"approach-2-utilizing-out-of-range-samples\">Approach 2: Utilizing out-of-range samples</h4> \n  <p><strong>Intuition</strong></p> \n  <p>There are a total of 2.45 calls to rand7() on average when using approach 1. Can we do better? Glad that you asked. In fact, we are able to improve average number of calls to rand7() by about 10%.</p> \n  <p>The idea is that we should not throw away the out-of-range samples, but instead use them to increase our chances of finding an in-range sample on the successive call to rand7.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Start by generating a random integer in the range 1 to 49 using the aforementioned method. In the event that we could not generate a number in the desired range (1 to 40), it is equally likely that each number of 41 to 49 would be chosen. In other words, we are able to obtain integers in the range of 1 to 9 uniformly. Now, run rand7() again to obtain integers in the range of 1 to 63 uniformly. Apply rejection sampling where the desired range is 1 to 60. If the generated number is in the desired range (1 to 60), we return the number. If it is not (61 to 63), we at least obtain integers of 1 to 3 uniformly. Run rand7() again to obtain integers in the range of 1 to 21 uniformly. The desired range is 1 to 20, and in the unlikely event we get a 21, we reject it and repeat the entire process again.</p> \n  <iframe src=\"https://leetcode.com/playground/frCUaJYp/shared\" frameborder=\"0\" width=\"100%\" height=\"480\" name=\"frCUaJYp\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time Complexity: <script type=\"math/tex; mode=display\">O(1)</script> average, but <script type=\"math/tex; mode=display\">O(\\infty)</script> worst case.</li> \n  </ul> \n  <p>The <a href=\"https://en.wikipedia.org/wiki/Expected_value\">expected value</a> for the number of calls to rand7() can be computed as follows (with some steps omitted due to tediousness):</p> \n  <p> <script type=\"math/tex; mode=display\">\n\\begin{align}\nE\\left( \\text{# calls to rand7} \\right) =\\,& 2 \\cdot \\frac{40}{49} + \\\\\n&3 \\cdot \\frac{9}{49} \\cdot \\frac{60}{63} + \\\\\n&4 \\cdot \\frac{9}{49} \\cdot \\frac{3}{63} \\cdot \\frac{20}{21} + \\\\\n\\\\\n&\\left(\\frac{9}{49} \\cdot \\frac{3}{63} \\cdot \\frac{1}{21}\\right) \\times \\\\\n& \\left( 6 \\cdot \\frac{40}{49} + \\right. \\\\\n& \\ \\ \\  7 \\cdot \\frac{9}{49} \\cdot \\frac{60}{63} + \\\\\n& \\left. \\ \\ \\ 8  \\cdot \\frac{9}{49} \\cdot \\frac{3}{63} \\cdot \\frac{20}{21} \\right) + \\\\\n\\\\\n&\\left(\\frac{9}{49} \\cdot \\frac{3}{63} \\cdot \\frac{1}{21}\\right)^2 \\times \\\\\n&\\left( 10 \\cdot \\frac{40}{49} + \\right. \\\\\n& \\ \\ \\  11 \\cdot \\frac{9}{49} \\cdot \\frac{60}{63} + \\\\\n& \\left. \\ \\ \\ 12 \\cdot \\frac{9}{49} \\cdot \\frac{3}{63} \\cdot \\frac{20}{21} \\right) + \\\\\n\\\\\n&\\ldots \\\\\n\\\\\n=\\,& 2.2123\n\\end{align}\n</script> </p> \n  <ul> \n   <li>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>.</li> \n  </ul> \n </div> \n</div>"
},
{
    "frontend_question_id": 871,
    "article_live": true,
    "article_slug": "minimum-number-of-refueling-stops",
    "title": "Minimum Number of Refueling Stops",
    "title_slug": "minimum-number-of-refueling-stops",
    "content": "<p>A car travels from a starting position to a destination which is <code>target</code> miles east of the starting position.</p>\r\n\r\n<p>Along the way, there are gas stations.&nbsp; Each <code>station[i]</code>&nbsp;represents a gas station that is <code>station[i][0]</code> miles east of the starting position, and has <code>station[i][1]</code> liters of gas.</p>\r\n\r\n<p>The car starts with an infinite tank of gas, which initially has&nbsp;<code>startFuel</code>&nbsp;liters of fuel in it.&nbsp; It uses 1 liter of gas per 1 mile that it drives.</p>\r\n\r\n<p>When the car&nbsp;reaches a gas station, it may stop and refuel, transferring all the gas from the station into the car.</p>\r\n\r\n<p>What is the least number of refueling stops the car must make in order to reach its destination?&nbsp; If it cannot reach the destination, return <code>-1</code>.</p>\r\n\r\n<p>Note that if the car reaches a gas station with 0 fuel left, the car can still refuel there.&nbsp; If the car reaches the destination with 0 fuel left, it is still considered to have arrived.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>target = <span id=\"example-input-1-1\">1</span>, startFuel = <span id=\"example-input-1-2\">1</span>, stations = <span id=\"example-input-1-3\">[]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">0</span>\r\n<strong>Explanation: </strong>We can reach the target without refueling.\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>target = <span id=\"example-input-2-1\">100</span>, startFuel = <span id=\"example-input-2-2\">1</span>, stations = <span id=\"example-input-2-3\">[[10,100]]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">-1</span>\r\n<strong>Explanation: </strong>We can&#39;t reach the target (or even the first gas station).\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>target = <span id=\"example-input-3-1\">100</span>, startFuel = <span id=\"example-input-3-2\">10</span>, stations = <span id=\"example-input-3-3\">[[10,60],[20,30],[30,30],[60,40]]</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">2</span>\r\n<strong>Explanation: </strong>\r\nWe start with 10 liters of fuel.\r\nWe drive to position 10, expending 10 liters of fuel.  We refuel from 0 liters to 60 liters of gas.\r\nThen, we drive from position 10 to position 60 (expending 50 liters of fuel),\r\nand refuel from 10 liters to 50 liters of gas.  We then drive to and reach the target.\r\nWe made 2 refueling stops along the way, so we return 2.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= target, startFuel, stations[i][1] &lt;= 10^9</code></li>\r\n\t<li><code>0 &lt;= stations.length &lt;= 500</code></li>\r\n\t<li><code>0 &lt; stations[0][0] &lt; stations[1][0] &lt; ... &lt; stations[stations.length-1][0] &lt; target</code></li>\r\n</ol>\r\n</div>\r\n</div>\r\n</div>\r\n",
    "tags": "Dynamic Programming, Heap",
    "difficulty": 3,
    "frontend_article_id": 871,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-dynamic-programming\">Approach 1: Dynamic Programming</a></li> \n      <li><a href=\"#approach-2-heap\">Approach 2: Heap</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-dynamic-programming\">Approach 1: Dynamic Programming</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Let's determine <code>dp[i]</code>, the farthest location we can get to using <code>i</code> refueling stops. This is motivated by the fact that we want the smallest <code>i</code> for which <code>dp[i] &gt;= target</code>.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Let's update <code>dp</code> as we consider each station in order. With no stations, clearly we can get a maximum distance of <code>startFuel</code> with <code>0</code> refueling stops.</p> \n  <p>Now let's look at the update step. When adding a station <code>station[i] = (location, capacity)</code>, any time we could reach this station with <code>t</code> refueling stops, we can now reach <code>capacity</code> further with <code>t+1</code> refueling stops.</p> \n  <p>For example, if we could reach a distance of 15 with 1 refueling stop, and now we added a station at location 10 with 30 liters of fuel, then we could potentially reach a distance of 45 with 2 refueling stops.</p> \n  <iframe src=\"https://leetcode.com/playground/yh7yQrw9/shared\" frameborder=\"0\" width=\"100%\" height=\"310\" name=\"yh7yQrw9\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>stations</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the space used by <code>dp</code>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-heap\">Approach 2: Heap</h4> \n  <p><strong>Intuition</strong></p> \n  <p>When driving past a gas station, let's remember the amount of fuel it contained. We don't need to decide yet whether to fuel up here or not - for example, there could be a bigger gas station up ahead that we would rather refuel at.</p> \n  <p>When we run out of fuel before reaching the next station, we'll retroactively fuel up: greedily choosing the largest gas stations first.</p> \n  <p>This is guaranteed to succeed because we drive the largest distance possible before each refueling stop, and therefore have the largest choice of gas stations to (retroactively) stop at.</p> \n  <p><strong>Algorithm</strong></p> \n  <p><code>pq</code> (\"priority queue\") will be a max-heap of the capacity of each gas station we've driven by. We'll also keep track of <code>tank</code>, our current fuel.</p> \n  <p>When we reach a station but have negative fuel (ie. we needed to have refueled at some point in the past), we will add the capacities of the largest gas stations we've driven by until the fuel is non-negative.</p> \n  <p>If at any point this process fails (that is, no more gas stations), then the task is impossible.</p> \n  <iframe src=\"https://leetcode.com/playground/X55xUw8U/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"X55xUw8U\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N \\log N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>stations</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the space used by <code>pq</code>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>. Approach 1 inspired by @lee215. Approach 2 inspired by @laiden.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 870,
    "article_live": true,
    "article_slug": "advantage-shuffle",
    "title": "Advantage Shuffle",
    "title_slug": "advantage-shuffle",
    "content": "<p>Given two arrays <code>A</code> and <code>B</code> of equal size, the <em>advantage of <code>A</code> with respect to <code>B</code></em> is the number of indices <code>i</code>&nbsp;for which <code>A[i] &gt; B[i]</code>.</p>\r\n\r\n<p>Return <strong>any</strong> permutation of <code>A</code> that maximizes its advantage with respect to <code>B</code>.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>A = <span id=\"example-input-1-1\">[2,7,11,15]</span>, B = <span id=\"example-input-1-2\">[1,10,4,11]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">[2,11,7,15]</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>A = <span id=\"example-input-2-1\">[12,24,8,32]</span>, B = <span id=\"example-input-2-2\">[13,25,32,11]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">[24,32,8,12]</span>\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= A.length = B.length &lt;= 10000</code></li>\r\n\t<li><code>0 &lt;= A[i] &lt;= 10^9</code></li>\r\n\t<li><code>0 &lt;= B[i] &lt;= 10^9</code></li>\r\n</ol>\r\n</div>\r\n</div>\r\n",
    "tags": "Array, Greedy",
    "difficulty": 2,
    "frontend_article_id": 870,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-greedy\">Approach 1: Greedy</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-greedy\">Approach 1: Greedy</h4> \n  <p><strong>Intuition</strong></p> \n  <p>If the smallest card <code>a</code> in <code>A</code> beats the smallest card <code>b</code> in <code>B</code>, we should pair them. Otherwise, <code>a</code> is useless for our score, as it can't beat any cards.</p> \n  <p>Why should we pair <code>a</code> and <code>b</code> if <code>a &gt; b</code>? Because every card in <code>A</code> is larger than <code>b</code>, any card we place in front of <code>b</code> will score a point. We might as well use the weakest card to pair with <code>b</code> as it makes the rest of the cards in <code>A</code> strictly larger, and thus have more potential to score points.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>We can use the above intuition to create a greedy approach. The current smallest card to beat in <code>B</code> will always be <code>b = sortedB[j]</code>. For each card <code>a</code> in <code>sortedA</code>, we will either have <code>a</code> beat that card <code>b</code> (put <code>a</code> into <code>assigned[b]</code>), or throw <code>a</code> out (put <code>a</code> into <code>remaining</code>).</p> \n  <p>Afterwards, we can use our annotations <code>assigned</code> and <code>remaining</code> to reconstruct the answer. Please see the comments for more details.</p> \n  <iframe src=\"https://leetcode.com/playground/GJdLmnhx/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"GJdLmnhx\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N \\log N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>A</code> and <code>B</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 869,
    "article_live": true,
    "article_slug": "reordered-power-of-2",
    "title": "Reordered Power of 2",
    "title_slug": "reordered-power-of-2",
    "content": "<p>Starting with a positive integer <code>N</code>, we reorder the digits in any order (including the original order) such that the leading digit is not zero.</p>\r\n\r\n<p>Return <code>true</code>&nbsp;if and only if we can do this in a way such that the resulting number is a power of 2.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<ol>\r\n</ol>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">1</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">true</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">10</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">false</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-3-1\">16</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">true</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 4:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-4-1\">24</span>\r\n<strong>Output: </strong><span id=\"example-output-4\">false</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 5:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-5-1\">46</span>\r\n<strong>Output: </strong><span id=\"example-output-5\">true</span>\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= N &lt;= 10^9</code></li>\r\n</ol>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n",
    "tags": "Math",
    "difficulty": 2,
    "frontend_article_id": 869,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-permutations\">Approach 1: Permutations</a></li> \n      <li><a href=\"#approach-2-counting\">Approach 2: Counting</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-permutations\">Approach 1: Permutations</h4> \n  <p><strong>Intuition</strong></p> \n  <p>For each permutation of the digits of <code>N</code>, let's check if that permutation is a power of 2.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>This approach has two steps: how will we generate the permutations of the digits, and how will we check that the permutation represents a power of 2?</p> \n  <p>To generate permutations of the digits, we place any digit into the first position (<code>start = 0</code>), then any of the remaining digits into the second position (<code>start = 1</code>), and so on. In Python, we can use the builtin function <code>itertools.permutations</code>.</p> \n  <p>To check whether a permutation represents a power of 2, we check that there is no leading zero, and divide out all factors of 2. If the result is <code>1</code> (that is, it contained no other factors besides <code>2</code>), then it was a power of 2. In Python, we can use the check <code>bin(N).count('1') == 1</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/jfG2dxr5/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"jfG2dxr5\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O((\\log N)! * \\log N)</script>. Note that <script type=\"math/tex; mode=display\">\\log N</script> is the number of digits in the binary representation of <script type=\"math/tex; mode=display\">N</script>. For each of <script type=\"math/tex; mode=display\">(\\log N)!</script> permutations of the digits of <script type=\"math/tex; mode=display\">N</script>, we need to check that it is a power of 2 in <script type=\"math/tex; mode=display\">O(\\log N)</script> time.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(\\log N)</script>, the space used by <code>A</code> (or <code>cand</code> in Python). <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-counting\">Approach 2: Counting</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>We can check whether two numbers have the same digits by comparing the <em>count</em> of their digits. For example, 338 and 833 have the same digits because they both have exactly two 3's and one 8.</p> \n  <p>Since <script type=\"math/tex; mode=display\">N</script> could only be a power of 2 with 9 digits or less (namely, <script type=\"math/tex; mode=display\">2^0, 2^1, \\cdots, 2^29</script>), we can just check whether <script type=\"math/tex; mode=display\">N</script> has the same digits as any of these possibilities.</p> \n  <iframe src=\"https://leetcode.com/playground/ZV2nPKdj/shared\" frameborder=\"0\" width=\"100%\" height=\"395\" name=\"ZV2nPKdj\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(\\log^2 N)</script>. There are <script type=\"math/tex; mode=display\">\\log N</script> different candidate powers of 2, and each comparison has <script type=\"math/tex; mode=display\">O(\\log N)</script> time complexity.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(\\log N)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 868,
    "article_live": true,
    "article_slug": "binary-gap",
    "title": "Binary Gap",
    "title_slug": "binary-gap",
    "content": "<p>Given a positive&nbsp;integer <code>N</code>, find and return the longest distance between two consecutive 1&#39;s in the binary representation of <code>N</code>.</p>\r\n\r\n<p>If there aren&#39;t two consecutive 1&#39;s, return <font face=\"monospace\">0</font>.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<div>\r\n<div>\r\n<ul>\r\n</ul>\r\n</div>\r\n</div>\r\n</div>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">22</span>\r\n<strong>Output: </strong>2\r\n<strong>Explanation: </strong>\r\n22 in binary is 0b10110.\r\nIn the binary representation of 22, there are three ones, and two consecutive pairs of 1&#39;s.\r\nThe first consecutive pair of 1&#39;s have distance 2.\r\nThe second consecutive pair of 1&#39;s have distance 1.\r\nThe answer is the largest of these two distances, which is 2.\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">5</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">2</span>\r\n<strong>Explanation: </strong>\r\n5 in binary is 0b101.\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-3-1\">6</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">1</span>\r\n<strong>Explanation: </strong>\r\n6 in binary is 0b110.\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 4:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-4-1\">8</span>\r\n<strong>Output: </strong><span id=\"example-output-4\">0</span>\r\n<strong>Explanation: </strong>\r\n8 in binary is 0b1000.\r\nThere aren&#39;t any consecutive pairs of 1&#39;s in the binary representation of 8, so we return 0.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<div>\r\n<div>\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= N &lt;= 10^9</code></li>\r\n</ul>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n",
    "tags": "Math",
    "difficulty": 1,
    "frontend_article_id": 868,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-store-indexes\">Approach 1: Store Indexes</a></li> \n      <li><a href=\"#approach-2-one-pass\">Approach 2: One Pass</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-store-indexes\">Approach 1: Store Indexes</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Since we wanted to inspect the distance between consecutive 1s in the binary representation of <code>N</code>, let's write down the index of each <code>1</code> in that binary representation. For example, if <code>N = 22 = 0b10110</code>, then we'll write <code>A = [1, 2, 4]</code>. This makes it easier to proceed, as now we have a problem about adjacent values in an array.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Let's make a list <code>A</code> of indices <code>i</code> such that <code>N</code> has the <code>i</code>th bit set.</p> \n  <p>With this array <code>A</code>, finding the maximum distance between consecutive <code>1</code>s is much easier: it's the maximum distance between adjacent values of this array.</p> \n  <iframe src=\"https://leetcode.com/playground/vjdm4iZG/shared\" frameborder=\"0\" width=\"100%\" height=\"293\" name=\"vjdm4iZG\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(\\log N)</script>. Note that <script type=\"math/tex; mode=display\">\\log N</script> is the number of digits in the binary representation of <script type=\"math/tex; mode=display\">N</script>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(\\log N)</script>, the space used by <code>A</code>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-one-pass\">Approach 2: One Pass</h4> \n  <p><strong>Intuition</strong></p> \n  <p>In <em>Approach 1</em>, we created an array <code>A</code> of indices <code>i</code> for which <code>N</code> had the <code>i</code>th bit set.</p> \n  <p>Since we only care about consecutive values of this array <code>A</code>, we don't need to store the whole array. We only need to remember the last value seen.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>We'll store <code>last</code>, the last value added to the <em>virtual</em> array <code>A</code>. If <code>N</code> has the <code>i</code>th bit set, a candidate answer is <code>i - last</code>, and then the new last value added to <code>A</code> would be <code>last = i</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/Pae8eWML/shared\" frameborder=\"0\" width=\"100%\" height=\"276\" name=\"Pae8eWML\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(\\log N)</script>. Note that <script type=\"math/tex; mode=display\">\\log N</script> is the number of digits in the binary representation of <script type=\"math/tex; mode=display\">N</script>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 867,
    "article_live": true,
    "article_slug": "transpose-matrix",
    "title": "Transpose Matrix",
    "title_slug": "transpose-matrix",
    "content": "<p>Given a&nbsp;matrix <code>A</code>, return the transpose of <code>A</code>.</p>\r\n\r\n<p>The transpose of a matrix is the matrix flipped over it&#39;s main diagonal, switching the row and column indices of the matrix.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[[1,2,3],[4,5,6],[7,8,9]]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">[[1,4,7],[2,5,8],[3,6,9]]</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">[[1,2,3],[4,5,6]]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">[[1,4],[2,5],[3,6]]</span>\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><span><strong>Note:</strong></span></p>\r\n\r\n<ol>\r\n\t<li><code><span>1 &lt;= A.length&nbsp;&lt;= 1000</span></code></li>\r\n\t<li><code><span>1 &lt;= A[0].length&nbsp;&lt;= 1000</span></code></li>\r\n</ol>\r\n</div>\r\n</div>\r\n",
    "tags": "Array",
    "difficulty": 1,
    "frontend_article_id": 867,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-copy-directly\">Approach 1: Copy Directly</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-copy-directly\">Approach 1: Copy Directly</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>The transpose of a matrix <code>A</code> with dimensions <code>R x C</code> is a matrix <code>ans</code> with dimensions <code>C x R</code> for which <code>ans[c][r] = A[r][c]</code>.</p> \n  <p>Let's initialize a new matrix <code>ans</code> representing the answer. Then, we'll copy each entry of the matrix as appropriate.</p> \n  <iframe src=\"https://leetcode.com/playground/npb7vRxu/shared\" frameborder=\"0\" width=\"100%\" height=\"242\" name=\"npb7vRxu\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(R * C)</script>, where <script type=\"math/tex; mode=display\">R</script> and <script type=\"math/tex; mode=display\">C</script> are the number of rows and columns in the given matrix <code>A</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(R * C)</script>, the space used by the answer. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 866,
    "article_live": true,
    "article_slug": "prime-palindrome",
    "title": "Prime Palindrome",
    "title_slug": "prime-palindrome",
    "content": "<p>Find the smallest prime palindrome greater than or equal to <code>N</code>.</p>\r\n\r\n<p>Recall that a&nbsp;number is <em>prime</em> if it&#39;s only divisors are 1 and itself, and it is greater than 1.&nbsp;</p>\r\n\r\n<p>For example, 2,3,5,7,11 and 13 are&nbsp;primes.</p>\r\n\r\n<p>Recall that a number is a <em>palindrome</em> if it reads the same from left to right as it does from right to left.&nbsp;</p>\r\n\r\n<p>For example, 12321 is a palindrome.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">6</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">7</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">8</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">11</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-3-1\">13</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">101</span></pre>\r\n</div>\r\n</div>\r\n</div>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= N &lt;= 10^8</code></li>\r\n\t<li>The answer is guaranteed to exist and be less than <code>2 * 10^8</code>.</li>\r\n</ul>\r\n",
    "tags": "Math",
    "difficulty": 2,
    "frontend_article_id": 866,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-framework\">Approach Framework</a></li> \n      <li><a href=\"#approach-1-iterate-palindromes\">Approach 1: Iterate Palindromes</a></li> \n      <li><a href=\"#approach-2-brute-force-with-mathematical-shortcut\">Approach 2: Brute Force with Mathematical Shortcut</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-framework\">Approach Framework</h4> \n  <p><strong>Investigation of Brute Force</strong></p> \n  <p>Let's investigate and improve on a brute force method.</p> \n  <p>With basic methods, we can check whether an integer <script type=\"math/tex; mode=display\">N</script> is a palindrome in <script type=\"math/tex; mode=display\">O(\\log N)</script> time, and check whether it is prime in <script type=\"math/tex; mode=display\">O(\\sqrt{N})</script> time. So we would probably like to do the palindrome check first.</p> \n  <p>Now, say we naively check every number <script type=\"math/tex; mode=display\">N, N+1, \\cdots, N+K</script>. How big is <script type=\"math/tex; mode=display\">K</script>?</p> \n  <p>Well, the palindromes could be approximately <script type=\"math/tex; mode=display\">10^4</script> apart, since for example <code>99988999</code>'s next palindrome is <code>99999999</code>. </p> \n  <p>If we assume being a palindrome and being a prime is independent, then based on the density of primes, <script type=\"math/tex; mode=display\">K \\approx 10^4 \\log N</script>, and we would do a palindrome check on approximately <script type=\"math/tex; mode=display\">10^4 \\log^2 N</script> values, and a primality test on <script type=\"math/tex; mode=display\">\\log N</script> values of complexity <script type=\"math/tex; mode=display\">\\sqrt{N} \\log N</script>. This seems to work.</p> \n  <p>However, we can't make this assumption of independence: whether a number is a palindrome or prime are <em>negatively correlated</em> events! For example, <script type=\"math/tex; mode=display\">22, 33, 44, \\cdots, 99</script> are clearly not prime. Actually, all palindromes with an even number of digits are divisible by 11, and are therefore not prime! (Except for 11.) For example, an 8 digit palindrome can be written as:</p> \n  <p> <script type=\"math/tex; mode=display\">\\sum_{i=0}^{3} a_i(10^{7-i} + 10^i) \\equiv \\sum a_i((-1)^{7-i} + (-1)^i) \\equiv \\sum a_i(0) \\equiv 0 \\pmod{11}</script> </p> \n  <p>where the second-last equivalence follows as <script type=\"math/tex; mode=display\">i</script> and <script type=\"math/tex; mode=display\">7-i</script> have different parity.</p> \n  <p><strong>Density of Palindromes</strong></p> \n  <p>For a palindrome of <script type=\"math/tex; mode=display\">d</script> digits, choosing the first <script type=\"math/tex; mode=display\">k = \\lfloor \\frac{d+1}{2} \\rfloor</script> digits uniquely determines the remaining digits. Hence, there are <script type=\"math/tex; mode=display\">9 * 10^{k-1}</script> of them (the first digit can't be 0.) Thus, there are</p> \n  <p> <script type=\"math/tex; mode=display\">9(10^0 + 10^0 + 10^1 + 10^1 + 10^2 + 10^2 + 10^3 + 10^3) < 20000</script> </p> \n  <p>palindromes of 8 digits or less. </p> \n  <p>Actually, we don't need to check the palindromes with an even number of digits, so there are under 10000 palindromes we need to check. However, we also need to check palindromes until we encounter the first 9 digit prime palindrome, as all 8 digit numbers <script type=\"math/tex; mode=display\">N</script> will have an answer equal to that. Luckily, it occurs quickly: <code>100030001</code> is the 4th 9-digit value checked. (We can verify this with brute force.)</p> \n  <p>For each palindrome, we can test whether it is prime in <script type=\"math/tex; mode=display\">O(\\sqrt{N})</script> operations. So in total, an approach centered around enumerating palindromes seems like it will succeed. <br> <br></p> \n  <hr> \n  <h4 id=\"approach-1-iterate-palindromes\">Approach 1: Iterate Palindromes</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Say we have a palindrome <script type=\"math/tex; mode=display\">X</script>. What is the next palindrome?</p> \n  <p>Each palindrome of <script type=\"math/tex; mode=display\">d</script> digits has a <em>palindromic root</em>, it's first <script type=\"math/tex; mode=display\">k = \\frac{d+1}{2}</script> digits. The next palindrome is formed by the next root.</p> \n  <p>For example, if <script type=\"math/tex; mode=display\">123</script> is a root for the 5 digit palindrome <script type=\"math/tex; mode=display\">12321</script>, then the next palindrome is <script type=\"math/tex; mode=display\">12421</script> with root <script type=\"math/tex; mode=display\">124</script>.</p> \n  <p>Notice that roots and palindromes are not a bijection, as palindromes <script type=\"math/tex; mode=display\">123321</script> and <script type=\"math/tex; mode=display\">12321</script> have the same root.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>For each <em>palindromic root</em>, let's find the two associated palindromes (one with an odd number of digits, and one with an even number.) For roots with <script type=\"math/tex; mode=display\">k</script> digits, they will generate palindromes of <script type=\"math/tex; mode=display\">2*k - 1</script> and <script type=\"math/tex; mode=display\">2*k</script> digits.</p> \n  <p>If we didn't know that palindromes with an even number of digits (and greater than 11) are never prime, we're still fine - we can just check both possibilities. When checking both possibilities, we check the palindromes with <script type=\"math/tex; mode=display\">2k - 1</script> digits first, as they are all smaller than the palindromes with <script type=\"math/tex; mode=display\">2k</script> digits.</p> \n  <p>We'll use an idea from <a href=\"https://leetcode.com/problems/reverse-integer\">[LeetCode Problem: Reverse an Integer]</a>, in order to check whether an integer is a palindrome. We could have also converted the integer to a string, and checked the indices directly.</p> \n  <p>As for testing primes with <code>isPrime(N)</code>, we'll use the standard <script type=\"math/tex; mode=display\">O(\\sqrt{N})</script> check: testing whether every number <script type=\"math/tex; mode=display\">\\leq \\sqrt{N}</script> is a divisor of <script type=\"math/tex; mode=display\">N</script>.</p> \n  <iframe src=\"https://leetcode.com/playground/UgnkELMD/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"UgnkELMD\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time Complexity: Based on our analysis above, we performed on the order of <script type=\"math/tex; mode=display\">O(N)</script> operations (not counting log factors from dealing with integers), given we knew the existence of prime palindrome <code>100030001</code>. </li> \n  </ul> \n  <p>Interestingly, the time complexity is an open problem in mathematics, as it is not even known whether there are infinitely many prime palindromes, or whether palindromes behave as random integers for our purposes here - see <a href=\"https://arxiv.org/pdf/math/0405056.pdf\">[\"Almost All Palindromes are Composite\"]</a> for more.</p> \n  <ul> \n   <li>Space Complexity: <script type=\"math/tex; mode=display\">O(\\log N)</script>, the space used by <code>s</code> (or <code>sb</code> in Java.) <br> <br></li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-brute-force-with-mathematical-shortcut\">Approach 2: Brute Force with Mathematical Shortcut</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Our brute force works except when <script type=\"math/tex; mode=display\">N</script> is 8 digits (as explained in <em>Approach Framework</em> when we established that all 8 digit palindromes are not prime), so we can skip all 8 digit numbers.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>For each number, check whether it is a palindrome. If it is, check whether it is a prime. If the number is 8 digits, skip to the 9 digit numbers.</p> \n  <iframe src=\"https://leetcode.com/playground/NSw4owuf/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"NSw4owuf\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, with the caveats explained in <em>Approach #1</em>, and ignoring the <script type=\"math/tex; mode=display\">\\log N</script> factor when checking an integer for palindromes.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 865,
    "article_live": true,
    "article_slug": "smallest-subtree-with-all-the-deepest-nodes",
    "title": "Smallest Subtree with all the Deepest Nodes",
    "title_slug": "smallest-subtree-with-all-the-deepest-nodes",
    "content": "<p>Given a binary tree rooted at <code>root</code>, the <em>depth</em> of each node is the shortest distance to the root.</p>\r\n\r\n<p>A node is <em>deepest</em> if it has the largest depth possible among&nbsp;any node in the <u>entire tree</u>.</p>\r\n\r\n<p>The subtree of a node is that node, plus the set of all descendants of that node.</p>\r\n\r\n<p>Return the node with the largest depth such that it contains all the deepest nodes in its subtree.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[3,5,1,6,2,0,8,null,null,7,4]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">[2,7,4]</span>\r\n<strong>Explanation:\r\n</strong>\r\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/01/sketch1.png\" style=\"width: 280px; height: 238px;\" />\r\n\r\nWe return the node with value 2, colored in yellow in the diagram.\r\nThe nodes colored in blue are the deepest nodes of the tree.\r\nThe input &quot;[3, 5, 1, 6, 2, 0, 8, null, null, 7, 4]&quot; is a serialization of the given tree.\r\nThe output &quot;[2, 7, 4]&quot; is a serialization of the subtree rooted at the node with value 2.\r\nBoth the input and output have TreeNode type.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>The number of nodes in the tree will be between 1 and 500.</li>\r\n\t<li>The values of each node are unique.</li>\r\n</ul>\r\n",
    "tags": "Tree",
    "difficulty": 2,
    "frontend_article_id": 865,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-paint-deepest-nodes\">Approach 1: Paint Deepest Nodes</a></li> \n      <li><a href=\"#approach-2-recursion\">Approach 2: Recursion</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-paint-deepest-nodes\">Approach 1: Paint Deepest Nodes</h4> \n  <p><strong>Intuition</strong></p> \n  <p>We try a straightforward approach that has two phases.</p> \n  <p>The first phase is to identify the nodes of the tree that are deepest. To do this, we have to annotate the depth of each node. We can do this with a depth first search.</p> \n  <p>Afterwards, we will use that annotation to help us find the answer:</p> \n  <ul> \n   <li> <p>If the <code>node</code> in question has maximum depth, it is the answer.</p> </li> \n   <li> <p>If both the left and right child of a <code>node</code> have a deepest descendant, then the answer is this parent <code>node</code>. </p> </li> \n   <li> <p>Otherwise, if some child has a deepest descendant, then the answer is that child.</p> </li> \n   <li> <p>Otherwise, the answer for this subtree doesn't exist.</p> </li> \n  </ul> \n  <p><strong>Algorithm</strong></p> \n  <p>In the first phase, we use a depth first search <code>dfs</code> to annotate our nodes.</p> \n  <p>In the second phase, we also use a depth first search <code>answer(node)</code>, returning the answer for the subtree at that <code>node</code>, and using the rules above to build our answer from the answers of the children of <code>node</code>.</p> \n  <p>Note that in this approach, the <code>answer</code> function returns answers that have the deepest nodes of the <em>entire</em> tree, not just the subtree being considered.</p> \n  <iframe src=\"https://leetcode.com/playground/BShzUaRJ/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"BShzUaRJ\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of nodes in the tree.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-recursion\">Approach 2: Recursion</h4> \n  <p><strong>Intuition</strong></p> \n  <p>We can combine both depth first searches in <em>Approach #1</em> into an approach that does both steps in one pass. We will have some function <code>dfs(node)</code> that returns both the answer for this subtree, and the distance from <code>node</code> to the deepest nodes in this subtree.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>The <code>Result</code> (on some subtree) returned by our (depth-first search) recursion will have two parts: <em> <code>Result.node</code>: the largest depth node that is equal to or an ancestor of all the deepest nodes of this subtree. </em> <code>Result.dist</code>: the number of nodes in the path from the root of this subtree, to the deepest node in this subtree.</p> \n  <p>We can calculate these answers disjointly for <code>dfs(node)</code>:</p> \n  <ul> \n   <li> <p>To calculate the <code>Result.node</code> of our answer:</p> \n    <ul> \n     <li> <p>If one <code>childResult</code> has deeper nodes, then <code>childResult.node</code> will be the answer.</p> </li> \n     <li> <p>If they both have the same depth nodes, then <code>node</code> will be the answer.</p> </li> \n    </ul> </li> \n   <li> <p>The <code>Result.dist</code> of our answer is always 1 more than the largest <code>childResult.dist</code> we have.</p> </li> \n  </ul> \n  <iframe src=\"https://leetcode.com/playground/QAN4y6ev/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"QAN4y6ev\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of nodes in the tree.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 864,
    "article_live": true,
    "article_slug": "shortest-path-to-get-all-keys",
    "title": "Shortest Path to Get All Keys",
    "title_slug": "shortest-path-to-get-all-keys",
    "content": "<p>We are given a 2-dimensional&nbsp;<code>grid</code>.&nbsp;<code>&quot;.&quot;</code> is an empty cell, <code>&quot;#&quot;</code> is&nbsp;a wall, <code>&quot;@&quot;</code> is the starting point, (<code>&quot;a&quot;</code>, <code>&quot;b&quot;</code>, ...) are keys, and (<code>&quot;A&quot;</code>,&nbsp;<code>&quot;B&quot;</code>, ...) are locks.</p>\r\n\r\n<p>We start at the starting point, and one move consists of walking one space in one of the 4 cardinal directions.&nbsp; We cannot walk outside the grid, or walk into a wall.&nbsp; If we walk over a key, we pick it up.&nbsp; We can&#39;t walk over a lock unless we have the corresponding key.</p>\r\n\r\n<p>For some <font face=\"monospace\">1 &lt;= K &lt;= 6</font>, there is exactly one lowercase and one uppercase letter of the first <code>K</code> letters of the English alphabet in the grid.&nbsp; This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were&nbsp;chosen in the same order as the English alphabet.</p>\r\n\r\n<p>Return the lowest number of moves to acquire all keys.&nbsp; If&nbsp;it&#39;s impossible, return <code>-1</code>.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[&quot;@.a.#&quot;,&quot;###.#&quot;,&quot;b.A.B&quot;]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">8</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">[&quot;@..aA&quot;,&quot;..B#.&quot;,&quot;....b&quot;]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">6</span>\r\n</pre>\r\n</div>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= grid.length&nbsp;&lt;= 30</code></li>\r\n\t<li><code>1 &lt;= grid[0].length&nbsp;&lt;= 30</code></li>\r\n\t<li><code>grid[i][j]</code> contains only<code> &#39;.&#39;</code>, <code>&#39;#&#39;</code>, <code>&#39;@&#39;</code>,&nbsp;<code>&#39;a&#39;-</code><code>&#39;f</code><code>&#39;</code> and <code>&#39;A&#39;-&#39;F&#39;</code></li>\r\n\t<li>The number of keys is in <code>[1, 6]</code>.&nbsp; Each key has a different letter and opens exactly one lock.</li>\r\n</ol>\r\n</div>\r\n",
    "tags": "Heap, Breadth-first Search",
    "difficulty": 3,
    "frontend_article_id": 864,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-permutations\">Approach 1: Brute Force + Permutations</a></li> \n      <li><a href=\"#approach-2-points-of-interest-dijkstra\">Approach 2: Points of Interest + Dijkstra</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-permutations\">Approach 1: Brute Force + Permutations</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>We have to pick up the keys <script type=\"math/tex; mode=display\">K</script> in some order, say <script type=\"math/tex; mode=display\">K_{\\sigma_i}</script>.</p> \n  <p>For each ordering, let's do a breadth first search to find the distance to the next key.</p> \n  <p>For example, if the keys are <code>'abcdef'</code>, then for each ordering such as <code>'bafedc'</code>, we will try to calculate the candidate distance from <code>'@' -&gt; 'b' -&gt; 'a' -&gt; 'f' -&gt; 'e' -&gt; 'd' -&gt; 'c'</code>.</p> \n  <p>Between each segment of our path (and corresponding breadth-first search), we should remember what keys we've picked up. Keys that are picked up become part of a mask that helps us identify what locks we are allowed to walk through during the next breadth-first search.</p> \n  <p>Each part of the algorithm is relatively straightforward, but the implementation in total can be quite challenging. See the comments for more details.</p> \n  <iframe src=\"https://leetcode.com/playground/cJwN3eUy/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"cJwN3eUy\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(R * C * \\mathcal{A} * \\mathcal{A}!)</script>, where <script type=\"math/tex; mode=display\">R, C</script> are the dimensions of the grid, and <script type=\"math/tex; mode=display\">\\mathcal{A}</script> is the maximum number of keys (<script type=\"math/tex; mode=display\">\\mathcal{A}</script> because it is the \"size of the alphabet\".) Each <code>bfs</code> is performed up to <script type=\"math/tex; mode=display\">\\mathcal{A} * \\mathcal{A}!</script> times.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(R * C + \\mathcal{A}!)</script>, the space for the <code>bfs</code> and to store the candidate key permutations. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-points-of-interest-dijkstra\">Approach 2: Points of Interest + Dijkstra</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Clearly, we only really care about walking between points of interest: the keys, locks, and starting position. We can use this insight to speed up our calculation.</p> \n  <p>Let's make this intuition more formal: any walk can be decomposed into <em>primitive</em> segments, where each segment (between two points of interest) is primitive if and only if it doesn't touch any other point of interest in between.</p> \n  <p>Then, we can calculate the distance (of a primitive segment) between any two points of interest, using a breadth first search.</p> \n  <p>Afterwards, we have some graph (where each node refers to at most <script type=\"math/tex; mode=display\">13</script> places, and at most <script type=\"math/tex; mode=display\">2^6</script> states of keys). We have a starting node (at <code>'@'</code> with no keys) and ending nodes (at anywhere with all keys.) We also know all the costs to go from one node to another - each node has outdegree at most 13. This shortest path problem is now ideal for using Dijkstra's algorithm.</p> \n  <p>Dijkstra's algorithm uses a priority queue to continually searches the path with the lowest cost to destination, so that when we reach the target, we know it must have been through the lowest cost path. Refer to <a href=\"https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\">this link</a> for more detail.</p> \n  <p>Again, each part of the algorithm is relatively straightforward (for those familiar with BFS and Dijkstra's algorithm), but the implementation in total can be quite challenging.</p> \n  <iframe src=\"https://leetcode.com/playground/M5ZW2JJm/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"M5ZW2JJm\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(RC(2\\mathcal{A} + 1) + \\mathcal{E} \\log \\mathcal{N})</script>, where <script type=\"math/tex; mode=display\">R, C</script> are the dimensions of the grid, and <script type=\"math/tex; mode=display\">\\mathcal{A}</script> is the maximum number of keys, <script type=\"math/tex; mode=display\">\\mathcal{N} = (2\\mathcal{A} + 1) * 2^\\mathcal{A}</script> is the number of nodes when we perform Dijkstra's, and <script type=\"math/tex; mode=display\">\\mathcal{E} = \\mathcal{N} * (2 \\mathcal{A} + 1)</script> is the maximum number of edges.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(\\mathcal{N})</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 710,
    "article_live": true,
    "article_slug": "random-pick-with-blacklist",
    "title": "Random Pick with Blacklist",
    "title_slug": "random-pick-with-blacklist",
    "content": "<p>Given a blacklist&nbsp;<code>B</code> containing unique integers&nbsp;from <code>[0, N)</code>, write a function to return a uniform random integer from <code>[0, N)</code> which is <strong>NOT</strong>&nbsp;in <code>B</code>.</p>\r\n\r\n<p>Optimize it such that it minimizes the call to system&rsquo;s <code>Math.random()</code>.</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= N &lt;= 1000000000</code></li>\r\n\t<li><code>0 &lt;= B.length &lt; min(100000, N)</code></li>\r\n\t<li><code>[0, N)</code>&nbsp;does NOT include N. See <a href=\"https://en.wikipedia.org/wiki/Interval_(mathematics)\" target=\"_blank\">interval notation</a>.</li>\r\n</ol>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: \r\n</strong><span id=\"example-input-1-1\">[&quot;Solution&quot;,&quot;pick&quot;,&quot;pick&quot;,&quot;pick&quot;]\r\n</span><span id=\"example-input-1-2\">[[1,[]],[],[],[]]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">[null,0,0,0]</span>\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: \r\n</strong><span id=\"example-input-2-1\">[&quot;Solution&quot;,&quot;pick&quot;,&quot;pick&quot;,&quot;pick&quot;]\r\n</span><span id=\"example-input-2-2\">[[2,[]],[],[],[]]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">[null,1,1,1]</span>\r\n</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: \r\n</strong><span id=\"example-input-3-1\">[&quot;Solution&quot;,&quot;pick&quot;,&quot;pick&quot;,&quot;pick&quot;]\r\n</span><span id=\"example-input-3-2\">[[3,[1]],[],[],[]]</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">[null,0,0,2]</span>\r\n</pre>\r\n\r\n<p><strong>Example 4:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: \r\n</strong><span id=\"example-input-4-1\">[&quot;Solution&quot;,&quot;pick&quot;,&quot;pick&quot;,&quot;pick&quot;]\r\n</span><span id=\"example-input-4-2\">[[4,[2]],[],[],[]]</span>\r\n<strong>Output: </strong><span id=\"example-output-4\">[null,1,3,1]</span>\r\n</pre>\r\n\r\n<p><strong>Explanation of Input Syntax:</strong></p>\r\n\r\n<p>The input is two lists:&nbsp;the subroutines called&nbsp;and their&nbsp;arguments.&nbsp;<code>Solution</code>&#39;s&nbsp;constructor has two arguments,&nbsp;<code>N</code> and the blacklist <code>B</code>. <code>pick</code> has no arguments.&nbsp;Arguments&nbsp;are&nbsp;always wrapped with a list, even if there aren&#39;t any.</p>\r\n",
    "tags": "Hash Table, Binary Search, Sort, Random",
    "difficulty": 3,
    "frontend_article_id": 710,
    "article_content": ""
},
{
    "frontend_question_id": 863,
    "article_live": true,
    "article_slug": "all-nodes-distance-k-in-binary-tree",
    "title": "All Nodes Distance K in Binary Tree",
    "title_slug": "all-nodes-distance-k-in-binary-tree",
    "content": "<p>We are given a binary tree (with root node&nbsp;<code>root</code>), a <code>target</code> node, and an integer value <code>K</code>.</p>\r\n\r\n<p>Return a list of the values of all&nbsp;nodes that have a distance <code>K</code> from the <code>target</code> node.&nbsp; The answer can be returned in any order.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<ol>\r\n</ol>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>root = <span id=\"example-input-1-1\">[3,5,1,6,2,0,8,null,null,7,4]</span>, target = <span id=\"example-input-1-2\">5</span>, K = <span id=\"example-input-1-3\">2</span>\r\n\r\n<strong>Output: </strong><span id=\"example-output-1\">[7,4,1]</span>\r\n\r\n<strong>Explanation: </strong>\r\nThe nodes that are a distance 2 from the target node (with value 5)\r\nhave values 7, 4, and 1.\r\n\r\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/28/sketch0.png\" style=\"width: 280px; height: 240px;\" />\r\n\r\nNote that the inputs &quot;root&quot; and &quot;target&quot; are actually TreeNodes.\r\nThe descriptions of the inputs above are just serializations of these objects.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li>The given tree is non-empty.</li>\r\n\t<li>Each node in the tree has unique values&nbsp;<code>0 &lt;= node.val &lt;= 500</code>.</li>\r\n\t<li>The <code>target</code>&nbsp;node is a node in the tree.</li>\r\n\t<li><code>0 &lt;= K &lt;= 1000</code>.</li>\r\n</ol>\r\n</div>\r\n",
    "tags": "Tree, Depth-first Search, Breadth-first Search",
    "difficulty": 2,
    "frontend_article_id": 863,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-annotate-parent\">Approach 1: Annotate Parent</a></li> \n      <li><a href=\"#approach-2-percolate-distance\">Approach 2: Percolate Distance</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-annotate-parent\">Approach 1: Annotate Parent</h4> \n  <p><strong>Intuition</strong></p> \n  <p>If we know the parent of every node <code>x</code>, we know all nodes that are distance <code>1</code> from <code>x</code>. We can then perform a breadth first search from the <code>target</code> node to find the answer.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>We first do a depth first search where we annotate every node with information about it's parent.</p> \n  <p>After, we do a breadth first search to find all nodes a distance <code>K</code> from the <code>target</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/75DQSaLT/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"75DQSaLT\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of nodes in the given tree.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-percolate-distance\">Approach 2: Percolate Distance</h4> \n  <p><strong>Intuition</strong></p> \n  <p>From <code>root</code>, say the <code>target</code> node is at depth <code>3</code> in the left branch. It means that any nodes that are distance <code>K - 3</code> in the right branch should be added to the answer.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Traverse every <code>node</code> with a depth first search <code>dfs</code>. We'll add all nodes <code>x</code> to the answer such that <code>node</code> is the node on the path from <code>x</code> to <code>target</code> that is closest to the <code>root</code>.</p> \n  <p>To help us, <code>dfs(node)</code> will return the distance from <code>node</code> to the <code>target</code>. Then, there are 4 cases:</p> \n  <ul> \n   <li> <p>If <code>node == target</code>, then we should add nodes that are distance <code>K</code> in the subtree rooted at <code>target</code>.</p> </li> \n   <li> <p>If <code>target</code> is in the left branch of <code>node</code>, say at distance <code>L+1</code>, then we should look for nodes that are distance <code>K - L - 1</code> in the right branch.</p> </li> \n   <li> <p>If <code>target</code> is in the right branch of <code>node</code>, the algorithm proceeds similarly.</p> </li> \n   <li> <p>If <code>target</code> isn't in either branch of <code>node</code>, then we stop.</p> </li> \n  </ul> \n  <p>In the above algorithm, we make use of the auxillary function <code>subtree_add(node, dist)</code> which adds the nodes in the subtree rooted at <code>node</code> that are distance <code>K - dist</code> from the given <code>node</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/ikd8SkzS/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"ikd8SkzS\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of nodes in the given tree.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 862,
    "article_live": true,
    "article_slug": "shortest-subarray-with-sum-atleast-k",
    "title": "Shortest Subarray with Sum at Least K",
    "title_slug": "shortest-subarray-with-sum-at-least-k",
    "content": "<p>Return the <strong>length</strong> of the shortest, non-empty, contiguous&nbsp;subarray of <code>A</code> with sum at least <code>K</code>.</p>\r\n\r\n<p>If there is no non-empty subarray with sum at least <code>K</code>, return <code>-1</code>.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<ol>\r\n</ol>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>A = <span id=\"example-input-1-1\">[1]</span>, K = <span id=\"example-input-1-2\">1</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">1</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>A = <span id=\"example-input-2-1\">[1,2]</span>, K = <span id=\"example-input-2-2\">4</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">-1</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>A = <span id=\"example-input-3-1\">[2,-1,2]</span>, K = <span id=\"example-input-3-2\">3</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">3</span>\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= A.length &lt;= 50000</code></li>\r\n\t<li><code>-10 ^ 5&nbsp;&lt;= A[i] &lt;= 10 ^ 5</code></li>\r\n\t<li><code>1 &lt;= K &lt;= 10 ^ 9</code></li>\r\n</ol>\r\n</div>\r\n</div>\r\n</div>\r\n",
    "tags": "Binary Search, Queue",
    "difficulty": 3,
    "frontend_article_id": 862,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-sliding-window\">Approach 1: Sliding Window</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-sliding-window\">Approach 1: Sliding Window</h4> \n  <p><strong>Intuition</strong></p> \n  <p>We can rephrase this as a problem about the prefix sums of <code>A</code>. Let <code>P[i] = A[0] + A[1] + ... + A[i-1]</code>. We want the smallest <code>y-x</code> such that <code>y &gt; x</code> and <code>P[y] - P[x] &gt;= K</code>.</p> \n  <p>Motivated by that equation, let <code>opt(y)</code> be the largest <code>x</code> such that <code>P[x] &lt;= P[y] - K</code>. We need two key observations:</p> \n  <ul> \n   <li> <p>If <code>x1 &lt; x2</code> and <code>P[x2] &lt;= P[x1]</code>, then <code>opt(y)</code> can never be <code>x1</code>, as if <code>P[x1] &lt;= P[y] - K</code>, then <code>P[x2] &lt;= P[x1] &lt;= P[y] - K</code> but <code>y - x2</code> is smaller. This implies that our candidates <code>x</code> for <code>opt(y)</code> will have increasing values of <code>P[x]</code>.</p> </li> \n   <li> <p>If <code>opt(y1) = x</code>, then we do not need to consider this <code>x</code> again. For if we find some <code>y2 &gt; y1</code> with <code>opt(y2) = x</code>, then it represents an answer of <code>y2 - x</code> which is worse (larger) than <code>y1 - x</code>.</p> </li> \n  </ul> \n  <p><strong>Algorithm</strong></p> \n  <p>Maintain a \"monoqueue\" of indices of <code>P</code>: a deque of indices <code>x_0, x_1, ...</code> such that <code>P[x_0], P[x_1], ...</code> is increasing.</p> \n  <p>When adding a new index <code>y</code>, we'll pop <code>x_i</code> from the end of the deque so that <code>P[x_0], P[x_1], ..., P[y]</code> will be increasing.</p> \n  <p>If <code>P[y] &gt;= P[x_0] + K</code>, then (as previously described), we don't need to consider this <code>x_0</code> again, and we can pop it from the front of the deque.</p> \n  <iframe src=\"https://leetcode.com/playground/RnfeP3KD/shared\" frameborder=\"0\" width=\"100%\" height=\"463\" name=\"RnfeP3KD\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>A</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 861,
    "article_live": true,
    "article_slug": "score-after-flipping-matrix",
    "title": "Score After Flipping Matrix",
    "title_slug": "score-after-flipping-matrix",
    "content": "<p>We have a two dimensional matrix&nbsp;<code>A</code> where each value is <code>0</code> or <code>1</code>.</p>\r\n\r\n<p>A move consists of choosing any row or column, and toggling each value in that row or column: changing all <code>0</code>s to <code>1</code>s, and all <code>1</code>s to <code>0</code>s.</p>\r\n\r\n<p>After making any number of moves, every row of this matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers.</p>\r\n\r\n<p>Return the highest possible&nbsp;score.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<ol>\r\n</ol>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[[0,0,1,1],[1,0,1,0],[1,1,0,0]]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">39</span>\r\n<strong>Explanation:\r\n</strong>Toggled to <span id=\"example-input-1-1\">[[1,1,1,1],[1,0,0,1],[1,1,1,1]].\r\n0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39</span></pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= A.length &lt;= 20</code></li>\r\n\t<li><code>1 &lt;= A[0].length &lt;= 20</code></li>\r\n\t<li><code>A[i][j]</code>&nbsp;is <code>0</code> or <code>1</code>.</li>\r\n</ol>\r\n</div>\r\n",
    "tags": "Greedy",
    "difficulty": 2,
    "frontend_article_id": 861,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force\">Approach 1: Brute Force</a></li> \n      <li><a href=\"#approach-2-greedy\">Approach 2: Greedy</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force\">Approach 1: Brute Force</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Notice that a <code>1</code> in the <script type=\"math/tex; mode=display\">i</script>th column from the right, contributes <script type=\"math/tex; mode=display\">2^i</script> to the score.</p> \n  <p>Say we are finished toggling the rows in some configuration. Then for each column, (to maximize the score), we'll toggle the column if it would increase the number of <code>1</code>s.</p> \n  <p>We can brute force over every possible way to toggle rows.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Say the matrix has <code>R</code> rows and <code>C</code> columns.</p> \n  <p>For each <code>state</code>, the transition <code>trans = state ^ (state-1)</code> represents the rows that must be toggled to get into the state of toggled rows represented by (the bits of) <code>state</code>.</p> \n  <p>We'll toggle them, and also maintain the correct column sums of the matrix on the side.</p> \n  <p>Afterwards, we'll calculate the score. If for example the last column has a column sum of <code>3</code>, then the score is <code>max(3, R-3)</code>, where <code>R-3</code> represents the score we get from toggling the last column.</p> \n  <p>In general, the score is increased by <code>max(col_sum, R - col_sum) * (1 &lt;&lt; (C-1-c))</code>, where the factor <code>(1 &lt;&lt; (C-1-c))</code> is the power of <code>2</code> that each <code>1</code> contributes.</p> \n  <p>Note that this approach may not run in the time allotted.</p> \n  <iframe src=\"https://leetcode.com/playground/RqkiosdE/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"RqkiosdE\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(2^R * R * C)</script>, where <script type=\"math/tex; mode=display\">R, C</script> is the number of rows and columns in the matrix.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(C)</script> in additional space complexity. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-greedy\">Approach 2: Greedy</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Notice that a <code>1</code> in the <script type=\"math/tex; mode=display\">i</script>th column from the right, contributes <script type=\"math/tex; mode=display\">2^i</script> to the score.</p> \n  <p>Since <script type=\"math/tex; mode=display\">2^n > 2^{n-1} + 2^{n-2} + \\cdots + 2^0</script>, maximizing the left-most digit is more important than any other digit. Thus, the rows should be toggled such that the left-most column is either all <code>0</code> or all <code>1</code> (so that after toggling the left-most column [if necessary], the left column is all <code>1</code>.)</p> \n  <p><strong>Algorithm</strong></p> \n  <p>If we toggle rows by the first column (<code>A[r][c] ^= A[r][0]</code>), then the first column will be all <code>0</code>.</p> \n  <p>Afterwards, the base score is <code>max(col, R - col)</code> where <code>col</code> is the column sum; and <code>(1 &lt;&lt; (C-1-c))</code> is the power of 2 that each <code>1</code> in that column contributes to the score.</p> \n  <iframe src=\"https://leetcode.com/playground/2SApjxHH/shared\" frameborder=\"0\" width=\"100%\" height=\"276\" name=\"2SApjxHH\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(R * C)</script>, <script type=\"math/tex; mode=display\">R, C</script> is the number of rows and columns in the matrix.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script> in additional space complexity. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 860,
    "article_live": true,
    "article_slug": "lemonade-change",
    "title": "Lemonade Change",
    "title_slug": "lemonade-change",
    "content": "<p>At a lemonade stand, each lemonade costs <code>$5</code>.&nbsp;</p>\r\n\r\n<p>Customers are standing in a queue to buy from you, and order one at a time (in the order specified by <code>bills</code>).</p>\r\n\r\n<p>Each customer will only buy one lemonade and&nbsp;pay with either a <code>$5</code>, <code>$10</code>, or <code>$20</code> bill.&nbsp; You must provide the correct change to each customer, so that the net transaction is that the customer pays $5.</p>\r\n\r\n<p>Note that you don&#39;t have any change&nbsp;in hand at first.</p>\r\n\r\n<p>Return <code>true</code>&nbsp;if and only if you can provide every customer with correct change.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[5,5,5,10,20]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">true</span>\r\n<strong>Explanation: </strong>\r\nFrom the first 3 customers, we collect three $5 bills in order.\r\nFrom the fourth customer, we collect a $10 bill and give back a $5.\r\nFrom the fifth customer, we give a $10 bill and a $5 bill.\r\nSince all customers got correct change, we output true.\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">[5,5,10]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">true</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-3-1\">[10,10]</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">false</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 4:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-4-1\">[5,5,10,10,20]</span>\r\n<strong>Output: </strong><span id=\"example-output-4\">false</span>\r\n<strong>Explanation: </strong>\r\nFrom the first two customers in order, we collect two $5 bills.\r\nFor the next two customers in order, we collect a $10 bill and give back a $5 bill.\r\nFor the last customer, we can't give change of $15 back because we only have two $10 bills.\r\nSince not every customer received correct change, the answer is false.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong><span>Note:</span></strong></p>\r\n\r\n<ul>\r\n\t<li><code>0 &lt;= bills.length &lt;= 10000</code></li>\r\n\t<li><code>bills[i]</code>&nbsp;will be either&nbsp;<code>5</code>, <code>10</code>, or <code>20</code>.</li>\r\n</ul>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n",
    "tags": "Greedy",
    "difficulty": 1,
    "frontend_article_id": 860,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-simulation\">Approach 1: Simulation</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-simulation\">Approach 1: Simulation</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Let's try to simulate giving change to each customer buying lemonade. Initially, we start with no <code>five</code> dollar bills, and no <code>ten</code> dollar bills.</p> \n  <ul> \n   <li> <p>If a customer brings a $5 bill, then we take it.</p> </li> \n   <li> <p>If a customer brings a $10 bill, we must return a five dollar bill. If we don't have a five dollar bill, the answer is <code>False</code>, since we can't make correct change.</p> </li> \n   <li> <p>If a customer brings a $20 bill, we must return $15.</p> \n    <ul> \n     <li> <p>If we have a $10 and a $5, then we always prefer giving change in that, because it is strictly worse for making change than three $5 bills.</p> </li> \n     <li> <p>Otherwise, if we have three $5 bills, then we'll give that.</p> </li> \n     <li> <p>Otherwise, we won't be able to give $15 in change, and the answer is <code>False</code>.</p> </li> \n    </ul> </li> \n  </ul> \n  <iframe src=\"https://leetcode.com/playground/aZ5ofLyL/shared\" frameborder=\"0\" width=\"100%\" height=\"480\" name=\"aZ5ofLyL\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>bills</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 859,
    "article_live": true,
    "article_slug": "buddy-strings",
    "title": "Buddy Strings",
    "title_slug": "buddy-strings",
    "content": "<p>Given two strings <code>A</code> and <code>B</code>&nbsp;of lowercase letters, return <code>true</code> if and only if we&nbsp;can swap two letters in <code>A</code> so that the result equals <code>B</code>.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<div>\r\n<pre>\r\n<strong>Input: </strong>A = <span id=\"example-input-1-1\">&quot;ab&quot;</span>, B = <span id=\"example-input-1-2\">&quot;ba&quot;</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">true</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>A = <span id=\"example-input-2-1\">&quot;ab&quot;</span>, B = <span id=\"example-input-2-2\">&quot;ab&quot;</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">false</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>A = <span id=\"example-input-3-1\">&quot;aa&quot;</span>, B = <span id=\"example-input-3-2\">&quot;aa&quot;</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">true</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 4:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>A = <span id=\"example-input-4-1\">&quot;aaaaaaabc&quot;</span>, B = <span id=\"example-input-4-2\">&quot;aaaaaaacb&quot;</span>\r\n<strong>Output: </strong><span id=\"example-output-4\">true</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 5:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>A = <span id=\"example-input-5-1\">&quot;&quot;</span>, B = <span id=\"example-input-5-2\">&quot;aa&quot;</span>\r\n<strong>Output: </strong><span id=\"example-output-5\">false</span>\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong><span>Note:</span></strong></p>\r\n\r\n<ol>\r\n\t<li><code>0 &lt;= A.length &lt;= 20000</code></li>\r\n\t<li><code>0 &lt;= B.length &lt;= 20000</code></li>\r\n\t<li><code>A</code> and&nbsp;<code>B</code> consist only of lowercase letters.</li>\r\n</ol>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n",
    "tags": "String",
    "difficulty": 1,
    "frontend_article_id": 859,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-enumerate-cases\">Approach 1: Enumerate Cases</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-enumerate-cases\">Approach 1: Enumerate Cases</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Let's say <code>i</code> is <em>matched</em> if <code>A[i] == B[i]</code>, otherwise <code>i</code> is <em>unmatched</em>. A buddy string has almost all matches, because a swap only affects two indices.</p> \n  <p>If swapping <code>A[i]</code> and <code>A[j]</code> would demonstrate that <code>A</code> and <code>B</code> are buddy strings, then <code>A[i] == B[j]</code> and <code>A[j] == B[i]</code>. That means among the four free variables <code>A[i], A[j], B[i], B[j]</code>, there are only two cases: either <code>A[i] == A[j]</code> or not.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Let's work through the cases.</p> \n  <p>In the case <code>A[i] == A[j] == B[i] == B[j]</code>, then the strings <code>A</code> and <code>B</code> are equal. So if <code>A == B</code>, we should check each index <code>i</code> for two matches with the same value.</p> \n  <p>In the case <code>A[i] == B[j], A[j] == B[i], (A[i] != A[j])</code>, the rest of the indices match. So if <code>A</code> and <code>B</code> have only two unmatched indices (say <code>i</code> and <code>j</code>), we should check that the equalities <code>A[i] == B[j]</code> and <code>A[j] == B[i]</code> hold.</p> \n  <iframe src=\"https://leetcode.com/playground/3ce2yPsD/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"3ce2yPsD\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>A</code> and <code>B</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 858,
    "article_live": true,
    "article_slug": "mirror-reflection",
    "title": "Mirror Reflection",
    "title_slug": "mirror-reflection",
    "content": "<p>There is&nbsp;a special square room with mirrors on each of the four&nbsp;walls.&nbsp; Except for the southwest&nbsp;corner, there are receptors on each of the remaining corners, numbered <code>0</code>, <code>1</code>, and <code>2</code>.</p>\r\n\r\n<p>The square room has walls of length <code>p</code>, and a laser ray from the southwest corner&nbsp;first meets the east wall at a distance <code>q</code>&nbsp;from the <code>0</code>th receptor.</p>\r\n\r\n<p>Return the number of the receptor that the ray meets first.&nbsp; (It is guaranteed that the ray will meet&nbsp;a receptor eventually.)</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>p = <span id=\"example-input-1-1\">2</span>, q = <span id=\"example-input-1-2\">1</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">2</span>\r\n<strong>Explanation: </strong>The ray meets receptor 2 the first time it gets reflected back to the left wall.\r\n<p><img alt=\"\" src=\"https://ibb.co/mYSFJT\" /><img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/18/reflection.png\" style=\"width: 218px; height: 217px;\" /></p>\r\n</pre>\r\n\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= p &lt;= 1000</code></li>\r\n\t<li><code>0 &lt;= q &lt;= p</code></li>\r\n</ol>\r\n</div>\r\n",
    "tags": "Math",
    "difficulty": 2,
    "frontend_article_id": 858,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-simulation\">Approach 1: Simulation</a></li> \n      <li><a href=\"#approach-2-mathematical\">Approach 2: Mathematical</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-simulation\">Approach 1: Simulation</h4> \n  <p><strong>Intuition</strong></p> \n  <p>The initial ray can be described as going from an origin <code>(x, y) = (0, 0)</code> in the direction <code>(rx, ry) = (p, q)</code>. From this, we can figure out which wall it will meet and where, and what the appropriate new ray will be (based on reflection.) We keep simulating the ray until it finds it's destination.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>The parameterized position of the laser after time <code>t</code> will be <code>(x + rx * t, y + ry * t)</code>. From there, we know when it will meet the east wall (if <code>x + rx * t == p</code>), and so on. For a positive (and nonnegligible) time <code>t</code>, it meets the next wall.</p> \n  <p>We can then calculate how the ray reflects. If it hits an east or west wall, then <code>rx *= -1</code>, else <code>ry *= -1</code>.</p> \n  <p>In Java, care must be taken with floating point operations.</p> \n  <iframe src=\"https://leetcode.com/playground/Ds4FZeYo/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"Ds4FZeYo\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(p)</script>. We can prove (using <em>Approach #2</em>) that the number of bounces is bounded by this.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-mathematical\">Approach 2: Mathematical</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Instead of modelling the ray as a bouncing line, model it as a straight line through reflections of the room.</p> \n  <p>For example, if <code>p = 2, q = 1</code>, then we can reflect the room horizontally, and draw a straight line from <code>(0, 0)</code> to <code>(4, 2)</code>. The ray meets the receptor <code>2</code>, which was reflected from <code>(0, 2)</code> to <code>(4, 2)</code>.</p> \n  <p>In general, the ray goes to the first integer point <code>(kp, kq)</code> where <code>k</code> is an integer, and <code>kp</code> and <code>kq</code> are multiples of <code>p</code>. Thus, the goal is just to find the smallest <code>k</code> for which <code>kq</code> is a multiple of <code>p</code>.</p> \n  <p>The mathematical answer is <code>k = p / gcd(p, q)</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/srjkydcW/shared\" frameborder=\"0\" width=\"100%\" height=\"327\" name=\"srjkydcW\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(\\log P)</script>, the complexity of the <code>gcd</code> operation.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 857,
    "article_live": true,
    "article_slug": "minimum-cost-to-hire-k-workers",
    "title": "Minimum Cost to Hire K Workers",
    "title_slug": "minimum-cost-to-hire-k-workers",
    "content": "<p>There are <code>N</code> workers.&nbsp; The <code>i</code>-th worker has a <code>quality[i]</code> and a minimum wage expectation <code>wage[i]</code>.</p>\r\n\r\n<p>Now we want to hire exactly <code>K</code>&nbsp;workers to form a <em>paid group</em>.&nbsp; When hiring a group of K workers, we must pay them according to the following rules:</p>\r\n\r\n<ol>\r\n\t<li>Every worker in the paid group should be paid in the ratio of their quality compared to other workers in the paid group.</li>\r\n\t<li>Every worker in the paid group must be paid at least their minimum wage expectation.</li>\r\n</ol>\r\n\r\n<p>Return the least amount of money needed to form a paid group satisfying the above conditions.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<ol>\r\n</ol>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>quality = <span id=\"example-input-1-1\">[10,20,5]</span>, wage = <span id=\"example-input-1-2\">[70,50,30]</span>, K = <span id=\"example-input-1-3\">2</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">105.00000\r\n<strong>Explanation</strong>: </span><span>We pay 70 to 0-th worker and 35 to 2-th worker.</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>quality = <span id=\"example-input-2-1\">[3,1,10,10,1]</span>, wage = <span id=\"example-input-2-2\">[4,8,2,2,7]</span>, K = <span id=\"example-input-2-3\">3</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">30.66667\r\n<strong>Explanation</strong>: </span><span>We pay 4 to 0-th worker, 13.33333 to 2-th and 3-th workers seperately.</span> \r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= K &lt;= N &lt;= 10000</code>, where <code>N = quality.length = wage.length</code></li>\r\n\t<li><code>1 &lt;= quality[i] &lt;= 10000</code></li>\r\n\t<li><code>1 &lt;= wage[i] &lt;= 10000</code></li>\r\n\t<li>Answers within <code>10^-5</code> of the correct answer will be considered correct.</li>\r\n</ol>\r\n</div>\r\n</div>\r\n",
    "tags": "Heap",
    "difficulty": 3,
    "frontend_article_id": 857,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-greedy\">Approach 1: Greedy</a></li> \n      <li><a href=\"#approach-2-heap\">Approach 2: Heap</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-greedy\">Approach 1: Greedy</h4> \n  <p><strong>Intuition</strong></p> \n  <p>At least one worker will be paid their minimum wage expectation. If not, we could scale all payments down by some factor and still keep everyone earning more than their wage expectation.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>For each <code>captain</code> worker that will be paid their minimum wage expectation, let's calculate the cost of hiring K workers where each point of quality is worth <code>wage[captain] / quality[captain]</code> dollars. With this approach, the remaining implementation is straightforward.</p> \n  <p>Note that this algorithm would not be efficient enough to pass larger test cases.</p> \n  <iframe src=\"https://leetcode.com/playground/6wfBasLL/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"6wfBasLL\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2 \\log N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of workers.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-heap\">Approach 2: Heap</h4> \n  <p><strong>Intuition</strong></p> \n  <p>As in <em>Approach #1</em>, at least one worker is paid their minimum wage expectation.</p> \n  <p>Additionally, every worker has some minimum <code>ratio</code> of dollars to quality that they demand. For example, if <code>wage[0] = 100</code> and <code>quality[0] = 20</code>, then the <code>ratio</code> for worker 0 is <code>5.0</code>.</p> \n  <p>The key insight is to iterate over the ratio. Let's say we hire workers with a ratio <code>R</code> or lower. Then, we would want to know the <code>K</code> workers with the lowest quality, and the sum of that quality. We can use a heap to maintain these variables.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Maintain a max heap of quality. (We're using a minheap, with negative values.) We'll also maintain <code>sumq</code>, the sum of this heap.</p> \n  <p>For each worker in order of ratio, we know all currently considered workers have lower ratio. (This worker will be the 'captain', as described in <em>Approach #1</em>.) We calculate the candidate answer as this ratio times the sum of the smallest K workers in quality.</p> \n  <iframe src=\"https://leetcode.com/playground/KRXJr8dq/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"KRXJr8dq\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N \\log N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of workers.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 856,
    "article_live": true,
    "article_slug": "score-of-parentheses",
    "title": "Score of Parentheses",
    "title_slug": "score-of-parentheses",
    "content": "<p>Given a balanced parentheses string <code>S</code>, compute the score of the string based on the following rule:</p>\r\n\r\n<ul>\r\n\t<li><code>()</code> has score 1</li>\r\n\t<li><code>AB</code> has score <code>A + B</code>, where A and B are balanced parentheses strings.</li>\r\n\t<li><code>(A)</code> has score <code>2 * A</code>, where A is a balanced parentheses string.</li>\r\n</ul>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">&quot;()&quot;</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">1</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">&quot;(())&quot;</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">2</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-3-1\">&quot;()()&quot;</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">2</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 4:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-4-1\">&quot;(()(()))&quot;</span>\r\n<strong>Output: </strong><span id=\"example-output-4\">6</span>\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>S</code> is a balanced parentheses string, containing only <code>(</code> and <code>)</code>.</li>\r\n\t<li><code>2 &lt;= S.length &lt;= 50</code></li>\r\n</ol>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n",
    "tags": "String, Stack",
    "difficulty": 2,
    "frontend_article_id": 856,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-divide-and-conquer\">Approach 1: Divide and Conquer</a></li> \n      <li><a href=\"#approach-2-stack\">Approach 2: Stack</a></li> \n      <li><a href=\"#approach-3-count-cores\">Approach 3: Count Cores</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-divide-and-conquer\">Approach 1: Divide and Conquer</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Split the string into <code>S = A + B</code> where <code>A</code> and <code>B</code> are balanced parentheses strings, and <code>A</code> is the smallest possible non-empty prefix of <code>S</code>.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Call a balanced string <em>primitive</em> if it cannot be partitioned into two non-empty balanced strings.</p> \n  <p>By keeping track of <code>balance</code> (the number of <code>(</code> parentheses minus the number of <code>)</code> parentheses), we can partition <code>S</code> into primitive substrings <code>S = P_1 + P_2 + ... + P_n</code>. Then, <code>score(S) = score(P_1) + score(P_2) + ... + score(P_n)</code>, by definition.</p> \n  <p>For each primitive substring <code>(S[i], S[i+1], ..., S[k])</code>, if the string is length 2, then the score of this string is 1. Otherwise, it's twice the score of the substring <code>(S[i+1], S[i+2], ..., S[k-1])</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/9n8zxSrk/shared\" frameborder=\"0\" width=\"100%\" height=\"446\" name=\"9n8zxSrk\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>S</code>. An example worst case is <code>(((((((....)))))))</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the size of the implied call stack. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-stack\">Approach 2: Stack</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Every position in the string has a <em>depth</em> - some number of matching parentheses surrounding it. For example, the dot in <code>(()(.()))</code> has depth 2, because of these parentheses: <code>(__(.__))</code></p> \n  <p>Our goal is to maintain the score at the current depth we are on. When we see an opening bracket, we increase our depth, and our score at the new depth is 0. When we see a closing bracket, we add twice the score of the previous deeper part - except when counting <code>()</code>, which has a score of 1.</p> \n  <p>For example, when counting <code>(()(()))</code>, our stack will look like this:</p> \n  <ul> \n   <li><code>[0, 0]</code> after parsing <code>(</code></li> \n   <li><code>[0, 0, 0]</code> after <code>(</code></li> \n   <li><code>[0, 1]</code> after <code>)</code></li> \n   <li><code>[0, 1, 0]</code> after <code>(</code></li> \n   <li><code>[0, 1, 0, 0]</code> after <code>(</code></li> \n   <li><code>[0, 1, 1]</code> after <code>)</code></li> \n   <li><code>[0, 3]</code> after <code>)</code></li> \n   <li><code>[6]</code> after <code>)</code></li> \n  </ul> \n  <iframe src=\"https://leetcode.com/playground/C2ky8oiW/shared\" frameborder=\"0\" width=\"100%\" height=\"327\" name=\"C2ky8oiW\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>S</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the size of the stack. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-count-cores\">Approach 3: Count Cores</h4> \n  <p><strong>Intuition</strong></p> \n  <p>The final sum will be a sum of powers of 2, as every <em>core</em> (a substring <code>()</code>, with score 1) will have it's score multiplied by 2 for each exterior set of parentheses that contains that core.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Keep track of the <code>balance</code> of the string, as defined in <em>Approach #1</em>. For every <code>)</code> that immediately follows a <code>(</code>, the answer is <code>1 &lt;&lt; balance</code>, as <code>balance</code> is the number of exterior set of parentheses that contains this core.</p> \n  <iframe src=\"https://leetcode.com/playground/EUsmNAS5/shared\" frameborder=\"0\" width=\"100%\" height=\"344\" name=\"EUsmNAS5\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>S</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 855,
    "article_live": true,
    "article_slug": "exam-room",
    "title": "Exam Room",
    "title_slug": "exam-room",
    "content": "<p>In an exam room, there are <code>N</code> seats in a single row, numbered <code>0, 1, 2, ..., N-1</code>.</p>\r\n\r\n<p>When a student enters the room, they must sit in the seat that maximizes the distance to the closest person.&nbsp; If there are multiple such seats, they sit in the seat with the lowest number.&nbsp; (Also, if no one is in the room, then the student sits at seat number 0.)</p>\r\n\r\n<p>Return a class <code>ExamRoom(int N)</code>&nbsp;that exposes two functions: <code>ExamRoom.seat()</code>&nbsp;returning an <code>int</code>&nbsp;representing what seat the student sat in, and <code>ExamRoom.leave(int p)</code>&nbsp;representing that the student in seat number <code>p</code>&nbsp;now leaves the room.&nbsp; It is guaranteed that any calls to <code>ExamRoom.leave(p)</code> have a student sitting in seat <code>p</code>.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[&quot;ExamRoom&quot;,&quot;seat&quot;,&quot;seat&quot;,&quot;seat&quot;,&quot;seat&quot;,&quot;leave&quot;,&quot;seat&quot;]</span>, <span id=\"example-input-1-2\">[[10],[],[],[],[],[4],[]]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">[null,0,9,4,2,null,5]</span>\r\n<span><strong>Explanation</strong>:\r\nExamRoom(10) -&gt; null\r\nseat() -&gt; 0, no one is in the room, then the student sits at seat number 0.\r\nseat() -&gt; 9, the student sits at the last seat number 9.\r\nseat() -&gt; 4, the student sits at the last seat number 4.\r\nseat() -&gt; 2, the student sits at the last seat number 2.\r\nleave(4) -&gt; null\r\nseat() -&gt; 5, the student sits at the last seat number 5.</span>\r\n</pre>\r\n\r\n<p><span>​​​​​​​</span></p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= N &lt;= 10^9</code></li>\r\n\t<li><code>ExamRoom.seat()</code> and <code>ExamRoom.leave()</code> will be called at most <code>10^4</code> times across all test cases.</li>\r\n\t<li>Calls to <code>ExamRoom.leave(p)</code> are guaranteed to have a student currently sitting in seat number <code>p</code>.</li>\r\n</ol>\r\n",
    "tags": "Map",
    "difficulty": 2,
    "frontend_article_id": 855,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-maintain-sorted-positions\">Approach 1: Maintain Sorted Positions</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-maintain-sorted-positions\">Approach 1: Maintain Sorted Positions</h4> \n  <p><strong>Intuition</strong></p> \n  <p>We'll maintain <code>ExamRoom.students</code>, a sorted <code>list</code> (or <code>TreeSet</code> in Java) of positions the students are currently seated in.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>The <code>ExamRoom.leave(p)</code> operation is clear - we will just <code>list.remove</code> (or <code>TreeSet.remove</code>) the student from <code>ExamRoom.students</code>.</p> \n  <p>Let's focus on the <code>ExamRoom.seat() : int</code> operation. For each pair of adjacent students <code>i</code> and <code>j</code>, the maximum distance to the closest student is <code>d = (j - i) / 2</code>, achieved in the left-most seat <code>i + d</code>. Otherwise, we could also sit in the left-most seat, or the right-most seat.</p> \n  <p>Finally, we should handle the case when there are no students separately.</p> \n  <p>For more details, please review the comments made in the implementations.</p> \n  <iframe src=\"https://leetcode.com/playground/9bZc2mLh/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"9bZc2mLh\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: Each <code>seat</code> operation is <script type=\"math/tex; mode=display\">O(P)</script>, (where <script type=\"math/tex; mode=display\">P</script> is the number of students sitting), as we iterate through every student. Each <code>leave</code> operation is <script type=\"math/tex; mode=display\">O(P)</script> (<script type=\"math/tex; mode=display\">\\log P</script> in Java).</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(P)</script>, the space used to store the positions of each student sitting.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 854,
    "article_live": true,
    "article_slug": "k-similar-strings",
    "title": "K-Similar Strings",
    "title_slug": "k-similar-strings",
    "content": "<p>Strings&nbsp;<code>A</code> and <code>B</code> are <code>K</code>-similar (for some non-negative integer <code>K</code>) if we can swap the positions of two letters in <code>A</code> exactly <code>K</code>&nbsp;times so that the resulting string equals <code>B</code>.</p>\r\n\r\n<p>Given two anagrams <code>A</code> and <code>B</code>, return the smallest <code>K</code>&nbsp;for which <code>A</code> and <code>B</code> are <code>K</code>-similar.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>A = <span id=\"example-input-1-1\">&quot;ab&quot;</span>, B = <span id=\"example-input-1-2\">&quot;ba&quot;</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">1</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>A = <span id=\"example-input-2-1\">&quot;abc&quot;</span>, B = <span id=\"example-input-2-2\">&quot;bca&quot;</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">2</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>A = <span id=\"example-input-3-1\">&quot;abac&quot;</span>, B = <span id=\"example-input-3-2\">&quot;baca&quot;</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">2</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 4:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>A = <span id=\"example-input-4-1\">&quot;aabc&quot;</span>, B = <span id=\"example-input-4-2\">&quot;abca&quot;</span>\r\n<strong>Output: </strong><span id=\"example-output-4\">2</span></pre>\r\n</div>\r\n</div>\r\n</div>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= A.length == B.length &lt;= 20</code></li>\r\n\t<li><code>A</code> and <code>B</code> contain only lowercase letters from the set <code>{&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;}</code></li>\r\n</ol>\r\n",
    "tags": "Breadth-first Search, Graph",
    "difficulty": 3,
    "frontend_article_id": 854,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-framework\">Approach Framework</a></li> \n      <li><a href=\"#approach-1-brute-force-with-dynamic-programming\">Approach 1: Brute Force with Dynamic Programming</a></li> \n      <li><a href=\"#approach-2-pruned-breadth-first-search\">Approach 2: Pruned Breadth First Search</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-framework\">Approach Framework</h4> \n  <p><strong>Explanation</strong></p> \n  <p>We'll call the <em>underlying graph</em> of the problem, the graph with 6 nodes <code>'a', 'b', ..., 'f'</code> and the edges <code>A[i] -&gt; B[i]</code>. Our goal is for this graph to have only self-edges (edges of the form <code>a -&gt; a</code>.) Let's make some deductions about how swaps between <code>A[i]</code> and <code>A[j]</code> affect this graph, and the nature of optimal swap schedules.</p> \n  <p>If <code>A = 'ca...'</code> and <code>B = 'ab...'</code>, then the first two edges of the underlying graph are <code>c -&gt; a</code> and <code>a -&gt; b</code>; and a swap between <code>A[1]</code> and <code>A[0]</code> changes these two edges to the single edge <code>c -&gt; b</code>. Let's call this type of operation <em>'cutting corners'</em>. Intuitively, our optimal swap schedule always increases the number of matches (<code>A[i] == B[i]</code>s) for each swap, so cutting corners is the only type of operation we need to consider. (This is essentially the <em>happy swap assumption</em>, proved in <a href=\"https://leetcode.com/articles/couples-holding-hands/\">765 - Couples Holding Hands</a>)</p> \n  <p>Now consider any cycle decomposition of the underlying graph. [This decomposition (or the number of cycles), is not necessarily unique.] Through operations of cutting corners, we'll delete all the (non-self) edges. Each cycle of length <code>k</code> requires <code>k-1</code> operations to delete. Thus, the answer is just the minimum possible value of <script type=\"math/tex; mode=display\">\\sum (C_k - 1)</script>, where <script type=\"math/tex; mode=display\">C_1, \\cdots C_k</script> are the lengths of the cycles in some cycle decomposition of the underlying graph. This can be re-written as <script type=\"math/tex; mode=display\">\\text{(Number of non-self edges)} - \\text{(Number of cycles)}</script>. Hence, we want to maximize the number of cycles in a cycle decomposition of the underlying graph. <br> <br></p> \n  <hr> \n  <h4 id=\"approach-1-brute-force-with-dynamic-programming\">Approach 1: Brute Force with Dynamic Programming</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Let <script type=\"math/tex; mode=display\">P_1, P_2, \\cdots</script> be possible cycles of the underlying graph <script type=\"math/tex; mode=display\">G</script>. Let's attempt to write <script type=\"math/tex; mode=display\">G = \\sum k_i P_i</script> for some constants <script type=\"math/tex; mode=display\">k_i</script>. Then, the number of cycles is <script type=\"math/tex; mode=display\">\\sum k_i</script>.</p> \n  <p>We can represent <script type=\"math/tex; mode=display\">G</script> and <script type=\"math/tex; mode=display\">P_i</script> as the number of directed edges from node <script type=\"math/tex; mode=display\">X</script> to <script type=\"math/tex; mode=display\">Y</script>. For example, if <script type=\"math/tex; mode=display\">P_1</script> is the cycle <code>a -&gt; b -&gt; d -&gt; e -&gt; a</code>, then <script type=\"math/tex; mode=display\">P_1</script> is <code>a -&gt; b</code> plus <code>b -&gt; d</code> plus <code>d -&gt; e</code> plus <code>e -&gt; a</code>. This can be represented as a column vector <code>possibles[0]</code> of 1s and 0s, with four 1s, (each <code>possibles[0][i] == 1</code> represents the <code>i</code>th directed edge being there [and having quantity 1]). Similarly, the graph <script type=\"math/tex; mode=display\">G</script> can also be represented as a column vector.</p> \n  <p>This sets the stage for dynamic programming. For each graph <script type=\"math/tex; mode=display\">G</script>, represented as a column vector, say we want to find <code>numCycles(G)</code>. We can take all possible cycles <script type=\"math/tex; mode=display\">C</script>, and check if <script type=\"math/tex; mode=display\">G</script> contains <script type=\"math/tex; mode=display\">C</script>. If it does, then a candidate answer is <code>1 + numCycles(G - C)</code>.</p> \n  <p>It should also be noted that maximizing the number of cycles cannot be done in a greedy way, ie. by always removing the lowest size cycle. For example, consider the graph with edges <code>a -&gt; b -&gt; c -&gt; a</code>, <code>b -&gt; d -&gt; e -&gt; b</code>, and <code>c -&gt; e -&gt; f -&gt; c</code>. Those form cycles, and there is a fourth 3-cycle <code>b -&gt; c -&gt; e -&gt; b</code>. If we remove that cycle first, then we would have only two cycles; but if we remove the first 3 cycles, then we would have three cycles.</p> \n  <iframe src=\"https://leetcode.com/playground/DxeyqwKV/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"DxeyqwKV\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(2^{N+W})</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of the string, and <script type=\"math/tex; mode=display\">W</script> is the length of the alphabet.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(2^{N+W})</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-pruned-breadth-first-search\">Approach 2: Pruned Breadth First Search</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Based on the <em>underlying graph</em> interpretation of the problem, we can prove that an optimal solution swaps the left-most unmatched character <code>A[i]</code> with an appropriate match <code>A[j] == B[i] (j &gt; i)</code>.</p> \n  <p>This reduces the number of \"neighbors\" of a node (string state) from <script type=\"math/tex; mode=display\">O(N^2)</script> to <script type=\"math/tex; mode=display\">O(N)</script>, but it also focuses our search greatly. Each node searched with <code>k</code> matches, will have at most <script type=\"math/tex; mode=display\">2^k</script> swaps on the unmatched characters. This leads to <script type=\"math/tex; mode=display\">\\sum_k \\binom{N}{k} 2^k = 3^N</script> checked states. Furthermore, some characters are the same, so we must divide the number of states by approximate factors of <script type=\"math/tex; mode=display\">\\prod (N_i)!</script> [where <script type=\"math/tex; mode=display\">N_i</script> is the number of occurrences of the <script type=\"math/tex; mode=display\">i</script>th character in <code>A</code>.] With <script type=\"math/tex; mode=display\">N \\leq 20</script>, this means the number of states will be small.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>We'll perform a regular breadth-first search. The neighbors to each node string <code>S</code> are all the strings reachable with 1 swap, that match the first unmatched character in <code>S</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/DrKKrcmp/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"DrKKrcmp\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(\\sum_{k=0}^n \\binom{N}{k} \\frac{\\min(2^k, (N-k)!)}{W * (\\frac{N-k}{W})!})</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of the string, and <script type=\"math/tex; mode=display\">W</script> is the length of the alphabet.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N * t)</script>, where <script type=\"math/tex; mode=display\">t</script> is the time complexity given above. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>. Idea for Solution #2 by <a href=\"https://leetcode.com/laiden\">@laiden</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 853,
    "article_live": true,
    "article_slug": "car-fleet",
    "title": "Car Fleet",
    "title_slug": "car-fleet",
    "content": "<p><code>N</code> cars are going to the same destination along a one lane road.&nbsp; The destination is <code>target</code>&nbsp;miles away.</p>\r\n\r\n<p>Each car <code>i</code>&nbsp;has a constant speed <code>speed[i]</code>&nbsp;(in miles per hour), and initial position <code>position[i]</code>&nbsp;miles towards the target along the road.</p>\r\n\r\n<p>A car can never pass another car ahead of it, but it can catch up to it, and drive bumper to bumper at the same speed.</p>\r\n\r\n<p>The distance between these two cars is ignored - they are assumed to have the same position.</p>\r\n\r\n<p>A <em>car fleet</em> is some non-empty set of cars driving&nbsp;at the same position and same speed.&nbsp; Note that a single car is also a car fleet.</p>\r\n\r\n<p>If a car catches up to a car fleet right at the destination point, it will&nbsp;still be&nbsp;considered as one car fleet.</p>\r\n\r\n<p><br />\r\nHow many car fleets will arrive at the destination?</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>target = <span id=\"example-input-1-1\">12</span>, position = <span id=\"example-input-1-2\">[10,8,0,5,3]</span>, speed = <span id=\"example-input-1-3\">[2,4,1,1,3]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">3</span>\r\n<strong>Explanation</strong>:\r\nThe cars starting at 10 and 8 become a fleet, meeting each other at 12.\r\nThe car starting at 0 doesn&#39;t catch up to any other car, so it is a fleet by itself.\r\nThe cars starting at 5 and 3 become a fleet, meeting each other at 6.\r\nNote that no other cars meet these fleets before the destination, so the answer is 3.\r\n</pre>\r\n\r\n<p><br />\r\n<strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>0 &lt;= N &lt;= 10 ^ 4</code></li>\r\n\t<li><code>0 &lt; target&nbsp;&lt;= 10 ^ 6</code></li>\r\n\t<li><code>0 &lt;&nbsp;speed[i] &lt;= 10 ^ 6</code></li>\r\n\t<li><code>0 &lt;= position[i] &lt; target</code></li>\r\n\t<li>All initial positions are different.</li>\r\n</ol>\r\n",
    "tags": "Stack",
    "difficulty": 2,
    "frontend_article_id": 853,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-stack\">Approach 1: Stack</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-stack\">Approach 1: Stack</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Call the \"lead fleet\" the fleet furthest in position.</p> \n  <p>If the car <code>S</code> (Second) behind the lead car <code>F</code> (First) would arrive earlier, then <code>S</code> forms a fleet with the lead car <code>F</code>. Otherwise, fleet <code>F</code> is final as no car can catch up to it - cars behind <code>S</code> would form fleets with <code>S</code>, never <code>F</code>.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>A car is a <code>(position, speed)</code> which implies some arrival time <code>(target - position) / speed</code>. Sort the cars by position.</p> \n  <p>Now apply the above reasoning - if the lead fleet drives away, then count it and continue. Otherwise, merge the fleets and continue.</p> \n  <iframe src=\"https://leetcode.com/playground/6mGXPSfM/shared\" frameborder=\"0\" width=\"100%\" height=\"497\" name=\"6mGXPSfM\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N \\log N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of cars. The complexity is dominated by the sorting operation.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the space used to store information about the cars.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 852,
    "article_live": true,
    "article_slug": "peak-index-in-a-mountain-array",
    "title": "Peak Index in a Mountain Array",
    "title_slug": "peak-index-in-a-mountain-array",
    "content": "<p>Let&#39;s call an array <code>A</code> a <em>mountain</em>&nbsp;if the following properties hold:</p>\r\n\r\n<ul>\r\n\t<li><code>A.length &gt;= 3</code></li>\r\n\t<li>There exists some <code>0 &lt; i&nbsp;&lt; A.length - 1</code> such that <code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</code></li>\r\n</ul>\r\n\r\n<p>Given an array that is definitely a mountain, return any&nbsp;<code>i</code>&nbsp;such that&nbsp;<code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</code>.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[0,1,0]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">1</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">[0,2,1,0]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">1</span></pre>\r\n</div>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>3 &lt;= A.length &lt;= 10000</code></li>\r\n\t<li><code><font face=\"monospace\">0 &lt;= A[i] &lt;= 10^6</font></code></li>\r\n\t<li>A&nbsp;is a mountain, as defined above.</li>\r\n</ol>\r\n",
    "tags": "Binary Search",
    "difficulty": 1,
    "frontend_article_id": 852,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-linear-scan\">Approach 1: Linear Scan</a></li> \n    <li><a href=\"#approach-2-binary-search\">Approach 2: Binary Search</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-linear-scan\">Approach 1: Linear Scan</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>The mountain increases until it doesn't. The point at which it stops increasing is the peak.</p> \n  <iframe src=\"https://leetcode.com/playground/wnFAmS4Z/shared\" frameborder=\"0\" width=\"100%\" height=\"174\" name=\"wnFAmS4Z\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>A</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-binary-search\">Approach 2: Binary Search</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>The comparison <code>A[i] &lt; A[i+1]</code> in a mountain array looks like <code>[True, True, True, ..., True, False, False, ..., False]</code>: 1 or more boolean <code>True</code>s, followed by 1 or more boolean <code>False</code>. For example, in the mountain array <code>[1, 2, 3, 4, 1]</code>, the comparisons <code>A[i] &lt; A[i+1]</code> would be <code>True, True, True, False</code>.</p> \n  <p>We can binary search over this array of comparisons, to find the largest index <code>i</code> such that <code>A[i] &lt; A[i+1]</code>. For more on <em>binary search</em>, see the <a href=\"https://leetcode.com/explore/learn/card/binary-search/\">LeetCode explore topic here.</a></p> \n  <iframe src=\"https://leetcode.com/playground/FoZ3SCRk/shared\" frameborder=\"0\" width=\"100%\" height=\"276\" name=\"FoZ3SCRk\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(\\log N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>A</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 851,
    "article_live": true,
    "article_slug": "loud-and-rich",
    "title": "Loud and Rich",
    "title_slug": "loud-and-rich",
    "content": "<p>In a group of N people (labelled <code>0, 1, 2, ..., N-1</code>), each person has different amounts of money, and different levels of quietness.</p>\r\n\r\n<p>For convenience, we&#39;ll call the person with label <code>x</code>, simply &quot;person <code>x</code>&quot;.</p>\r\n\r\n<p>We&#39;ll say that <code>richer[i] = [x, y]</code> if person <code>x</code>&nbsp;definitely has more money than person&nbsp;<code>y</code>.&nbsp; Note that <code>richer</code>&nbsp;may only be a subset of valid observations.</p>\r\n\r\n<p>Also, we&#39;ll say <code>quiet[x] = q</code> if person <font face=\"monospace\">x</font>&nbsp;has quietness <code>q</code>.</p>\r\n\r\n<p>Now, return <code>answer</code>, where <code>answer[x] = y</code> if <code>y</code> is the least quiet person (that is, the person <code>y</code> with the smallest value of <code>quiet[y]</code>), among all people&nbsp;who definitely have&nbsp;equal to or more money than person <code>x</code>.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>richer = <span id=\"example-input-1-1\">[[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]]</span>, quiet = <span id=\"example-input-1-2\">[3,2,5,4,6,1,7,0]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">[5,5,2,5,4,5,6,7]</span>\r\n<strong>Explanation: </strong>\r\nanswer[0] = 5.\r\nPerson 5 has more money than 3, which has more money than 1, which has more money than 0.\r\nThe only person who is quieter (has lower quiet[x]) is person 7, but\r\nit isn&#39;t clear if they have more money than person 0.\r\n\r\nanswer[7] = 7.\r\nAmong all people that definitely have equal to or more money than person 7\r\n(which could be persons 3, 4, 5, 6, or 7), the person who is the quietest (has lower quiet[x])\r\nis person 7.\r\n\r\nThe other answers can be filled out with similar reasoning.\r\n</pre>\r\n</div>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= quiet.length = N &lt;= 500</code></li>\r\n\t<li><code>0 &lt;= quiet[i] &lt; N</code>, all <code>quiet[i]</code> are different.</li>\r\n\t<li><code>0 &lt;= richer.length &lt;= N * (N-1) / 2</code></li>\r\n\t<li><code>0 &lt;= richer[i][j] &lt; N</code></li>\r\n\t<li><code>richer[i][0] != richer[i][1]</code></li>\r\n\t<li><code>richer[i]</code>&#39;s are all different.</li>\r\n\t<li>The&nbsp;observations in <code>richer</code> are all logically consistent.</li>\r\n</ol>\r\n",
    "tags": "Depth-first Search",
    "difficulty": 2,
    "frontend_article_id": 851,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-cached-depth-first-search-accepted\">Approach #1: Cached Depth-First Search [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-cached-depth-first-search-accepted\">Approach #1: Cached Depth-First Search [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Consider the directed graph with edge <code>x -&gt; y</code> if <code>y</code> is richer than <code>x</code>.</p> \n  <p>For each person <code>x</code>, we want the quietest person in the subtree at <code>x</code>.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Construct the graph described above, and say <code>dfs(person)</code> is the quietest person in the subtree at <code>person</code>. Notice because the statements are logically consistent, the graph must be a DAG - a directed graph with no cycles.</p> \n  <p>Now <code>dfs(person)</code> is either <code>person</code>, or <code>min(dfs(child) for child in person)</code>. That is to say, the quietest person in the subtree is either the <code>person</code> itself, or the quietest person in some subtree of a child of <code>person</code>.</p> \n  <p>We can cache values of <code>dfs(person)</code> as <code>answer[person]</code>, when performing our <em>post-order traversal</em> of the graph. That way, we don't repeat work. This technique reduces a quadratic time algorithm down to linear time.</p> \n  <iframe src=\"https://leetcode.com/playground/uMRUYCdD/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"uMRUYCdD\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of people.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the space used by the <code>answer</code>, and the implicit call stack of <code>dfs</code>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 850,
    "article_live": true,
    "article_slug": "rectangle-area-ii",
    "title": "Rectangle Area II",
    "title_slug": "rectangle-area-ii",
    "content": "<p>We are given a list of (axis-aligned)&nbsp;<code>rectangles</code>.&nbsp; Each&nbsp;<code>rectangle[i] = [x1, y1, x2, y2]&nbsp;</code>, where (x1, y1) are the coordinates of the bottom-left corner, and (x2, y2) are the coordinates of the top-right corner of the <code>i</code>th rectangle.</p>\r\n\r\n<p>Find the total area covered by all <code>rectangles</code> in the plane.&nbsp; Since the answer&nbsp;may be too large, <strong>return it modulo 10^9 + 7</strong>.</p>\r\n\r\n<p><img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/06/rectangle_area_ii_pic.png\" style=\"width: 480px; height: 360px;\" /></p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>[[0,0,2,2],[1,0,2,3],[1,0,3,1]]\r\n<strong>Output: </strong>6\r\n<strong>Explanation: </strong>As illustrated in the picture.\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>[[0,0,1000000000,1000000000]]\r\n<strong>Output: </strong>49\r\n<strong>Explanation: </strong>The answer is 10^18 modulo (10^9 + 7), which is (10^9)^2 = (-7)^2 = 49.\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= rectangles.length &lt;= 200</code></li>\r\n\t<li><code><font face=\"monospace\">rectanges[i].length = 4</font></code></li>\r\n\t<li><code>0 &lt;= rectangles[i][j] &lt;= 10^9</code></li>\r\n\t<li>The total area covered by all rectangles will never exceed&nbsp;<code>2^63 - 1</code>&nbsp;and thus will fit in a 64-bit signed integer.</li>\r\n</ul>\r\n",
    "tags": "Segment Tree",
    "difficulty": 3,
    "frontend_article_id": 850,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-principle-of-inclusion-exclusion\">Approach #1: Principle of Inclusion-Exclusion</a></li> \n      <li><a href=\"#approach-2-coordinate-compression\">Approach #2: Coordinate Compression</a></li> \n      <li><a href=\"#approach-3-line-sweep\">Approach #3: Line Sweep</a></li> \n      <li><a href=\"#approach-4-segment-tree\">Approach #4: Segment Tree</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-principle-of-inclusion-exclusion\">Approach #1: Principle of Inclusion-Exclusion</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Say we have two rectangles, <script type=\"math/tex; mode=display\">A</script> and <script type=\"math/tex; mode=display\">B</script>. The area of their union is:</p> \n  <p> <script type=\"math/tex; mode=display\">\n|A \\cup B| = |A| + |B| - |A \\cap B|\n</script> </p> \n  <p>Say we have three rectangles, <script type=\"math/tex; mode=display\">A, B, C</script>. The area of their union is:</p> \n  <p> <script type=\"math/tex; mode=display\">\n|A \\cup B \\cup C| = |A| + |B| + |C| - |A \\cap B| - |A \\cap C| - |B \\cap C| + |A \\cap B \\cap C|\n</script> </p> \n  <p>This can be seen by drawing a Venn diagram.</p> \n  <p>Say we have four rectangles, <script type=\"math/tex; mode=display\">A, B, C, D</script>. The area of their union is:</p> \n  <p> <script type=\"math/tex; mode=display\">\n\\begin{align}\n|A \\cup B \\cup C \\cup D| =\\,&\\left( |A| + |B| + |C| + |D| \\right) - \\\\\n\\,&\\left(|A \\cap B| + |A \\cap C| + |A \\cap D| + |B \\cap C| + |B \\cap D| + |C \\cap D|\\right) +\\\\\n\\,&\\left(|A \\cap B \\cap C| + |A \\cap B \\cap D| + |A \\cap C \\cap D| + |B \\cap C \\cap D|\\right) -\\\\\n\\,&\\left(|A \\cap B \\cap C \\cap D|\\right)\n\\end{align}\n</script> </p> \n  <p>In general, the area of the union of <script type=\"math/tex; mode=display\">n</script> rectangles <script type=\"math/tex; mode=display\">A_1, A_2, \\cdots , A_n</script> will be:</p> \n  <p> <script type=\"math/tex; mode=display\">\n\\bigg|\\bigcup_{i=1}^n A_i\\bigg| = \\sum_{\\emptyset \\neq S \\subseteq [n]} (-1)^{|S| + 1} \\bigg| \\bigcap_{i \\in S} A_i \\bigg|\n</script> </p> \n  <p><strong>Algorithm</strong></p> \n  <p>If we do not know the above fact, we can prove it by considering any point in <script type=\"math/tex; mode=display\">\\bigg|\\bigcup_{i=1}^n A_i\\bigg|</script>. Say this point occurs in all <script type=\"math/tex; mode=display\">A_i (i \\in S)</script>, and let <script type=\"math/tex; mode=display\">|S| = n</script>. Then on the right side, it is counted <script type=\"math/tex; mode=display\">\\binom{n}{1} - \\binom{n}{2} + \\binom{n}{3} - \\cdots \\pm \\binom{n}{n}</script> times. By considering the binomial expansion of <script type=\"math/tex; mode=display\">(1 - 1)^n</script>, this is in fact equal to <script type=\"math/tex; mode=display\">1</script>.</p> \n  <p>From <em>Rectangle Area I</em>, we know that the intersection of two axis-aligned rectangles is another axis-aligned rectangle (or nothing). So in particular, the intersection <script type=\"math/tex; mode=display\">\\bigcap_{i \\in S} A_i</script> is always a rectangle (or nothing).</p> \n  <p>Now our algorithm proceeds as follows: for every subset <script type=\"math/tex; mode=display\">S</script> of <script type=\"math/tex; mode=display\">\\{1, 2, 3, \\cdots, N\\}</script> (where <script type=\"math/tex; mode=display\">N</script> is the number of rectangles), we'll calculate the intersection of the rectangles in that subset <script type=\"math/tex; mode=display\">\\bigcap_{i \\in S} A_i</script>, and then the area of that rectangle. This allows us to calculate algorithmically the right-hand side of the general equation we wrote earlier.</p> \n  <iframe src=\"https://leetcode.com/playground/LVWa7ckv/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"LVWa7ckv\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N * 2^N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of rectangles.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-coordinate-compression\">Approach #2: Coordinate Compression</h4> \n  <p><strong>Intuition</strong></p> \n  <p></p>\n  <center> \n   <img src=\"../Figures/850/example.png\" alt=\"Image from problem description\" style=\"height: 200px;\"> \n  </center>\n  <p></p> \n  <p>Suppose instead of <code>rectangles = [[0,0,2,2],[1,0,2,3],[1,0,3,1]]</code>, we had <code>[[0,0,200,200],[100,0,200,300],[100,0,300,100]]</code>. The answer would just be 100 times bigger.</p> \n  <p>What about if <code>rectangles = [[0,0,2,2],[1,0,2,3],[1,0,30002,1]]</code> ? Only the blue region would have area <code>30000</code> instead of <code>1</code>.</p> \n  <p>Our idea is this: we'll take all the <code>x</code> and <code>y</code> coordinates, and re-map them to <code>0, 1, 2, ...</code> etc. For example, if <code>rectangles = [[0,0,200,200],[100,0,200,300],[100,0,300,100]]</code>, we could re-map it to <code>[[0,0,2,2],[1,0,2,3],[1,0,3,1]]</code>. Then, we can solve the problem with brute force. However, each region may actually represent some larger area, so we'll need to adjust for that at the end.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Re-map each <code>x</code> coordinate to <code>0, 1, 2, ...</code>. Independently, re-map all <code>y</code> coordinates too.</p> \n  <p>We then have a problem that can be solved by brute force: for each rectangle with re-mapped coordinates <code>(rx1, ry1, rx2, ry2)</code>, we can fill the grid <code>grid[x][y] = True</code> for <code>rx1 &lt;= x &lt; rx2</code> and <code>ry1 &lt;= y &lt; ry2</code>.</p> \n  <p>Afterwards, each <code>grid[rx][ry]</code> represents the area <code>(imapx(rx+1) - imapx(rx)) * (imapy(ry+1) - imapy(ry))</code>, where if <code>x</code> got remapped to <code>rx</code>, then <code>imapx(rx) = x</code> (\"inverse-map-x of remapped-x equals x\"), and similarly for <code>imapy</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/hp6mu9MY/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"hp6mu9MY\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^3)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of rectangles.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-line-sweep\">Approach #3: Line Sweep</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Imagine we pass a horizontal line from bottom to top over the shape. We have some active intervals on this horizontal line, which gets updated twice for each rectangle. In total, there are <script type=\"math/tex; mode=display\">2 * N</script> events, and we can update our (up to <script type=\"math/tex; mode=display\">N</script>) active horizontal intervals for each update.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>For a rectangle like <code>rec = [1,0,3,1]</code>, the first update is to add <code>[1, 3]</code> to the active set at <code>y = 0</code>, and the second update is to remove <code>[1, 3]</code> at <code>y = 1</code>. Note that adding and removing respects multiplicity - if we also added <code>[0, 2]</code> at <code>y = 0</code>, then removing <code>[1, 3]</code> at <code>y = 1</code> will still leave us with <code>[0, 2]</code> active.</p> \n  <p>This gives us a plan: create these two events for each rectangle, then process all the events in sorted order of <code>y</code>. The issue now is deciding how to process the events <code>add(x1, x2)</code> and <code>remove(x1, x2)</code> such that we are able to <code>query()</code> the total horizontal length of our active intervals.</p> \n  <p>We can use the fact that our <code>remove(...)</code> operation will always be on an interval that was previously added. Let's store all the <code>(x1, x2)</code> intervals in sorted order. Then, we can <code>query()</code> in linear time using a technique similar to a classic LeetCode problem, <a href=\"https://leetcode.com/problems/merge-intervals/\">Merge Intervals</a>.</p> \n  <iframe src=\"https://leetcode.com/playground/vyrMx2Y9/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"vyrMx2Y9\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2 \\log N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of rectangles.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-4-segment-tree\">Approach #4: Segment Tree</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>As in <em>Approach #3</em>, we want to support <code>add(x1, x2)</code>, <code>remove(x1, x2)</code>, and <code>query()</code>. While outside the scope of a typical interview, this is the perfect setting for using a <em>segment tree</em>. For completeness, we include the following implementation.</p> \n  <p>You can learn more about Segment Trees by visiting the articles of these problems: <a href=\"https://leetcode.com/problems/falling-squares/\">Falling Squares</a>, <a href=\"https://leetcode.com/problems/number-of-longest-increasing-subsequence/\">Number of Longest Increasing Subsequence</a>.</p> \n  <iframe src=\"https://leetcode.com/playground/MmabC4t6/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"MmabC4t6\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N \\log N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of rectangles.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>. Idea for Solution #4 by <a href=\"https://leetcode.com/lee215\">@lee215</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 849,
    "article_live": true,
    "article_slug": "maximize-distance-to-closest-person",
    "title": "Maximize Distance to Closest Person",
    "title_slug": "maximize-distance-to-closest-person",
    "content": "<p>In a row of <code>seats</code>, <code>1</code> represents a person sitting in that seat, and <code>0</code> represents that the seat is empty.&nbsp;</p>\r\n\r\n<p>There is at least one empty seat, and at least one person sitting.</p>\r\n\r\n<p>Alex wants to sit in the seat such that the distance between him and the closest person to him is maximized.&nbsp;</p>\r\n\r\n<p>Return that maximum distance to closest person.</p>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[1,0,0,0,1,0,1]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">2</span>\r\n<strong>Explanation: </strong>\r\nIf Alex sits in the second open seat (seats[2]), then the closest person has distance 2.\r\nIf Alex sits in any other open seat, the closest person has distance 1.\r\nThus, the maximum distance to the closest person is 2.</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">[1,0,0,0]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">3</span>\r\n<strong>Explanation: </strong>\r\nIf Alex sits in the last seat, the closest person is 3 seats away.\r\nThis is the maximum distance possible, so the answer is 3.\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= seats.length &lt;= 20000</code></li>\r\n\t<li><code>seats</code>&nbsp;contains only 0s or 1s, at least one <code>0</code>, and at least one <code>1</code>.</li>\r\n</ol>\r\n</div>\r\n</div>\r\n",
    "tags": "Array",
    "difficulty": 1,
    "frontend_article_id": 849,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-next-array-accepted\">Approach #1: Next Array [Accepted]</a></li> \n    <li><a href=\"#approach-2-two-pointer-accepted\">Approach #2: Two Pointer [Accepted]</a></li> \n    <li><a href=\"#approach-3-group-by-zero-accepted\">Approach #3: Group by Zero [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-next-array-accepted\">Approach #1: Next Array [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Let <code>left[i]</code> be the distance from seat <code>i</code> to the closest person sitting to the left of <code>i</code>. Similarly, let <code>right[i]</code> be the distance to the closest person sitting to the right of <code>i</code>. This is motivated by the idea that the closest person in seat <code>i</code> sits a distance <code>min(left[i], right[i])</code> away.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>To construct <code>left[i]</code>, notice it is either <code>left[i-1] + 1</code> if the seat is empty, or <code>0</code> if it is full. <code>right[i]</code> is constructed in a similar way.</p> \n  <iframe src=\"https://leetcode.com/playground/Mdkek4gh/shared\" frameborder=\"0\" width=\"100%\" height=\"480\" name=\"Mdkek4gh\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>seats</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the space used by <code>left</code> and <code>right</code>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-two-pointer-accepted\">Approach #2: Two Pointer [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>As we iterate through seats, we'll update the closest person sitting to our left, and closest person sitting to our right.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Keep track of <code>prev</code>, the filled seat at or to the left of <code>i</code>, and <code>future</code>, the filled seat at or to the right of <code>i</code>.</p> \n  <p>Then at seat <code>i</code>, the closest person is <code>min(i - prev, future - i)</code>, with one exception. <code>i - prev</code> should be considered infinite if there is no person to the left of seat <code>i</code>, and similarly <code>future - i</code> is infinite if there is no one to the right of seat <code>i</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/VSP6cs27/shared\" frameborder=\"0\" width=\"100%\" height=\"429\" name=\"VSP6cs27\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>seats</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-group-by-zero-accepted\">Approach #3: Group by Zero [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>In a group of <code>K</code> adjacent empty seats between two people, the answer is <code>(K+1) / 2</code>.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>For each group of <code>K</code> empty seats between two people, we can take into account the candidate answer <code>(K+1) / 2</code>.</p> \n  <p>For groups of empty seats between the edge of the row and one other person, the answer is <code>K</code>, and we should take into account those answers too.</p> \n  <iframe src=\"https://leetcode.com/playground/wKJwsWbr/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"wKJwsWbr\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>seats</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>. (In Python, <code>seats[::-1]</code> uses <script type=\"math/tex; mode=display\">O(N)</script> space, but this can be remedied.)</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 848,
    "article_live": true,
    "article_slug": "shifting-letters",
    "title": "Shifting Letters",
    "title_slug": "shifting-letters",
    "content": "<p>We have a string <code>S</code> of lowercase letters, and an integer array <code>shifts</code>.</p>\r\n\r\n<p>Call the <em>shift</em> of a letter, the next letter in the alphabet, (wrapping around so that <code>&#39;z&#39;</code> becomes <code>&#39;a&#39;</code>).&nbsp;</p>\r\n\r\n<p>For example, <code>shift(&#39;a&#39;) = &#39;b&#39;</code>, <code>shift(&#39;t&#39;) = &#39;u&#39;</code>, and <code>shift(&#39;z&#39;) = &#39;a&#39;</code>.</p>\r\n\r\n<p>Now for each <code>shifts[i] = x</code>, we want to shift the first <code>i+1</code>&nbsp;letters of <code>S</code>, <code>x</code> times.</p>\r\n\r\n<p>Return the final string&nbsp;after all such shifts to <code>S</code> are applied.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>S = &quot;abc&quot;, shifts = [3,5,9]\r\n<strong>Output: </strong>&quot;rpl&quot;\r\n<strong>Explanation: </strong>\r\nWe start with &quot;abc&quot;.\r\nAfter shifting the first 1 letters of S by 3, we have &quot;dbc&quot;.\r\nAfter shifting the first 2 letters of S by 5, we have &quot;igc&quot;.\r\nAfter shifting the first 3 letters of S by 9, we have &quot;rpl&quot;, the answer.\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= S.length = shifts.length &lt;= 20000</code></li>\r\n\t<li><code>0 &lt;= shifts[i] &lt;= 10 ^ 9</code></li>\r\n</ol>\r\n",
    "tags": "String",
    "difficulty": 2,
    "frontend_article_id": 848,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-prefix-sum-accepted\">Approach #1: Prefix Sum [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-prefix-sum-accepted\">Approach #1: Prefix Sum [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Let's ask how many times the <code>i</code>th character is shifted.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>The <code>i</code>th character is shifted <code>shifts[i] + shifts[i+1] + ... + shifts[shifts.length - 1]</code> times. That's because only operations at the <code>i</code>th operation and after, affect the <code>i</code>th character.</p> \n  <p>Let <code>X</code> be the number of times the current <code>i</code>th character is shifted. Then the next character <code>i+1</code> is shifted <code>X - shifts[i]</code> times.</p> \n  <p>For example, if <code>S.length = 4</code> and <code>S[0]</code> is shifted <code>X = shifts[0] + shifts[1] + shifts[2] + shifts[3]</code> times, then <code>S[1]</code> is shifted <code>shifts[1] + shifts[2] + shifts[3]</code> times, <code>S[2]</code> is shifted <code>shifts[2] + shifts[3]</code> times, and so on.</p> \n  <p>In general, we need to do <code>X -= shifts[i]</code> to maintain the correct value of <code>X</code> as we increment <code>i</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/eh9zG8Q2/shared\" frameborder=\"0\" width=\"100%\" height=\"327\" name=\"eh9zG8Q2\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>S</code> (and <code>shifts</code>).</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the space needed to output the answer.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 847,
    "article_live": true,
    "article_slug": "shortest-path-visiting-all-nodes",
    "title": "Shortest Path Visiting All Nodes",
    "title_slug": "shortest-path-visiting-all-nodes",
    "content": "<p>An undirected, connected graph of N nodes (labeled&nbsp;<code>0, 1, 2, ..., N-1</code>) is given as <code>graph</code>.</p>\r\n\r\n<p><code>graph.length = N</code>, and <code>j != i</code>&nbsp;is in the list&nbsp;<code>graph[i]</code>&nbsp;exactly once, if and only if nodes <code>i</code> and <code>j</code> are connected.</p>\r\n\r\n<p>Return the length of the shortest path that visits every node. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<ol>\r\n</ol>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>[[1,2,3],[0],[0],[0]]\r\n<strong>Output: </strong>4\r\n<strong>Explanation</strong>: One possible path is [1,0,2,0,3]</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>[[1],[0,2,4],[1,3,4],[2],[1,2]]\r\n<strong>Output: </strong>4\r\n<strong>Explanation</strong>: One possible path is [0,1,4,2,3]\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= graph.length &lt;= 12</code></li>\r\n\t<li><code>0 &lt;= graph[i].length &lt;&nbsp;graph.length</code></li>\r\n</ol>\r\n",
    "tags": "Dynamic Programming, Breadth-first Search",
    "difficulty": 3,
    "frontend_article_id": 847,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-breadth-first-search-accepted\">Approach #1: Breadth First Search [Accepted]</a></li> \n    <li><a href=\"#approach-2-dynamic-programming-accepted\">Approach #2: Dynamic Programming [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-breadth-first-search-accepted\">Approach #1: Breadth First Search [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>A path 'state' can be represented as the subset of nodes visited, plus the current 'head' node. Then, the problem reduces to a shortest path problem among these states, which can be solved with a breadth-first search.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Let's call the set of nodes visited by a path so far the <em>cover</em>, and the current node as the <em>head</em>. We'll store the <code>cover</code> states using set bits: <code>k</code> is in the cover if the <code>k</code>th bit of <code>cover</code> is 1.</p> \n  <p>For states <code>state = (cover, head)</code>, we can perform a breadth-first search on these states. The neighbors are <code>(cover | (1 &lt;&lt; child), child)</code> for each <code>child in graph[head]</code>.</p> \n  <p>If at any point we find a state with all set bits in it's cover, because it is a breadth-first search, we know this must represent the shortest path length.</p> \n  <iframe src=\"https://leetcode.com/playground/RSKL3uRn/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"RSKL3uRn\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(2^N * N)</script>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(2^N * N)</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-dynamic-programming-accepted\">Approach #2: Dynamic Programming [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>A path 'state' can be represented as the subset of nodes visited, plus the current 'head' node. As in Approach #1, we have a recurrence in states: <code>answer(cover, head)</code> is <code>min(1 + answer(cover | (1&lt;&lt;child), child) for child in graph[head])</code>. Because these states form a DAG (a directed graph with no cycles), we can do dynamic programming.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Let's call the set of nodes visited by a path so far the <em>cover</em>, and the current node as the <em>head</em>. We'll store <code>dist[cover][head]</code> as the length of the shortest path with that cover and head. We'll store the <code>cover</code> states using set bits, and maintain the loop invariant (on <code>cover</code>), that <code>dist[k][...]</code> is correct for <code>k &lt; cover</code>.</p> \n  <p>For every state <code>(cover, head)</code>, the possible <code>next</code> (neighbor) nodes in the path are found in <code>graph[head]</code>. The new <code>cover2</code> is the old cover plus <code>next</code>.</p> \n  <p>For each of these, we perform a \"relaxation step\" (for those familiar with the Bellman-Ford algorithm), where if the new candidate distance for <code>dist[cover2][next]</code> is larger than <code>dist[cover][head] + 1</code>, we'll update it to <code>dist[cover][head] + 1</code>.</p> \n  <p>Care must be taken to perform the relaxation step multiple times on the same cover if <code>cover = cover2</code>. This is because a minimum state for <code>dist[cover][head]</code> might only be achieved through multiple steps through some path.</p> \n  <p>Finally, it should be noted that we are using implicitly the fact that when iterating <code>cover = 0 .. (1&lt;&lt;N) - 1</code>, that each new cover <code>cover2 = cover | 1 &lt;&lt; x</code> is such that <code>cover2 &gt;= cover</code>. This implies a topological ordering, which means that the recurrence on these states form a DAG.</p> \n  <iframe src=\"https://leetcode.com/playground/f8jJAcDL/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"f8jJAcDL\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(2^N * N)</script>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(2^N * N)</script>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 846,
    "article_live": true,
    "article_slug": "hand-of-straights",
    "title": "Hand of Straights",
    "title_slug": "hand-of-straights",
    "content": "<p>Alice has a <code>hand</code> of cards, given as an array of integers.</p>\r\n\r\n<p>Now she wants to rearrange the cards into groups so that each group is size <code>W</code>, and consists of <code>W</code> consecutive cards.</p>\r\n\r\n<p>Return <code>true</code> if and only if she can.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<ol>\r\n</ol>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>hand = [1,2,3,6,2,3,4,7,8], W = 3\r\n<strong>Output: </strong>true\r\n<strong>Explanation:</strong> Alice&#39;s <code>hand</code> can be rearranged as <code>[1,2,3],[2,3,4],[6,7,8]</code>.</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>hand = [1,2,3,4,5], W = 4\r\n<strong>Output: </strong>false\r\n<strong>Explanation:</strong> Alice&#39;s <code>hand</code> can&#39;t be rearranged into groups of <code>4</code>.</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= hand.length &lt;= 10000</code></li>\r\n\t<li><code>0 &lt;= hand[i]&nbsp;&lt;= 10^9</code></li>\r\n\t<li><code>1 &lt;= W &lt;= hand.length</code></li>\r\n</ol>\r\n",
    "tags": "Map",
    "difficulty": 2,
    "frontend_article_id": 846,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-brute-force-accepted\">Approach #1: Brute Force [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-brute-force-accepted\">Approach #1: Brute Force [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>We will repeatedly try to form a group (of size W) starting with the lowest card. This works because the lowest card still in our hand must be the bottom end of a size <code>W</code> straight.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Let's keep a count <code>{card: number of copies of card}</code> as a <code>TreeMap</code> (or <code>dict</code>).</p> \n  <p>Then, repeatedly we will do the following steps: find the lowest value card that has 1 or more copies (say with value <code>x</code>), and try to remove <code>x, x+1, x+2, ..., x+W-1</code> from our count. If we can't, then the task is impossible.</p> \n  <iframe src=\"https://leetcode.com/playground/VyDASsga/shared\" frameborder=\"0\" width=\"100%\" height=\"446\" name=\"VyDASsga\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N * (N/W))</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>hand</code>. The <script type=\"math/tex; mode=display\">(N / W)</script> factor comes from <code>min(count)</code>. In Java, the <script type=\"math/tex; mode=display\">(N / W)</script> factor becomes <script type=\"math/tex; mode=display\">\\log N</script> due to the complexity of <code>TreeMap</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 845,
    "article_live": true,
    "article_slug": "longest-mountain-in-array",
    "title": "Longest Mountain in Array",
    "title_slug": "longest-mountain-in-array",
    "content": "<p>Let&#39;s call any (contiguous) subarray B (of A)&nbsp;a <em>mountain</em> if the following properties hold:</p>\r\n\r\n<ul>\r\n\t<li><code>B.length &gt;= 3</code></li>\r\n\t<li>There exists some <code>0 &lt; i&nbsp;&lt; B.length - 1</code> such that <code>B[0] &lt; B[1] &lt; ... B[i-1] &lt; B[i] &gt; B[i+1] &gt; ... &gt; B[B.length - 1]</code></li>\r\n</ul>\r\n\r\n<p>(Note that B could be any subarray of A, including the entire array A.)</p>\r\n\r\n<p>Given an array <code>A</code>&nbsp;of integers,&nbsp;return the length of the longest&nbsp;<em>mountain</em>.&nbsp;</p>\r\n\r\n<p>Return <code>0</code> if there is no mountain.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>[2,1,4,7,3,2,5]\r\n<strong>Output: </strong>5\r\n<strong>Explanation: </strong>The largest mountain is [1,4,7,3,2] which has length 5.\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>[2,2,2]\r\n<strong>Output: </strong>0\r\n<strong>Explanation: </strong>There is no mountain.\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>0 &lt;= A.length &lt;= 10000</code></li>\r\n\t<li><code>0 &lt;= A[i] &lt;= 10000</code></li>\r\n</ol>\r\n\r\n<p><strong>Follow up:</strong></p>\r\n\r\n<ul>\r\n\t<li>Can you solve it using only one pass?</li>\r\n\t<li>Can you solve it in <code>O(1)</code> space?</li>\r\n</ul>\r\n",
    "tags": "Two Pointers",
    "difficulty": 2,
    "frontend_article_id": 845,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-two-pointer-accepted\">Approach #1: Two Pointer [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-two-pointer-accepted\">Approach #1: Two Pointer [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Without loss of generality, a mountain can only start after the previous one ends.</p> \n  <p>This is because if it starts before the peak, it will be smaller than a mountain starting previous; and it is impossible to start after the peak.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>For a starting index <code>base</code>, let's calculate the length of the longest mountain <code>A[base], A[base+1], ..., A[end]</code>.</p> \n  <p>If such a mountain existed, the next possible mountain will start at <code>base = end</code>; if it didn't, then either we reached the end, or we have <code>A[base] &gt; A[base+1]</code> and we can start at <code>base + 1</code>.</p> \n  <p><strong>Example</strong></p> \n  <p>Here is a worked example on the array <code>A = [1, 2, 3, 2, 1, 0, 2, 3, 1]</code>:</p> \n  <p></p>\n  <center> \n   <img src=\"../Figures/845/diagram1.png\" alt=\"Worked example of A = [1,2,3,2,1,0,2,3,1]\" style=\"height: 150px\"> \n  </center>\n  <p></p> \n  <p><br></p> \n  <p><code>base</code> starts at <code>0</code>, and <code>end</code> travels using the first while loop to <code>end = 2</code> (<code>A[end] = 3</code>), the potential peak of this mountain. After, it travels to <code>end = 5</code> (<code>A[end] = 0</code>) during the second while loop, and a candidate answer of 6 <code>(base = 0, end = 5)</code> is recorded.</p> \n  <p>Afterwards, base is set to <code>5</code> and the process starts over again, with <code>end = 7</code> the peak of the mountain, and <code>end = 8</code> the right boundary, and the candidate answer of 4 <code>(base = 5, end = 8)</code> being recorded.</p> \n  <iframe src=\"https://leetcode.com/playground/7cVQKFLP/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"7cVQKFLP\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>A</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 844,
    "article_live": true,
    "article_slug": "backspace-string-compare",
    "title": "Backspace String Compare",
    "title_slug": "backspace-string-compare",
    "content": "<p>Given two&nbsp;strings&nbsp;<code>S</code>&nbsp;and <code>T</code>,&nbsp;return if they are equal when both are typed into empty text editors. <code>#</code> means a backspace character.</p>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>S = <span id=\"example-input-1-1\">&quot;ab#c&quot;</span>, T = <span id=\"example-input-1-2\">&quot;ad#c&quot;</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">true\r\n</span><span><strong>Explanation</strong>: Both S and T become &quot;ac&quot;.</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>S = <span id=\"example-input-2-1\">&quot;ab##&quot;</span>, T = <span id=\"example-input-2-2\">&quot;c#d#&quot;</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">true\r\n</span><span><strong>Explanation</strong>: Both S and T become &quot;&quot;.</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>S = <span id=\"example-input-3-1\">&quot;a##c&quot;</span>, T = <span id=\"example-input-3-2\">&quot;#a#c&quot;</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">true\r\n</span><span><strong>Explanation</strong>: Both S and T become &quot;c&quot;.</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 4:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>S = <span id=\"example-input-4-1\">&quot;a#c&quot;</span>, T = <span id=\"example-input-4-2\">&quot;b&quot;</span>\r\n<strong>Output: </strong><span id=\"example-output-4\">false\r\n</span><span><strong>Explanation</strong>: S becomes &quot;c&quot; while T becomes &quot;b&quot;.</span>\r\n</pre>\r\n\r\n<p><span><strong>Note</strong>:</span></p>\r\n\r\n<ol>\r\n\t<li><code><span>1 &lt;= S.length &lt;= 200</span></code></li>\r\n\t<li><code><span>1 &lt;= T.length &lt;= 200</span></code></li>\r\n\t<li><span><code>S</code>&nbsp;and <code>T</code> only contain&nbsp;lowercase letters and <code>&#39;#&#39;</code> characters.</span></li>\r\n</ol>\r\n\r\n<p><strong>Follow up:</strong></p>\r\n\r\n<ul>\r\n\t<li>Can you solve it in <code>O(N)</code> time and <code>O(1)</code> space?</li>\r\n</ul>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n",
    "tags": "Two Pointers, Stack",
    "difficulty": 1,
    "frontend_article_id": 844,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-build-string-accepted\">Approach #1: Build String [Accepted]</a></li> \n    <li><a href=\"#approach-2-two-pointer-accepted\">Approach #2: Two Pointer [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-build-string-accepted\">Approach #1: Build String [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Let's individually build the result of each string (<code>build(S)</code> and <code>build(T)</code>), then compare if they are equal.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>To build the result of a string <code>build(S)</code>, we'll use a stack based approach, simulating the result of each keystroke.</p> \n  <iframe src=\"https://leetcode.com/playground/oeguUYg8/shared\" frameborder=\"0\" width=\"100%\" height=\"327\" name=\"oeguUYg8\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(M + N)</script>, where <script type=\"math/tex; mode=display\">M, N</script> are the lengths of <code>S</code> and <code>T</code> respectively.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(M + N)</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-two-pointer-accepted\">Approach #2: Two Pointer [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>When writing a character, it may or may not be part of the final string depending on how many backspace keystrokes occur in the future.</p> \n  <p>If instead we iterate through the string in reverse, then we will know how many backspace characters we have seen, and therefore whether the result includes our character.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Iterate through the string in reverse. If we see a backspace character, the next non-backspace character is skipped. If a character isn't skipped, it is part of the final answer.</p> \n  <p>See the comments in the code for more details.</p> \n  <iframe src=\"https://leetcode.com/playground/sqdQBEmS/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"sqdQBEmS\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(M + N)</script>, where <script type=\"math/tex; mode=display\">M, N</script> are the lengths of <code>S</code> and <code>T</code> respectively.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 843,
    "article_live": true,
    "article_slug": "guess-the-word",
    "title": "Guess the Word",
    "title_slug": "guess-the-word",
    "content": "<p>This problem is an&nbsp;<strong><em>interactive problem</em></strong>&nbsp;new to the LeetCode platform.</p>\r\n\r\n<p>We are given a word list of unique words, each word is 6 letters long, and one word in this list is chosen as <strong>secret</strong>.</p>\r\n\r\n<p>You may call <code>master.guess(word)</code>&nbsp;to guess a word.&nbsp; The guessed word should have&nbsp;type <code>string</code>&nbsp;and must be from the original list&nbsp;with 6 lowercase letters.</p>\r\n\r\n<p>This function returns an&nbsp;<code>integer</code>&nbsp;type, representing&nbsp;the number of exact matches (value and position) of your guess to the <strong>secret word</strong>.&nbsp; Also, if your guess is not in the given wordlist, it will return <code>-1</code> instead.</p>\r\n\r\n<p>For each test case, you have 10 guesses to guess the word. At the end of any number of calls, if you have made 10 or less calls to <code>master.guess</code>&nbsp;and at least one of these guesses was the <strong>secret</strong>, you pass the testcase.</p>\r\n\r\n<p>Besides the example test case below, there will be 5&nbsp;additional test cases, each with 100 words in the word list.&nbsp; The letters of each word in those testcases were chosen&nbsp;independently at random from <code>&#39;a&#39;</code> to <code>&#39;z&#39;</code>, such that every word in the given word lists is unique.</p>\r\n\r\n<pre>\r\n<strong>Example 1:</strong>\r\n<strong>Input:</strong>&nbsp;secret = &quot;acckzz&quot;, wordlist = [&quot;acckzz&quot;,&quot;ccbazz&quot;,&quot;eiowzz&quot;,&quot;abcczz&quot;]\r\n\r\n<strong>Explanation:</strong>\r\n\r\n<code>master.guess(&quot;aaaaaa&quot;)</code> returns -1, because&nbsp;<code>&quot;aaaaaa&quot;</code>&nbsp;is not in wordlist.\r\n<code>master.guess(&quot;acckzz&quot;) </code>returns 6, because&nbsp;<code>&quot;acckzz&quot;</code> is secret and has all 6&nbsp;matches.\r\n<code>master.guess(&quot;ccbazz&quot;)</code> returns 3, because<code>&nbsp;&quot;ccbazz&quot;</code>&nbsp;has 3 matches.\r\n<code>master.guess(&quot;eiowzz&quot;)</code> returns 2, because&nbsp;<code>&quot;eiowzz&quot;</code>&nbsp;has 2&nbsp;matches.\r\n<code>master.guess(&quot;abcczz&quot;)</code> returns 4, because&nbsp;<code>&quot;abcczz&quot;</code> has 4 matches.\r\n\r\nWe made 5 calls to&nbsp;master.guess and one of them was the secret, so we pass the test case.\r\n</pre>\r\n\r\n<p><strong>Note:</strong>&nbsp; Any solutions that attempt to circumvent the judge&nbsp;will result in disqualification.</p>\r\n",
    "tags": "Minimax",
    "difficulty": 3,
    "frontend_article_id": 843,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-minimax-with-heuristic-accepted\">Approach #1: Minimax with Heuristic [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-minimax-with-heuristic-accepted\">Approach #1: Minimax with Heuristic [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>We can guess that having less words in the word list is generally better. If the data is random, we can reason this is often the case.</p> \n  <p>Now let's use the strategy of making the guess that minimizes the maximum possible size of the resulting word list. If we started with <script type=\"math/tex; mode=display\">N</script> words in our word list, we can iterate through all possibilities for what the secret could be.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Store <code>H[i][j]</code> as the number of matches of <code>wordlist[i]</code> and <code>wordlist[j]</code>. For each guess that hasn't been guessed before, do a minimax as described above, taking the guess that gives us the smallest group that might occur.</p> \n  <iframe src=\"https://leetcode.com/playground/XyZRWsin/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"XyZRWsin\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2 \\log N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of words, and assuming their length is <script type=\"math/tex; mode=display\">O(1)</script>. Each call to <code>solve</code> is <script type=\"math/tex; mode=display\">O(N^2)</script>, and the number of calls is bounded by <script type=\"math/tex; mode=display\">O(\\log N)</script>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 842,
    "article_live": true,
    "article_slug": "split-array-into-fibonacci-sequence",
    "title": "Split Array into Fibonacci Sequence",
    "title_slug": "split-array-into-fibonacci-sequence",
    "content": "<p>Given a string <code>S</code>&nbsp;of digits, such as <code>S = &quot;123456579&quot;</code>, we can split it into a <em>Fibonacci-like sequence</em>&nbsp;<code>[123, 456, 579].</code></p>\r\n\r\n<p>Formally, a Fibonacci-like sequence is a list&nbsp;<code>F</code> of non-negative integers such that:</p>\r\n\r\n<ul>\r\n\t<li><code>0 &lt;= F[i] &lt;= 2^31 - 1</code>, (that is,&nbsp;each integer fits a 32-bit signed integer type);</li>\r\n\t<li><code>F.length &gt;= 3</code>;</li>\r\n\t<li>and<code> F[i] + F[i+1] = F[i+2] </code>for all <code>0 &lt;= i &lt; F.length - 2</code>.</li>\r\n</ul>\r\n\r\n<p>Also, note that when splitting the string into pieces, each piece must not have extra leading zeroes, except if the piece is the number 0 itself.</p>\r\n\r\n<p>Return any Fibonacci-like sequence split from <code>S</code>, or return <code>[]</code> if it cannot be done.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>&quot;123456579&quot;\r\n<strong>Output: </strong>[123,456,579]\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>&quot;11235813&quot;\r\n<strong>Output: </strong>[1,1,2,3,5,8,13]\r\n</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>&quot;112358130&quot;\r\n<strong>Output: </strong>[]\r\n<strong>Explanation: </strong>The task is impossible.\r\n</pre>\r\n\r\n<p><strong>Example 4:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>&quot;0123&quot;\r\n<strong>Output: </strong>[]\r\n<strong>Explanation: </strong>Leading zeroes are not allowed, so &quot;01&quot;, &quot;2&quot;, &quot;3&quot; is not valid.\r\n</pre>\r\n\r\n<p><strong>Example 5:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>&quot;1101111&quot;\r\n<strong>Output: </strong>[110, 1, 111]\r\n<strong>Explanation: </strong>The output [11, 0, 11, 11] would also be accepted.\r\n</pre>\r\n\r\n<p><strong>Note: </strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= S.length&nbsp;&lt;= 200</code></li>\r\n\t<li><code>S</code> contains only digits.</li>\r\n</ol>\r\n",
    "tags": "String, Backtracking, Greedy",
    "difficulty": 2,
    "frontend_article_id": 842,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-brute-force-accepted\">Approach #1: Brute Force [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-brute-force-accepted\">Approach #1: Brute Force [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>The first two elements of the array uniquely determine the rest of the sequence.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>For each of the first two elements, assuming they have no leading zero, let's iterate through the rest of the string. At each stage, we expect a number less than or equal to <code>2^31 - 1</code> that starts with the sum of the two previous numbers.</p> \n  <iframe src=\"https://leetcode.com/playground/2PpFDrmP/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"2PpFDrmP\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>S</code>, and with the requirement that the values of the answer are <script type=\"math/tex; mode=display\">O(1)</script> in length.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 841,
    "article_live": true,
    "article_slug": "keys-and-rooms",
    "title": "Keys and Rooms",
    "title_slug": "keys-and-rooms",
    "content": "<p>There are <code>N</code> rooms and you start in room <code>0</code>.&nbsp; Each room has a distinct number in <code>0, 1, 2, ..., N-1</code>, and each room may have&nbsp;some keys to access the next room.&nbsp;</p>\r\n\r\n<p>Formally, each room <code>i</code>&nbsp;has a list of keys <code>rooms[i]</code>, and each key <code>rooms[i][j]</code> is an integer in <code>[0, 1, ..., N-1]</code> where <code>N = rooms.length</code>.&nbsp; A key <code>rooms[i][j] = v</code>&nbsp;opens the room with number <code>v</code>.</p>\r\n\r\n<p>Initially, all the rooms start locked (except for room <code>0</code>).&nbsp;</p>\r\n\r\n<p>You can walk back and forth between rooms freely.</p>\r\n\r\n<p>Return <code>true</code>&nbsp;if and only if you can enter&nbsp;every room.</p>\r\n\r\n<ol>\r\n</ol>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>[[1],[2],[3],[]]\r\n<strong>Output: </strong>true\r\n<strong>Explanation:  </strong>\r\nWe start in room 0, and pick up key 1.\r\nWe then go to room 1, and pick up key 2.\r\nWe then go to room 2, and pick up key 3.\r\nWe then go to room 3.  Since we were able to go to every room, we return true.\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>[[1,3],[3,0,1],[2],[0]]\r\n<strong>Output: </strong>false\r\n<strong>Explanation: </strong>We can&#39;t enter the room with number 2.\r\n</pre>\r\n\r\n<p><b>Note:</b></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= rooms.length &lt;=&nbsp;1000</code></li>\r\n\t<li><code>0 &lt;= rooms[i].length &lt;= 1000</code></li>\r\n\t<li>The number of keys in all rooms combined is at most&nbsp;<code>3000</code>.</li>\r\n</ol>\r\n",
    "tags": "Depth-first Search, Graph",
    "difficulty": 2,
    "frontend_article_id": 841,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-depth-first-search-accepted\">Approach #1: Depth-First Search [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-depth-first-search-accepted\">Approach #1: Depth-First Search [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>When visiting a room for the first time, look at all the keys in that room. For any key that hasn't been used yet, add it to the todo list (<code>stack</code>) for it to be used.</p> \n  <p>See the comments of the code for more details.</p> \n  <iframe src=\"https://leetcode.com/playground/DStbTdKq/shared\" frameborder=\"0\" width=\"100%\" height=\"446\" name=\"DStbTdKq\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N + E)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of rooms, and <script type=\"math/tex; mode=display\">E</script> is the total number of keys.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script> in additional space complexity, to store <code>stack</code> and <code>seen</code>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 840,
    "article_live": true,
    "article_slug": "magic-squares-in-grid",
    "title": "Magic Squares In Grid",
    "title_slug": "magic-squares-in-grid",
    "content": "<p>A 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers <strong>from 1 to 9</strong> such that each row, column, and both diagonals all have the same sum.</p>\r\n\r\n<p>Given an <code>grid</code>&nbsp;of integers, how many 3 x 3 &quot;magic square&quot; subgrids are there?&nbsp; (Each subgrid is contiguous).</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>[[4,3,8,4],\r\n        [9,5,1,9],\r\n        [2,7,6,2]]\r\n<strong>Output: </strong>1\r\n<strong>Explanation: </strong>\r\nThe following subgrid is a 3 x 3 magic square:\r\n438\r\n951\r\n276\r\n\r\nwhile this one is not:\r\n384\r\n519\r\n762\r\n\r\nIn total, there is only one magic square inside the given grid.\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= grid.length&nbsp;&lt;= 10</code></li>\r\n\t<li><code>1 &lt;= grid[0].length&nbsp;&lt;= 10</code></li>\r\n\t<li><code>0 &lt;= grid[i][j] &lt;= 15</code></li>\r\n</ol>\r\n",
    "tags": "Array",
    "difficulty": 1,
    "frontend_article_id": 840,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-brute-force-accepted\">Approach #1: Brute Force [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-brute-force-accepted\">Approach #1: Brute Force [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Let's check every 3x3 grid individually. For each grid, all numbers must be unique and between 1 and 9; plus every row, column, and diagonal must have the same sum.</p> \n  <p><strong>Extra Credit</strong></p> \n  <p>We could also include an <code>if grid[r+1][c+1] != 5: continue</code> check into our code, helping us skip over our <code>for r... for c...</code> for loops faster. This is based on the following observations:</p> \n  <ul> \n   <li>The sum of the grid must be 45, as it is the sum of the distinct values from 1 to 9.</li> \n   <li>Each horizontal and vertical line must add up to 15, as the sum of 3 of these lines equals the sum of the whole grid.</li> \n   <li>The diagonal lines must also sum to 15, by definition of the problem statement.</li> \n   <li>Adding the 12 values from the four lines that cross the center, these 4 lines add up to 60; but they also add up to the entire grid (45), plus 3 times the middle value. This implies the middle value is 5.</li> \n  </ul> \n  <iframe src=\"https://leetcode.com/playground/6yuMDRxQ/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"6yuMDRxQ\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(R*C)</script>, where <script type=\"math/tex; mode=display\">R, C</script> are the number of rows and columns in the given <code>grid</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 839,
    "article_live": true,
    "article_slug": "similar-string-groups",
    "title": "Similar String Groups",
    "title_slug": "similar-string-groups",
    "content": "<p>Two strings <code>X</code>&nbsp;and <code>Y</code>&nbsp;are similar if we can swap two letters (in different positions) of <code>X</code>, so that&nbsp;it equals <code>Y</code>.</p>\r\n\r\n<p>For example, <code>&quot;tars&quot;</code>&nbsp;and <code>&quot;rats&quot;</code>&nbsp;are similar (swapping at positions <code>0</code> and <code>2</code>), and <code>&quot;rats&quot;</code> and <code>&quot;arts&quot;</code> are similar, but <code>&quot;star&quot;</code> is not similar to <code>&quot;tars&quot;</code>, <code>&quot;rats&quot;</code>, or <code>&quot;arts&quot;</code>.</p>\r\n\r\n<p>Together, these form two connected groups by similarity: <code>{&quot;tars&quot;, &quot;rats&quot;, &quot;arts&quot;}</code> and <code>{&quot;star&quot;}</code>.&nbsp; Notice that <code>&quot;tars&quot;</code> and <code>&quot;arts&quot;</code> are in the same group even though they are not similar.&nbsp; Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group.</p>\r\n\r\n<p>We are given a list <code>A</code> of strings.&nbsp; Every string in <code>A</code> is an anagram of every other string in <code>A</code>.&nbsp; How many groups are there?</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>[&quot;tars&quot;,&quot;rats&quot;,&quot;arts&quot;,&quot;star&quot;]\r\n<strong>Output: </strong>2</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>A.length &lt;= 2000</code></li>\r\n\t<li><code>A[i].length &lt;= 1000</code></li>\r\n\t<li><code>A.length * A[i].length &lt;= 20000</code></li>\r\n\t<li>All words in <code>A</code>&nbsp;consist of lowercase letters only.</li>\r\n\t<li>All words in <code>A</code> have the same length and are anagrams of each other.</li>\r\n\t<li>The judging time limit has been increased for this question.</li>\r\n</ol>\r\n",
    "tags": "Depth-first Search, Union Find, Graph",
    "difficulty": 3,
    "frontend_article_id": 839,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-piecewise-accepted\">Approach #1: Piecewise [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-piecewise-accepted\">Approach #1: Piecewise [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Let <code>W = A[0].length</code>. It is clear that we can determine in <script type=\"math/tex; mode=display\">O(W)</script> time, whether two words from <code>A</code> are similar.</p> \n  <p>One attempt is a standard kind of brute force: for each pair of words, let's draw an edge between these words if they are similar. We can do this in <script type=\"math/tex; mode=display\">O(N^2 W)</script> time. After, finding the connected components can be done in <script type=\"math/tex; mode=display\">O(N^2)</script> time naively (each node may have up to <script type=\"math/tex; mode=display\">N-1</script> edges), (or <script type=\"math/tex; mode=display\">O(N)</script> with a union-find structure.) The total complexity is <script type=\"math/tex; mode=display\">O(N^2 W)</script>.</p> \n  <p>Another attempt is to enumerate all neighbors of a word. A <code>word</code> has up to <script type=\"math/tex; mode=display\">\\binom{W}{2}</script> neighbors, and if that <code>neighbor</code> is itself a given word, we know that <code>word</code> and <code>neighbor</code> are connected by an edge. In this way, we can build the graph in <script type=\"math/tex; mode=display\">O(N W^3)</script> time, and again take <script type=\"math/tex; mode=display\">O(N^2)</script> or <script type=\"math/tex; mode=display\">O(N)</script> time to analyze the number of connected components.</p> \n  <p>One insight is that between these two approaches, we can choose which approach works better. If we have very few words, we want to use the first approach; if we have very short words, we want to use the second approach. We'll piecewise add these two approaches (with complexity <script type=\"math/tex; mode=display\">O(N^2 W)</script> and <script type=\"math/tex; mode=display\">O(N W^3)</script>), to create an approach with <script type=\"math/tex; mode=display\">O(NW\\min(N, W^2))</script> complexity.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>We will build some underlying graph with <code>N</code> nodes, where nodes <code>i</code> and <code>j</code> are connected if and only if <code>A[i]</code> is similar to <code>A[j]</code>, then look at the number of connected components.</p> \n  <p>There are a few challenges involved in this problem, but each challenge is relatively straightforward. </p> \n  <ul> \n   <li> <p>Use a helper function <code>similar(word1, word2)</code> that is <code>true</code> if and only if two given words are similar.</p> </li> \n   <li> <p>Enumerate all neighbors of a word, and discover when it is equal to a given word.</p> </li> \n   <li> <p>Use either a union-find structure or a depth-first search, to calculate the number of connected components of the underlying graph. We've showcased a union-find structure in this solution, with notes of a depth-first search in the comments.</p> </li> \n  </ul> \n  <p>For more details, see the implementations below.</p> \n  <iframe src=\"https://leetcode.com/playground/B2BjbwA7/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"B2BjbwA7\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(NW \\min(N, W^2))</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>A</code>, and <script type=\"math/tex; mode=display\">W</script> is the length of each given word.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(NW^3)</script>. If <script type=\"math/tex; mode=display\">N < W^2</script>, the space complexity is <script type=\"math/tex; mode=display\">O(N)</script>. Otherwise, the space complexity is <script type=\"math/tex; mode=display\">O(NW^3)</script>: for each of <script type=\"math/tex; mode=display\">NW^2</script> neighbors we store a word of length <script type=\"math/tex; mode=display\">W</script>. (Plus, we store <script type=\"math/tex; mode=display\">O(NW^2)</script> node indices (\"buckets\") which is dominated by the <script type=\"math/tex; mode=display\">O(NW^3)</script> term.) Because <script type=\"math/tex; mode=display\">W^2 <= N</script> in this case, we could also write the space complexity as <script type=\"math/tex; mode=display\">O(N^2 W)</script>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 838,
    "article_live": true,
    "article_slug": "push-dominoes",
    "title": "Push Dominoes",
    "title_slug": "push-dominoes",
    "content": "<p>There are<font face=\"monospace\">&nbsp;<code>N</code></font> dominoes in a line, and we place each domino vertically upright.</p>\r\n\r\n<p>In the beginning, we simultaneously push&nbsp;some of the dominoes either to the left or to the right.</p>\r\n\r\n<p><img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/05/18/domino.png\" style=\"height: 160px;\" /></p>\r\n\r\n<p>After each second, each domino that is falling to the left pushes the adjacent domino on the left.</p>\r\n\r\n<p>Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right.</p>\r\n\r\n<p>When a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces.</p>\r\n\r\n<p>For the purposes of this question, we will consider that a falling domino&nbsp;expends no additional force to a falling or already fallen domino.</p>\r\n\r\n<p>Given a string &quot;S&quot; representing the initial state.&nbsp;<code>S[i] = &#39;L&#39;</code>, if the i-th domino has been pushed to the left; <code>S[i] = &#39;R&#39;</code>, if the i-th domino has been pushed to the right; <code>S[i] = &#39;.&#39;</code>,&nbsp;if the <code>i</code>-th domino has not been pushed.</p>\r\n\r\n<p>Return a string representing the final state.&nbsp;</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>&quot;.L.R...LR..L..&quot;\r\n<strong>Output: </strong>&quot;LL.RR.LLRRLL..&quot;\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>&quot;RR.L&quot;\r\n<strong>Output: </strong>&quot;RR.L&quot;\r\n<strong>Explanation: </strong>The first domino expends no additional force on the second domino.\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>0 &lt;= N&nbsp;&lt;= 10^5</code></li>\r\n\t<li>String&nbsp;<code>dominoes</code> contains only&nbsp;<code>&#39;L</code>&#39;, <code>&#39;R&#39;</code> and <code>&#39;.&#39;</code></li>\r\n</ol>\r\n",
    "tags": "Two Pointers, Dynamic Programming",
    "difficulty": 2,
    "frontend_article_id": 838,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-adjacent-symbols-accepted\">Approach #1: Adjacent Symbols [Accepted]</a></li> \n    <li><a href=\"#approach-2-calculate-force-accepted\">Approach #2: Calculate Force [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-adjacent-symbols-accepted\">Approach #1: Adjacent Symbols [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Between every group of vertical dominoes (<code>'.'</code>), we have up to two non-vertical dominoes bordering this group. Since additional dominoes outside this group do not affect the outcome, we can analyze these situations individually: there are 9 of them (as the border could be empty). Actually, if we border the dominoes by <code>'L'</code> and <code>'R'</code>, there are only 4 cases. We'll write new letters between these symbols depending on each case.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Continuing our explanation, we analyze cases:</p> \n  <ul> \n   <li> <p>If we have say <code>\"A....B\"</code>, where A = B, then we should write <code>\"AAAAAA\"</code>.</p> </li> \n   <li> <p>If we have <code>\"R....L\"</code>, then we will write <code>\"RRRLLL\"</code>, or <code>\"RRR.LLL\"</code> if we have an odd number of dots. If the initial symbols are at positions <code>i</code> and <code>j</code>, we can check our distance <code>k-i</code> and <code>j-k</code> to decide at position <code>k</code> whether to write <code>'L'</code>, <code>'R'</code>, or <code>'.'</code>.</p> </li> \n   <li> <p>(If we have <code>\"L....R\"</code> we don't do anything. We can skip this case.)</p> </li> \n  </ul> \n  <iframe src=\"https://leetcode.com/playground/X63wt96u/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"X63wt96u\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time and Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>dominoes</code>.</li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-calculate-force-accepted\">Approach #2: Calculate Force [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>We can calculate the net force applied on every domino. The forces we care about are how close a domino is to a leftward <code>'R'</code>, and to a rightward <code>'L'</code>: the closer we are, the stronger the force.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Scanning from left to right, our force decays by 1 every iteration, and resets to <code>N</code> if we meet an <code>'R'</code>, so that <code>force[i]</code> is higher (than <code>force[j]</code>) if and only if <code>dominoes[i]</code> is closer (looking leftward) to <code>'R'</code> (than <code>dominoes[j]</code>).</p> \n  <p>Similarly, scanning from right to left, we can find the force going rightward (closeness to <code>'L'</code>).</p> \n  <p>For some domino <code>answer[i]</code>, if the forces are equal, then the answer is <code>'.'</code>. Otherwise, the answer is implied by whichever force is stronger.</p> \n  <p><strong>Example</strong></p> \n  <p>Here is a worked example on the string <code>S = 'R.R...L'</code>: We find the force going from left to right is <code>[7, 6, 7, 6, 5, 4, 0]</code>. The force going from right to left is <code>[0, 0, 0, -4, -5, -6, -7]</code>. Combining them (taking their vector addition), the combined force is <code>[7, 6, 7, 2, 0, -2, -7]</code>, for a final answer of <code>RRRR.LL</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/xrAD5knD/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"xrAD5knD\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time and Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>.</li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 837,
    "article_live": true,
    "article_slug": "new-21-game",
    "title": "New 21 Game",
    "title_slug": "new-21-game",
    "content": "<p>Alice plays the following game, loosely based on the card game &quot;21&quot;.</p>\r\n\r\n<p>Alice starts with <code>0</code> points, and draws numbers while she has less than <code>K</code> points.&nbsp; During each draw, she gains an integer number of points randomly from the range <code>[1, W]</code>, where <code>W</code> is an integer.&nbsp; Each draw is independent and the outcomes have equal probabilities.</p>\r\n\r\n<p>Alice stops drawing numbers when she gets <code>K</code> or more points.&nbsp; What is the probability&nbsp;that she has <code>N</code> or less points?</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>N = 10, K = 1, W = 10\r\n<strong>Output: </strong>1.00000\r\n<strong>Explanation: </strong> Alice gets a single card, then stops.\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>N = 6, K = 1, W = 10\r\n<strong>Output: </strong>0.60000\r\n<strong>Explanation: </strong> Alice gets a single card, then stops.\r\nIn 6 out of W = 10 possibilities, she is at or below N = 6 points.\r\n</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>N = 21, K = 17, W = 10\r\n<strong>Output: </strong>0.73278</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>0 &lt;= K &lt;= N &lt;= 10000</code></li>\r\n\t<li><code>1 &lt;= W &lt;= 10000</code></li>\r\n\t<li>Answers will be accepted as correct if they are within <code>10^-5</code> of the correct answer.</li>\r\n\t<li>The judging time limit has been reduced for this question.</li>\r\n</ol>\r\n",
    "tags": "Dynamic Programming",
    "difficulty": 2,
    "frontend_article_id": 837,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-dynamic-programming-accepted\">Approach #1: Dynamic Programming [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-dynamic-programming-accepted\">Approach #1: Dynamic Programming [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>It is clear that the probability that Alice wins the game is only related to how many points <code>x</code> she starts the next draw with, so we can try to formulate an answer in terms of <code>x</code>.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Let <code>f(x)</code> be the answer when we already have <code>x</code> points. When she has between <code>K</code> and <code>N</code> points, then she stops drawing and wins. If she has more than <code>N</code> points, then she loses.</p> \n  <p>The key recursion is <script type=\"math/tex; mode=display\">f(x) = (\\frac{1}{W}) * (f(x+1) + f(x+2) + ... + f(x+W))</script> This is because there is a probability of <script type=\"math/tex; mode=display\">\\frac{1}{W}</script> to draw each card from <script type=\"math/tex; mode=display\">1</script> to <script type=\"math/tex; mode=display\">W</script>.</p> \n  <p>With this recursion, we could do a naive dynamic programming solution as follows:</p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"c1\">#psuedocode</span>\n<span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">k</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span> <span class=\"n\">when</span> <span class=\"n\">K</span> <span class=\"o\">&lt;=</span> <span class=\"n\">k</span> <span class=\"o\">&lt;=</span> <span class=\"n\">N</span><span class=\"p\">,</span> <span class=\"k\">else</span> <span class=\"mf\">0.0</span>\n<span class=\"c1\"># dp[x] = the answer when Alice has x points</span>\n<span class=\"k\">for</span> <span class=\"n\">k</span> <span class=\"kn\">from</span> <span class=\"nn\">K</span><span class=\"o\">-</span><span class=\"mi\">1</span> <span class=\"n\">to</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n    <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">k</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">k</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"o\">...</span> <span class=\"o\">+</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">k</span><span class=\"o\">+</span><span class=\"n\">W</span><span class=\"p\">])</span> <span class=\"o\">/</span> <span class=\"n\">W</span>\n<span class=\"k\">return</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n</pre>\n  </div> \n  <p>This leads to a solution with <script type=\"math/tex; mode=display\">O(K*W + (N-K))</script> time complexity, which isn't efficient enough. Every calculation of <code>dp[k]</code> does <script type=\"math/tex; mode=display\">O(W)</script> work, but the work is quite similar.</p> \n  <p>Actually, the difference is <script type=\"math/tex; mode=display\">f(x) - f(x-1) = \\frac{1}{W} \\big( f(x+W) - f(x) \\big)</script>. This allows us to calculate subsequent <script type=\"math/tex; mode=display\">f(k)</script>'s in <script type=\"math/tex; mode=display\">O(1)</script> time, by maintaining the numerator <script type=\"math/tex; mode=display\">S = f(x+1) + f(x+2) + \\cdots + f(x+W)</script>.</p> \n  <p>As we calculate each <code>dp[k] = S / W</code>, we maintain the correct value of this numerator <script type=\"math/tex; mode=display\">S \\Rightarrow S + f(k) - f(k+W)</script>.</p> \n  <iframe src=\"https://leetcode.com/playground/x4pmytdi/shared\" frameborder=\"0\" width=\"100%\" height=\"327\" name=\"x4pmytdi\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time and Space Complexity: <script type=\"math/tex; mode=display\">O(N + W)</script>.<br> Note that we can reduce the time complexity to <script type=\"math/tex; mode=display\">O(\\max(K, W))</script> and the space complexity to <script type=\"math/tex; mode=display\">O(W)</script> by only keeping track of the last <script type=\"math/tex; mode=display\">W</script> values of <code>dp</code>, but it isn't required.</li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 836,
    "article_live": true,
    "article_slug": "rectangle-overlap",
    "title": "Rectangle Overlap",
    "title_slug": "rectangle-overlap",
    "content": "<p>A rectangle is&nbsp;represented as a&nbsp;list <code>[x1, y1, x2, y2]</code>, where&nbsp;<code>(x1, y1)</code>&nbsp;are the coordinates of its bottom-left corner, and <code>(x2,&nbsp;y2)</code>&nbsp;are the coordinates of its top-right corner.</p>\r\n\r\n<p>Two rectangles overlap if the area of their intersection is positive.&nbsp; To be clear, two rectangles that only touch at the corner or edges do not overlap.</p>\r\n\r\n<p>Given two (axis-aligned) rectangles, return whether&nbsp;they overlap.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>rec1 = [0,0,2,2], rec2 = [1,1,3,3]\r\n<strong>Output: </strong>true\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>rec1 = [0,0,1,1], rec2 = [1,0,2,1]\r\n<strong>Output: </strong>false\r\n</pre>\r\n\r\n<p><strong>Notes:</strong></p>\r\n\r\n<ol>\r\n\t<li>Both rectangles <code>rec1</code> and <code>rec2</code> are lists of 4 integers.</li>\r\n\t<li>All coordinates in rectangles will be between&nbsp;<code>-10^9 </code>and<code> 10^9</code>.</li>\r\n</ol>\r\n",
    "tags": "Math",
    "difficulty": 1,
    "frontend_article_id": 836,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-check-position-accepted\">Approach #1: Check Position [Accepted]</a></li> \n    <li><a href=\"#approach-2-check-area-accepted\">Approach #2: Check Area [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-check-position-accepted\">Approach #1: Check Position [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>If the rectangles do not overlap, then <code>rec1</code> must either be higher, lower, to the left, or to the right of <code>rec2</code>.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>The answer for whether they <em>don't</em> overlap is <code>LEFT OR RIGHT OR UP OR DOWN</code>, where <code>OR</code> is the logical OR, and <code>LEFT</code> is a boolean that represents whether <code>rec1</code> is to the left of <code>rec2</code>. The answer for whether they do overlap is the negation of this.</p> \n  <p>The condition \"<code>rec1</code> is to the left of <code>rec2</code>\" is <code>rec1[2] &lt;= rec2[0]</code>, that is the right-most x-coordinate of <code>rec1</code> is left of the left-most x-coordinate of <code>rec2</code>. The other cases are similar.</p> \n  <iframe src=\"https://leetcode.com/playground/XsHWyYAa/shared\" frameborder=\"0\" width=\"100%\" height=\"191\" name=\"XsHWyYAa\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time and Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>.</li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-check-area-accepted\">Approach #2: Check Area [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>If the rectangles overlap, they have positive area. This area must be a rectangle where both dimensions are positive, since the boundaries of the intersection are axis aligned.</p> \n  <p>Thus, we can reduce the problem to the one-dimensional problem of determining whether two line segments overlap.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Say the area of the intersection is <code>width * height</code>, where <code>width</code> is the intersection of the rectangles projected onto the x-axis, and <code>height</code> is the same for the y-axis. We want both quantities to be positive.</p> \n  <p>The <code>width</code> is positive when <code>min(rec1[2], rec2[2]) &gt; max(rec1[0], rec2[0])</code>, that is when the smaller of (the largest x-coordinates) is larger than the larger of (the smallest x-coordinates). The <code>height</code> is similar.</p> \n  <iframe src=\"https://leetcode.com/playground/gthZq8DL/shared\" frameborder=\"0\" width=\"100%\" height=\"157\" name=\"gthZq8DL\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time and Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>.</li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 489,
    "article_live": false,
    "title": "Robot Room Cleaner",
    "title_slug": "robot-room-cleaner",
    "tags": "Depth-first Search",
    "difficulty": 3,
    "frontend_article_id": 489
},
{
    "frontend_question_id": 835,
    "article_live": true,
    "article_slug": "image-overlap",
    "title": "Image Overlap",
    "title_slug": "image-overlap",
    "content": "<p>Two images <code>A</code> and <code>B</code> are given, represented as&nbsp;binary, square matrices of the same size.&nbsp; (A binary matrix has only 0s and 1s as values.)</p>\r\n\r\n<p>We translate one image however we choose (sliding it left, right, up, or down any number of units), and place it on top of the other image.&nbsp; After, the <em>overlap</em> of this translation is the number of positions that have a 1 in both images.</p>\r\n\r\n<p>(Note also that a translation does <strong>not</strong> include any kind of rotation.)</p>\r\n\r\n<p>What is the largest possible overlap?</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>A = [[1,1,0],\r\n            [0,1,0],\r\n&nbsp;           [0,1,0]]\r\n&nbsp;      B = [[0,0,0],\r\n&nbsp;           [0,1,1],\r\n&nbsp;           [0,0,1]]\r\n<strong>Output: </strong>3\r\n<strong>Explanation:</strong> We slide A to right by 1 unit and down by 1 unit.</pre>\r\n\r\n<p><strong>Notes:</strong>&nbsp;</p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= A.length = A[0].length = B.length = B[0].length &lt;= 30</code></li>\r\n\t<li><code>0 &lt;=&nbsp;A[i][j], B[i][j] &lt;= 1</code></li>\r\n</ol>\r\n",
    "tags": "Array",
    "difficulty": 2,
    "frontend_article_id": 835,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-translate-by-delta-accepted\">Approach #1: Translate by Delta [Accepted]</a></li> \n    <li><a href=\"#approach-2-count-by-delta-accepted\">Approach #2: Count by Delta [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-translate-by-delta-accepted\">Approach #1: Translate by Delta [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>For each translation <code>delta</code>, we calculate the candidate answer <code>overlap(delta)</code>, which is the size of the overlap if we shifted the matrix <code>A</code> by delta.</p> \n  <p>We only need to check <code>delta</code> for which some point in <code>A</code> maps to some point in <code>B</code>, since a candidate overlap must be at least 1. Using a Set <code>seen</code>, we remember if we've calculated <code>overlap(delta)</code>, so that we don't perform this expensive check more than once per <code>delta</code>.</p> \n  <p>We use <code>java.awt.Point</code> (or <code>complex</code> in Python) to handle our 2D vectors gracefully. We could have also mapped a vector <code>delta = (x, y)</code> (which has coordinates between <code>-(N-1)</code> and <code>N-1</code>) to <code>2*N x + y</code> for convenience. Note that we cannot map it to <code>N*dx, dy</code> as there would be interference: <code>(0, N-1)</code> and <code>(1, -1)</code> would map to the same point.</p> \n  <iframe src=\"https://leetcode.com/playground/gnwqTeGt/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"gnwqTeGt\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^6)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>A</code> or <code>B</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-count-by-delta-accepted\">Approach #2: Count by Delta [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>We can do the reverse of <em>Approach #1</em>: count every possible <code>delta = b - a</code> we see. If we see say, 5 of the same <code>delta = b - a</code>, then the translation by <code>delta</code> must have overlap 5.</p> \n  <iframe src=\"https://leetcode.com/playground/YmA2kxzz/shared\" frameborder=\"0\" width=\"100%\" height=\"378\" name=\"YmA2kxzz\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^4)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>A</code> or <code>B</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 834,
    "article_live": true,
    "article_slug": "sum-of-distances-in-tree",
    "title": "Sum of Distances in Tree",
    "title_slug": "sum-of-distances-in-tree",
    "content": "<p>An undirected, connected&nbsp;tree with <code>N</code> nodes labelled <code>0...N-1</code> and <code>N-1</code> <code>edges</code>&nbsp;are&nbsp;given.</p>\r\n\r\n<p>The <code>i</code>th edge connects nodes&nbsp;<code>edges[i][0] </code>and<code>&nbsp;edges[i][1]</code>&nbsp;together.</p>\r\n\r\n<p>Return a list <code>ans</code>, where <code>ans[i]</code> is the sum of the distances between node <code>i</code> and all other nodes.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>N = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]\r\n<strong>Output: </strong>[8,12,6,10,10,10]\r\n<strong>Explanation: </strong>\r\nHere is a diagram of the given tree:\r\n  0\r\n / \\\r\n1   2\r\n   /|\\\r\n  3 4 5\r\nWe can see that dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5)\r\nequals 1 + 1 + 2 + 2 + 2 = 8.  Hence, answer[0] = 8, and so on.\r\n</pre>\r\n\r\n<p>Note:<font face=\"monospace\">&nbsp;<code>1 &lt;= N &lt;= 10000</code></font></p>\r\n",
    "tags": "Tree, Depth-first Search",
    "difficulty": 3,
    "frontend_article_id": 834,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-subtree-sum-and-count-accepted\">Approach #1: Subtree Sum and Count [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-subtree-sum-and-count-accepted\">Approach #1: Subtree Sum and Count [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Let <code>ans</code> be the returned answer, so that in particular <code>ans[x]</code> be the answer for node <code>x</code>.</p> \n  <p>Naively, finding each <code>ans[x]</code> would take <script type=\"math/tex; mode=display\">O(N)</script> time (where <script type=\"math/tex; mode=display\">N</script> is the number of nodes in the graph), which is too slow. This is the motivation to find out how <code>ans[x]</code> and <code>ans[y]</code> are related, so that we cut down on repeated work.</p> \n  <p>Let's investigate the answers of neighboring nodes <script type=\"math/tex; mode=display\">x</script> and <script type=\"math/tex; mode=display\">y</script>. In particular, say <script type=\"math/tex; mode=display\">xy</script> is an edge of the graph, that if cut would form two trees <script type=\"math/tex; mode=display\">X</script> (containing <script type=\"math/tex; mode=display\">x</script>) and <script type=\"math/tex; mode=display\">Y</script> (containing <script type=\"math/tex; mode=display\">y</script>).</p> \n  <p></p>\n  <center> \n   <img src=\"../Figures/834/sketch1.png\" alt=\"Tree diagram illustrating recurrence for ans[child]\" style=\"width: 1000px;\"> \n  </center>\n  <p></p> \n  <p>Then, as illustrated in the diagram, the answer for <script type=\"math/tex; mode=display\">x</script> in the entire tree, is the answer of <script type=\"math/tex; mode=display\">x</script> on <script type=\"math/tex; mode=display\">X</script> <code>\"x@X\"</code>, plus the answer of <script type=\"math/tex; mode=display\">y</script> on <script type=\"math/tex; mode=display\">Y</script> <code>\"y@Y\"</code>, plus the number of nodes in <script type=\"math/tex; mode=display\">Y</script> <code>\"#(Y)\"</code>. The last part <code>\"#(Y)\"</code> is specifically because for any node <code>z in Y</code>, <code>dist(x, z) = dist(y, z) + 1</code>.</p> \n  <p>By similar reasoning, the answer for <script type=\"math/tex; mode=display\">y</script> in the entire tree is <code>ans[y] = x@X + y@Y + #(X)</code>. Hence, for neighboring nodes <script type=\"math/tex; mode=display\">x</script> and <script type=\"math/tex; mode=display\">y</script>, <code>ans[x] - ans[y] = #(Y) - #(X)</code>.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Root the tree. For each node, consider the subtree <script type=\"math/tex; mode=display\">S_{\\text{node}}</script> of that node plus all descendants. Let <code>count[node]</code> be the number of nodes in <script type=\"math/tex; mode=display\">S_{\\text{node}}</script>, and <code>stsum[node]</code> (\"subtree sum\") be the sum of the distances from <code>node</code> to the nodes in <script type=\"math/tex; mode=display\">S_{\\text{node}}</script>.</p> \n  <p>We can calculate <code>count</code> and <code>stsum</code> using a post-order traversal, where on exiting some <code>node</code>, the <code>count</code> and <code>stsum</code> of all descendants of this node is correct, and we now calculate <code>count[node] += count[child]</code> and <code>stsum[node] += stsum[child] + count[child]</code>.</p> \n  <p>This will give us the right answer for the <code>root</code>: <code>ans[root] = stsum[root]</code>.</p> \n  <p>Now, to use the insight explained previously: if we have a node <code>parent</code> and it's child <code>child</code>, then these are neighboring nodes, and so <code>ans[child] = ans[parent] - count[child] + (N - count[child])</code>. This is because there are <code>count[child]</code> nodes that are <code>1</code> easier to get to from <code>child</code> than <code>parent</code>, and <code>N-count[child]</code> nodes that are <code>1</code> harder to get to from <code>child</code> than <code>parent</code>.</p> \n  <p></p>\n  <center> \n   <img src=\"../Figures/834/sketch2.png\" alt=\"Tree diagram illustrating recurrence for ans[child]\" style=\"height: 200px;\"> \n  </center>\n  <p></p> \n  <p>Using a second, pre-order traversal, we can update our answer in linear time for all of our nodes.</p> \n  <iframe src=\"https://leetcode.com/playground/u5mhW6AL/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"u5mhW6AL\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of nodes in the graph.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 833,
    "article_live": true,
    "article_slug": "find-and-replace-in-string",
    "title": "Find And Replace in String",
    "title_slug": "find-and-replace-in-string",
    "content": "<p>To some string <code>S</code>, we will perform some&nbsp;replacement&nbsp;operations that replace groups of letters with new ones (not necessarily the same size).</p>\r\n\r\n<p>Each replacement operation has <code>3</code> parameters: a starting index <code>i</code>, a source word&nbsp;<code>x</code>&nbsp;and a target word&nbsp;<code>y</code>.&nbsp; The rule is that if <code><font face=\"monospace\">x</font></code>&nbsp;starts at position <code>i</code>&nbsp;in the <strong>original</strong> <strong>string</strong> <strong><code>S</code></strong>, then we will replace that occurrence of&nbsp;<code>x</code>&nbsp;with&nbsp;<code>y</code>.&nbsp; If not, we do nothing.</p>\r\n\r\n<p>For example, if we have&nbsp;<code>S = &quot;abcd&quot;</code>&nbsp;and we have some replacement operation&nbsp;<code>i = 2, x = &quot;cd&quot;, y = &quot;ffff&quot;</code>, then because&nbsp;<code>&quot;cd&quot;</code>&nbsp;starts at position <code><font face=\"monospace\">2</font></code>&nbsp;in the original string <code>S</code>, we will replace it with <code>&quot;ffff&quot;</code>.</p>\r\n\r\n<p>Using another example on <code>S = &quot;abcd&quot;</code>, if we have both the replacement operation <code>i = 0, x = &quot;ab&quot;, y = &quot;eee&quot;</code>, as well as another replacement operation&nbsp;<code>i = 2, x = &quot;ec&quot;, y = &quot;ffff&quot;</code>, this second operation does nothing because in the original string&nbsp;<code>S[2] = &#39;c&#39;</code>, which doesn&#39;t match&nbsp;<code>x[0] = &#39;e&#39;</code>.</p>\r\n\r\n<p>All these operations occur simultaneously.&nbsp; It&#39;s guaranteed that there won&#39;t be any overlap in replacement: for example,&nbsp;<code>S = &quot;abc&quot;, indexes = [0, 1],&nbsp;sources = [&quot;ab&quot;,&quot;bc&quot;]</code> is not a valid test case.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>S = &quot;abcd&quot;, indexes = [0,2], sources = [&quot;a&quot;,&quot;cd&quot;], targets = [&quot;eee&quot;,&quot;ffff&quot;]\r\n<strong>Output: </strong>&quot;eeebffff&quot;\r\n<strong>Explanation:</strong> &quot;a&quot; starts at index 0 in S, so it&#39;s replaced by &quot;eee&quot;.\r\n&quot;cd&quot; starts at index 2 in S, so it&#39;s replaced by &quot;ffff&quot;.\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>S = &quot;abcd&quot;, indexes = [0,2], sources = [&quot;ab&quot;,&quot;ec&quot;], targets = [&quot;eee&quot;,&quot;ffff&quot;]\r\n<strong>Output: </strong>&quot;eeecd&quot;\r\n<strong>Explanation:</strong> &quot;ab&quot; starts at index 0 in S, so it&#39;s replaced by &quot;eee&quot;. \r\n&quot;ec&quot; doesn&#39;t starts at index 2 in the <strong>original</strong> S, so we do nothing.\r\n</pre>\r\n\r\n<p>Notes:</p>\r\n\r\n<ol>\r\n\t<li><code>0 &lt;=&nbsp;indexes.length =&nbsp;sources.length =&nbsp;targets.length &lt;= 100</code></li>\r\n\t<li><code>0&nbsp;&lt;&nbsp;indexes[i]&nbsp;&lt; S.length &lt;= 1000</code></li>\r\n\t<li>All characters in given inputs are lowercase letters.</li>\r\n</ol>\r\n\r\n<p>&nbsp;</p>\r\n",
    "tags": "String",
    "difficulty": 2,
    "frontend_article_id": 833,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-direct-accepted\">Approach #1: Direct [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-direct-accepted\">Approach #1: Direct [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>We showcase two different approaches. In both approaches, we build some answer string <code>ans</code>, that starts as <code>S</code>. Our main motivation in these approaches is to be able to identify and handle when a given replacement operation does nothing.</p> \n  <p>In <em>Java</em>, the idea is to build an array <code>match</code> that tells us <code>match[ix] = j</code> whenever <code>S[ix]</code> is the head of a successful replacement operation <code>j</code>: that is, whenever <code>S[ix:].startswith(sources[j])</code>.</p> \n  <p>After, we build the answer using this match array. For each index <code>ix</code> in <code>S</code>, we can use <code>match</code> to check whether <code>S[ix]</code> is being replaced or not. We repeatedly either write the next character <code>S[ix]</code>, or groups of characters <code>targets[match[ix]]</code>, depending on the value of <code>match[ix]</code>.</p> \n  <p>In <em>Python</em>, we sort our replacement jobs <code>(i, x, y)</code> in reverse order. If <code>S[i:].startswith(x)</code>, then we can replace that section <code>S[i:i+len(x)]</code> with the target <code>y</code>. We used a reverse order so that edits to <code>S</code> do not interfere with the rest of the queries.</p> \n  <iframe src=\"https://leetcode.com/playground/2qLJpytD/shared\" frameborder=\"0\" width=\"100%\" height=\"480\" name=\"2qLJpytD\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(NQ)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>S</code>, and we have <script type=\"math/tex; mode=display\">Q</script> replacement operations. (Our complexity could be faster with a more accurate implementation, but it isn't necessary.)</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, if we consider <code>targets[i].length &lt;= 100</code> as a constant bound.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 832,
    "article_live": true,
    "article_slug": "flipping-an-image",
    "title": "Flipping an Image",
    "title_slug": "flipping-an-image",
    "content": "<p>Given a binary matrix <code>A</code>, we want to flip the image horizontally, then invert it, and return the resulting image.</p>\r\n\r\n<p>To flip an image horizontally means that each row of the image is reversed.&nbsp; For example, flipping&nbsp;<code>[1, 1, 0]</code>&nbsp;horizontally results in&nbsp;<code>[0, 1, 1]</code>.</p>\r\n\r\n<p>To invert an image means&nbsp;that each <code>0</code> is replaced by <code>1</code>, and each <code>1</code> is replaced by <code>0</code>.&nbsp;For example, inverting&nbsp;<code>[0, 1, 1]</code>&nbsp;results in&nbsp;<code>[1, 0, 0]</code>.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>[[1,1,0],[1,0,1],[0,0,0]]\r\n<strong>Output: </strong>[[1,0,0],[0,1,0],[1,1,1]]\r\n<strong>Explanation:</strong> First reverse each row: [[0,1,1],[1,0,1],[0,0,0]].\r\nThen, invert the image: [[1,0,0],[0,1,0],[1,1,1]]\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>[[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]\r\n<strong>Output: </strong>[[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]\r\n<strong>Explanation:</strong> First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]].\r\nThen invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]\r\n</pre>\r\n\r\n<p><strong>Notes:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= A.length = A[0].length &lt;= 20</code></li>\r\n\t<li><code>0 &lt;= A[i][j]<font face=\"sans-serif, Arial, Verdana, Trebuchet MS\">&nbsp;&lt;=&nbsp;</font>1</code></li>\r\n</ul>\r\n",
    "tags": "Array",
    "difficulty": 1,
    "frontend_article_id": 832,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-direct-accepted\">Approach #1: Direct [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-direct-accepted\">Approach #1: Direct [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>We can do this in place. In each row, the <code>i</code>th value from the left is equal to the inverse of the <code>i</code>th value from the right.</p> \n  <p>We use <code>(C+1) / 2</code> (with floor division) to iterate over all indexes <code>i</code> in the first half of the row, including the center.</p> \n  <iframe src=\"https://leetcode.com/playground/rePZz3yF/shared\" frameborder=\"0\" width=\"100%\" height=\"276\" name=\"rePZz3yF\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <code>N</code> is the total number of elements in <code>A</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script> in <em>additional</em> space complexity.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 622,
    "article_live": false,
    "title": "Design Circular Queue",
    "title_slug": "design-circular-queue",
    "content": "<p>Design your implementation of the circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO (First In First Out) principle and the last position is connected back to the first position to make a circle. It is also called &quot;Ring Buffer&quot;.</p>\r\n\r\n<p>One of the benefits of the circular queue is that we can make use of the spaces in front of the queue. In a normal queue, once the queue becomes full, we cannot insert the next element even if there is a space in front of the queue. But using the circular queue, we can use the space to store new values.</p>\r\n\r\n<p>Your implementation should support following operations:</p>\r\n\r\n<ul>\r\n\t<li><code>MyCircularQueue(k)</code>: Constructor, set the size of the queue to be k.</li>\r\n\t<li><code>Front</code>: Get the front item from the queue. If the queue is empty, return -1.</li>\r\n\t<li><code>Rear</code>: Get the last item from the queue. If the queue is empty, return -1.</li>\r\n\t<li><code>enQueue(value)</code>: Insert an element into the circular queue. Return true if the operation is successful.</li>\r\n\t<li><code>deQueue()</code>: Delete an element from the circular queue. Return true if the operation is successful.</li>\r\n\t<li><code>isEmpty()</code>: Checks whether the circular queue is empty or not.</li>\r\n\t<li><code>isFull()</code>: Checks whether the circular queue is full or not.</li>\r\n</ul>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\nMyCircularQueue circularQueue = new MycircularQueue(3); // set the size to be 3\r\ncircularQueue.enQueue(1); &nbsp;// return true\r\ncircularQueue.enQueue(2); &nbsp;// return true\r\ncircularQueue.enQueue(3); &nbsp;// return true\r\ncircularQueue.enQueue(4); &nbsp;// return false, the queue is full\r\ncircularQueue.Rear(); &nbsp;// return 3\r\ncircularQueue.isFull(); &nbsp;// return true\r\ncircularQueue.deQueue(); &nbsp;// return true\r\ncircularQueue.enQueue(4); &nbsp;// return true\r\ncircularQueue.Rear(); &nbsp;// return 4\r\n</pre>\r\n&nbsp;\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>All values will be in the range of [0, 1000].</li>\r\n\t<li>The number of operations will be in the range of&nbsp;[1, 1000].</li>\r\n\t<li>Please do not use the built-in Queue library.</li>\r\n</ul>\r\n",
    "tags": "Design, Queue",
    "difficulty": 2,
    "frontend_article_id": 622
},
{
    "frontend_question_id": 641,
    "article_live": false,
    "title": "Design Circular Deque",
    "title_slug": "design-circular-deque",
    "content": "<p>Design your implementation of the circular double-ended queue (deque).</p>\r\n\r\n<p>Your implementation should support following operations:</p>\r\n\r\n<ul>\r\n\t<li><code>MyCircularDeque(k)</code>: Constructor, set the size of the deque to be k.</li>\r\n\t<li><code>insertFront()</code>: Adds an item at the front of Deque. Return true if the operation is successful.</li>\r\n\t<li><code>insertLast()</code>: Adds an item at the rear of Deque. Return true if the operation is successful.</li>\r\n\t<li><code>deleteFront()</code>: Deletes an item from the front of Deque. Return true if the operation is successful.</li>\r\n\t<li><code>deleteLast()</code>: Deletes an item from the rear of Deque. Return true if the operation is successful.</li>\r\n\t<li><code>getFront()</code>: Gets the front item from the Deque. If the deque is empty, return -1.</li>\r\n\t<li><code>getRear()</code>: Gets the last item from Deque. If the deque is empty, return -1.</li>\r\n\t<li><code>isEmpty()</code>: Checks whether Deque is empty or not.&nbsp;</li>\r\n\t<li><code>isFull()</code>: Checks whether Deque is full or not.</li>\r\n</ul>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\nMyCircularDeque circularDeque = new MycircularDeque(3); // set the size to be 3\r\ncircularDeque.insertLast(1);\t\t\t// return true\r\ncircularDeque.insertLast(2);\t\t\t// return true\r\ncircularDeque.insertFront(3);\t\t\t// return true\r\ncircularDeque.insertFront(4);\t\t\t// return false, the queue is full\r\ncircularDeque.getRear();  \t\t\t// return 2\r\ncircularDeque.isFull();\t\t\t\t// return true\r\ncircularDeque.deleteLast();\t\t\t// return true\r\ncircularDeque.insertFront(4);\t\t\t// return true\r\ncircularDeque.getFront();\t\t\t// return 4\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>All values will be in the range of [0, 1000].</li>\r\n\t<li>The number of operations will be in the range of&nbsp;[1, 1000].</li>\r\n\t<li>Please do not use the built-in Deque library.</li>\r\n</ul>\r\n",
    "tags": "Design, Queue",
    "difficulty": 2,
    "frontend_article_id": 641
},
{
    "frontend_question_id": 831,
    "article_live": true,
    "article_slug": "masking-personal-information",
    "title": "Masking Personal Information",
    "title_slug": "masking-personal-information",
    "content": "<p>We are given a&nbsp;personal information string <code>S</code>, which may represent&nbsp;either <strong>an email address</strong> or <strong>a phone number.</strong></p>\r\n\r\n<p>We would like to mask this&nbsp;personal information according to the&nbsp;following rules:</p>\r\n\r\n<p><br />\r\n<u><strong>1. Email address:</strong></u></p>\r\n\r\n<p>We define a&nbsp;<strong>name</strong> to be a string of <code>length &ge; 2</code> consisting&nbsp;of only lowercase letters&nbsp;<code>a-z</code> or uppercase&nbsp;letters&nbsp;<code>A-Z</code>.</p>\r\n\r\n<p>An email address starts with a name, followed by the&nbsp;symbol <code>&#39;@&#39;</code>, followed by a name, followed by the&nbsp;dot&nbsp;<code>&#39;.&#39;</code>&nbsp;and&nbsp;followed by a name.&nbsp;</p>\r\n\r\n<p>All email addresses are&nbsp;guaranteed to be valid and in the format of&nbsp;<code>&quot;name1@name2.name3&quot;.</code></p>\r\n\r\n<p>To mask an email, <strong>all names must be converted to lowercase</strong> and <strong>all letters between the first and last letter of the first name</strong> must be replaced by 5 asterisks <code>&#39;*&#39;</code>.</p>\r\n\r\n<p><br />\r\n<u><strong>2. Phone number:</strong></u></p>\r\n\r\n<p>A phone number is a string consisting of&nbsp;only the digits <code>0-9</code> or the characters from the set <code>{&#39;+&#39;, &#39;-&#39;, &#39;(&#39;, &#39;)&#39;, &#39;&nbsp;&#39;}.</code>&nbsp;You may assume a phone&nbsp;number contains&nbsp;10 to 13 digits.</p>\r\n\r\n<p>The last 10 digits make up the local&nbsp;number, while the digits before those make up the country code. Note that&nbsp;the country code is optional. We want to expose only the last 4 digits&nbsp;and mask all other&nbsp;digits.</p>\r\n\r\n<p>The local&nbsp;number&nbsp;should be formatted and masked as <code>&quot;***-***-1111&quot;,&nbsp;</code>where <code>1</code> represents the exposed digits.</p>\r\n\r\n<p>To mask a phone number with country code like <code>&quot;+111 111 111 1111&quot;</code>, we write it in the form <code>&quot;+***-***-***-1111&quot;.</code>&nbsp; The <code>&#39;+&#39;</code>&nbsp;sign and the first <code>&#39;-&#39;</code>&nbsp;sign before the local number should only exist if there is a country code.&nbsp; For example, a 12 digit phone number mask&nbsp;should start&nbsp;with <code>&quot;+**-&quot;</code>.</p>\r\n\r\n<p>Note that extraneous characters like <code>&quot;(&quot;, &quot;)&quot;, &quot; &quot;</code>, as well as&nbsp;extra dashes or plus signs not part of the above formatting scheme should be removed.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Return the correct &quot;mask&quot; of the information provided.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>&quot;LeetCode@LeetCode.com&quot;\r\n<strong>Output: </strong>&quot;l*****e@leetcode.com&quot;\r\n<strong>Explanation:&nbsp;</strong>All names are converted to lowercase, and the letters between the\r\n&nbsp;            first and last letter of the first name is replaced by 5 asterisks.\r\n&nbsp;            Therefore, &quot;leetcode&quot; -&gt; &quot;l*****e&quot;.\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>&quot;AB@qq.com&quot;\r\n<strong>Output: </strong>&quot;a*****b@qq.com&quot;\r\n<strong>Explanation:&nbsp;</strong>There must be 5 asterisks between the first and last letter \r\n&nbsp;            of the first name &quot;ab&quot;. Therefore, &quot;ab&quot; -&gt; &quot;a*****b&quot;.\r\n</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>&quot;1(234)567-890&quot;\r\n<strong>Output: </strong>&quot;***-***-7890&quot;\r\n<strong>Explanation:</strong>&nbsp;10 digits in the phone number, which means all digits make up the local number.\r\n</pre>\r\n\r\n<p><strong>Example 4:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>&quot;86-(10)12345678&quot;\r\n<strong>Output: </strong>&quot;+**-***-***-5678&quot;\r\n<strong>Explanation:</strong>&nbsp;12 digits, 2 digits for country code and 10 digits for local number. \r\n</pre>\r\n\r\n<p><strong>Notes:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>S.length&nbsp;&lt;=&nbsp;40</code>.</li>\r\n\t<li>Emails have length at least 8.</li>\r\n\t<li>Phone numbers have length at least 10.</li>\r\n</ol>\r\n",
    "tags": "String",
    "difficulty": 2,
    "frontend_article_id": 831,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-direct-accepted\">Approach #1: Direct [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-direct-accepted\">Approach #1: Direct [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>We perform the algorithm as described.</p> \n  <p>First, to check if information is an email, we check whether it contains a <code>'@'</code>. (There are many different tests: we could check for letters versus digits, for example.)</p> \n  <p>If we have an email, we should replace the first name with the first letter of that name, followed by 5 asterisks, followed by the last letter of that name.</p> \n  <p>If we have a phone number, we should collect all the digits and then format it according to the description.</p> \n  <iframe src=\"https://leetcode.com/playground/9iWWL6yp/shared\" frameborder=\"0\" width=\"100%\" height=\"327\" name=\"9iWWL6yp\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(1)</script>, if we consider the length of <code>S</code> as bounded by a constant.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 830,
    "article_live": true,
    "article_slug": "positions-of-large-groups",
    "title": "Positions of Large Groups",
    "title_slug": "positions-of-large-groups",
    "content": "<p>In a string&nbsp;<code>S</code>&nbsp;of lowercase letters, these letters form consecutive groups of the same character.</p>\r\n\r\n<p>For example, a string like <code>S = &quot;abbxxxxzyy&quot;</code> has the groups <code>&quot;a&quot;</code>, <code>&quot;bb&quot;</code>, <code>&quot;xxxx&quot;</code>, <code>&quot;z&quot;</code> and&nbsp;<code>&quot;yy&quot;</code>.</p>\r\n\r\n<p>Call a group <em>large</em> if it has 3 or more characters.&nbsp; We would like the starting and ending positions of every large group.</p>\r\n\r\n<p>The final answer should be in lexicographic order.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>&quot;abbxxxxzzy&quot;\r\n<strong>Output: </strong>[[3,6]]\r\n<strong>Explanation</strong>: <code>&quot;xxxx&quot; is the single </code>large group with starting  3 and ending positions 6.\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>&quot;abc&quot;\r\n<strong>Output: </strong>[]\r\n<strong>Explanation</strong>: We have &quot;a&quot;,&quot;b&quot; and &quot;c&quot; but no large group.\r\n</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>&quot;abcdddeeeeaabbbcd&quot;\r\n<strong>Output: </strong>[[3,5],[6,9],[12,14]]</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:&nbsp;</strong>&nbsp;<code>1 &lt;= S.length &lt;= 1000</code></p>\r\n",
    "tags": "Array",
    "difficulty": 1,
    "frontend_article_id": 830,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-two-pointer-accepted\">Approach #1: Two Pointer [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-two-pointer-accepted\">Approach #1: Two Pointer [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>We scan through the string to identify the start and end of each group. If the size of the group is at least 3, we add it to the answer.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Maintain pointers <code>i, j</code> with <code>i &lt;= j</code>. The <code>i</code> pointer will represent the start of the current group, and we will increment <code>j</code> forward until it reaches the end of the group.</p> \n  <p>We know that we have reached the end of the group when <code>j</code> is at the end of the string, or <code>S[j] != S[j+1]</code>. At this point, we have some group <code>[i, j]</code>; and after, we will update <code>i = j+1</code>, the start of the next group.</p> \n  <iframe src=\"https://leetcode.com/playground/m9hgNCUd/shared\" frameborder=\"0\" width=\"100%\" height=\"327\" name=\"m9hgNCUd\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>S</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the space used by the answer.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 829,
    "article_live": true,
    "article_slug": "consecutive-numbers-sum",
    "title": "Consecutive Numbers Sum",
    "title_slug": "consecutive-numbers-sum",
    "content": "<p>Given a positive integer&nbsp;<code>N</code>, how many ways can we write it as a sum of&nbsp;consecutive positive integers?</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>5\r\n<strong>Output: </strong>2\r\n<strong>Explanation: </strong>5 = 5 = 2 + 3</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>9\r\n<strong>Output: </strong>3\r\n<strong>Explanation: </strong>9 = 9 = 4 + 5 = 2 + 3 + 4</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>15\r\n<strong>Output: </strong>4\r\n<strong>Explanation: </strong>15 = 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5</pre>\r\n\r\n<p><strong>Note:</strong>&nbsp;<code>1 &lt;= N &lt;= 10 ^ 9</code>.</p>\r\n",
    "tags": "Math",
    "difficulty": 3,
    "frontend_article_id": 829,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-brute-force-time-limit-exceeded\">Approach #1: Brute Force [Time Limit Exceeded]</a></li> \n    <li><a href=\"#approach-2-mathematical-naive-time-limit-exceeded\">Approach #2: Mathematical (Naive) [Time Limit Exceeded]</a></li> \n    <li><a href=\"#approach-3-mathematical-fast-accepted\">Approach #3: Mathematical (Fast) [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-brute-force-time-limit-exceeded\">Approach #1: Brute Force [Time Limit Exceeded]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>For each starting number, we scan forward until we meet or exceed the target <code>N</code>. If we meet it, then it represents one way to write <code>N</code> as a sum of consecutive numbers.</p> \n  <p>For example, if <code>N = 6</code>, and we scan forward from <code>1</code>, we'll get <code>1 + 2 + 3 = 6</code> which contributes to the answer. If we scan forward from <code>2</code>, we'll get <code>2 + 3 + 4</code> (the first time that the sum is <code>&gt;= N</code>) which is too big.</p> \n  <iframe src=\"https://leetcode.com/playground/W5wabBJ4/shared\" frameborder=\"0\" width=\"100%\" height=\"259\" name=\"W5wabBJ4\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-mathematical-naive-time-limit-exceeded\">Approach #2: Mathematical (Naive) [Time Limit Exceeded]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>We can model the situation by the equation <script type=\"math/tex; mode=display\">N = (x+1) + (x+2) + \\cdots + (x+k)</script>. Here, <script type=\"math/tex; mode=display\">x \\geq 0, k \\geq 1</script>. Using the identity <script type=\"math/tex; mode=display\">1 + 2 + \\cdots + k = \\frac{k(k+1)}{2}</script>, we can simplify this equation to <script type=\"math/tex; mode=display\">2*N = k(2*x + k + 1)</script>.</p> \n  <p>From here, clearly <script type=\"math/tex; mode=display\">1 \\leq k \\leq 2*N</script>. We can try every such <script type=\"math/tex; mode=display\">k</script>. We need <script type=\"math/tex; mode=display\">x = \\frac{\\frac{2*N}{k} - k - 1}{2}</script> to be a non-negative integer for a solution to exist for the <script type=\"math/tex; mode=display\">k</script> we are trying.</p> \n  <iframe src=\"https://leetcode.com/playground/y3LRDRHT/shared\" frameborder=\"0\" width=\"100%\" height=\"276\" name=\"y3LRDRHT\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-mathematical-fast-accepted\">Approach #3: Mathematical (Fast) [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>As in <em>Approach #2</em>, <script type=\"math/tex; mode=display\">2*N = k(2*x + k + 1)</script> with <script type=\"math/tex; mode=display\">x \\geq 0, k \\geq 1</script>. Call <script type=\"math/tex; mode=display\">k</script> the first factor, and <script type=\"math/tex; mode=display\">2*x + k + 1</script> the second factor. We are looking for ways to solve this equation without trying all <script type=\"math/tex; mode=display\">2*N</script> possibilities.</p> \n  <p>Now notice that the parity of <script type=\"math/tex; mode=display\">k</script> and <script type=\"math/tex; mode=display\">(2*x + k + 1)</script> are different. That is, if <script type=\"math/tex; mode=display\">k</script> is even then the other quantity is odd, and vice versa. Also, <script type=\"math/tex; mode=display\">2*x + k + 1 \\geq k + 1 > k</script>, so the second factor must be bigger.</p> \n  <p>Now write <script type=\"math/tex; mode=display\">2N = 2^\\alpha * M</script> where <script type=\"math/tex; mode=display\">M</script> is odd. If we factor <script type=\"math/tex; mode=display\">M = a * b</script>, then two candidate solutions are <script type=\"math/tex; mode=display\">k = a, 2x+k+1 = b * 2^\\alpha</script>, or <script type=\"math/tex; mode=display\">k = a * 2^\\alpha, 2x+k+1 = b</script>. However, only one of these solutions will have the second factor larger than the first. (Because <script type=\"math/tex; mode=display\">\\alpha \\geq 1</script>, we are guaranteed that one factor is strictly larger.)</p> \n  <p>Thus, the answer is the number of ways to factor the odd part of <script type=\"math/tex; mode=display\">N</script>.</p> \n  <iframe src=\"https://leetcode.com/playground/RNh28dQE/shared\" frameborder=\"0\" width=\"100%\" height=\"378\" name=\"RNh28dQE\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(\\sqrt(N))</script>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 828,
    "article_live": true,
    "article_slug": "unique-letter-string",
    "title": "Unique Letter String",
    "title_slug": "unique-letter-string",
    "content": "<p>A character is unique in string <code>S</code> if it occurs exactly once in it.</p>\r\n\r\n<p>For example, in string <code>S = &quot;LETTER&quot;</code>, the only unique characters are <code>&quot;L&quot;</code> and <code>&quot;R&quot;</code>.</p>\r\n\r\n<p>Let&#39;s define <code>UNIQ(S)</code> as the number of unique characters in string <code>S</code>.</p>\r\n\r\n<p>For example, <code>UNIQ(&quot;LETTER&quot;) =&nbsp; 2</code>.</p>\r\n\r\n<p>Given a string <code>S</code> with only uppercases, calculate the sum of <code>UNIQ(substring)</code> over all non-empty substrings of <code>S</code>.</p>\r\n\r\n<p>If there are two or more equal substrings at different positions in <code>S</code>, we consider them different.</p>\r\n\r\n<p>Since the answer can be very large, return&nbsp;the answer&nbsp;modulo&nbsp;<code>10 ^ 9 + 7</code>.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>&quot;ABC&quot;\r\n<strong>Output: </strong>10\r\n<strong>Explanation: </strong>All possible substrings are: &quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;AB&quot;,&quot;BC&quot; and &quot;ABC&quot;.\r\nEvey substring is composed with only unique letters.\r\nSum of lengths of all substring is 1 + 1 + 1 + 2 + 2 + 3 = 10</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>&quot;ABA&quot;\r\n<strong>Output: </strong>8\r\n<strong>Explanation: </strong>The same as example 1, except uni(&quot;ABA&quot;) = 1.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong> <code>0 &lt;= S.length &lt;= 10000</code>.</p>\r\n",
    "tags": "Two Pointers",
    "difficulty": 3,
    "frontend_article_id": 828,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-maintain-answer-of-suffix-accepted\">Approach #1: Maintain Answer of Suffix [Accepted]</a></li> \n    <li><a href=\"#approach-2-split-by-character-accepted\">Approach #2: Split by Character [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-maintain-answer-of-suffix-accepted\">Approach #1: Maintain Answer of Suffix [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>We can think of substrings as two for-loops, for the left and right boundary of the substring. To get a handle on this problem, let's try to answer the question: what is the answer over all substrings that start at index <code>i</code>? Let's call this <script type=\"math/tex; mode=display\">F(i)</script>. If we can compute this faster than linear (brute force), we have an approach.</p> \n  <p>Now let <script type=\"math/tex; mode=display\">U</script> be the unique letters function, eg. <script type=\"math/tex; mode=display\">U(\\text{\"LETTER\"}) = 2</script>.</p> \n  <p>The key idea is we can write <script type=\"math/tex; mode=display\">U</script> as a sum of disjoint functions over each character. Let <script type=\"math/tex; mode=display\">U_{\\text{\"A\"}}(x)</script> be <script type=\"math/tex; mode=display\">1</script> if <script type=\"math/tex; mode=display\">\\text{\"A\"}</script> occurs exactly once in <script type=\"math/tex; mode=display\">x</script>, otherwise <script type=\"math/tex; mode=display\">0</script>, and so on with every letter. Then <script type=\"math/tex; mode=display\">U(x) = \\sum_{c \\in \\mathcal{A}} U_c(x)</script>, where <script type=\"math/tex; mode=display\">\\mathcal{A} = \\{ \\text{\"A\"}, \\text{\"B\"}, \\dots \\}</script> is the alphabet.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>This means we only need to answer the following question (26 times, one for each character): how many substrings have exactly one <script type=\"math/tex; mode=display\">\\text{\"A\"}</script>? If we knew that <code>S[10] = S[14] = S[20] = \"A\"</code> (and only those indexes have an <code>\"A\"</code>), then when <code>i = 8</code>, the answer is <code>4</code> (<code>j = 10, 11, 12, 13</code>); when <code>i = 12</code> the answer is <code>6</code> (<code>j = 14, 15, 16, 17, 18, 19</code>), and so on.</p> \n  <p>In total, <script type=\"math/tex; mode=display\">F(0) = \\sum_{c \\in \\mathcal{A}} \\text{index}[c][1] - \\text{index}[c][0]</script>, where <code>index[c]</code> are the indices <code>i</code> (in order) where <code>S[i] == c</code> (and padded with <code>S.length</code> if out of bounds). In the above example, <code>index[\"A\"] = [10, 14, 20]</code>.</p> \n  <p>Now, we want the final answer of <script type=\"math/tex; mode=display\">\\sum_{i \\geq 0} F(i)</script>. There is a two pointer approach: how does <script type=\"math/tex; mode=display\">F(1)</script> differ from <script type=\"math/tex; mode=display\">F(0)</script>? If for example <code>S[0] == \"B\"</code>, then most of the sum remains unchanged (specifically, <script type=\"math/tex; mode=display\">\\sum_{c \\in \\mathcal{A}, c \\neq \\text{\"B\"}} \\text{index}[c][1] - \\text{index}[c][0]</script>), and only the <script type=\"math/tex; mode=display\">c = \\text{\"B\"}</script> part changes, from <script type=\"math/tex; mode=display\">\\text{index}[\\text{\"B\"}][1] - \\text{index}[\\text{\"B\"}][0]</script> to <script type=\"math/tex; mode=display\">\\text{index}[\\text{\"B\"}][2] - \\text{index}[\\text{\"B\"}][1]</script>.</p> \n  <p>We can manage this in general by keeping track of <code>peek[c]</code>, which tells us the correct index <code>i = peek[c]</code> such that our current contribution by character <code>c</code> of <script type=\"math/tex; mode=display\">F(i)</script> is <code>index[c][peek[c] + 1] - index[c][peek[c]]</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/fkvb227q/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"fkvb227q\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>S</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-split-by-character-accepted\">Approach #2: Split by Character [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>As in <em>Approach #1</em>, we have <script type=\"math/tex; mode=display\">U(x) = \\sum_{c \\in \\mathcal{A}} U_c(x)</script>, where <script type=\"math/tex; mode=display\">\\mathcal{A} = \\{ \\text{\"A\"}, \\text{\"B\"}, \\dots \\}</script> is the alphabet, and we only need to answer the following question (26 times, one for each character): how many substrings have exactly one <script type=\"math/tex; mode=display\">\\text{\"A\"}</script>?</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Consider how many substrings have a specific <script type=\"math/tex; mode=display\">\\text{\"A\"}</script>. For example, let's say <code>S</code> only has three <code>\"A\"</code>'s, at '<code>S[10] = S[14] = S[20] = \"A\"</code>; and we want to know the number of substrings that contain <code>S[14]</code>. The answer is that there are 4 choices for the left boundary of the substring <code>(11, 12, 13, 14)</code>, and 6 choices for the right boundary <code>(14, 15, 16, 17, 18, 19)</code>. So in total, there are 24 substrings that have <code>S[14]</code> as their unique <code>\"A\"</code>.</p> \n  <p>Continuing our example, if we wanted to count the number of substrings that have <code>S[10]</code>, this would be <code>10 * 4</code> - note that when there is no more <code>\"A\"</code> characters to the left of <code>S[10]</code>, we have to count up to the left edge of the string.</p> \n  <p>We can add up all these possibilities to get our final answer.</p> \n  <iframe src=\"https://leetcode.com/playground/qiRvovcd/shared\" frameborder=\"0\" width=\"100%\" height=\"395\" name=\"qiRvovcd\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>S</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. We could reduce this to <script type=\"math/tex; mode=display\">O(\\mathcal{A})</script> if we do not store all the indices, but compute the answer on the fly.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>. Approach #2 inspired by <a href=\"https://leetcode.com/lee215\">@lee215</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 827,
    "article_live": true,
    "article_slug": "making-a-large-island",
    "title": "Making A Large Island",
    "title_slug": "making-a-large-island",
    "content": "<p>In a 2D grid of <code>0</code>s and <code>1</code>s, we change at most one <code>0</code> to a <code>1</code>.</p>\r\n\r\n<p>After, what is the size of the largest island?&nbsp;(An island is a 4-directionally connected group of <code>1</code>s).</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>[[1, 0], [0, 1]]\r\n<strong>Output:</strong> 3\r\n<strong>Explanation:</strong> Change one 0 to 1 and connect two 1s, then we get an island with area = 3.\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>[[1, 1], [1, 0]]\r\n<strong>Output:</strong> 4\r\n<strong>Explanation: </strong>Change the 0 to 1 and make the island bigger, only one island with area = 4.</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>[[1, 1], [1, 1]]\r\n<strong>Output:</strong> 4\r\n<strong>Explanation:</strong> Can&#39;t change any 0 to 1, only one island with area = 4.</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Notes:</p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= grid.length = grid[0].length &lt;= 50</code>.</li>\r\n\t<li><code>0 &lt;= grid[i][j] &lt;= 1</code>.</li>\r\n</ul>\r\n\r\n<p>&nbsp;</p>\r\n",
    "tags": "Depth-first Search",
    "difficulty": 3,
    "frontend_article_id": 827,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-naive-depth-first-search-time-limit-exceeded\">Approach #1: (Naive) Depth First Search [Time Limit Exceeded]</a></li> \n    <li><a href=\"#approach-2-component-sizes-accepted\">Approach #2: Component Sizes [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-naive-depth-first-search-time-limit-exceeded\">Approach #1: (Naive) Depth First Search [Time Limit Exceeded]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>For each <code>0</code> in the grid, let's temporarily change it to a <code>1</code>, then count the size of the group from that square.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>For each <code>0</code>, change it to a <code>1</code>, then do a depth first search to find the size of that component. The answer is the maximum size component found.</p> \n  <p>Of course, if there is no <code>0</code> in the grid, then the answer is the size of the whole grid.</p> \n  <iframe src=\"https://leetcode.com/playground/T2PdhCGT/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"T2PdhCGT\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^4)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length and width of the <code>grid</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, the additional space used in the depth first search by <code>stack</code> and <code>seen</code>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-component-sizes-accepted\">Approach #2: Component Sizes [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>As in the previous solution, we check every <code>0</code>. However, we also store the size of each group, so that we do not have to use depth-first search to repeatedly calculate the same size.</p> \n  <p>However, this idea fails when the <code>0</code> touches the same group. For example, consider <code>grid = [[0,1],[1,1]]</code>. The answer is <code>4</code>, not <code>1 + 3 + 3</code>, since the right neighbor and the bottom neighbor of the <code>0</code> belong to the same group.</p> \n  <p>We can remedy this problem by keeping track of a group id (or index), that is unique for each group. Then, we'll only add areas of neighboring groups with different ids.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>For each group, fill it with value <code>index</code> and remember it's size as <code>area[index] = dfs(...)</code>.</p> \n  <p>Then for each <code>0</code>, look at the neighboring group ids <code>seen</code> and add the area of those groups, plus 1 for the <code>0</code> we are toggling. This gives us a candidate answer, and we take the maximum.</p> \n  <p>To solve the issue of having potentially no <code>0</code>, we take the maximum of the previously calculated areas.</p> \n  <iframe src=\"https://leetcode.com/playground/ZBn4MTj4/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"ZBn4MTj4\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length and width of the <code>grid</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, the additional space used in the depth first search by <code>area</code>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>. Idea for Solution #2 by <a href=\"https://leetcode.com/lee215\">@lee215</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 826,
    "article_live": true,
    "article_slug": "most-profit-assigning-work",
    "title": "Most Profit Assigning Work",
    "title_slug": "most-profit-assigning-work",
    "content": "<p>We have jobs: <code>difficulty[i]</code>&nbsp;is the difficulty of the&nbsp;<code>i</code>th job, and&nbsp;<code>profit[i]</code>&nbsp;is the profit of the&nbsp;<code>i</code>th job.&nbsp;</p>\r\n\r\n<p>Now we have some workers.&nbsp;<code>worker[i]</code>&nbsp;is the ability of the&nbsp;<code>i</code>th worker, which means that this worker can only complete a job with difficulty at most&nbsp;<code>worker[i]</code>.&nbsp;</p>\r\n\r\n<p>Every worker can be assigned at most one job, but one job&nbsp;can be completed multiple times.</p>\r\n\r\n<p>For example, if 3 people attempt the same job that pays $1, then the total profit will be $3.&nbsp; If a worker cannot complete any job, his profit is $0.</p>\r\n\r\n<p>What is the most profit we can make?</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]\r\n<strong>Output: </strong>100 \r\n<strong>Explanation: W</strong>orkers are assigned jobs of difficulty [4,4,6,6] and they get profit of [20,20,30,30] seperately.</pre>\r\n\r\n<p><strong>Notes:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= difficulty.length = profit.length &lt;= 10000</code></li>\r\n\t<li><code>1 &lt;= worker.length &lt;= 10000</code></li>\r\n\t<li><code>difficulty[i], profit[i], worker[i]</code>&nbsp; are in range&nbsp;<code>[1, 10^5]</code></li>\r\n</ul>\r\n",
    "tags": "Two Pointers",
    "difficulty": 2,
    "frontend_article_id": 826,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-sorting-events-accepted\">Approach #1: Sorting Events [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-sorting-events-accepted\">Approach #1: Sorting Events [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>We can consider the workers in any order, so let's process them in order of skill.</p> \n  <p>If we processed all jobs with lower skill first, then the profit is just the most profitable job we have seen so far.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>We can use a \"two pointer\" approach to process jobs in order. We will keep track of <code>best</code>, the maximum profit seen.</p> \n  <p>For each worker with a certain <code>skill</code>, after processing all jobs with lower or equal difficulty, we add <code>best</code> to our answer.</p> \n  <iframe src=\"https://leetcode.com/playground/52pUn6By/shared\" frameborder=\"0\" width=\"100%\" height=\"412\" name=\"52pUn6By\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N \\log N + Q \\log Q)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of jobs, and <script type=\"math/tex; mode=display\">Q</script> is the number of people.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the additional space used by <code>jobs</code>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 825,
    "article_live": true,
    "article_slug": "friends-of-appropriate-ages",
    "title": "Friends Of Appropriate Ages",
    "title_slug": "friends-of-appropriate-ages",
    "content": "<p>Some people will make friend requests. The&nbsp;list of their ages is given and&nbsp;<code>ages[i]</code>&nbsp;is the age of the&nbsp;ith person.&nbsp;</p>\r\n\r\n<p>Person A will NOT friend request person B (B != A) if any of the following conditions are true:</p>\r\n\r\n<ul>\r\n\t<li><code>age[B]&nbsp;&lt;= 0.5 * age[A]&nbsp;+ 7</code></li>\r\n\t<li><code>age[B]&nbsp;&gt; age[A]</code></li>\r\n\t<li><code>age[B]&nbsp;&gt; 100 &amp;&amp;&nbsp;age[A]&nbsp;&lt; 100</code></li>\r\n</ul>\r\n\r\n<p>Otherwise, A will friend request B.</p>\r\n\r\n<p>Note that if&nbsp;A requests B, B does not necessarily request A.&nbsp; Also, people will not friend request themselves.</p>\r\n\r\n<p>How many total friend requests are made?</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>[16,16]\r\n<strong>Output: </strong>2\r\n<strong>Explanation: </strong>2 people friend request each other.\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>[16,17,18]\r\n<strong>Output: </strong>2\r\n<strong>Explanation: </strong>Friend requests are made 17 -&gt; 16, 18 -&gt; 17.</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>[20,30,100,110,120]\r\n<strong>Output: </strong>\r\n<strong>Explanation: </strong>Friend requests are made 110 -&gt; 100, 120 -&gt; 110, 120 -&gt; 100.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Notes:</p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= ages.length&nbsp;&lt;= 20000</code>.</li>\r\n\t<li><code>1 &lt;= ages[i] &lt;= 120</code>.</li>\r\n</ul>\r\n",
    "tags": "Array",
    "difficulty": 2,
    "frontend_article_id": 825,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-counting-accepted\">Approach #1: Counting [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-counting-accepted\">Approach #1: Counting [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Instead of processing all <code>20000</code> people, we can process pairs of <code>(age, count)</code> representing how many people are that age. Since there are only 120 possible ages, this is a much faster loop.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>For each pair <code>(ageA, countA)</code>, <code>(ageB, countB)</code>, if the conditions are satisfied with respect to age, then <code>countA * countB</code> pairs of people made friend requests.</p> \n  <p>If <code>ageA == ageB</code>, then we overcounted: we should have <code>countA * (countA - 1)</code> pairs of people making friend requests instead, as you cannot friend request yourself.</p> \n  <iframe src=\"https://leetcode.com/playground/hhWFMLmx/shared\" frameborder=\"0\" width=\"100%\" height=\"412\" name=\"hhWFMLmx\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(\\mathcal{A}^2 + N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of people, and <script type=\"math/tex; mode=display\">\\mathcal{A}</script> is the number of ages.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(\\mathcal{A})</script>, the space used to store <code>count</code>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 824,
    "article_live": true,
    "article_slug": "goat-latin",
    "title": "Goat Latin",
    "title_slug": "goat-latin",
    "content": "<p>A sentence <code>S</code> is given, composed of words separated by spaces. Each word consists of lowercase and uppercase letters only.</p>\r\n\r\n<p>We would like to convert the sentence to &quot;<em>Goat Latin&quot;</em>&nbsp;(a made-up language similar to Pig Latin.)</p>\r\n\r\n<p>The rules of Goat Latin are as follows:</p>\r\n\r\n<ul>\r\n\t<li>If a word begins with a vowel (a, e, i, o, or u), append <code>&quot;ma&quot;</code>&nbsp;to the end of the word.<br />\r\n\tFor example, the word &#39;apple&#39; becomes &#39;applema&#39;.<br />\r\n\t&nbsp;</li>\r\n\t<li>If a word begins with a consonant (i.e. not a vowel), remove the first letter and append it to the end, then add <code>&quot;ma&quot;</code>.<br />\r\n\tFor example, the word <code>&quot;goat&quot;</code>&nbsp;becomes <code>&quot;oatgma&quot;</code>.<br />\r\n\t&nbsp;</li>\r\n\t<li>Add one letter <code>&#39;a&#39;</code>&nbsp;to the end of each word per its word index in the sentence, starting with 1.<br />\r\n\tFor example,&nbsp;the first word gets <code>&quot;a&quot;</code> added to the end, the second word gets <code>&quot;aa&quot;</code> added to the end and so on.</li>\r\n</ul>\r\n\r\n<p>Return the&nbsp;final sentence representing the conversion from <code>S</code>&nbsp;to Goat&nbsp;Latin.&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>&quot;I speak Goat Latin&quot;\r\n<strong>Output: </strong>&quot;Imaa peaksmaaa oatGmaaaa atinLmaaaaa&quot;\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>&quot;The quick brown fox jumped over the lazy dog&quot;\r\n<strong>Output: </strong>&quot;heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa&quot;\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Notes:</p>\r\n\r\n<ul>\r\n\t<li><code>S</code> contains only uppercase, lowercase and spaces.&nbsp;Exactly one space between each word.</li>\r\n\t<li><code>1 &lt;= S.length &lt;= 150</code>.</li>\r\n</ul>\r\n",
    "tags": "String",
    "difficulty": 1,
    "frontend_article_id": 824,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-string-accepted\">Approach #1: String [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-string-accepted\">Approach #1: String [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>We apply the steps given in the problem in a straightforward manner. The difficulty lies in the implementation.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>For each <code>word</code> in the sentence split, if it is a vowel we consider the word, otherwise we consider the rotation of the word (either <code>word[1:] + word[:1]</code> in Python, otherwise <code>word.substring(1) + word.substring(0, 1)</code> in Java).</p> \n  <p>Afterwards, we add <code>\"ma\"</code>, the desired number of <code>\"a\"</code>'s, and a space character.</p> \n  <iframe src=\"https://leetcode.com/playground/oPStDbDq/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"oPStDbDq\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>S</code>. This represents the complexity of rotating the word and adding extra <code>\"a\"</code> characters.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, the space added to the answer by adding extra <code>\"a\"</code> characters.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 708,
    "article_live": false,
    "title": "Insert into a Cyclic Sorted List",
    "title_slug": "insert-into-a-cyclic-sorted-list",
    "tags": "Linked List",
    "difficulty": 2,
    "frontend_article_id": 708
},
{
    "frontend_question_id": 823,
    "article_live": true,
    "article_slug": "binary-trees-with-factors",
    "title": "Binary Trees With Factors",
    "title_slug": "binary-trees-with-factors",
    "content": "<p>Given an array of unique integers, each integer is strictly greater than 1.</p>\r\n\r\n<p>We make a binary tree using these integers&nbsp;and each number may be used for any number of times.</p>\r\n\r\n<p>Each non-leaf node&#39;s&nbsp;value should be equal to the product of the values of it&#39;s children.</p>\r\n\r\n<p>How many binary trees can we make?&nbsp; Return the answer <strong>modulo 10 ** 9 + 7</strong>.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> <code>A = [2, 4]</code>\r\n<strong>Output:</strong> 3\r\n<strong>Explanation:</strong> We can make these trees: <code>[2], [4], [4, 2, 2]</code></pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> <code>A = [2, 4, 5, 10]</code>\r\n<strong>Output:</strong> <code>7</code>\r\n<strong>Explanation:</strong> We can make these trees: <code>[2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2]</code>.</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= A.length &lt;=&nbsp;1000</code>.</li>\r\n\t<li><code>2 &lt;=&nbsp;A[i]&nbsp;&lt;=&nbsp;10 ^ 9</code>.</li>\r\n</ol>\r\n",
    "tags": "",
    "difficulty": 2,
    "frontend_article_id": 823,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-dynamic-programming-accepted\">Approach #1: Dynamic Programming [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-dynamic-programming-accepted\">Approach #1: Dynamic Programming [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>The largest value <code>v</code> used must be the root node in the tree. Say <code>dp(v)</code> is the number of ways to make a tree with root node <code>v</code>.</p> \n  <p>If the root node of the tree (with value <code>v</code>) has children with values <code>x</code> and <code>y</code> (and <code>x * y == v</code>), then there are <code>dp(x) * dp(y)</code> ways to make this tree.</p> \n  <p>In total, there are <script type=\"math/tex; mode=display\">\\sum_{\\substack{x * y = v}} \\text{dp}(x) * \\text{dp}(y)</script> ways to make a tree with root node <code>v</code>.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Actually, let <code>dp[i]</code> be the number of ways to have a root node with value <code>A[i]</code>.</p> \n  <p>Since in the above example we always have <code>x &lt; v</code> and <code>y &lt; v</code>, we can calculate the values of <code>dp[i]</code> in increasing order using dynamic programming.</p> \n  <p>For some root value <code>A[i]</code>, let's try to find candidates for the children with values <code>A[j]</code> and <code>A[i] / A[j]</code> (so that evidently <code>A[j] * (A[i] / A[j]) = A[i]</code>). To do this quickly, we will need <code>index</code> which looks up this value: if <code>A[k] = A[i] / A[j]</code>, then index[A[i] / A[j]] = k`.</p> \n  <p>After, we'll add all possible <code>dp[j] * dp[k]</code> (with <code>j &lt; i, k &lt; i</code>) to our answer <code>dp[i]</code>. In our Java implementation, we carefully used <code>long</code> so avoid overflow issues.</p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">numFactoredBinaryTrees</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">MOD</span> <span class=\"o\">=</span> <span class=\"mi\">1_000_000_007</span><span class=\"o\">;</span>\n        <span class=\"kt\">int</span> <span class=\"n\">N</span> <span class=\"o\">=</span> <span class=\"n\">A</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span>\n        <span class=\"n\">Arrays</span><span class=\"o\">.</span><span class=\"na\">sort</span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">);</span>\n        <span class=\"kt\">long</span><span class=\"o\">[]</span> <span class=\"n\">dp</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">long</span><span class=\"o\">[</span><span class=\"n\">N</span><span class=\"o\">];</span>\n        <span class=\"n\">Arrays</span><span class=\"o\">.</span><span class=\"na\">fill</span><span class=\"o\">(</span><span class=\"n\">dp</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n\n        <span class=\"n\">Map</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">,</span> <span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">index</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HashMap</span><span class=\"o\">();</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">N</span><span class=\"o\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"o\">)</span>\n            <span class=\"n\">index</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">],</span> <span class=\"n\">i</span><span class=\"o\">);</span>\n\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">N</span><span class=\"o\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"o\">)</span>\n            <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;</span> <span class=\"n\">i</span><span class=\"o\">;</span> <span class=\"o\">++</span><span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">%</span> <span class=\"n\">A</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">]</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span> <span class=\"c1\">// A[j] is left child</span>\n                    <span class=\"kt\">int</span> <span class=\"n\">right</span> <span class=\"o\">=</span> <span class=\"n\">A</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">/</span> <span class=\"n\">A</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">];</span>\n                    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">index</span><span class=\"o\">.</span><span class=\"na\">containsKey</span><span class=\"o\">(</span><span class=\"n\">right</span><span class=\"o\">))</span> <span class=\"o\">{</span>\n                        <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">+</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">]</span> <span class=\"o\">*</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">index</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">right</span><span class=\"o\">)])</span> <span class=\"o\">%</span> <span class=\"n\">MOD</span><span class=\"o\">;</span>\n                    <span class=\"o\">}</span>\n                <span class=\"o\">}</span>\n            <span class=\"o\">}</span>\n\n        <span class=\"kt\">long</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">long</span> <span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">dp</span><span class=\"o\">)</span> <span class=\"n\">ans</span> <span class=\"o\">+=</span> <span class=\"n\">x</span><span class=\"o\">;</span>\n        <span class=\"k\">return</span> <span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ans</span> <span class=\"o\">%</span> <span class=\"n\">MOD</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">numFactoredBinaryTrees</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">A</span><span class=\"p\">):</span>\n        <span class=\"n\">MOD</span> <span class=\"o\">=</span> <span class=\"mi\">10</span> <span class=\"o\">**</span> <span class=\"mi\">9</span> <span class=\"o\">+</span> <span class=\"mi\">7</span>\n        <span class=\"n\">N</span> <span class=\"o\">=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">)</span>\n        <span class=\"n\">A</span><span class=\"o\">.</span><span class=\"n\">sort</span><span class=\"p\">()</span>\n        <span class=\"n\">dp</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"n\">N</span>\n        <span class=\"n\">index</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">i</span> <span class=\"k\">for</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">x</span> <span class=\"ow\">in</span> <span class=\"nb\">enumerate</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">)}</span>\n        <span class=\"k\">for</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">x</span> <span class=\"ow\">in</span> <span class=\"nb\">enumerate</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">):</span>\n            <span class=\"k\">for</span> <span class=\"n\">j</span> <span class=\"ow\">in</span> <span class=\"nb\">xrange</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">):</span>\n                <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"o\">%</span> <span class=\"n\">A</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">:</span> <span class=\"c1\">#A[j] will be left child</span>\n                    <span class=\"n\">right</span> <span class=\"o\">=</span> <span class=\"n\">x</span> <span class=\"o\">/</span> <span class=\"n\">A</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">]</span>\n                    <span class=\"k\">if</span> <span class=\"n\">right</span> <span class=\"ow\">in</span> <span class=\"n\">index</span><span class=\"p\">:</span>\n                        <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">+=</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">index</span><span class=\"p\">[</span><span class=\"n\">right</span><span class=\"p\">]]</span>\n                        <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">%=</span> <span class=\"n\">MOD</span>\n\n        <span class=\"k\">return</span> <span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"n\">dp</span><span class=\"p\">)</span> <span class=\"o\">%</span> <span class=\"n\">MOD</span>\n</pre>\n  </div> \n  <p></p> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>A</code>. This comes from the two for-loops iterating <code>i</code> and <code>j</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the space used by <code>dp</code> and <code>index</code>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 822,
    "article_live": true,
    "article_slug": "card-flipping-game",
    "title": "Card Flipping Game",
    "title_slug": "card-flipping-game",
    "content": "<p>On a table are <code>N</code> cards, with a positive integer printed on the front and back of each card (possibly different).</p>\r\n\r\n<p>We flip any number of cards, and after we choose one&nbsp;card.&nbsp;</p>\r\n\r\n<p>If the number <code>X</code> on the back of the chosen&nbsp;card is not on the front of any card, then this number X is good.</p>\r\n\r\n<p>What is the smallest number that is good?&nbsp; If no number is good, output <code>0</code>.</p>\r\n\r\n<p>Here, <code>fronts[i]</code> and <code>backs[i]</code> represent the number on the front and back of card <code>i</code>.&nbsp;</p>\r\n\r\n<p>A&nbsp;flip swaps the front and back numbers, so the value on the front is now on the back and vice versa.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> fronts = [1,2,4,4,7], backs = [1,3,4,1,3]\r\n<strong>Output:</strong> <code>2</code>\r\n<strong>Explanation:</strong> If we flip the second card, the fronts are <code>[1,3,4,4,7]</code> and the backs are <code>[1,2,4,1,3]</code>.\r\nWe choose the second card, which has number 2 on the back, and it isn&#39;t on the front of any card, so <code>2</code> is good.</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= fronts.length == backs.length&nbsp;&lt;=&nbsp;1000</code>.</li>\r\n\t<li><code>1 &lt;=&nbsp;fronts[i]&nbsp;&lt;= 2000</code>.</li>\r\n\t<li><code>1 &lt;= backs[i]&nbsp;&lt;= 2000</code>.</li>\r\n</ol>\r\n",
    "tags": "",
    "difficulty": 2,
    "frontend_article_id": 822,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-hash-set-accepted\">Approach #1: Hash Set [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-hash-set-accepted\">Approach #1: Hash Set [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>If a card has the same value <code>x</code> on the front and back, it is impossible to win with <code>x</code>. Otherwise, it has two different values, and if we win with <code>x</code>, we can put <code>x</code> face down on the rest of the cards.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Remember all values <code>same</code> that occur twice on a single card. Then for every value <code>x</code> on any card that isn't in <code>same</code>, <code>x</code> is a candidate answer. If we have no candidate answers, the final answer is zero.</p> \n  <iframe src=\"https://leetcode.com/playground/DvJ47nbA/shared\" frameborder=\"0\" width=\"100%\" height=\"378\" name=\"DvJ47nbA\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>fronts</code> (and <code>backs</code>). We scan through the arrays.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 821,
    "article_live": true,
    "article_slug": "shortest-distance-to-a-character",
    "title": "Shortest Distance to a Character",
    "title_slug": "shortest-distance-to-a-character",
    "content": "<p>Given a string <code>S</code>&nbsp;and a character <code>C</code>, return an array of integers representing the shortest distance from the character <code>C</code> in the string.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> S = &quot;loveleetcode&quot;, C = &#39;e&#39;\r\n<strong>Output:</strong> [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>S</code> string length is&nbsp;in&nbsp;<code>[1, 10000].</code></li>\r\n\t<li><code>C</code>&nbsp;is a single character, and guaranteed to be in string <code>S</code>.</li>\r\n\t<li>All letters in <code>S</code> and <code>C</code> are lowercase.</li>\r\n</ol>\r\n",
    "tags": "",
    "difficulty": 1,
    "frontend_article_id": 821,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-min-array-accepted\">Approach #1: Min Array [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-min-array-accepted\">Approach #1: Min Array [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>For each index <code>S[i]</code>, let's try to find the distance to the next character <code>C</code> going left, and going right. The answer is the minimum of these two values.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>When going left to right, we'll remember the index <code>prev</code> of the last character <code>C</code> we've seen. Then the answer is <code>i - prev</code>.</p> \n  <p>When going right to left, we'll remember the index <code>prev</code> of the last character <code>C</code> we've seen. Then the answer is <code>prev - i</code>.</p> \n  <p>We take the minimum of these two answers to create our final answer.</p> \n  <iframe src=\"https://leetcode.com/playground/oPmtNjJL/shared\" frameborder=\"0\" width=\"100%\" height=\"395\" name=\"oPmtNjJL\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>S</code>. We scan through the string twice.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the size of <code>ans</code>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 820,
    "article_live": true,
    "article_slug": "short-encoding-of-words",
    "title": "Short Encoding of Words",
    "title_slug": "short-encoding-of-words",
    "content": "<p>Given a list of words, we may encode it by writing a reference string <code>S</code> and a list of indexes <code>A</code>.</p>\r\n\r\n<p>For example, if the list of words is <code>[&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]</code>, we can write it as <code>S = &quot;time#bell#&quot;</code>&nbsp;and <code>indexes = [0, 2, 5]</code>.</p>\r\n\r\n<p>Then for each index, we will recover the word by reading from the reference string from that index until we reach a <code>&quot;#&quot;</code> character.</p>\r\n\r\n<p>What is the length of the shortest reference string S possible that encodes the given words?</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> words = <code>[&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]</code>\r\n<strong>Output:</strong> 10\r\n<strong>Explanation:</strong> S = <code>&quot;time#bell#&quot; and indexes = [0, 2, 5</code>].\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= words.length&nbsp;&lt;= 2000</code>.</li>\r\n\t<li><code>1 &lt;=&nbsp;words[i].length&nbsp;&lt;= 7</code>.</li>\r\n\t<li>Each word&nbsp;has only&nbsp;lowercase letters.</li>\r\n</ol>\r\n",
    "tags": "",
    "difficulty": 2,
    "frontend_article_id": 820,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-store-prefixes-accepted\">Approach #1: Store Prefixes [Accepted]</a></li> \n    <li><a href=\"#approach-2-trie-accepted\">Approach #2: Trie [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-store-prefixes-accepted\">Approach #1: Store Prefixes [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>If a word <code>X</code> is a suffix of <code>Y</code>, then it does not need to be considered, as the encoding of <code>Y</code> in the reference string will also encode <code>X</code>. For example, if <code>\"me\"</code> and <code>\"time\"</code> is in <code>words</code>, we can throw out <code>\"me\"</code> without changing the answer.</p> \n  <p>If a word <code>Y</code> does not have any other word <code>X</code> (in the list of <code>words</code>) that is a suffix of <code>Y</code>, then <code>Y</code> must be part of the reference string.</p> \n  <p>Thus, the goal is to remove words from the list such that no word is a suffix of another. The final answer would be <code>sum(word.length + 1 for word in words)</code>.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Since a word only has up to 7 suffixes (as <code>words[i].length &lt;= 7</code>), let's iterate over all of them. For each suffix, we'll try to remove it from our <code>words</code> list. For efficiency, we'll make <code>words</code> a set.</p> \n  <iframe src=\"https://leetcode.com/playground/gV8UXxb3/shared\" frameborder=\"0\" width=\"100%\" height=\"293\" name=\"gV8UXxb3\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(\\sum w_i^2)</script>, where <script type=\"math/tex; mode=display\">w_i</script> is the length of <code>words[i]</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(\\sum w_i)</script>, the space used in storing suffixes.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-trie-accepted\">Approach #2: Trie [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>As in <em>Approach #1</em>, the goal is to remove words that are suffixes of another word in the list.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>To find whether different words have the same suffix, let's put them backwards into a trie (prefix tree). For example, if we have <code>\"time\"</code> and <code>\"me\"</code>, we will put <code>\"emit\"</code> and <code>\"em\"</code> into our trie.</p> \n  <p>After, the leaves of this trie (nodes with no children) represent words that have no suffix, and we will count <code>sum(word.length + 1 for word in words)</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/whsBS94T/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"whsBS94T\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(\\sum w_i)</script>, where <script type=\"math/tex; mode=display\">w_i</script> is the length of <code>words[i]</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(\\sum w_i)</script>, the space used by the trie.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 707,
    "article_live": false,
    "title": "Design Linked List",
    "title_slug": "design-linked-list",
    "content": "<p>Design your&nbsp;implementation of the linked list. You can choose to use the singly linked list or the doubly linked list. A node in a singly&nbsp;linked list should have two attributes: <code>val</code>&nbsp;and <code>next</code>. <code>val</code> is the value of the current node, and <code>next</code>&nbsp;is&nbsp;a&nbsp;pointer/reference to the next node. If you want to use the doubly linked list,&nbsp;you will need&nbsp;one more attribute <code>prev</code> to indicate the previous node in the linked list. Assume all nodes in the linked list are 0-indexed.</p>\r\n\r\n<p>Implement these functions in your linked list class:</p>\r\n\r\n<ul>\r\n\t<li>get(index) : Get the value of&nbsp;the <code>index</code>-th&nbsp;node in the linked list. If the index is invalid, return <code>-1</code>.</li>\r\n\t<li>addAtHead(val) : Add a node of value <code>val</code>&nbsp;before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.</li>\r\n\t<li>addAtTail(val) : Append a node of value <code>val</code>&nbsp;to the last element of the linked list.</li>\r\n\t<li>addAtIndex(index, val) : Add a node of value <code>val</code>&nbsp;before the <code>index</code>-th&nbsp;node in the linked list.&nbsp;If <code>index</code>&nbsp;equals&nbsp;to the length of&nbsp;linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.</li>\r\n\t<li>deleteAtIndex(index) : Delete&nbsp;the <code>index</code>-th&nbsp;node in the linked list, if the index is valid.</li>\r\n</ul>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\nMyLinkedList linkedList = new MyLinkedList();\r\nlinkedList.addAtHead(1);\r\nlinkedList.addAtTail(3);\r\nlinkedList.addAtIndex(1, 2);  // linked list becomes 1-&gt;2-&gt;3\r\nlinkedList.get(1);            // returns 2\r\nlinkedList.deleteAtIndex(1);  // now the linked list is 1-&gt;3\r\nlinkedList.get(1);&nbsp;&nbsp;&nbsp;         // returns 3\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>All values will be in the range of <code>[1, 1000]</code>.</li>\r\n\t<li>The number of operations will be in the range of&nbsp;<code>[1, 1000]</code>.</li>\r\n\t<li>Please do not use the built-in LinkedList library.</li>\r\n</ul>\r\n",
    "tags": "Linked List, Design",
    "difficulty": 1,
    "frontend_article_id": 707
},
{
    "frontend_question_id": 819,
    "article_live": true,
    "article_slug": "most-common-word",
    "title": "Most Common Word",
    "title_slug": "most-common-word",
    "content": "<p>Given a paragraph&nbsp;and a list of banned words, return the most frequent word that is not in the list of banned words.&nbsp; It is guaranteed there is at least one word that isn&#39;t banned, and that the answer is unique.</p>\r\n\r\n<p>Words in the list of banned words are given in lowercase, and free of punctuation.&nbsp; Words in the paragraph are not case sensitive.&nbsp; The answer is in lowercase.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> \r\nparagraph = &quot;Bob hit a ball, the hit BALL flew far after it was hit.&quot;\r\nbanned = [&quot;hit&quot;]\r\n<strong>Output:</strong> &quot;ball&quot;\r\n<strong>Explanation:</strong> \r\n&quot;hit&quot; occurs 3 times, but it is a banned word.\r\n&quot;ball&quot; occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph. \r\nNote that words in the paragraph are not case sensitive,\r\nthat punctuation is ignored (even if adjacent to words, such as &quot;ball,&quot;), \r\nand that &quot;hit&quot; isn&#39;t the answer even though it occurs more because it is banned.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note: </strong></p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= paragraph.length &lt;= 1000</code>.</li>\r\n\t<li><code>1 &lt;= banned.length &lt;= 100</code>.</li>\r\n\t<li><code>1 &lt;= banned[i].length &lt;= 10</code>.</li>\r\n\t<li>The answer is unique, and written in lowercase (even if its occurrences in <code>paragraph</code>&nbsp;may have&nbsp;uppercase symbols, and even if it is a proper noun.)</li>\r\n\t<li><code>paragraph</code> only consists of letters, spaces, or the punctuation symbols <code>!?&#39;,;.</code></li>\r\n\t<li>There are no hyphens or hyphenated words.</li>\r\n\t<li>Words only consist of letters, never apostrophes or other punctuation symbols.</li>\r\n</ul>\r\n",
    "tags": "String",
    "difficulty": 1,
    "frontend_article_id": 819,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-counting-accepted\">Approach #1: Counting [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-counting-accepted\">Approach #1: Counting [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>This problem is about the implementation, as the question tells us how to solve the problem. We'll count each word separately, ignoring punctuation and converting each word to lowercase. The word with the highest frequency that isn't in the banned list is the answer.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>We'll need some <code>count</code> of words (converted to lowercase) that we have seen in the paragraph. As we iterate through the paragraph, we will collect these words (with punctuation removed and converted to lowercase).</p> \n  <p>There are two ways we could try to collect these words: we could try to split the paragraph (delimited by spaces) and then clean up the fragment like <code>\"Bob!\"</code> to be <code>\"bob\"</code>. Or, we could add characters one by one to build the next word, stopping when we reach a character that isn't a letter.</p> \n  <p>For each word (lowercase, and free of punctuation), we'll update our count and update the answer if the count of that word is highest (and the word is not banned.)</p> \n  <iframe src=\"https://leetcode.com/playground/aAhpvopR/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"aAhpvopR\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(P + B)</script>, where <script type=\"math/tex; mode=display\">P</script> is the size of <code>paragraph</code> and <script type=\"math/tex; mode=display\">B</script> is the size of <code>banned</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(P + B)</script>, to store the <code>count</code> and the banned set.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 818,
    "article_live": true,
    "article_slug": "race-car",
    "title": "Race Car",
    "title_slug": "race-car",
    "content": "<p>Your car starts at position 0 and speed +1 on an infinite number line.&nbsp; (Your car can go into negative positions.)</p>\r\n\r\n<p>Your car drives automatically according to a sequence of instructions A (accelerate) and R (reverse).</p>\r\n\r\n<p>When you get an instruction &quot;A&quot;, your car does the following:&nbsp;<code>position += speed, speed *= 2</code>.</p>\r\n\r\n<p>When you get an instruction &quot;R&quot;, your car does the following: if your speed is positive then&nbsp;<code>speed = -1</code>&nbsp;, otherwise&nbsp;<code>speed = 1</code>.&nbsp; (Your position stays the same.)</p>\r\n\r\n<p>For example, after commands &quot;AAR&quot;, your car goes to positions 0-&gt;1-&gt;3-&gt;3, and your speed goes to 1-&gt;2-&gt;4-&gt;-1.</p>\r\n\r\n<p>Now for some target position, say the <strong>length</strong> of the shortest sequence of instructions to get there.</p>\r\n\r\n<pre>\r\n<strong>Example 1:</strong>\r\n<strong>Input:</strong> \r\ntarget = 3\r\n<strong>Output:</strong> 2\r\n<strong>Explanation:</strong> \r\nThe shortest instruction sequence is &quot;AA&quot;.\r\nYour position goes from 0-&gt;1-&gt;3.\r\n</pre>\r\n\r\n<pre>\r\n<strong>Example 2:</strong>\r\n<strong>Input:</strong> \r\ntarget = 6\r\n<strong>Output:</strong> 5\r\n<strong>Explanation:</strong> \r\nThe shortest instruction sequence is &quot;AAARA&quot;.\r\nYour position goes from 0-&gt;1-&gt;3-&gt;7-&gt;7-&gt;6.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note: </strong></p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= target &lt;= 10000</code>.</li>\r\n</ul>\r\n",
    "tags": "Dynamic Programming, Heap",
    "difficulty": 3,
    "frontend_article_id": 818,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-framework\">Approach Framework</a></li> \n    <li><a href=\"#approach-1-dijkstras-accepted\">Approach #1: Dijkstra's [Accepted]</a></li> \n    <li><a href=\"#approach-2-dynamic-programming-accepted\">Approach #2: Dynamic Programming [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-framework\">Approach Framework</h4> \n  <p><strong>Explanation</strong></p> \n  <p>Let <script type=\"math/tex; mode=display\">A^k</script> denote the command <script type=\"math/tex; mode=display\">A A A \\cdots A</script> (k times).</p> \n  <p>Starting with an <code>\"R\"</code> command doesn't help, and as the final sequence does not end on an <code>\"R\"</code>, so we have some sequence like <script type=\"math/tex; mode=display\">R A^{k_1} R A^{k_2} \\cdots R A^{k_n}</script> which could be instead <script type=\"math/tex; mode=display\">A^{k_2} R A^{k_3} R \\cdots A^{k_n} R R A^{k_1}</script> for the same final position of the car. (Here, <script type=\"math/tex; mode=display\">k_i \\geq 0</script>, where <script type=\"math/tex; mode=display\">A^0</script> means no command.)</p> \n  <p>So let's suppose our command is always of the form <script type=\"math/tex; mode=display\">A^{k_1} R A^{k_2} R \\cdots A^{k_n}</script>. Note that under such a command, the car will move to final position <script type=\"math/tex; mode=display\">(2^{k_1} - 1) - (2^{k_2} - 1) + (2^{k_3} - 1) - \\cdots </script>.</p> \n  <p>Without loss of generality, we can say that (<script type=\"math/tex; mode=display\">k_i</script>, <script type=\"math/tex; mode=display\">i</script> odd) is monotone decreasing, and (<script type=\"math/tex; mode=display\">k_i</script>, <script type=\"math/tex; mode=display\">i</script> even) is also monotone decreasing.</p> \n  <p>Also because terms will cancel out, we can also ignore the possibility that <script type=\"math/tex; mode=display\">k_i = k_j</script> (for <script type=\"math/tex; mode=display\">i, j</script> with different parity).</p> \n  <p>A key claim is that <script type=\"math/tex; mode=display\">k_i</script> is bounded by <script type=\"math/tex; mode=display\">a+1</script>, where <script type=\"math/tex; mode=display\">a</script> is the smallest integer such that <script type=\"math/tex; mode=display\">2^a \\geq \\text{target}</script> - basically, if you drive past the target, you don't need to keep driving. This is because it adds another power of two (as <script type=\"math/tex; mode=display\">2^{k_i} - 1 = \\sum_{j < k_i} 2^j</script>) to the position that must get erased by one or more negative terms later (in whole or in part), as it is not part of the target.</p> \n  <hr> \n  <h4 id=\"approach-1-dijkstras-accepted\">Approach #1: Dijkstra's [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>With some <code>target</code>, we have different moves we can perform (such as <script type=\"math/tex; mode=display\">k_1 = 0, 1, 2, \\cdots</script>, using the notation from our <em>Approach Framework</em>), with different costs.</p> \n  <p>This is an ideal setup for Dijkstra's algorithm, which can help us find the shortest cost path in a weighted graph. </p> \n  <p><strong>Algorithm</strong></p> \n  <p>Dijkstra's algorithm uses a priority queue to continually searches the path with the lowest cost to destination, so that when we reach the target, we know it must have been through the lowest cost path. Refer to <a href=\"https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\">this link</a> for more detail.</p> \n  <p>Back to the problem, as described above, we have some <code>barrier</code> where we are guaranteed to never cross. We will also handle negative targets; in total we will have <code>2 * barrier + 1</code> nodes.</p> \n  <p>After, we could move <code>walk = 2**k - 1</code> steps for a cost of <code>k + 1</code> (the <code>1</code> is to reverse). If we reach our destination exactly, we don't need the <code>R</code>, so it is just <code>k</code> steps.</p> \n  <iframe src=\"https://leetcode.com/playground/qNruc33Y/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"qNruc33Y\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(T \\log T)</script>. There are <script type=\"math/tex; mode=display\">O(T)</script> nodes, we process each one using <script type=\"math/tex; mode=display\">O(\\log T)</script> work (both popping from the heap and adding the edges).</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(T)</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-dynamic-programming-accepted\">Approach #2: Dynamic Programming [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>As in our <em>Approach Framework</em>, we've framed the problem as a series of moves <script type=\"math/tex; mode=display\">k_i</script>.</p> \n  <p>Now say we have some target <code>2**(k-1) &lt;= t &lt; 2**k</code> and we want to know the cost to go there, if we know all the other costs <code>dp[u]</code> (for <code>u &lt; t</code>).</p> \n  <p>If <code>t == 2**k - 1</code>, the cost is just <code>k</code>: we use the command <script type=\"math/tex; mode=display\">A^k</script>, and clearly we can't do better.</p> \n  <p>Otherwise, we might drive without crossing the target for a position change of <script type=\"math/tex; mode=display\">2^{k-1} - 2**j</script>, by the command <script type=\"math/tex; mode=display\">A^{k-1} R A^{j} R</script>, for a total cost of <script type=\"math/tex; mode=display\">k - 1 + j + 2</script>.</p> \n  <p>Finally, we might drive <script type=\"math/tex; mode=display\">2^k - 1</script> which crosses the target, by the command <script type=\"math/tex; mode=display\">A^k R</script>, for a total cost of <script type=\"math/tex; mode=display\">k + 1</script>.</p> \n  <p>We can use dynamic programming together with the above recurrence to implement the code below.</p> \n  <iframe src=\"https://leetcode.com/playground/ZF65uxfa/shared\" frameborder=\"0\" width=\"100%\" height=\"412\" name=\"ZF65uxfa\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(T \\log T)</script>. Each node <code>i</code> does <script type=\"math/tex; mode=display\">\\log i</script> work.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(T)</script>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 817,
    "article_live": true,
    "article_slug": "linked-list-components",
    "title": "Linked List Components",
    "title_slug": "linked-list-components",
    "content": "<p>We are given&nbsp;<code>head</code>,&nbsp;the head node of a linked list containing&nbsp;<strong>unique integer values</strong>.</p>\r\n\r\n<p>We are also given the list&nbsp;<code>G</code>, a subset of the values in the linked list.</p>\r\n\r\n<p>Return the number of connected components in <code>G</code>, where two values are connected if they appear consecutively in the linked list.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> \r\nhead: 0-&gt;1-&gt;2-&gt;3\r\nG = [0, 1, 3]\r\n<strong>Output:</strong> 2\r\n<strong>Explanation:</strong> \r\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> \r\nhead: 0-&gt;1-&gt;2-&gt;3-&gt;4\r\nG = [0, 3, 1, 4]\r\n<strong>Output:</strong> 2\r\n<strong>Explanation:</strong> \r\n0 and 1 are connected, 3 and 4 are connected, so [0, 1] and [3, 4] are the two connected components.\r\n</pre>\r\n\r\n<p><strong>Note: </strong></p>\r\n\r\n<ul>\r\n\t<li>If&nbsp;<code>N</code>&nbsp;is the&nbsp;length of the linked list given by&nbsp;<code>head</code>,&nbsp;<code>1 &lt;= N &lt;= 10000</code>.</li>\r\n\t<li>The value of each node in the linked list will be in the range<code> [0, N - 1]</code>.</li>\r\n\t<li><code>1 &lt;= G.length &lt;= 10000</code>.</li>\r\n\t<li><code>G</code> is a subset of all values in the linked list.</li>\r\n</ul>\r\n",
    "tags": "Linked List",
    "difficulty": 2,
    "frontend_article_id": 817,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-grouping-accepted\">Approach #1: Grouping [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-grouping-accepted\">Approach #1: Grouping [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Instead of thinking about connected components in <code>G</code>, think about them in the linked list. Connected components in <code>G</code> must occur consecutively in the linked list.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Scanning through the list, if <code>node.val</code> is in <code>G</code> and <code>node.next.val</code> isn't (including if <code>node.next</code> is <code>null</code>), then this must be the end of a connected component.</p> \n  <p>For example, if the list is <code>0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7</code>, and <code>G = [0, 2, 3, 5, 7]</code>, then when scanning through the list, we fulfill the above condition at <code>0, 3, 5, 7</code>, for a total answer of <code>4</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/V3u2LbFe/shared\" frameborder=\"0\" width=\"100%\" height=\"361\" name=\"V3u2LbFe\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N + G\\text{.length})</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of the linked list with root node <code>head</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(G\\text{.length})</script>, to store <code>Gset</code>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 816,
    "article_live": true,
    "article_slug": "ambiguous-coordinates",
    "title": "Ambiguous Coordinates",
    "title_slug": "ambiguous-coordinates",
    "content": "<p>We had some 2-dimensional coordinates, like <code>&quot;(1, 3)&quot;</code> or <code>&quot;(2, 0.5)&quot;</code>.&nbsp; Then, we removed&nbsp;all commas, decimal points, and spaces, and ended up with the string&nbsp;<code>S</code>.&nbsp; Return a list of strings representing&nbsp;all possibilities for what our original coordinates could have been.</p>\r\n\r\n<p>Our original representation never had extraneous zeroes, so we never started with numbers like &quot;00&quot;, &quot;0.0&quot;, &quot;0.00&quot;, &quot;1.0&quot;, &quot;001&quot;, &quot;00.01&quot;, or any other number that can be represented with&nbsp;less digits.&nbsp; Also, a decimal point within a number never occurs without at least one digit occuring before it, so we never started with numbers like &quot;.1&quot;.</p>\r\n\r\n<p>The final answer list can be returned in any order.&nbsp; Also note that all coordinates in the final answer&nbsp;have exactly one space between them (occurring after the comma.)</p>\r\n\r\n<pre>\r\n<strong>Example 1:</strong>\r\n<strong>Input:</strong> &quot;(123)&quot;\r\n<strong>Output:</strong> [&quot;(1, 23)&quot;, &quot;(12, 3)&quot;, &quot;(1.2, 3)&quot;, &quot;(1, 2.3)&quot;]\r\n</pre>\r\n\r\n<pre>\r\n<strong>Example 2:</strong>\r\n<strong>Input:</strong> &quot;(00011)&quot;\r\n<strong>Output:</strong> &nbsp;[&quot;(0.001, 1)&quot;, &quot;(0, 0.011)&quot;]\r\n<strong>Explanation:</strong> \r\n0.0, 00, 0001 or 00.01 are not allowed.\r\n</pre>\r\n\r\n<pre>\r\n<strong>Example 3:</strong>\r\n<strong>Input:</strong> &quot;(0123)&quot;\r\n<strong>Output:</strong> [&quot;(0, 123)&quot;, &quot;(0, 12.3)&quot;, &quot;(0, 1.23)&quot;, &quot;(0.1, 23)&quot;, &quot;(0.1, 2.3)&quot;, &quot;(0.12, 3)&quot;]\r\n</pre>\r\n\r\n<pre>\r\n<strong>Example 4:</strong>\r\n<strong>Input:</strong> &quot;(100)&quot;\r\n<strong>Output:</strong> [(10, 0)]\r\n<strong>Explanation:</strong> \r\n1.0 is not allowed.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note: </strong></p>\r\n\r\n<ul>\r\n\t<li><code>4 &lt;= S.length &lt;= 12</code>.</li>\r\n\t<li><code>S[0]</code> = &quot;(&quot;, <code>S[S.length - 1]</code> = &quot;)&quot;, and the other elements in <code>S</code> are digits.</li>\r\n</ul>\r\n\r\n<p>&nbsp;</p>\r\n",
    "tags": "String",
    "difficulty": 2,
    "frontend_article_id": 816,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-cartesian-product-accepted\">Approach #1: Cartesian Product [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-cartesian-product-accepted\">Approach #1: Cartesian Product [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>For each place to put the comma, we separate the string into two fragments. For example, with a string like <code>\"1234\"</code>, we could separate it into fragments <code>\"1\" and \"234\"</code>, <code>\"12\" and \"34\"</code>, or <code>\"123\"</code> and <code>\"4\"</code>.</p> \n  <p>Then, for each fragment, we have a choice of where to put the period, to create a list <code>make(...)</code> of choices. For example, <code>\"123\"</code> could be made into <code>\"1.23\"</code>, <code>\"12.3\"</code>, or <code>\"123\"</code>.</p> \n  <p>Because of extranneous zeroes, we should ignore possibilities where the part of the fragment to the <code>left</code> of the decimal starts with <code>\"0\"</code> (unless it is exactly <code>\"0\"</code>), and ignore possibilities where the part of the fragment to the <code>right</code> of the decimal ends with <code>\"0\"</code>, as these are not allowed.</p> \n  <p>Note that this process could result in an empty answer, such as for the case <code>S = \"(000)\"</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/Gdyt4CNE/shared\" frameborder=\"0\" width=\"100%\" height=\"463\" name=\"Gdyt4CNE\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^3)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length <code>S</code>. We evaluate the sum <script type=\"math/tex; mode=display\">O(\\sum_k k(N-k))</script>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N^3)</script>, to store the answer.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 815,
    "article_live": true,
    "article_slug": "bus-routes",
    "title": "Bus Routes",
    "title_slug": "bus-routes",
    "content": "<p>We have a list of bus routes. Each <code>routes[i]</code> is a bus route that the i-th bus&nbsp;repeats forever. For example if <code>routes[0] = [1, 5, 7]</code>, this means that the first&nbsp;bus (0-th indexed) travels in the sequence 1-&gt;5-&gt;7-&gt;1-&gt;5-&gt;7-&gt;1-&gt;... forever.</p>\r\n\r\n<p>We start at bus stop <code>S</code> (initially not on a bus), and we want to go to bus stop <code>T</code>. Travelling by buses only, what is the least number of buses we must take to reach our destination? Return -1 if it is not possible.</p>\r\n\r\n<pre>\r\n<strong>Example:</strong>\r\n<strong>Input:</strong> \r\nroutes = [[1, 2, 7], [3, 6, 7]]\r\nS = 1\r\nT = 6\r\n<strong>Output:</strong> 2\r\n<strong>Explanation:</strong> \r\nThe best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6.\r\n</pre>\r\n\r\n<p><strong>Note: </strong></p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= routes.length &lt;= 500</code>.</li>\r\n\t<li><code>1 &lt;= routes[i].length &lt;= 500</code>.</li>\r\n\t<li><code>0 &lt;= routes[i][j] &lt; 10 ^ 6</code>.</li>\r\n</ul>\r\n",
    "tags": "Breadth-first Search",
    "difficulty": 3,
    "frontend_article_id": 815,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-breadth-first-search-accepted\">Approach #1: Breadth First Search [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-breadth-first-search-accepted\">Approach #1: Breadth First Search [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Instead of thinking of the stops as nodes (of a graph), think of the buses as nodes. We want to take the least number of buses, which is a shortest path problem, conducive to using a breadth-first search.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>We perform a breadth first search on bus numbers. When we start at <code>S</code>, originally we might be able to board many buses, and if we end at <code>T</code> we may have many <code>targets</code> for our goal state.</p> \n  <p>One difficulty is to efficiently decide whether two buses are connected by an edge. They are connected if they share at least one bus stop. Whether two lists share a common value can be done by set intersection (HashSet), or by sorting each list and using a two pointer approach.</p> \n  <p>To make our search easy, we will annotate the depth of each node: <code>info[0] = node, info[1] = depth</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/fji6uJ5m/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"fji6uJ5m\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: Let <script type=\"math/tex; mode=display\">N</script> denote the number of buses, and <script type=\"math/tex; mode=display\">b_i</script> be the number of stops on the <script type=\"math/tex; mode=display\">i</script>th bus.</p> \n    <ul> \n     <li> <p>To create the graph, in Python we do <script type=\"math/tex; mode=display\">O(\\sum (N - i) b_i)</script> work (we can improve this by checking for which of <code>r1, r2</code> is smaller), while in Java we did a <script type=\"math/tex; mode=display\">O(\\sum b_i \\log b_i)</script> sorting step, plus our searches are <script type=\"math/tex; mode=display\">O(N \\sum b_i)</script> work.</p> </li> \n     <li> <p>Our (breadth-first) search is on <script type=\"math/tex; mode=display\">N</script> nodes, and each node could have <script type=\"math/tex; mode=display\">N</script> edges, so it is <script type=\"math/tex; mode=display\">O(N^2)</script>.</p> </li> \n    </ul> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N^2 + \\sum b_i)</script> additional space complexity, the size of <code>graph</code> and <code>routes</code>. In Java, our space complexity is <script type=\"math/tex; mode=display\">O(N^2)</script> because we do not have an equivalent of <code>routes</code>. Dual-pivot quicksort (as used in <code>Arrays.sort(int[])</code>) is an in-place algorithm, so in Java we did not increase our space complexity by sorting.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 814,
    "article_live": true,
    "article_slug": "binary-tree-pruning",
    "title": "Binary Tree Pruning",
    "title_slug": "binary-tree-pruning",
    "content": "<p>We are given the head node <code>root</code>&nbsp;of a binary tree, where additionally every node&#39;s value is either a 0 or a 1.</p>\r\n\r\n<p>Return the same tree where every subtree (of the given tree) not containing a 1 has been removed.</p>\r\n\r\n<p>(Recall that the subtree of a node X is X, plus every node that is a descendant of X.)</p>\r\n\r\n<pre>\r\n<strong>Example 1:</strong>\r\n<strong>Input:</strong> [1,null,0,0,1]\r\n<strong>Output: </strong>[1,null,0,null,1]\r\n \r\n<strong>Explanation:</strong> \r\nOnly the red nodes satisfy the property &quot;every subtree not containing a 1&quot;.\r\nThe diagram on the right represents the answer.\r\n\r\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/06/1028_2.png\" style=\"width:450px\" />\r\n</pre>\r\n\r\n<pre>\r\n<strong>Example 2:</strong>\r\n<strong>Input:</strong> [1,0,1,0,0,0,1]\r\n<strong>Output: </strong>[1,null,1,null,1]\r\n\r\n\r\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/06/1028_1.png\" style=\"width:450px\" />\r\n</pre>\r\n\r\n<pre>\r\n<strong>Example 3:</strong>\r\n<strong>Input:</strong> [1,1,0,1,1,0,1,0]\r\n<strong>Output: </strong>[1,1,0,1,1,null,1]\r\n\r\n\r\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/05/1028.png\" style=\"width:450px\" />\r\n</pre>\r\n\r\n<p><strong>Note: </strong></p>\r\n\r\n<ul>\r\n\t<li>The binary tree&nbsp;will&nbsp;have&nbsp;at&nbsp;most <code>100 nodes</code>.</li>\r\n\t<li>The value of each node will only be <code>0</code> or <code>1</code>.</li>\r\n</ul>\r\n",
    "tags": "Tree",
    "difficulty": 2,
    "frontend_article_id": 814,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-recursion-accepted\">Approach #1: Recursion [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-recursion-accepted\">Approach #1: Recursion [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Prune children of the tree recursively. The only decisions at each node are whether to prune the left child or the right child.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>We'll use a function <code>containsOne(node)</code> that does two things: it tells us whether the subtree at this <code>node</code> contains a <code>1</code>, and it also prunes all subtrees not containing <code>1</code>.</p> \n  <p>If for example, <code>node.left</code> does not contain a one, then we should prune it via <code>node.left = null</code>.</p> \n  <p>Also, the parent needs to be checked. If for example the tree is a single node <code>0</code>, the answer is an empty tree.</p> \n  <iframe src=\"https://leetcode.com/playground/oKrtTG2C/shared\" frameborder=\"0\" width=\"100%\" height=\"293\" name=\"oKrtTG2C\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of nodes in the tree. We process each node once.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(H)</script>, where <script type=\"math/tex; mode=display\">H</script> is the height of the tree. This represents the size of the implicit call stack in our recursion.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 813,
    "article_live": true,
    "article_slug": "largest-sum-of-averages",
    "title": "Largest Sum of Averages",
    "title_slug": "largest-sum-of-averages",
    "content": "<p>We partition a row of numbers <code>A</code>&nbsp;into at most <code>K</code> adjacent (non-empty) groups, then our score is the sum of the average of each group. What is the largest score we can achieve?</p>\r\n\r\n<p>Note that our partition must use every number in A, and that scores are not necessarily integers.</p>\r\n\r\n<pre>\r\n<strong>Example:</strong>\r\n<strong>Input:</strong> \r\nA = [9,1,2,3,9]\r\nK = 3\r\n<strong>Output:</strong> 20\r\n<strong>Explanation:</strong> \r\nThe best choice is to partition A into [9], [1, 2, 3], [9]. The answer is 9 + (1 + 2 + 3) / 3 + 9 = 20.\r\nWe could have also partitioned A into [9, 1], [2], [3, 9], for example.\r\nThat partition would lead to a score of 5 + 2 + 6 = 13, which is worse.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note: </strong></p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= A.length &lt;= 100</code>.</li>\r\n\t<li><code>1 &lt;= A[i] &lt;= 10000</code>.</li>\r\n\t<li><code>1 &lt;= K &lt;= A.length</code>.</li>\r\n\t<li>Answers within <code>10^-6</code> of the correct answer will be accepted as correct.</li>\r\n</ul>\r\n",
    "tags": "Dynamic Programming",
    "difficulty": 2,
    "frontend_article_id": 813,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-dynamic-programming-accepted\">Approach #1: Dynamic Programming [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-dynamic-programming-accepted\">Approach #1: Dynamic Programming [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>The best score partitioning <code>A[i:]</code> into at most <code>K</code> parts depends on answers to paritioning <code>A[j:]</code> (<code>j &gt; i</code>) into less parts. We can use dynamic programming as the states form a directed acyclic graph.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Let <code>dp(i, k)</code> be the best score partioning <code>A[i:]</code> into at most <code>K</code> parts.</p> \n  <p>If the first group we partition <code>A[i:]</code> into ends before <code>j</code>, then our candidate partition has score <code>average(i, j) + dp(j, k-1))</code>, where <code>average(i, j) = (A[i] + A[i+1] + ... + A[j-1]) / (j - i)</code> (floating point division). We take the highest score of these, keeping in mind we don't necessarily need to partition - <code>dp(i, k)</code> can also be just <code>average(i, N)</code>.</p> \n  <p>In total, our recursion in the general case is <code>dp(i, k) = max(average(i, N), max_{j &gt; i}(average(i, j) + dp(j, k-1)))</code>.</p> \n  <p>We can calculate <code>average</code> a little bit faster by remembering prefix sums. If <code>P[x+1] = A[0] + A[1] + ... + A[x]</code>, then <code>average(i, j) = (P[j] - P[i]) / (j - i)</code>.</p> \n  <p>Our implementation showcases a \"bottom-up\" style of dp. Here at loop number <code>k</code> in our outer-most loop, <code>dp[i]</code> represents <code>dp(i, k)</code> from the discussion above, and we are calculating the next layer <code>dp(i, k+1)</code>. The end of our second loop <code>for i = 0..N-1</code> represents finishing the calculation of the correct value for <code>dp(i, t)</code>, and the inner-most loop performs the calculation <code>max_{j &gt; i}(average(i, j) + dp(j, k))</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/Eem7Vreg/shared\" frameborder=\"0\" width=\"100%\" height=\"378\" name=\"Eem7Vreg\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(K * N^2)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>A</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the size of <code>dp</code>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 812,
    "article_live": true,
    "article_slug": "largest-triangle-area",
    "title": "Largest Triangle Area",
    "title_slug": "largest-triangle-area",
    "content": "<p>You have a list of points in the plane. Return the area of the largest triangle that can be formed by any 3 of the points.</p>\r\n\r\n<pre>\r\n<strong>Example:</strong>\r\n<strong>Input:</strong> points = [[0,0],[0,1],[1,0],[0,2],[2,0]]\r\n<strong>Output:</strong> 2\r\n<strong>Explanation:</strong> \r\nThe five points are show in the figure below. The red triangle is the largest.\r\n</pre>\r\n\r\n<p><img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/04/1027.png\" style=\"height:328px; width:400px\" /></p>\r\n\r\n<p><strong>Notes: </strong></p>\r\n\r\n<ul>\r\n\t<li><code>3 &lt;= points.length &lt;= 50</code>.</li>\r\n\t<li>No points will be duplicated.</li>\r\n\t<li>&nbsp;<code>-50 &lt;= points[i][j] &lt;= 50</code>.</li>\r\n\t<li>Answers within&nbsp;<code>10^-6</code>&nbsp;of the true value will be accepted as correct.</li>\r\n</ul>\r\n\r\n<p>&nbsp;</p>\r\n",
    "tags": "Math",
    "difficulty": 1,
    "frontend_article_id": 812,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-brute-force-accepted\">Approach #1: Brute Force [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-brute-force-accepted\">Approach #1: Brute Force [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>For each possible triangle, check it's area and keep the area of the largest.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>We will have 3 for loops to cycle through each choice of 3 points in the array.</p> \n  <p>After, we'll need a function to calculate the area given 3 points. Here we have some options:</p> \n  <ul> \n   <li> <p>We can use the Shoelace formula directly, which tells us the area given the 3 points;</p> </li> \n   <li> <p>We can use Heron's formula, which requires the 3 side lengths which we can get by taking the distance of two points;</p> </li> \n   <li> <p>We can use the formula <code>area = 0.5 * a * b * sin(C)</code> and calculate the angle <code>C</code> with trigonometry.</p> </li> \n  </ul> \n  <p>Our implementation illustrates the use of the shoelace formula.</p> \n  <p>If we did not know the shoelace formula, we could derive it for triangles with the following approach: starting with points <code>(px, py), (qx, qy), (rx, ry)</code>, the area of this triangle is the same under a translation by <code>(-rx, -ry)</code>, so that the points become <code>(px-rx, py-ry), (qx-rx, qy-ry), (0, 0)</code>.</p> \n  <p>From there, we could draw a square around the triangle with sides touching the coordinate axes, and calculate the area of the square minus the area of the right triangles surrounding the inner triangle.</p> \n  <p>For more on this approach, see the <a href=\"https://en.wikipedia.org/wiki/Shoelace_formula\">Wikipedia entry for the Shoelace formula</a>.</p> \n  <iframe src=\"https://leetcode.com/playground/n9XwHjZg/shared\" frameborder=\"0\" width=\"100%\" height=\"327\" name=\"n9XwHjZg\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^3)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>points</code>. We use three for-loops of length <script type=\"math/tex; mode=display\">O(N)</script>, and our work calculating the area of a single triangle is <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 811,
    "article_live": true,
    "article_slug": "subdomain-visit-count",
    "title": "Subdomain Visit Count",
    "title_slug": "subdomain-visit-count",
    "content": "<p>A website domain like &quot;discuss.leetcode.com&quot; consists of various subdomains. At the top level, we have &quot;com&quot;, at the next level, we have &quot;leetcode.com&quot;, and at the lowest level, &quot;discuss.leetcode.com&quot;. When we visit a domain like &quot;discuss.leetcode.com&quot;, we will also visit the parent domains &quot;leetcode.com&quot; and &quot;com&quot; implicitly.</p>\r\n\r\n<p>Now, call a &quot;count-paired domain&quot; to be a count (representing the number of visits this domain received), followed by a space, followed by the address. An example of a count-paired domain might be &quot;9001 discuss.leetcode.com&quot;.</p>\r\n\r\n<p>We are given a list <code>cpdomains</code> of count-paired domains. We would like a list of count-paired domains, (in the same format as the input, and in any order), that explicitly counts the number of visits to each subdomain.</p>\r\n\r\n<pre>\r\n<strong>Example 1:</strong>\r\n<strong>Input:</strong> \r\n[&quot;9001 discuss.leetcode.com&quot;]\r\n<strong>Output:</strong> \r\n[&quot;9001 discuss.leetcode.com&quot;, &quot;9001 leetcode.com&quot;, &quot;9001 com&quot;]\r\n<strong>Explanation:</strong> \r\nWe only have one website domain: &quot;discuss.leetcode.com&quot;. As discussed above, the subdomain &quot;leetcode.com&quot; and &quot;com&quot; will also be visited. So they will all be visited 9001 times.\r\n\r\n</pre>\r\n\r\n<pre>\r\n<strong>Example 2:</strong>\r\n<strong>Input:</strong> \r\n[&quot;900 google.mail.com&quot;, &quot;50 yahoo.com&quot;, &quot;1 intel.mail.com&quot;, &quot;5 wiki.org&quot;]\r\n<strong>Output:</strong> \r\n[&quot;901 mail.com&quot;,&quot;50 yahoo.com&quot;,&quot;900 google.mail.com&quot;,&quot;5 wiki.org&quot;,&quot;5 org&quot;,&quot;1 intel.mail.com&quot;,&quot;951 com&quot;]\r\n<strong>Explanation:</strong> \r\nWe will visit &quot;google.mail.com&quot; 900 times, &quot;yahoo.com&quot; 50 times, &quot;intel.mail.com&quot; once and &quot;wiki.org&quot; 5 times. For the subdomains, we will visit &quot;mail.com&quot; 900 + 1 = 901 times, &quot;com&quot; 900 + 50 + 1 = 951 times, and &quot;org&quot; 5 times.\r\n\r\n</pre>\r\n\r\n<p><strong>Notes: </strong></p>\r\n\r\n<ul>\r\n\t<li>The length of <code>cpdomains</code> will not exceed&nbsp;<code>100</code>.&nbsp;</li>\r\n\t<li>The length of each domain name will not exceed <code>100</code>.</li>\r\n\t<li>Each address will have either 1 or 2 &quot;.&quot; characters.</li>\r\n\t<li>The input count&nbsp;in any count-paired domain will not exceed <code>10000</code>.</li>\r\n\t<li>The answer output can be returned in any order.</li>\r\n</ul>\r\n",
    "tags": "Hash Table",
    "difficulty": 1,
    "frontend_article_id": 811,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-hash-map-accepted\">Approach #1: Hash Map [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-hash-map-accepted\">Approach #1: Hash Map [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>The algorithm is straightforward: we just do what the problem statement tells us to do.</p> \n  <p>For an address like <code>a.b.c</code>, we will count <code>a.b.c</code>, <code>b.c</code>, and <code>c</code>. For an address like <code>x.y</code>, we will count <code>x.y</code> and <code>y</code>.</p> \n  <p>To count these strings, we will use a hash map. To split the strings into the required pieces, we will use library <code>split</code> functions.</p> \n  <iframe src=\"https://leetcode.com/playground/tMRWeTNX/shared\" frameborder=\"0\" width=\"100%\" height=\"395\" name=\"tMRWeTNX\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>cpdomains</code>, and assuming the length of <code>cpdomains[i]</code> is fixed.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the space used in our count.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 810,
    "article_live": true,
    "article_slug": "chalkboard-xor-game",
    "title": "Chalkboard XOR Game",
    "title_slug": "chalkboard-xor-game",
    "content": "<p>We are given non-negative integers nums[i] which are written on a chalkboard.&nbsp; Alice and Bob take turns erasing exactly one number from the chalkboard, with Alice starting first.&nbsp; If erasing a number causes&nbsp;the bitwise XOR of all the elements of the chalkboard to become&nbsp;0, then that player loses.&nbsp; (Also, we&#39;ll say the bitwise XOR of one element is that element itself, and the bitwise XOR of no elements is 0.)</p>\r\n\r\n<p>Also, if any player starts their turn with the bitwise XOR of all the elements of the chalkboard equal to 0, then that player wins.</p>\r\n\r\n<p>Return True if and only if Alice wins the game, assuming both players play optimally.</p>\r\n\r\n<pre>\r\n<strong>Example:</strong>\r\n<strong>Input:</strong> nums = [1, 1, 2]\r\n<strong>Output:</strong> false\r\n<strong>Explanation:</strong> \r\nAlice has two choices: erase 1 or erase 2. \r\nIf she erases 1, the nums array becomes [1, 2]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 2 = 3. Now Bob can remove any element he wants, because Alice will be the one to erase the last element and she will lose. \r\nIf Alice erases 2 first, now nums becomes [1, 1]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 1 = 0. Alice will lose.\r\n\r\n</pre>\r\n\r\n<p><strong>Notes: </strong></p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= N &lt;= 1000</code>.&nbsp;</li>\r\n\t<li><code>0 &lt;= nums[i] &lt;= 2^16</code>.</li>\r\n</ul>\r\n\r\n<p>&nbsp;</p>\r\n",
    "tags": "Math",
    "difficulty": 3,
    "frontend_article_id": 810,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-mathematical-accepted\">Approach #1: Mathematical [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-mathematical-accepted\">Approach #1: Mathematical [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>As in the problem statement, if the <code>XOR</code> of the entire array is <code>0</code>, then Alice wins.</p> \n  <p>If the <code>XOR</code> condition is never triggered, then clearly Alice wins if and only if there are an even number of elements, as every player always has a move.</p> \n  <p>Now for the big leap in intuition. Actually, Alice always has a move when there are an even number of elements. If <script type=\"math/tex; mode=display\"> S = x_1 \\oplus x_2 \\oplus \\cdots x_n \\neq 0 </script>, but there are no possible moves (<script type=\"math/tex; mode=display\"> S \\oplus x_i = 0 </script>), then <script type=\"math/tex; mode=display\">(S \\oplus x_1) \\oplus (S \\oplus x_2) \\oplus \\cdots \\oplus (S \\oplus x_n) = (S \\oplus \\cdots \\oplus S) \\oplus (x_1 \\oplus x_2 \\oplus \\cdots \\oplus x_n) = 0 \\oplus S \\neq 0</script>, a contradiction.</p> \n  <p>Similarly, if there are an odd number of elements, then Bob always faces an even number of elements, and has a move. So the answer is just the parity of the number of elements in the array.</p> \n  <p>Those that are familiar with the Sprague-Grundy theorem may know that this game is a misère-form game, meaning the theorem does not apply, and giving a big hint that there may exist a simpler solution.</p> \n  <iframe src=\"https://leetcode.com/playground/bz5ugFJG/shared\" frameborder=\"0\" width=\"100%\" height=\"174\" name=\"bz5ugFJG\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>nums</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 809,
    "article_live": true,
    "article_slug": "expressive-words",
    "title": "Expressive Words",
    "title_slug": "expressive-words",
    "content": "<p>Sometimes people repeat letters to represent extra feeling, such as &quot;hello&quot; -&gt; &quot;heeellooo&quot;, &quot;hi&quot; -&gt; &quot;hiiii&quot;.&nbsp; Here, we have&nbsp;groups, of adjacent letters that are all the same character, and adjacent characters to&nbsp;the group are different.&nbsp; A group&nbsp;is extended if that group is length 3 or more, so &quot;e&quot; and &quot;o&quot; would be extended in the first example, and &quot;i&quot; would be extended in the second example.&nbsp; As another example, the groups of &quot;abbcccaaaa&quot; would be &quot;a&quot;, &quot;bb&quot;, &quot;ccc&quot;, and &quot;aaaa&quot;; and &quot;ccc&quot; and &quot;aaaa&quot; are the extended groups of that string.</p>\r\n\r\n<p>For some given string S, a query word is <em>stretchy</em> if it can be made to be equal to S by extending some groups.&nbsp; Formally, we are allowed to repeatedly choose a group&nbsp;(as defined above) of characters <code>c</code>, and add some number of the&nbsp;same character <code>c</code> to it so that the length of the group is 3 or more.&nbsp; Note that we cannot extend a group of size one like &quot;h&quot; to a group of size two like &quot;hh&quot; - all extensions must leave the group extended - ie., at least 3 characters long.</p>\r\n\r\n<p>Given a list of query words, return the number of words that are stretchy.&nbsp;</p>\r\n\r\n<pre>\r\n<strong>Example:</strong>\r\n<strong>Input:</strong> \r\nS = &quot;heeellooo&quot;\r\nwords = [&quot;hello&quot;, &quot;hi&quot;, &quot;helo&quot;]\r\n<strong>Output:</strong> 1\r\n<strong>Explanation:</strong> \r\nWe can extend &quot;e&quot; and &quot;o&quot; in the word &quot;hello&quot; to get &quot;heeellooo&quot;.\r\nWe can&#39;t extend &quot;helo&quot; to get &quot;heeellooo&quot; because the group &quot;ll&quot; is not extended.\r\n</pre>\r\n\r\n<p><strong>Notes: </strong></p>\r\n\r\n<ul>\r\n\t<li><code>0 &lt;= len(S) &lt;= 100</code>.</li>\r\n\t<li><code>0 &lt;= len(words) &lt;= 100</code>.</li>\r\n\t<li><code>0 &lt;= len(words[i]) &lt;= 100</code>.</li>\r\n\t<li><code>S</code> and all words in <code>words</code>&nbsp;consist only of&nbsp;lowercase letters</li>\r\n</ul>\r\n\r\n<p>&nbsp;</p>\r\n",
    "tags": "String",
    "difficulty": 2,
    "frontend_article_id": 809,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-run-length-encoding-accepted\">Approach #1: Run Length Encoding [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-run-length-encoding-accepted\">Approach #1: Run Length Encoding [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>For some word, write the head character of every group, and the count of that group. For example, for <code>\"abbcccddddaaaaa\"</code>, we'll write the \"key\" of <code>\"abcda\"</code>, and the \"count\" <code>[1,2,3,4,5]</code>.</p> \n  <p>Let's see if a <code>word</code> is stretchy. Evidently, it needs to have the same key as <code>S</code>.</p> \n  <p>Now, let's say we have individual counts <code>c1 = S.count[i]</code> and <code>c2 = word.count[i]</code>.</p> \n  <ul> \n   <li> <p>If <code>c1 &lt; c2</code>, then we can't make the <code>i</code>th group of <code>word</code> equal to the <code>i</code>th word of <code>S</code> by adding characters.</p> </li> \n   <li> <p>If <code>c1 &gt;= 3</code>, then we can add letters to the <code>i</code>th group of <code>word</code> to match the <code>i</code>th group of <code>S</code>, as the latter is <em>extended</em>.</p> </li> \n   <li> <p>Else, if <code>c1 &lt; 3</code>, then we must have <code>c2 == c1</code> for the <code>i</code>th groups of <code>word</code> and <code>S</code> to match.</p> </li> \n  </ul> \n  <iframe src=\"https://leetcode.com/playground/CtqN5Fqo/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"CtqN5Fqo\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(QK)</script>, where <script type=\"math/tex; mode=display\">Q</script> is the length of <code>words</code> (at least 1), and <script type=\"math/tex; mode=display\">K</script> is the maximum length of a word.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(K)</script>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 808,
    "article_live": true,
    "article_slug": "soup-servings",
    "title": "Soup Servings",
    "title_slug": "soup-servings",
    "content": "<p>There are two types of soup: type A and type B. Initially we have <code>N</code> ml of each type of soup. There are four kinds of operations:</p>\r\n\r\n<ol>\r\n\t<li>Serve&nbsp;100 ml of soup A and 0 ml of soup B</li>\r\n\t<li>Serve&nbsp;75 ml of soup A and 25&nbsp;ml of soup B</li>\r\n\t<li>Serve 50 ml of soup A and 50 ml of soup B</li>\r\n\t<li>Serve 25&nbsp;ml of soup A and 75&nbsp;ml of soup B</li>\r\n</ol>\r\n\r\n<p>When we serve some soup, we give it to someone and we no longer have it.&nbsp; Each turn,&nbsp;we will choose from the four operations with equal probability 0.25. If the remaining volume of soup is not enough to complete the operation, we will serve&nbsp;as much as we can.&nbsp; We stop once we no longer have some quantity of both types of soup.</p>\r\n\r\n<p>Note that we do not have the operation where all 100 ml&#39;s of soup B are used first.&nbsp;&nbsp;</p>\r\n\r\n<p>Return the probability that soup A will be empty&nbsp;first, plus half the probability that A and B become empty at the same time.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<pre>\r\n<strong>Example:</strong>\r\n<strong>Input:</strong> N = 50\r\n<strong>Output:</strong> 0.625\r\n<strong>Explanation:</strong> \r\nIf we choose the first two operations, A will become empty first. For the third operation, A and B will become empty at the same time. For the fourth operation, B will become empty first. So the total probability of A becoming empty first plus half the probability that A and B become empty at the same time, is 0.25 * (1 + 1 + 0.5 + 0) = 0.625.\r\n\r\n</pre>\r\n\r\n<p><strong>Notes: </strong></p>\r\n\r\n<ul>\r\n\t<li><code>0 &lt;= N &lt;= 10^9</code>.&nbsp;</li>\r\n\t<li>Answers within&nbsp;<code>10^-6</code>&nbsp;of the true value will be accepted as correct.</li>\r\n</ul>\r\n",
    "tags": "Dynamic Programming",
    "difficulty": 2,
    "frontend_article_id": 808,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-dynamic-programming-accepted\">Approach #1: Dynamic Programming [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-dynamic-programming-accepted\">Approach #1: Dynamic Programming [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>First, we can simplify all the numbers by dividing by 25. More specifically, each unit is 25ml, and partial quantities of 25ml are rounded up to a full quantity.</p> \n  <p>When <code>N</code> is small, this is a relatively straightforward dynamic programming problem: we have quantities of soup represented by the state <code>(x, y)</code>, and we can either go to <code>(x-4, y-0)</code>, <code>(x-3, y-1)</code>, <code>(x-2, y-2)</code>, or <code>(x-1, y-3)</code> each with equal probability. </p> \n  <p>When <code>N</code> is very large, this approach fails, so we need a different idea.</p> \n  <p>Instead of serving in batches of <code>(4, 0), (3, 1), (2, 2), (1, 3)</code>, pretend we serve <code>(1, 0)</code> on the side first, and then serve from the fair distribution <code>(3, 0), (2, 1), (1, 2), (0, 3)</code>. If the pots of soup initially start at <code>(N, N)</code>, then after roughly less than <code>N/2</code> servings, one pot will still have soup. Because of the <code>(1, 0)</code> servings on the side, this means that roughly speaking, pot <code>A</code> is used first if we serve <code>N/2</code> fairly from the first pot before <code>N</code> from the second pot.</p> \n  <p>When <code>N</code> is very large, this almost always happens (better than 99.9999%, so we can output 1), and we can check this either experimentally or mathematically.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>We convert all units by dividing by 25 and rounding up. If <code>N &gt;= 500</code> (in new units), then by the above argument the answer is <code>1</code>.</p> \n  <p>Otherwise, we will perform a dynamic programming algorithm to find the answer. Our Java implementation showcases a \"bottom-up\" approach, that fills <code>memo</code> diagonally from top left to bottom right, where <code>s = i + j</code> is the sum of the indices. Our Python implemtation showcases a \"top-down\" approach that uses memoization.</p> \n  <iframe src=\"https://leetcode.com/playground/aS5JpTPa/shared\" frameborder=\"0\" width=\"100%\" height=\"497\" name=\"aS5JpTPa\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(1)</script>. (There exists a constant <code>C</code> such that the algorithm never performs more than <code>C</code> steps.)</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>. (There exists a constant <code>C</code> such that the algorithm never uses more than <code>C</code> space.)</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 807,
    "article_live": true,
    "article_slug": "max-increase-to-keep-city-skyline",
    "title": "Max Increase to Keep City Skyline",
    "title_slug": "max-increase-to-keep-city-skyline",
    "content": "<p>In a 2 dimensional array <code>grid</code>, each value <code>grid[i][j]</code> represents the height of a building located there. We are allowed to increase the height of any number of buildings, by any amount (the amounts&nbsp;can be different for different buildings). Height&nbsp;0 is considered to be a&nbsp;building&nbsp;as well.&nbsp;</p>\r\n\r\n<p>At the end, the &quot;skyline&quot; when viewed from all four directions&nbsp;of the grid, i.e.&nbsp;top, bottom, left, and right,&nbsp;must be the same as the&nbsp;skyline of the original grid. A city&#39;s skyline is the outer contour of the rectangles formed by all the buildings when viewed from a distance. See&nbsp;the following example.</p>\r\n\r\n<p>What is the maximum total sum that the height of the buildings can be increased?</p>\r\n\r\n<pre>\r\n<strong>Example:</strong>\r\n<strong>Input:</strong> grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]\r\n<strong>Output:</strong> 35\r\n<strong>Explanation:</strong> \r\nThe grid is:\r\n[ [3, 0, 8, 4], \r\n  [2, 4, 5, 7],\r\n  [9, 2, 6, 3],\r\n  [0, 3, 1, 0] ]\r\n\r\nThe skyline viewed from top or bottom is: [9, 4, 8, 7]\r\nThe skyline viewed from left or right is: [8, 7, 9, 3]\r\n\r\nThe grid after increasing the height of buildings without affecting skylines is:\r\n\r\ngridNew = [ [8, 4, 8, 7],\r\n            [7, 4, 7, 7],\r\n            [9, 4, 8, 7],\r\n            [3, 3, 3, 3] ]\r\n\r\n</pre>\r\n\r\n<p><strong>Notes: </strong></p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt; grid.length = grid[0].length &lt;= 50</code>.</li>\r\n\t<li>All heights <code>grid[i][j]</code> are in the range <code>[0, 100]</code>.</li>\r\n\t<li>All buildings in <code>grid[i][j]</code> occupy the entire grid cell: that is, they are a <code>1 x 1 x grid[i][j]</code> rectangular prism.</li>\r\n</ul>\r\n",
    "tags": "",
    "difficulty": 2,
    "frontend_article_id": 807,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-row-and-column-maximums-accepted\">Approach #1: Row and Column Maximums [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-row-and-column-maximums-accepted\">Approach #1: Row and Column Maximums [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>The skyline looking from the top is <code>col_maxes = [max(column_0), max(column_1), ...]</code>. Similarly, the skyline from the left is <code>row_maxes [max(row_0), max(row_1), ...]</code></p> \n  <p>In particular, each building <code>grid[r][c]</code> could become height <code>min(max(row_r), max(col_c))</code>, and this is the largest such height. If it were larger, say <code>grid[r][c] &gt; max(row_r)</code>, then the part of the skyline <code>row_maxes = [..., max(row_r), ...]</code> would change.</p> \n  <p>These increases are also independent (none of them change the skyline), so we can perform them independently.</p> \n  <iframe src=\"https://leetcode.com/playground/ELQgWsrX/shared\" frameborder=\"0\" width=\"100%\" height=\"395\" name=\"ELQgWsrX\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of rows (and columns) of the grid. We iterate through every cell of the grid.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the space used by <code>row_maxes</code> and <code>col_maxes</code>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 806,
    "article_live": true,
    "article_slug": "number-of-lines-to-write-string",
    "title": "Number of Lines To Write String",
    "title_slug": "number-of-lines-to-write-string",
    "content": "<p>We are to write the letters of a given string <code>S</code>, from left to right into lines. Each line has maximum width 100 units, and if writing a letter would cause the width of the line to exceed 100 units, it is written on the next line. We are given an array&nbsp;<code>widths</code>, an array where widths[0] is the width of &#39;a&#39;, widths[1] is the width of &#39;b&#39;, ..., and widths[25] is the width of &#39;z&#39;.</p>\r\n\r\n<p>Now answer two questions: how many lines have at least one character from <code>S</code>, and what is the width used by the last such line? Return your answer as an integer list of length 2.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<pre>\r\n<strong>Example :</strong>\r\n<strong>Input:</strong> \r\nwidths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]\r\nS = &quot;abcdefghijklmnopqrstuvwxyz&quot;\r\n<strong>Output:</strong> [3, 60]\r\n<strong>Explanation: </strong>\r\nAll letters have the same length of 10. To write all 26 letters,\r\nwe need two full lines and one line with 60 units.\r\n</pre>\r\n\r\n<pre>\r\n<strong>Example :</strong>\r\n<strong>Input:</strong> \r\nwidths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]\r\nS = &quot;bbbcccdddaaa&quot;\r\n<strong>Output:</strong> [2, 4]\r\n<strong>Explanation: </strong>\r\nAll letters except &#39;a&#39; have the same length of 10, and \r\n&quot;bbbcccdddaa&quot; will cover 9 * 10 + 2 * 4 = 98 units.\r\nFor the last &#39;a&#39;, it is written on the second line because\r\nthere is only 2 units left in the first line.\r\nSo the answer is 2 lines, plus 4 units in the second line.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>The length of <code>S</code> will be in the range&nbsp;[1, 1000].</li>\r\n\t<li><code>S</code> will only contain lowercase letters.</li>\r\n\t<li><code>widths</code> is&nbsp;an array of length <code>26</code>.</li>\r\n\t<li><code>widths[i]</code> will be in the range of <code>[2, 10]</code>.</li>\r\n</ul>\r\n",
    "tags": "",
    "difficulty": 1,
    "frontend_article_id": 806,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-insert-each-character-accepted\">Approach #1: Insert Each Character [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-insert-each-character-accepted\">Approach #1: Insert Each Character [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>We can write out each character in the string <code>S</code> one by one.</p> \n  <p>As we write characters, we can update <code>(lines, width)</code> that keeps track of how many lines we have used, and what is the length of the used space in the last line.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>If the space <code>w</code> of the next character in <code>S</code> fits our current line, we will add it. Otherwise, we will start a new line, and use <code>w</code> space to put that character on the next line.</p> \n  <iframe src=\"https://leetcode.com/playground/QNF9BsvY/shared\" frameborder=\"0\" width=\"100%\" height=\"310\" name=\"QNF9BsvY\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(S\\text{.length})</script>, as we iterate through <code>S</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script> additional space, as we only use <code>lines</code> and <code>width</code>. (In Java, our <code>toCharArray</code> method makes this <script type=\"math/tex; mode=display\">O(S\\text{.length})</script>, but we could use <code>.charAt</code> instead).</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 805,
    "article_live": true,
    "article_slug": "split-array-with-same-average",
    "title": "Split Array With Same Average",
    "title_slug": "split-array-with-same-average",
    "content": "<p>In a given integer array A, we must move every element of A to either list B or list C. (B and C initially start empty.)</p>\r\n\r\n<p>Return true if and only if after such a move, it is possible that the average value of B is equal to the average value of C, and B and C are both non-empty.</p>\r\n\r\n<pre>\r\n<strong>Example :</strong>\r\n<strong>Input:</strong> \r\n[1,2,3,4,5,6,7,8]\r\n<strong>Output:</strong> true\r\n<strong>Explanation: </strong>We can split the array into [1,4,5,8] and [2,3,6,7], and both of them have the average of 4.5.\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>The length of <code>A</code> will be in the range&nbsp;[1, 30].</li>\r\n\t<li><code>A[i]</code> will be in the range of <code>[0, 10000]</code>.</li>\r\n</ul>\r\n\r\n<p>&nbsp;</p>\r\n",
    "tags": "Math",
    "difficulty": 3,
    "frontend_article_id": 805,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-meet-in-the-middle-accepted\">Approach #1: Meet in the Middle [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-meet-in-the-middle-accepted\">Approach #1: Meet in the Middle [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>First, let's get a sense of the condition that <code>average(B) = average(C)</code>, where <code>B, C</code> are defined in the problem statement.</p> \n  <p>Say <code>A</code> (the input array) has <code>N</code> elements which sum to <code>S</code>, and <code>B</code> (one of the splitting sets) has <code>K</code> elements which sum to <code>X</code>. Then the equation for <code>average(B) = average(C)</code> becomes <script type=\"math/tex; mode=display\">\\frac{X}{K} = \\frac{S-X}{N-K}</script>. This reduces to <script type=\"math/tex; mode=display\">X(N-K) = (S-X)K</script> which is <script type=\"math/tex; mode=display\">\\frac{X}{K} = \\frac{S}{N}</script>. That is, <code>average(B) = average(A)</code>.</p> \n  <p>Now, we could delete <code>average(A)</code> from each element <code>A[i]</code> without changing our choice for <code>B</code>. (<code>A[i] -= mu</code>, where <code>mu = average(A)</code>). This means we just want to choose a set <code>B</code> that sums to <code>0</code>.</p> \n  <p>Trying all <script type=\"math/tex; mode=display\">2^N</script> sets is still too many choices, so we will create sets of sums <code>left, right</code> of the approximately <script type=\"math/tex; mode=display\">2^{N/2}</script> choices on the left and on the right separately. (That is, <code>left</code> is a set of sums of every powerset in the first half of A, and <code>right</code> is the set of sums of every powerset in the second half of A). Then, it is true if we find <script type=\"math/tex; mode=display\">0</script> in these powersets, or if two sums in different halves cancel out (<code>-x in right for x in left</code>), except for one minor detail below.</p> \n  <p>Care must be taken that we do not specify sets that would make the original <code>B</code> or <code>C</code> empty. If <code>sleft = A[0] + A[1] + ... + A[N/2 - 1]</code>, and <code>sright = A[N/2] + ... + A[N-1]</code>, (where <code>A[i]</code> was transformed to the new <code>A[i] - average(A)</code>) then we cannot choose both (<code>sleft, sright</code>). This is correct because if for example <code>sleft</code> was a sum reached by a strictly smaller powerset than <code>{A[0], A[1], ..., A[N/2 - 1]}</code>, then the difference between these sets would be non-empty and have sum <code>0</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/MCygqyNn/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"MCygqyNn\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(2^{N/2})</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>A</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(2^{N/2})</script>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 804,
    "article_live": true,
    "article_slug": "unique-morse-code-words",
    "title": "Unique Morse Code Words",
    "title_slug": "unique-morse-code-words",
    "content": "<p>International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: <code>&quot;a&quot;</code> maps to <code>&quot;.-&quot;</code>, <code>&quot;b&quot;</code> maps to <code>&quot;-...&quot;</code>, <code>&quot;c&quot;</code> maps to <code>&quot;-.-.&quot;</code>, and so on.</p>\r\n\r\n<p>For convenience, the full table for the 26 letters of the English alphabet is given below:</p>\r\n\r\n<pre>\r\n[&quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot;]</pre>\r\n\r\n<p>Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, &quot;cba&quot; can be written as &quot;-.-.-....-&quot;, (which is the concatenation &quot;-.-.&quot; + &quot;-...&quot; + &quot;.-&quot;). We&#39;ll call such a concatenation, the transformation&nbsp;of a word.</p>\r\n\r\n<p>Return the number of different transformations among all words we have.</p>\r\n\r\n<pre>\r\n<strong>Example:</strong>\r\n<strong>Input:</strong> words = [&quot;gin&quot;, &quot;zen&quot;, &quot;gig&quot;, &quot;msg&quot;]\r\n<strong>Output:</strong> 2\r\n<strong>Explanation: </strong>\r\nThe transformation of each word is:\r\n&quot;gin&quot; -&gt; &quot;--...-.&quot;\r\n&quot;zen&quot; -&gt; &quot;--...-.&quot;\r\n&quot;gig&quot; -&gt; &quot;--...--.&quot;\r\n&quot;msg&quot; -&gt; &quot;--...--.&quot;\r\n\r\nThere are 2 different transformations, &quot;--...-.&quot; and &quot;--...--.&quot;.\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>The length of <code>words</code> will be at most <code>100</code>.</li>\r\n\t<li>Each <code>words[i]</code> will have length in range <code>[1, 12]</code>.</li>\r\n\t<li><code>words[i]</code> will only consist of lowercase letters.</li>\r\n</ul>\r\n",
    "tags": "String",
    "difficulty": 1,
    "frontend_article_id": 804,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-hash-set-accepted\">Approach #1: Hash Set [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-hash-set-accepted\">Approach #1: Hash Set [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>We can transform each <code>word</code> into it's Morse Code representation.</p> \n  <p>After, we put all transformations into a set <code>seen</code>, and return the size of the set.</p> \n  <iframe src=\"https://leetcode.com/playground/f4mHEzpq/shared\" frameborder=\"0\" width=\"100%\" height=\"361\" name=\"f4mHEzpq\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(S)</script>, where <script type=\"math/tex; mode=display\">S</script> is the sum of the lengths of words in <code>words</code>. We iterate through each character of each word in <code>words</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(S)</script>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 803,
    "article_live": true,
    "article_slug": "bricks-falling-when-hit",
    "title": "Bricks Falling When Hit",
    "title_slug": "bricks-falling-when-hit",
    "content": "<p>We have a grid of 1s and 0s; the 1s in a cell represent bricks.&nbsp; A brick will not drop if and only if it is directly connected to the top of the grid, or at least one of its (4-way) adjacent bricks will not drop.</p>\r\n\r\n<p>We will do some erasures&nbsp;sequentially. Each time we want to do the erasure at the location (i, j), the brick (if it exists) on that location will disappear, and then some other bricks may&nbsp;drop because of that&nbsp;erasure.</p>\r\n\r\n<p>Return an array representing the number of bricks that will drop after each erasure in sequence.</p>\r\n\r\n<pre>\r\n<strong>Example 1:</strong>\r\n<strong>Input:</strong> \r\ngrid = [[1,0,0,0],[1,1,1,0]]\r\nhits = [[1,0]]\r\n<strong>Output:</strong> [2]\r\n<strong>Explanation: </strong>\r\nIf we erase the brick at (1, 0), the brick at (1, 1) and (1, 2) will drop. So we should return 2.</pre>\r\n\r\n<pre>\r\n<strong>Example 2:</strong>\r\n<strong>Input:</strong> \r\ngrid = [[1,0,0,0],[1,1,0,0]]\r\nhits = [[1,1],[1,0]]\r\n<strong>Output:</strong> [0,0]\r\n<strong>Explanation: </strong>\r\nWhen we erase the brick at (1, 0), the brick at (1, 1) has already disappeared due to the last move. So each erasure will cause no bricks dropping.  Note that the erased brick (1, 0) will not be counted as a dropped brick.</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>The number of rows and columns in the grid will be in the range&nbsp;[1, 200].</li>\r\n\t<li>The number of erasures will not exceed the area of the grid.</li>\r\n\t<li>It is guaranteed that each erasure will be different from any other erasure, and located inside the grid.</li>\r\n\t<li>An erasure may refer to a location with no brick - if it does, no bricks drop.</li>\r\n</ul>\r\n",
    "tags": "Union Find",
    "difficulty": 3,
    "frontend_article_id": 803,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-reverse-time-and-union-find-accepted\">Approach #1: Reverse Time and Union-Find [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-reverse-time-and-union-find-accepted\">Approach #1: Reverse Time and Union-Find [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>The problem is about knowing information about the connected components of a graph as we cut vertices. In particular, we'll like to know the size of the \"roof\" (component touching the top edge) between each cut. Here, a cut refers to the erasure of a vertex.</p> \n  <p>As we may know, a useful data structure for joining connected components is a disjoint set union structure. The key idea in this problem is that we can use this structure if we work in reverse: instead of looking at the graph as a series of sequential cuts, we'll look at the graph after all the cuts, and reverse each cut.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>We'll modify our typical disjoint-set-union structure to include a <code>dsu.size</code> operation, that tells us the size of this component. The way we do this is whenever we make a component point to a new parent, we'll also send it's size to that parent.</p> \n  <p>We'll also include <code>dsu.top</code>, which tells us the size of the \"roof\", or the component connected to the top edge. We use an <em>ephemeral</em> \"source\" node with label <code>R * C</code> where all nodes on the top edge (with row number <code>0</code>) are connected to the source node.</p> \n  <p>For more information on DSU, please look at <em>Approach #2</em> in the <a href=\"https://leetcode.com/articles/redundant-connection/\">article here</a>.</p> \n  <p>Next, we'll introduce <code>A</code>, the grid after all the cuts have happened, and initialize our disjoint union structure on the graph induced by <code>A</code> (nodes are grid squares with a brick; edges between 4-directionally adjacent nodes).</p> \n  <p>After, if we get an cut at <code>(r, c)</code> but the original <code>grid[r][c]</code> was always <code>0</code>, then we couldn't have had a meaningful cut - the number of dropped bricks is <code>0</code>.</p> \n  <p>Otherwise, we'll look at the size of the new roof after adding this brick at <code>(r, c)</code>, and compare them to find the number of dropped bricks.</p> \n  <p>Since we were working in reverse time order, we should reverse our working answer to arrive at our final answer.</p> \n  <iframe src=\"https://leetcode.com/playground/vKx7cbxE/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"vKx7cbxE\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N*Q*\\alpha(N * Q))</script>, where <script type=\"math/tex; mode=display\">N = R*C</script> is the number of grid squares, <script type=\"math/tex; mode=display\">Q</script> is the length of <code>hits</code>, and <script type=\"math/tex; mode=display\">\\alpha</script> is the <em>Inverse-Ackermann function</em>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 802,
    "article_live": true,
    "article_slug": "find-eventual-safe-states",
    "title": "Find Eventual Safe States",
    "title_slug": "find-eventual-safe-states",
    "content": "<p>In a directed graph, we start at some node and every turn, walk along a directed edge of the graph.&nbsp; If we reach a node that is terminal (that is, it has no outgoing directed edges), we stop.</p>\r\n\r\n<p>Now, say our starting node is <em>eventually safe&nbsp;</em>if and only if we must eventually walk to a terminal node.&nbsp; More specifically, there exists a natural number <code>K</code> so that for any choice of where to walk, we must have stopped at a terminal node in less than <code>K</code> steps.</p>\r\n\r\n<p>Which nodes are eventually safe?&nbsp; Return them as an array in sorted order.</p>\r\n\r\n<p>The directed graph has <code>N</code> nodes with labels <code>0, 1, ..., N-1</code>, where <code>N</code> is the length of <code>graph</code>.&nbsp; The&nbsp;graph is given in the following form: <code>graph[i]</code> is a list of labels <code>j</code> such that <code>(i, j)</code> is a directed edge of the graph.</p>\r\n\r\n<pre>\r\n<strong>Example:</strong>\r\n<strong>Input:</strong> graph = [[1,2],[2,3],[5],[0],[5],[],[]]\r\n<strong>Output:</strong> [2,4,5,6]\r\nHere is a diagram of the above graph.\r\n\r\n</pre>\r\n\r\n<p><img alt=\"Illustration of graph\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/03/17/picture1.png\" style=\"height:86px; width:300px\" /></p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>graph</code> will have length at most <code>10000</code>.</li>\r\n\t<li>The number of edges in the graph will not exceed <code>32000</code>.</li>\r\n\t<li>Each <code>graph[i]</code> will be a sorted list of different integers, chosen within the range <code>[0, graph.length - 1]</code>.</li>\r\n</ul>\r\n",
    "tags": "Depth-first Search, Graph",
    "difficulty": 2,
    "frontend_article_id": 802,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-reverse-edges-accepted\">Approach #1: Reverse Edges [Accepted]</a></li> \n    <li><a href=\"#approach-2-depth-first-search-accepted\">Approach #2: Depth-First Search [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-reverse-edges-accepted\">Approach #1: Reverse Edges [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>The crux of the problem is whether you can reach a cycle from the node you start in. If you can, then there is a way to avoid stopping indefinitely; and if you can't, then after some finite number of steps you'll stop.</p> \n  <p>Thinking about this property more, a node is eventually safe if all it's outgoing edges are to nodes that are eventually safe.</p> \n  <p>This gives us the following idea: we start with nodes that have no outgoing edges - those are eventually safe. Now, we can update any nodes which only point to eventually safe nodes - those are also eventually safe. Then, we can update again, and so on.</p> \n  <p>However, we'll need a good algorithm to make sure our updates are efficient.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>We'll keep track of <code>graph</code>, a way to know for some node <code>i</code>, what the outgoing edges <code>(i, j)</code> are. We'll also keep track of <code>rgraph</code>, a way to know for some node <code>j</code>, what the incoming edges <code>(i, j)</code> are.</p> \n  <p>Now for every node <code>j</code> which was declared eventually safe, we'll process them in a queue. We'll look at all parents <code>i = rgraph[j]</code> and remove the edge <code>(i, j)</code> from the graph (from <code>graph</code>). If this causes the <code>graph</code> to have no outgoing edges <code>graph[i]</code>, then we'll declare it eventually safe and add it to our queue.</p> \n  <p>Also, we'll keep track of everything we ever added to the queue, so we can read off the answer in sorted order later.</p> \n  <iframe src=\"https://leetcode.com/playground/x49F98kC/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"x49F98kC\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N + E)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of nodes in the given graph, and <script type=\"math/tex; mode=display\">E</script> is the total number of edges.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script> in additional space complexity.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-depth-first-search-accepted\">Approach #2: Depth-First Search [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>As in <em>Approach #1</em>, the crux of the problem is whether you reach a cycle or not.</p> \n  <p>Let us perform a \"brute force\": a cycle-finding DFS algorithm on each node individually. This is a classic \"white-gray-black\" DFS algorithm that would be part of any textbook on DFS. We mark a node gray on entry, and black on exit. If we see a gray node during our DFS, it must be part of a cycle. In a naive view, we'll clear the colors between each search.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>We can improve this approach, by noticing that we don't need to clear the colors between each search.</p> \n  <p>When we visit a node, the only possibilities are that we've marked the entire subtree black (which must be eventually safe), or it has a cycle and we have only marked the members of that cycle gray. So indeed, the invariant that gray nodes are always part of a cycle, and black nodes are always eventually safe is maintained.</p> \n  <p>In order to exit our search quickly when we find a cycle (and not paint other nodes erroneously), we'll say the result of visiting a node is <code>true</code> if it is eventually safe, otherwise <code>false</code>. This allows information that we've reached a cycle to propagate up the call stack so that we can terminate our search early.</p> \n  <iframe src=\"https://leetcode.com/playground/VxkXPWTw/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"VxkXPWTw\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N + E)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of nodes in the given graph, and <script type=\"math/tex; mode=display\">E</script> is the total number of edges.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script> in additional space complexity.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 801,
    "article_live": true,
    "article_slug": "minimum-swaps-to-make-sequences-increasing",
    "title": "Minimum Swaps To Make Sequences Increasing",
    "title_slug": "minimum-swaps-to-make-sequences-increasing",
    "content": "<p>We have two integer sequences <code>A</code> and <code>B</code> of the same non-zero length.</p>\r\n\r\n<p>We are allowed to swap elements <code>A[i]</code> and <code>B[i]</code>.&nbsp; Note that both elements are in the same index position in their respective sequences.</p>\r\n\r\n<p>At the end of some number of swaps, <code>A</code> and <code>B</code> are both strictly increasing.&nbsp; (A sequence is <em>strictly increasing</em> if and only if <code>A[0] &lt; A[1] &lt; A[2] &lt; ... &lt; A[A.length - 1]</code>.)</p>\r\n\r\n<p>Given A and B, return the minimum number of swaps to make both sequences strictly increasing.&nbsp; It is guaranteed that the given input always makes it possible.</p>\r\n\r\n<pre>\r\n<strong>Example:</strong>\r\n<strong>Input:</strong> A = [1,3,5,4], B = [1,2,3,7]\r\n<strong>Output:</strong> 1\r\n<strong>Explanation: </strong>\r\nSwap A[3] and B[3].  Then the sequences are:\r\nA = [1, 3, 5, 7] and B = [1, 2, 3, 4]\r\nwhich are both strictly increasing.\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>A, B</code> are arrays with the same length, and that length will be in the range <code>[1, 1000]</code>.</li>\r\n\t<li><code>A[i], B[i]</code> are integer values in the range <code>[0, 2000]</code>.</li>\r\n</ul>\r\n",
    "tags": "Dynamic Programming",
    "difficulty": 2,
    "frontend_article_id": 801,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-dynamic-programming-accepted\">Approach #1: Dynamic Programming [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-dynamic-programming-accepted\">Approach #1: Dynamic Programming [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>The cost of making both sequences increasing up to the first <code>i</code> columns can be expressed in terms of the cost of making both sequences increasing up to the first <code>i-1</code> columns. This is because the only thing that matters to the <code>i</code>th column is whether the previous column was swapped or not. This makes dynamic programming an ideal choice.</p> \n  <p>Let's remember <code>n1</code> (<code>natural1</code>), the cost of making the first <code>i-1</code> columns increasing and not swapping the <code>i-1</code>th column; and <code>s1</code> (<code>swapped1</code>), the cost of making the first <code>i-1</code> columns increasing and swapping the <code>i-1</code>th column.</p> \n  <p>Now we want candidates <code>n2</code> (and <code>s2</code>), the costs of making the first <code>i</code> columns increasing if we do not swap (or swap, respectively) the <code>i</code>th column.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>For convenience, say <code>a1 = A[i-1], b1 = B[i-1]</code> and <code>a2 = A[i], b2 = B[i]</code>.</p> \n  <p>Now, if <code>a1 &lt; a2</code> and <code>b1 &lt; b2</code>, then it is allowed to have both of these columns natural (unswapped), or both of these columns swapped. This possibility leads to <code>n2 = min(n2, n1)</code> and <code>s2 = min(s2, s1 + 1)</code>.</p> \n  <p>Another, (not exclusive) possibility is that <code>a1 &lt; b2</code> and <code>b1 &lt; a2</code>. This means that it is allowed to have exactly one of these columns swapped. This possibility leads to <code>n2 = min(n2, s1)</code> or <code>s2 = min(s2, n1 + 1)</code>.</p> \n  <p>Note that it is important to use two if statements separately, because both of the above possibilities might be possible.</p> \n  <p>At the end, the optimal solution must leave the last column either natural or swapped, so we take the minimum number of swaps between the two possibilities.</p> \n  <iframe src=\"https://leetcode.com/playground/KT3yuKkz/shared\" frameborder=\"0\" width=\"100%\" height=\"395\" name=\"KT3yuKkz\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 800,
    "article_live": true,
    "article_slug": "similar-rgb-color",
    "title": "Similar RGB Color",
    "title_slug": "similar-rgb-color",
    "tags": "Math, String",
    "difficulty": 1,
    "frontend_article_id": 800,
    "article_content": ""
},
{
    "frontend_question_id": 706,
    "article_live": false,
    "title": "Design HashMap",
    "title_slug": "design-hashmap",
    "content": "<p>Design a HashMap&nbsp;without using any built-in hash table libraries.</p>\r\n\r\n<p>To be specific, your design should include these functions:</p>\r\n\r\n<ul>\r\n\t<li><code>put(key, value)</code> :&nbsp;Insert a (key, value) pair into the HashMap. If the value already exists in the HashMap, update the value.</li>\r\n\t<li><code>get(key)</code>: Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key.</li>\r\n\t<li><code>remove(key)</code> :&nbsp;Remove the mapping for the value key if this map contains the mapping for the key.</li>\r\n</ul>\r\n\r\n<p><br />\r\n<strong>Example:</strong></p>\r\n\r\n<pre>\r\nMyHashMap hashMap = new MyHashMap();\r\nhashMap.put(1, 1); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\r\nhashMap.put(2, 2); &nbsp; &nbsp; &nbsp; &nbsp; \r\nhashMap.get(1); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// returns 1\r\nhashMap.get(3); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// returns -1 (not found)\r\nhashMap.put(2, 1); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// update the existing value\r\nhashMap.get(2); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// returns 1 \r\nhashMap.remove(2); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// remove the mapping for 2\r\nhashMap.get(2); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// returns -1 (not found) \r\n</pre>\r\n\r\n<p><br />\r\n<strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>All keys and values will be in the range of <code>[0, 1000000]</code>.</li>\r\n\t<li>The number of operations will be in the range of&nbsp;<code>[1, 10000]</code>.</li>\r\n\t<li>Please do not use the built-in HashMap library.</li>\r\n</ul>\r\n",
    "tags": "Hash Table, Design",
    "difficulty": 1,
    "frontend_article_id": 706
},
{
    "frontend_question_id": 705,
    "article_live": false,
    "title": "Design HashSet",
    "title_slug": "design-hashset",
    "content": "<p>Design a HashSet&nbsp;without using any built-in hash table libraries.</p>\r\n\r\n<p>To be specific, your design should include these functions:</p>\r\n\r\n<ul>\r\n\t<li><code>add(value)</code>:&nbsp;Insert a value into the HashSet.&nbsp;</li>\r\n\t<li><code>contains(value)</code> : Return whether the value exists in the HashSet or not.</li>\r\n\t<li><code>remove(value)</code>: Remove a value in&nbsp;the HashSet. If the value does not exist in the HashSet, do nothing.</li>\r\n</ul>\r\n\r\n<p><br />\r\n<strong>Example:</strong></p>\r\n\r\n<pre>\r\nMyHashSet hashSet = new MyHashSet();\r\nhashSet.add(1); &nbsp; &nbsp; &nbsp; &nbsp; \r\nhashSet.add(2); &nbsp; &nbsp; &nbsp; &nbsp; \r\nhashSet.contains(1); &nbsp;&nbsp;&nbsp;// returns true\r\nhashSet.contains(3); &nbsp;&nbsp;&nbsp;// returns false (not found)\r\nhashSet.add(2); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\r\nhashSet.contains(2); &nbsp;&nbsp;&nbsp;// returns true\r\nhashSet.remove(2); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\r\nhashSet.contains(2); &nbsp;&nbsp;&nbsp;// returns false (already removed)\r\n</pre>\r\n\r\n<p><br />\r\n<strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>All values will be in the range of <code>[0, 1000000]</code>.</li>\r\n\t<li>The number of operations will be in the range of&nbsp;<code>[1, 10000]</code>.</li>\r\n\t<li>Please do not use the built-in HashSet library.</li>\r\n</ul>\r\n",
    "tags": "Hash Table, Design",
    "difficulty": 1,
    "frontend_article_id": 705
},
{
    "frontend_question_id": 799,
    "article_live": true,
    "article_slug": "champagne-tower",
    "title": "Champagne Tower",
    "title_slug": "champagne-tower",
    "content": "<p>We stack glasses in a pyramid, where the first row has 1 glass, the second row has 2 glasses, and so on until the 100th row.&nbsp; Each glass holds one cup (250ml) of champagne.</p>\r\n\r\n<p>Then, some champagne is poured in the first glass at the top.&nbsp; When the top most glass is full, any excess liquid poured will fall equally to the glass immediately to the left and right of it.&nbsp; When those glasses become full, any excess champagne will fall equally to the left and right of those glasses, and so on.&nbsp; (A glass at the bottom row has it&#39;s excess champagne fall on the floor.)</p>\r\n\r\n<p>For example, after one cup of champagne is poured, the top most glass is full.&nbsp; After two cups of champagne are poured, the two glasses on the second row are half full.&nbsp; After three cups of champagne are poured, those two cups become full - there are 3 full glasses total now.&nbsp; After four cups of champagne are poured, the third row has the middle glass half full, and the two outside glasses are a quarter full, as pictured below.</p>\r\n\r\n<p><img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/03/09/tower.png\" style=\"height:200px; width:290px\" /></p>\r\n\r\n<p>Now after pouring some non-negative integer cups of champagne, return how full the j-th glass in the i-th row is (both i and j are 0 indexed.)</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<pre>\r\n<strong>Example 1:</strong>\r\n<strong>Input:</strong> poured = 1, query_glass = 1, query_row = 1\r\n<strong>Output:</strong> 0.0\r\n<strong>Explanation:</strong> We poured 1 cup of champange to the top glass of the tower (which is indexed as (0, 0)). There will be no excess liquid so all the glasses under the top glass will remain empty.\r\n\r\n<strong>Example 2:</strong>\r\n<strong>Input:</strong> poured = 2, query_glass = 1, query_row = 1\r\n<strong>Output:</strong> 0.5\r\n<strong>Explanation:</strong> We poured 2 cups of champange to the top glass of the tower (which is indexed as (0, 0)). There is one cup of excess liquid. The glass indexed as (1, 0) and the glass indexed as (1, 1) will share the excess liquid equally, and each will get half cup of champange.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>poured</code>&nbsp;will&nbsp;be&nbsp;in the range of <code>[0, 10 ^ 9]</code>.</li>\r\n\t<li><code>query_glass</code> and <code>query_row</code> will be in the range of <code>[0, 99]</code>.</li>\r\n</ul>\r\n\r\n<p>&nbsp;</p>\r\n",
    "tags": "",
    "difficulty": 2,
    "frontend_article_id": 799,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-simulation-accepted\">Approach #1: Simulation [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-simulation-accepted\">Approach #1: Simulation [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Instead of keeping track of how much champagne should end up in a glass, keep track of the total amount of champagne that flows through a glass. For example, if <code>poured = 10</code> cups are poured at the top, then the total flow-through of the top glass is <code>10</code>; the total flow-through of each glass in the second row is <code>4.5</code>, and so on.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>In general, if a glass has flow-through <code>X</code>, then <code>Q = (X - 1.0) / 2.0</code> quantity of champagne will equally flow left and right. We can simulate the entire pour for 100 rows of glasses. A glass at <code>(r, c)</code> will have excess champagne flow towards <code>(r+1, c)</code> and <code>(r+1, c+1)</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/GbytuGmq/shared\" frameborder=\"0\" width=\"100%\" height=\"344\" name=\"GbytuGmq\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(R^2)</script>, where <script type=\"math/tex; mode=display\">R</script> is the number of rows. As this is fixed, we can consider this complexity to be <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(R^2)</script>, or <script type=\"math/tex; mode=display\">O(1)</script> by the reasoning above.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 798,
    "article_live": true,
    "article_slug": "smallest-rotation-with-highest-score",
    "title": "Smallest Rotation with Highest Score",
    "title_slug": "smallest-rotation-with-highest-score",
    "content": "<p>&nbsp;Given an array <code>A</code>, we may rotate it by a non-negative integer <code>K</code> so that the array becomes <code>A[K], A[K+1], A{K+2], ... A[A.length - 1], A[0], A[1], ..., A[K-1]</code>.&nbsp; Afterward, any entries that are less than or equal to their index are worth 1 point.&nbsp;</p>\r\n\r\n<p>For example, if we have <code>[2, 4, 1, 3, 0]</code>, and we rotate by <code>K = 2</code>, it becomes <code>[1, 3, 0, 2, 4]</code>.&nbsp; This is worth 3 points because 1 &gt; 0 [no points], 3 &gt; 1 [no points], 0 &lt;= 2 [one point], 2 &lt;= 3 [one point], 4 &lt;= 4 [one point].</p>\r\n\r\n<p>Over all possible rotations, return the rotation index K that corresponds to the highest score we could receive.&nbsp; If there are multiple answers, return the smallest such index K.</p>\r\n\r\n<pre>\r\n<strong>Example 1:</strong>\r\n<strong>Input:</strong> [2, 3, 1, 4, 0]\r\n<strong>Output:</strong> 3\r\n<strong>Explanation: </strong> \r\nScores for each K are listed below: \r\nK = 0,  A = [2,3,1,4,0],    score 2\r\nK = 1,  A = [3,1,4,0,2],    score 3\r\nK = 2,  A = [1,4,0,2,3],    score 3\r\nK = 3,  A = [4,0,2,3,1],    score 4\r\nK = 4,  A = [0,2,3,1,4],    score 3\r\n</pre>\r\n\r\n<p>So we should choose K = 3, which has the highest score.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<pre>\r\n<strong>Example 2:</strong>\r\n<strong>Input:</strong> [1, 3, 0, 2, 4]\r\n<strong>Output:</strong> 0\r\n<strong>Explanation: </strong> A will always have 3 points no matter how it shifts.\r\nSo we will choose the smallest K, which is 0.\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>A</code>&nbsp;will have&nbsp;length at most <code>20000</code>.</li>\r\n\t<li><code>A[i]</code> will be in the range <code>[0, A.length]</code>.</li>\r\n</ul>\r\n",
    "tags": "",
    "difficulty": 3,
    "frontend_article_id": 798,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-interval-stabbing-accepted\">Approach #1: Interval Stabbing [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-interval-stabbing-accepted\">Approach #1: Interval Stabbing [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Say <code>N = 10</code> and <code>A[2] = 5</code>. Then there are 5 rotations that are bad for this number: rotation indexes <code>0, 1, 2, 8, 9</code> - these rotations will cause this number to not get 1 point later.</p> \n  <p>In general, for each number in the array, we can map out what rotation indexes will be bad for this number. It will always be a region of one interval, possibly two if the interval wraps around (eg. <code>8, 9, 0, 1, 2</code> wraps around, to become <code>[8, 9]</code> and <code>[0, 1, 2]</code>.)</p> \n  <p>At the end of plotting these intervals, we need to know which rotation index has the least intervals overlapping it - this one is the answer.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>First, an element like <code>A[2] = 5</code> will not get score in (up to) 5 posiitons: when the 5 is at final index 0, 1, 2, 3, or 4. When we shift by 2, we'll get final index 0. If we shift <code>5-1 = 4</code> before this, this element will end up at final index 4. In general (modulo N), a shift of <code>i - A[i] + 1</code> to <code>i</code> will be the rotation indexes that will make <code>A[i]</code> not score a point.</p> \n  <p>If we are trying to plot an interval like <code>[2, 3, 4]</code>, then instead of doing <code>bad[2]--; bad[3]--; bad[4]--;</code>, what we will do instead is keep track of the cumulative total: <code>bad[2]--; bad[5]++</code>. For \"wrap-around\" intervals like <code>[8, 9, 0, 1, 2]</code>, we will keep track of this as two separate intervals: <code>bad[8]--, bad[10]++, bad[0]--, bad[3]++</code>. (Actually, because of our implementation, we don't need to remember the <code>bad[10]++</code> part.)</p> \n  <p>At the end, we want to find a rotation index with the least intervals overlapping. We'll maintain a cumulative total <code>cur</code> representing how many intervals are currently overlapping our current rotation index, then update it as we step through each rotation index.</p> \n  <iframe src=\"https://leetcode.com/playground/wYbwGZmT/shared\" frameborder=\"0\" width=\"100%\" height=\"480\" name=\"wYbwGZmT\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>A</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 797,
    "article_live": true,
    "article_slug": "all-paths-from-source-to-target",
    "title": "All Paths From Source to Target",
    "title_slug": "all-paths-from-source-to-target",
    "content": "<p>Given a directed, acyclic graph of <code>N</code> nodes.&nbsp; Find all possible paths from node <code>0</code> to node <code>N-1</code>, and return them in any order.</p>\r\n\r\n<p>The graph is given as follows:&nbsp; the nodes are 0, 1, ..., graph.length - 1.&nbsp; graph[i] is a list of all nodes j for which the edge (i, j) exists.</p>\r\n\r\n<pre>\r\n<strong>Example:</strong>\r\n<strong>Input:</strong> [[1,2], [3], [3], []] \r\n<strong>Output:</strong> [[0,1,3],[0,2,3]] \r\n<strong>Explanation:</strong> The graph looks like this:\r\n0---&gt;1\r\n|    |\r\nv    v\r\n2---&gt;3\r\nThere are two paths: 0 -&gt; 1 -&gt; 3 and 0 -&gt; 2 -&gt; 3.\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>The number of nodes in the graph will be in the range <code>[2, 15]</code>.</li>\r\n\t<li>You can print different paths in any order, but you should keep the order of nodes inside one path.</li>\r\n</ul>\r\n",
    "tags": "",
    "difficulty": 2,
    "frontend_article_id": 797,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-recursion-accepted\">Approach #1: Recursion [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-recursion-accepted\">Approach #1: Recursion [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Since the graph is a directed, acyclic graph, any path from <code>A</code> to <code>B</code> is going to be composed of <code>A</code> plus a path from any neighbor of <code>A</code> to <code>B</code>. We can use a recursion to return the answer.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Let <code>N</code> be the number of nodes in the graph. If we are at node <code>N-1</code>, the answer is just the path <code>{N-1}</code>. Otherwise, if we are at node <code>node</code>, the answer is <code>{node} + {path from nei to N-1}</code> for each neighbor <code>nei</code> of <code>node</code>. This is a natural setting to use a recursion to form the answer.</p> \n  <iframe src=\"https://leetcode.com/playground/KUaNbvp4/shared\" frameborder=\"0\" width=\"100%\" height=\"463\" name=\"KUaNbvp4\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(2^N N^2)</script>. We can have exponentially many paths, and for each such path, our prepending operation <code>path.add(0, node)</code> will be <script type=\"math/tex; mode=display\">O(N^2)</script>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(2^N N)</script>, the size of the output dominating the final space complexity.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 796,
    "article_live": true,
    "article_slug": "rotate-string",
    "title": "Rotate String",
    "title_slug": "rotate-string",
    "content": "<p>We are given two strings, <code>A</code> and <code>B</code>.</p>\r\n\r\n<p>A <em>shift on <code>A</code></em> consists of taking string <code>A</code> and moving the leftmost character to the rightmost position. For example, if <code>A = &#39;abcde&#39;</code>, then it will be <code>&#39;bcdea&#39;</code> after one shift on <code>A</code>. Return <code>True</code> if and only if <code>A</code> can become <code>B</code> after some number of shifts on <code>A</code>.</p>\r\n\r\n<pre>\r\n<strong>Example 1:</strong>\r\n<strong>Input:</strong> A = &#39;abcde&#39;, B = &#39;cdeab&#39;\r\n<strong>Output:</strong> true\r\n\r\n<strong>Example 2:</strong>\r\n<strong>Input:</strong> A = &#39;abcde&#39;, B = &#39;abced&#39;\r\n<strong>Output:</strong> false\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>A</code> and <code>B</code> will have length at most <code>100</code>.</li>\r\n</ul>\r\n",
    "tags": "",
    "difficulty": 1,
    "frontend_article_id": 796,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-brute-force-accepted\">Approach #1: Brute Force [Accepted]</a></li> \n    <li><a href=\"#approach-2-simple-check-accepted\">Approach #2: Simple Check [Accepted]</a></li> \n    <li><a href=\"#approach-3-rolling-hash-accepted\">Approach #3: Rolling Hash [Accepted]</a></li> \n    <li><a href=\"#approach-4-kmp-knuth-morris-pratt-accepted\">Approach #4: KMP (Knuth-Morris-Pratt) [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-brute-force-accepted\">Approach #1: Brute Force [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>For each rotation of <code>A</code>, let's check if it equals <code>B</code>.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>More specifically, say we rotate <code>A</code> by <code>s</code>. Then, instead of <code>A[0], A[1], A[2], ...</code>, we have <code>A[s], A[s+1], A[s+2], ...</code>; and we should check that <code>A[s] == B[0]</code>, <code>A[s+1] == B[1]</code>, <code>A[s+2] == B[2]</code>, etc.</p> \n  <iframe src=\"https://leetcode.com/playground/Q9S39BXZ/shared\" frameborder=\"0\" width=\"100%\" height=\"361\" name=\"Q9S39BXZ\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>A</code>. For each rotation <code>s</code>, we check up to <script type=\"math/tex; mode=display\">N</script> elements in <code>A</code> and <code>B</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>. We only use pointers to elements of <code>A</code> and <code>B</code>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-simple-check-accepted\">Approach #2: Simple Check [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>All rotations of <code>A</code> are contained in <code>A+A</code>. Thus, we can simply check whether <code>B</code> is a substring of <code>A+A</code>. We also need to check <code>A.length == B.length</code>, otherwise we will fail cases like <code>A = \"a\", B = \"aa\"</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/ETPY9FAY/shared\" frameborder=\"0\" width=\"100%\" height=\"140\" name=\"ETPY9FAY\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>A</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the space used building <code>A+A</code>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-rolling-hash-accepted\">Approach #3: Rolling Hash [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Our approach comes down to quickly checking whether want to check whether <code>B</code> is a substring of <code>A2 = A+A</code>. Specifically, (if <code>N = A.length</code>) we should check whether <code>B = A2[0:N], or B = A2[1:N+1], or B = A2[2:N+2]</code> and so on. To check this, we can use a rolling hash.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>For a string <code>S</code>, say <code>hash(S) = (S[0] * P**0 + S[1] * P**1 + S[2] * P**2 + ...) % MOD</code>, where <code>X**Y</code> represents exponentiation, and <code>S[i]</code> is the ASCII character code of the string at that index.</p> \n  <p>The idea is that <code>hash(S)</code> has output that is approximately uniformly distributed between <code>[0, 1, 2, ..., MOD-1]</code>, and so if <code>hash(S) == hash(T)</code> it is very likely that <code>S == T</code>.</p> \n  <p>Now say we have a hash <code>hash(A)</code>, and we want the hash of <code>A[1], A[2], ..., A[N-1], A[0]</code>. We can subtract <code>A[0]</code> from the hash, divide by <code>P</code>, and add <code>A[0] * P**(N-1)</code>. (Our division is under the finite field <script type=\"math/tex; mode=display\">\\mathbb{F}_\\text{MOD}</script> - done by multiplying by the modular inverse <code>Pinv = pow(P, MOD-2, MOD)</code>.)</p> \n  <iframe src=\"https://leetcode.com/playground/v8qW4q9q/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"v8qW4q9q\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>A</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, to perform the final check <code>A_rotation == B</code>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-4-kmp-knuth-morris-pratt-accepted\">Approach #4: KMP (Knuth-Morris-Pratt) [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>As before, we want to find whether <code>B</code> exists in <code>A+A</code>. The KMP algorithm is a textbook algorithm that does string matching in linear time, which is faster than brute force.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>The algorithm is broken up into two steps, building the shifts table (or <em>failure table</em>), and using it to find whether a match exists.</p> \n  <p>The shift table tells us about the largest prefix of <code>B</code> that ends here. More specifically, <code>B[:shifts[i+1]] == B[i - shifts[i+1] : i]</code> is the largest possible prefix of <code>B</code> ending before <code>B[i]</code>.</p> \n  <p>To build the shift table, we use a dynamic programming approach, where all previously calculated values of <code>shifts</code> are correct. Then, <code>left</code> will be the end of the candidate prefix of <code>B</code>, and <code>right</code> will be the end of the candidate section that should match the prefix <code>B[0], B[1], ..., B[left]</code>. Call positions <code>(left, right)</code> \"matching\" if the prefix ending at <code>B[left]</code> matches the same length string ending at <code>B[right]</code>. The invariant in our loop will be that <code>(left - 1, right - 1)</code> is matching by the end of each for-block.</p> \n  <p>In a new for-block, if <code>(left, right)</code> is matching (ie. <code>(left - 1, right - 1)</code> is matching from before, plus <code>B[left] == B[right]</code>), then we know the shift (<code>right - left</code>) is the same number as before. Otherwise, when <code>(left, right)</code> is not matching, we need to find a shorter prefix.</p> \n  <p>Our strategy is to find a matching of <code>(left2, right)</code> where <code>left2 &lt; left</code>, by finding matchings <code>(left2 - 1, right - 1)</code> plus checking <code>B[left2] == B[right]</code>. Since <code>(left - 1, right - 1)</code> is a matching, by transitivity we want to find matchings <code>(left2 - 1, left - 1)</code>. The largest such <code>left2</code> is <code>left2 = left - shifts[left]</code>. We repeatedly check these <code>left2</code>'s in greedy order from largest to smallest.</p> \n  <p>To find a match of <code>B</code> in <code>A+A</code> with such a shift table ready, we employ a similar strategy. We maintain a matching <code>(match_len - 1, i - 1)</code>, where these positions correspond to strings of length <code>match_len</code> that end at <code>B[match_len - 1]</code> and <code>(A+A)[i-1]</code> respectively.</p> \n  <p>Now when trying to find the largest length matching for <code>(A+A)</code> at position <code>i</code>, it must be at most <code>(match_len - 1) + 1</code>, where the quantity in brackets is the largest length matching to position <code>i-1</code>.</p> \n  <p>Again, our strategy is to find a matching <code>(match_len2 - 1, i - 1)</code> plus check that <code>B[match_len2] == (A+A)[i]</code>. Similar to before, if <code>B[match_len] != (A+A)[i]</code>, then because <code>(match_len - 1, i - 1)</code> was a matching, by transitivity <code>(match_len2 - 1, match_len - 1)</code> must be a matching, of which the largest is found by <code>match_len2 = match_len - shifts[match_len]</code>. We also repeatedly check these <code>match_len</code>'s in order from largest to smallest.</p> \n  <p>If at any point in this algorithm our match length is <code>N</code>, we've found <code>B</code> in <code>A+A</code> successfully.</p> \n  <iframe src=\"https://leetcode.com/playground/PBHA9iPW/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"PBHA9iPW\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>A</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, to create the shift table <code>shifts</code>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 795,
    "article_live": true,
    "article_slug": "number-of-subarrays-with-bounded-maximum",
    "title": "Number of Subarrays with Bounded Maximum",
    "title_slug": "number-of-subarrays-with-bounded-maximum",
    "content": "<p>We are given an array <code>A</code> of positive integers, and two positive integers <code>L</code> and <code>R</code> (<code>L &lt;= R</code>).</p>\r\n\r\n<p>Return the number of (contiguous, non-empty) subarrays such that the value of the maximum array element in that subarray is at least <code>L</code> and at most <code>R</code>.</p>\r\n\r\n<pre>\r\n<strong>Example :</strong>\r\n<strong>Input:</strong> \r\nA = [2, 1, 4, 3]\r\nL = 2\r\nR = 3\r\n<strong>Output:</strong> 3\r\n<strong>Explanation:</strong> There are three subarrays that meet the requirements: [2], [2, 1], [3].\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>L, R&nbsp; and <code>A[i]</code> will be an integer in the range <code>[0, 10^9]</code>.</li>\r\n\t<li>The length of <code>A</code> will be in the range of <code>[1, 50000]</code>.</li>\r\n</ul>\r\n",
    "tags": "Array",
    "difficulty": 2,
    "frontend_article_id": 795,
    "article_content": ""
},
{
    "frontend_question_id": 794,
    "article_live": true,
    "article_slug": "valid-tic-tac-toe-state",
    "title": "Valid Tic-Tac-Toe State",
    "title_slug": "valid-tic-tac-toe-state",
    "content": "<p>A Tic-Tac-Toe board is given as a string array <code>board</code>. Return True if and only if it is possible to reach this board position during the course of a valid tic-tac-toe game.</p>\r\n\r\n<p>The <code>board</code> is a 3 x 3 array, and consists of characters <code>&quot; &quot;</code>, <code>&quot;X&quot;</code>, and <code>&quot;O&quot;</code>.&nbsp; The &quot; &quot; character represents an empty square.</p>\r\n\r\n<p>Here are the rules of Tic-Tac-Toe:</p>\r\n\r\n<ul>\r\n\t<li>Players take turns placing characters into empty squares (&quot; &quot;).</li>\r\n\t<li>The first player always places &quot;X&quot; characters, while the second player always places &quot;O&quot; characters.</li>\r\n\t<li>&quot;X&quot; and &quot;O&quot; characters are always placed into empty squares, never filled ones.</li>\r\n\t<li>The game ends when there are 3 of the same (non-empty) character filling any row, column, or diagonal.</li>\r\n\t<li>The game also ends if all squares are non-empty.</li>\r\n\t<li>No more moves can be played if the game is over.</li>\r\n</ul>\r\n\r\n<pre>\r\n<strong>Example 1:</strong>\r\n<strong>Input:</strong> board = [&quot;O&nbsp; &quot;, &quot;&nbsp; &nbsp;&quot;, &quot;&nbsp; &nbsp;&quot;]\r\n<strong>Output:</strong> false\r\n<strong>Explanation:</strong> The first player always plays &quot;X&quot;.\r\n\r\n<strong>Example 2:</strong>\r\n<strong>Input:</strong> board = [&quot;XOX&quot;, &quot; X &quot;, &quot;   &quot;]\r\n<strong>Output:</strong> false\r\n<strong>Explanation:</strong> Players take turns making moves.\r\n\r\n<strong>Example 3:</strong>\r\n<strong>Input:</strong> board = [&quot;XXX&quot;, &quot;   &quot;, &quot;OOO&quot;]\r\n<strong>Output:</strong> false\r\n\r\n<strong>Example 4:</strong>\r\n<strong>Input:</strong> board = [&quot;XOX&quot;, &quot;O O&quot;, &quot;XOX&quot;]\r\n<strong>Output:</strong> true\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>board</code> is a length-3 array of strings, where each string <code>board[i]</code> has length 3.</li>\r\n\t<li>Each <code>board[i][j]</code> is a character in the set <code>{&quot; &quot;, &quot;X&quot;, &quot;O&quot;}</code>.</li>\r\n</ul>\r\n",
    "tags": "Math, Recursion",
    "difficulty": 2,
    "frontend_article_id": 794,
    "article_content": ""
},
{
    "frontend_question_id": 793,
    "article_live": true,
    "article_slug": "preimage-size-of-factorial-zeroes-function",
    "title": "Preimage Size of Factorial Zeroes Function",
    "title_slug": "preimage-size-of-factorial-zeroes-function",
    "content": "<p>Let <code>f(x)</code> be the number of zeroes at the end of <code>x!</code>. (Recall that <code>x! = 1 * 2 * 3 * ... * x</code>, and by convention, <code>0! = 1</code>.)</p>\r\n\r\n<p>For example, <code>f(3) = 0</code> because 3! = 6 has no zeroes at the end, while <code>f(11) = 2</code> because 11! = 39916800 has 2 zeroes at the end. Given <code>K</code>, find how many non-negative integers <code>x</code> have the property that <code>f(x) = K</code>.</p>\r\n\r\n<pre>\r\n<strong>Example 1:</strong>\r\n<strong>Input:</strong> K = 0\r\n<strong>Output:</strong> 5\r\n<strong>Explanation:</strong> 0!, 1!, 2!, 3!, and 4! end with K = 0 zeroes.\r\n\r\n<strong>Example 2:</strong>\r\n<strong>Input:</strong> K = 5\r\n<strong>Output:</strong> 0\r\n<strong>Explanation:</strong> There is no x such that x! ends in K = 5 zeroes.\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>K</code> will be an integer in the range <code>[0, 10^9]</code>.</li>\r\n</ul>\r\n",
    "tags": "Binary Search",
    "difficulty": 3,
    "frontend_article_id": 793,
    "article_content": ""
},
{
    "frontend_question_id": 792,
    "article_live": true,
    "article_slug": "number-of-matching-subsequences",
    "title": "Number of Matching Subsequences",
    "title_slug": "number-of-matching-subsequences",
    "content": "<p>Given string <code>S</code> and a&nbsp;dictionary of words <code>words</code>, find the number of <code>words[i]</code> that is a subsequence of <code>S</code>.</p>\r\n\r\n<pre>\r\n<strong>Example :</strong>\r\n<strong>Input:</strong> \r\nS = &quot;abcde&quot;\r\nwords = [&quot;a&quot;, &quot;bb&quot;, &quot;acd&quot;, &quot;ace&quot;]\r\n<strong>Output:</strong> 3\r\n<strong>Explanation:</strong> There are three words in <code>words</code> that are a subsequence of <code>S</code>: &quot;a&quot;, &quot;acd&quot;, &quot;ace&quot;.\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>All words in <code>words</code> and <code>S</code> will only consists of lowercase letters.</li>\r\n\t<li>The length of <code>S</code> will be in the range of <code>[1, 50000]</code>.</li>\r\n\t<li>The length of <code>words</code> will be in the range of&nbsp;<code>[1, 5000]</code>.</li>\r\n\t<li>The length of <code>words[i]</code> will be in the range of <code>[1, 50]</code>.</li>\r\n</ul>\r\n",
    "tags": "Array",
    "difficulty": 2,
    "frontend_article_id": 792,
    "article_content": ""
},
{
    "frontend_question_id": 791,
    "article_live": true,
    "article_slug": "custom-sort-string",
    "title": "Custom Sort String",
    "title_slug": "custom-sort-string",
    "content": "<p><code>S</code> and <code>T</code> are strings composed of lowercase letters. In <code>S</code>, no letter occurs more than once.</p>\r\n\r\n<p><code>S</code> was sorted in some custom order previously. We want to permute the characters of <code>T</code> so that they match the order that <code>S</code> was sorted. More specifically, if <code>x</code> occurs before <code>y</code> in <code>S</code>, then <code>x</code> should occur before <code>y</code> in the returned string.</p>\r\n\r\n<p>Return any permutation of <code>T</code> (as a string) that satisfies this property.</p>\r\n\r\n<pre>\r\n<strong>Example :</strong>\r\n<strong>Input:</strong> \r\nS = &quot;cba&quot;\r\nT = &quot;abcd&quot;\r\n<strong>Output:</strong> &quot;cbad&quot;\r\n<strong>Explanation:</strong> \r\n&quot;a&quot;, &quot;b&quot;, &quot;c&quot; appear in S, so the order of &quot;a&quot;, &quot;b&quot;, &quot;c&quot; should be &quot;c&quot;, &quot;b&quot;, and &quot;a&quot;. \r\nSince &quot;d&quot; does not appear in S, it can be at any position in T. &quot;dcba&quot;, &quot;cdba&quot;, &quot;cbda&quot; are also valid outputs.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>S</code> has length at most <code>26</code>, and no character is repeated in <code>S</code>.</li>\r\n\t<li><code>T</code> has length at most <code>200</code>.</li>\r\n\t<li><code>S</code> and <code>T</code> consist of lowercase letters only.</li>\r\n</ul>\r\n",
    "tags": "String",
    "difficulty": 2,
    "frontend_article_id": 791,
    "article_content": ""
},
{
    "frontend_question_id": 790,
    "article_live": true,
    "article_slug": "domino-and-tromino-tiling",
    "title": "Domino and Tromino Tiling",
    "title_slug": "domino-and-tromino-tiling",
    "content": "<p>We have two types of tiles: a 2x1 domino shape, and an &quot;L&quot; tromino shape. These shapes may be rotated.</p>\r\n\r\n<pre>\r\nXX  &lt;- domino\r\n\r\nXX  &lt;- &quot;L&quot; tromino\r\nX\r\n</pre>\r\n\r\n<p>Given N, how many ways are there to tile a 2 x N board? <strong>Return your answer modulo 10^9 + 7</strong>.</p>\r\n\r\n<p>(In a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.)</p>\r\n\r\n\r\n<pre>\r\n<strong>Example:</strong>\r\n<strong>Input:</strong> 3\r\n<strong>Output:</strong> 5\r\n<strong>Explanation:</strong> \r\nThe five different ways are listed below, different letters indicates different tiles:\r\nXYZ XXZ XYY XXY XYY\r\nXYZ YYZ XZZ XYY XXY</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>N&nbsp; will be in range <code>[1, 1000]</code>.</li>\r\n</ul>\r\n\r\n<p>&nbsp;</p>\r\n",
    "tags": "Dynamic Programming",
    "difficulty": 2,
    "frontend_article_id": 790,
    "article_content": ""
},
{
    "frontend_question_id": 789,
    "article_live": true,
    "article_slug": "escape-the-ghosts",
    "title": "Escape The Ghosts",
    "title_slug": "escape-the-ghosts",
    "content": "<p>You are playing a simplified Pacman game. You&nbsp;start at the point <code>(0, 0)</code>, and your destination is<code> (target[0], target[1])</code>. There are several ghosts on the map, the i-th ghost starts at<code> (ghosts[i][0], ghosts[i][1])</code>.</p>\r\n\r\n<p>Each turn, you and all ghosts simultaneously *may* move in one of 4 cardinal directions: north, east, west, or south, going from the previous point to a new point 1 unit of distance away.</p>\r\n\r\n<p>You escape if and only if you can reach the target before any ghost reaches you (for any given moves the ghosts may take.)&nbsp; If you reach any square (including the target) at the same time as a ghost, it doesn&#39;t count as an escape.</p>\r\n\r\n<p>Return True if and only if it is possible to escape.</p>\r\n\r\n<pre>\r\n<strong>Example 1:</strong>\r\n<strong>Input:</strong> \r\nghosts = [[1, 0], [0, 3]]\r\ntarget = [0, 1]\r\n<strong>Output:</strong> true\r\n<strong>Explanation:</strong> \r\nYou can directly reach the destination (0, 1) at time 1, while the ghosts located at (1, 0) or (0, 3) have no way to catch up with you.\r\n</pre>\r\n\r\n<pre>\r\n<strong>Example 2:</strong>\r\n<strong>Input:</strong> \r\nghosts = [[1, 0]]\r\ntarget = [2, 0]\r\n<strong>Output:</strong> false\r\n<strong>Explanation:</strong> \r\nYou need to reach the destination (2, 0), but the ghost at (1, 0) lies between you and the destination.\r\n</pre>\r\n\r\n<pre>\r\n<strong>Example 3:</strong>\r\n<strong>Input:</strong> \r\nghosts = [[2, 0]]\r\ntarget = [1, 0]\r\n<strong>Output:</strong> false\r\n<strong>Explanation:</strong> \r\nThe ghost can reach the target at the same time as you.\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>All points have coordinates with absolute value &lt;= <code>10000</code>.</li>\r\n\t<li>The number of ghosts will not exceed <code>100</code>.</li>\r\n</ul>\r\n",
    "tags": "Math",
    "difficulty": 2,
    "frontend_article_id": 789,
    "article_content": ""
},
{
    "frontend_question_id": 788,
    "article_live": true,
    "article_slug": "rotated-digits",
    "title": "Rotated Digits",
    "title_slug": "rotated-digits",
    "content": "<p>X is a good number if after rotating each digit individually by 180 degrees, we get a valid number that is different from X.&nbsp; Each digit must be rotated - we cannot choose to leave it alone.</p>\r\n\r\n<p>A number is valid if each digit remains a digit after rotation. 0, 1, and 8 rotate to themselves; 2 and 5 rotate to each other; 6 and 9 rotate to each other, and the rest of the numbers do not rotate to any other number and become invalid.</p>\r\n\r\n<p>Now&nbsp;given a positive number <code>N</code>, how many numbers X from <code>1</code> to <code>N</code> are good?</p>\r\n\r\n<pre>\r\n<strong>Example:</strong>\r\n<strong>Input:</strong> 10\r\n<strong>Output:</strong> 4\r\n<strong>Explanation:</strong> \r\nThere are four good numbers in the range [1, 10] : 2, 5, 6, 9.\r\nNote that 1 and 10 are not good numbers, since they remain unchanged after rotating.\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>N&nbsp; will be in range <code>[1, 10000]</code>.</li>\r\n</ul>\r\n",
    "tags": "String",
    "difficulty": 1,
    "frontend_article_id": 788,
    "article_content": ""
},
{
    "frontend_question_id": 787,
    "article_live": true,
    "article_slug": "cheapest-flights-within-k-stops",
    "title": "Cheapest Flights Within K Stops",
    "title_slug": "cheapest-flights-within-k-stops",
    "content": "<p>There are <code>n</code> cities connected by&nbsp;<code>m</code> flights. Each fight starts from city&nbsp;<code>u </code>and arrives at&nbsp;<code>v</code> with a price <code>w</code>.</p>\r\n\r\n<p>Now given all the cities and flights, together with starting city <code>src</code> and the destination&nbsp;<code>dst</code>, your task is to find the cheapest price from <code>src</code> to <code>dst</code> with up to <code>k</code> stops. If there is no such route, output <code>-1</code>.</p>\r\n\r\n<pre>\r\n<strong>Example 1:</strong>\r\n<strong>Input:</strong> \r\nn = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]\r\nsrc = 0, dst = 2, k = 1\r\n<strong>Output:</strong> 200\r\n<strong>Explanation:</strong> \r\nThe graph looks like this:\r\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/02/16/995.png\" style=\"height:180px; width:246px\" />\r\n\r\nThe cheapest price from city <code>0</code> to city <code>2</code> with at most 1 stop costs 200, as marked red in the picture.</pre>\r\n\r\n<pre>\r\n<strong>Example 2:</strong>\r\n<strong>Input:</strong> \r\nn = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]\r\nsrc = 0, dst = 2, k = 0\r\n<strong>Output:</strong> 500\r\n<strong>Explanation:</strong> \r\nThe graph looks like this:\r\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/02/16/995.png\" style=\"height:180px; width:246px\" />\r\n\r\nThe cheapest price from city <code>0</code> to city <code>2</code> with at most 0 stop costs 500, as marked blue in the picture.</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>The number of&nbsp;nodes&nbsp;<code>n</code> will be&nbsp;in range <code>[1, 100]</code>, with nodes labeled from <code>0</code> to <code>n</code><code> - 1</code>.</li>\r\n\t<li>The&nbsp;size of <code>flights</code> will be&nbsp;in range <code>[0, n * (n - 1) / 2]</code>.</li>\r\n\t<li>The format of each flight will be <code>(src, </code><code>dst</code><code>, price)</code>.</li>\r\n\t<li>The price of each flight will be in the range <code>[1, 10000]</code>.</li>\r\n\t<li><code>k</code> is in the range of <code>[0, n - 1]</code>.</li>\r\n\t<li>There&nbsp;will&nbsp;not&nbsp;be&nbsp;any&nbsp;duplicated&nbsp;flights or&nbsp;self&nbsp;cycles.</li>\r\n</ul>\r\n",
    "tags": "Dynamic Programming, Heap, Breadth-first Search",
    "difficulty": 2,
    "frontend_article_id": 787,
    "article_content": ""
},
{
    "frontend_question_id": 786,
    "article_live": true,
    "article_slug": "k-th-smallest-prime-fraction",
    "title": "K-th Smallest Prime Fraction",
    "title_slug": "k-th-smallest-prime-fraction",
    "content": "<p>A sorted list <code>A</code> contains 1, plus some number of primes.&nbsp; Then, for every p &lt; q in the list, we consider the fraction p/q.</p>\r\n\r\n<p>What is the <code>K</code>-th smallest fraction considered?&nbsp; Return your answer as an array of ints, where <code>answer[0] = p</code> and <code>answer[1] = q</code>.</p>\r\n\r\n<pre>\r\n<strong>Examples:</strong>\r\n<strong>Input:</strong> A = [1, 2, 3, 5], K = 3\r\n<strong>Output:</strong> [2, 5]\r\n<strong>Explanation:</strong>\r\nThe fractions to be considered in sorted order are:\r\n1/5, 1/3, 2/5, 1/2, 3/5, 2/3.\r\nThe third fraction is 2/5.\r\n\r\n<strong>Input:</strong> A = [1, 7], K = 1\r\n<strong>Output:</strong> [1, 7]\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>A</code> will have length between <code>2</code> and <code>2000</code>.</li>\r\n\t<li>Each <code>A[i]</code> will be between <code>1</code> and <code>30000</code>.</li>\r\n\t<li><code>K</code> will be between <code>1</code> and <code>A.length * (A.length - 1) / 2</code>.</li>\r\n</ul>",
    "tags": "Binary Search, Heap",
    "difficulty": 3,
    "frontend_article_id": 786,
    "article_content": ""
},
{
    "frontend_question_id": 785,
    "article_live": true,
    "article_slug": "is-graph-bipartite",
    "title": "Is Graph Bipartite?",
    "title_slug": "is-graph-bipartite",
    "content": "<p>Given an undirected&nbsp;<code>graph</code>, return <code>true</code> if and only if it is bipartite.</p>\r\n\r\n<p>Recall that a graph is <em>bipartite</em> if we can split it&#39;s set of nodes into two independent&nbsp;subsets A and B such that every edge in the graph has one node in A and another node in B.</p>\r\n\r\n<p>The graph is given in the following form: <code>graph[i]</code> is a list of indexes <code>j</code> for which the edge between nodes <code>i</code> and <code>j</code> exists.&nbsp; Each node is an integer between <code>0</code> and <code>graph.length - 1</code>.&nbsp; There are no self edges or parallel edges: <code>graph[i]</code> does not contain <code>i</code>, and it doesn&#39;t contain any element twice.</p>\r\n\r\n<pre>\r\n<strong>Example 1:</strong>\r\n<strong>Input:</strong> [[1,3], [0,2], [1,3], [0,2]]\r\n<strong>Output:</strong> true\r\n<strong>Explanation:</strong> \r\nThe graph looks like this:\r\n0----1\r\n|    |\r\n|    |\r\n3----2\r\nWe can divide the vertices into two groups: {0, 2} and {1, 3}.\r\n</pre>\r\n\r\n<pre>\r\n<strong>Example 2:</strong>\r\n<strong>Input:</strong> [[1,2,3], [0,2], [0,1,3], [0,2]]\r\n<strong>Output:</strong> false\r\n<strong>Explanation:</strong> \r\nThe graph looks like this:\r\n0----1\r\n| \\  |\r\n|  \\ |\r\n3----2\r\nWe cannot find a way to divide the set of nodes into two independent subsets.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>graph</code> will have length in range <code>[1, 100]</code>.</li>\r\n\t<li><code>graph[i]</code> will contain integers in range <code>[0, graph.length - 1]</code>.</li>\r\n\t<li><code>graph[i]</code> will not contain <code>i</code> or duplicate values.</li>\r\n\t<li>The graph is undirected: if any element <code>j</code> is in <code>graph[i]</code>, then <code>i</code> will be in <code>graph[j]</code>.</li>\r\n</ul>\r\n",
    "tags": "Depth-first Search, Breadth-first Search, Graph",
    "difficulty": 2,
    "frontend_article_id": 785,
    "article_content": ""
},
{
    "frontend_question_id": 784,
    "article_live": true,
    "article_slug": "letter-case-permutation",
    "title": "Letter Case Permutation",
    "title_slug": "letter-case-permutation",
    "content": "<p>Given a string S, we can transform every letter individually&nbsp;to be lowercase or uppercase to create another string.&nbsp; Return a list of all possible strings we could create.</p>\r\n\r\n<pre>\r\n<strong>Examples:</strong>\r\n<strong>Input:</strong> S = &quot;a1b2&quot;\r\n<strong>Output:</strong> [&quot;a1b2&quot;, &quot;a1B2&quot;, &quot;A1b2&quot;, &quot;A1B2&quot;]\r\n\r\n<strong>Input:</strong> S = &quot;3z4&quot;\r\n<strong>Output:</strong> [&quot;3z4&quot;, &quot;3Z4&quot;]\r\n\r\n<strong>Input:</strong> S = &quot;12345&quot;\r\n<strong>Output:</strong> [&quot;12345&quot;]\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>S</code> will be a string with length between <code>1</code> and <code>12</code>.</li>\r\n\t<li><code>S</code> will consist only of letters or digits.</li>\r\n</ul>\r\n",
    "tags": "Backtracking, Bit Manipulation",
    "difficulty": 1,
    "frontend_article_id": 784,
    "article_content": ""
},
{
    "frontend_question_id": 783,
    "article_live": true,
    "article_slug": "minimum-distance-between-bst-nodes",
    "title": "Minimum Distance Between BST Nodes",
    "title_slug": "minimum-distance-between-bst-nodes",
    "content": "<p>Given a Binary Search Tree (BST) with the root node <code>root</code>, return&nbsp;the minimum difference between the values of any two different nodes in the tree.</p>\r\n\r\n<p><strong>Example :</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> root = [4,2,6,1,3,null,null]\r\n<strong>Output:</strong> 1\r\n<strong>Explanation:</strong>\r\nNote that root is a TreeNode object, not an array.\r\n\r\nThe given tree [4,2,6,1,3,null,null] is represented by the following diagram:\r\n\r\n          4\r\n        /   \\\r\n      2      6\r\n     / \\    \r\n    1   3  \r\n\r\nwhile the minimum difference in this tree is 1, it occurs between node 1 and node 2, also between node 3 and node 2.\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li>The size of the BST will be between 2 and&nbsp;<code>100</code>.</li>\r\n\t<li>The BST is always valid, each node&#39;s value is an integer, and each node&#39;s value is different.</li>\r\n</ol>\r\n",
    "tags": "Binary Search Tree",
    "difficulty": 1,
    "frontend_article_id": 783,
    "article_content": ""
},
{
    "frontend_question_id": 782,
    "article_live": true,
    "article_slug": "transform-to-chessboard",
    "title": "Transform to Chessboard",
    "title_slug": "transform-to-chessboard",
    "content": "<p>An N x N <code>board</code> contains only <code>0</code>s and <code>1</code>s. In each move, you can swap any 2 rows with each other, or any 2 columns with each other.</p>\r\n\r\n<p>What is the minimum number of moves to transform the board into a &quot;chessboard&quot; - a board where no <code>0</code>s and no <code>1</code>s are 4-directionally adjacent? If the task is impossible, return -1.</p>\r\n\r\n<pre>\r\n<strong>Examples:</strong>\r\n<strong>Input:</strong> board = [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]]\r\n<strong>Output:</strong> 2\r\n<strong>Explanation:</strong>\r\nOne potential sequence of moves is shown below, from left to right:\r\n\r\n0110     1010     1010\r\n0110 --&gt; 1010 --&gt; 0101\r\n1001     0101     1010\r\n1001     0101     0101\r\n\r\nThe first move swaps the first and second column.\r\nThe second move swaps the second and third row.\r\n\r\n\r\n<strong>Input:</strong> board = [[0, 1], [1, 0]]\r\n<strong>Output:</strong> 0\r\n<strong>Explanation:</strong>\r\nAlso note that the board with 0 in the top left corner,\r\n01\r\n10\r\n\r\nis also a valid chessboard.\r\n\r\n<strong>Input:</strong> board = [[1, 0], [1, 0]]\r\n<strong>Output:</strong> -1\r\n<strong>Explanation:</strong>\r\nNo matter what sequence of moves you make, you cannot end with a valid chessboard.\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>board</code> will have the same number of rows and columns, a number in the range <code>[2, 30]</code>.</li>\r\n\t<li><code>board[i][j]</code> will be only <code>0</code>s or <code>1</code>s.</li>\r\n</ul>\r\n",
    "tags": "Array, Math",
    "difficulty": 3,
    "frontend_article_id": 782,
    "article_content": ""
},
{
    "frontend_question_id": 781,
    "article_live": true,
    "article_slug": "rabbits-in-forest",
    "title": "Rabbits in Forest",
    "title_slug": "rabbits-in-forest",
    "content": "<p>In a forest, each rabbit has some color. Some subset of rabbits (possibly all of them) tell you how many other rabbits have the same color as them. Those <code>answers</code> are placed in an array.</p>\r\n\r\n<p>Return the minimum number of rabbits that could be in the forest.</p>\r\n\r\n<pre>\r\n<strong>Examples:</strong>\r\n<strong>Input:</strong> answers = [1, 1, 2]\r\n<strong>Output:</strong> 5\r\n<strong>Explanation:</strong>\r\nThe two rabbits that answered &quot;1&quot; could both be the same color, say red.\r\nThe rabbit than answered &quot;2&quot; can&#39;t be red or the answers would be inconsistent.\r\nSay the rabbit that answered &quot;2&quot; was blue.\r\nThen there should be 2 other blue rabbits in the forest that didn&#39;t answer into the array.\r\nThe smallest possible number of rabbits in the forest is therefore 5: 3 that answered plus 2 that didn&#39;t.\r\n\r\n<strong>Input:</strong> answers = [10, 10, 10]\r\n<strong>Output:</strong> 11\r\n\r\n<strong>Input:</strong> answers = []\r\n<strong>Output:</strong> 0\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>answers</code> will have length at most <code>1000</code>.</li>\r\n\t<li>Each <code>answers[i]</code> will be an integer in the range <code>[0, 999]</code>.</li>\r\n</ol>\r\n",
    "tags": "Hash Table, Math",
    "difficulty": 2,
    "frontend_article_id": 781,
    "article_content": ""
},
{
    "frontend_question_id": 780,
    "article_live": true,
    "article_slug": "reaching-points",
    "title": "Reaching Points",
    "title_slug": "reaching-points",
    "content": "<p>A move consists of taking a point <code>(x, y)</code> and transforming it to either <code>(x, x+y)</code> or <code>(x+y, y)</code>.</p>\r\n\r\n<p>Given a starting point <code>(sx, sy)</code> and a target point <code>(tx, ty)</code>, return <code>True</code> if and only if a sequence of moves exists to transform the point <code>(sx, sy)</code> to <code>(tx, ty)</code>. Otherwise, return <code>False</code>.</p>\r\n\r\n<pre>\r\n<strong>Examples:</strong>\r\n<strong>Input:</strong> sx = 1, sy = 1, tx = 3, ty = 5\r\n<strong>Output:</strong> True\r\n<strong>Explanation:</strong>\r\nOne series of moves that transforms the starting point to the target is:\r\n(1, 1) -&gt; (1, 2)\r\n(1, 2) -&gt; (3, 2)\r\n(3, 2) -&gt; (3, 5)\r\n\r\n<strong>Input:</strong> sx = 1, sy = 1, tx = 2, ty = 2\r\n<strong>Output:</strong> False\r\n\r\n<strong>Input:</strong> sx = 1, sy = 1, tx = 1, ty = 1\r\n<strong>Output:</strong> True\r\n\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>sx, sy, tx, ty</code> will all be integers in the range <code>[1, 10^9]</code>.</li>\r\n</ul>\r\n",
    "tags": "Math",
    "difficulty": 3,
    "frontend_article_id": 780,
    "article_content": ""
},
{
    "frontend_question_id": 779,
    "article_live": true,
    "article_slug": "k-th-symbol-in-grammar",
    "title": "K-th Symbol in Grammar",
    "title_slug": "k-th-symbol-in-grammar",
    "content": "<p>On the first row, we write a <code>0</code>. Now in every subsequent row, we look at the previous row and replace each occurrence of <code>0</code> with <code>01</code>, and each occurrence of <code>1</code> with <code>10</code>.</p>\r\n\r\n<p>Given row <code>N</code> and index <code>K</code>, return the <code>K</code>-th indexed symbol in row <code>N</code>. (The values of <code>K</code> are 1-indexed.) (1 indexed).</p>\r\n\r\n<pre>\r\n<strong>Examples:</strong>\r\n<strong>Input:</strong> N = 1, K = 1\r\n<strong>Output:</strong> 0\r\n\r\n<strong>Input:</strong> N = 2, K = 1\r\n<strong>Output:</strong> 0\r\n\r\n<strong>Input:</strong> N = 2, K = 2\r\n<strong>Output:</strong> 1\r\n\r\n<strong>Input:</strong> N = 4, K = 5\r\n<strong>Output:</strong> 1\r\n\r\n<strong>Explanation:</strong>\r\nrow 1: 0\r\nrow 2: 01\r\nrow 3: 0110\r\nrow 4: 01101001\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>N</code> will be an integer in the range <code>[1, 30]</code>.</li>\r\n\t<li><code>K</code> will be an integer in the range <code>[1, 2^(N-1)]</code>.</li>\r\n</ol>\r\n",
    "tags": "Recursion",
    "difficulty": 2,
    "frontend_article_id": 779,
    "article_content": ""
},
{
    "frontend_question_id": 778,
    "article_live": true,
    "article_slug": "swim-in-rising-water",
    "title": "Swim in Rising Water",
    "title_slug": "swim-in-rising-water",
    "content": "<p>On an N x N <code>grid</code>, each square <code>grid[i][j]</code> represents the elevation at that point <code>(i,j)</code>.</p>\r\n\r\n<p>Now rain starts to fall. At time <code>t</code>, the depth of the water everywhere is <code>t</code>. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are&nbsp;at most&nbsp;<code>t</code>. You can swim infinite distance in zero time. Of course, you must stay within the boundaries of the grid during your swim.</p>\r\n\r\n<p>You start at the top left square <code>(0, 0)</code>. What is the least time until you can reach the bottom right square <code>(N-1, N-1)</code>?</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [[0,2],[1,3]]\r\n<strong>Output:</strong> 3\r\n<strong>Explanation:</strong>\r\nAt time <code>0</code>, you are in grid location <code>(0, 0)</code>.\r\nYou cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.\r\n\r\nYou cannot reach point <code>(1, 1)</code> until time <code>3</code>.\r\nWhen the depth of water is <code>3</code>, we can swim anywhere inside the grid.\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]\r\n<strong>Output:</strong> 16\r\n<strong>Explanation:</strong>\r\n<strong> 0  1  2  3  4</strong>\r\n24 23 22 21  <strong>5</strong>\r\n<strong>12 13 14 15 16</strong>\r\n<strong>11</strong> 17 18 19 20\r\n<strong>10  9  8  7  6</strong>\r\n\r\nThe final route is marked in bold.\r\nWe need to wait until time 16 so that (0, 0) and (4, 4) are connected.\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>2 &lt;= N &lt;= 50</code>.</li>\r\n\t<li>grid[i][j] is a permutation of [0, ..., N*N - 1].</li>\r\n</ol>\r\n",
    "tags": "Binary Search, Heap, Depth-first Search, Union Find",
    "difficulty": 3,
    "frontend_article_id": 778,
    "article_content": ""
},
{
    "frontend_question_id": 777,
    "article_live": true,
    "article_slug": "swap-adjacent-in-lr-string",
    "title": "Swap Adjacent in LR String",
    "title_slug": "swap-adjacent-in-lr-string",
    "content": "<p>In a string composed of <code>&#39;L&#39;</code>, <code>&#39;R&#39;</code>, and <code>&#39;X&#39;</code> characters, like <code>&quot;RXXLRXRXL&quot;</code>, a move consists of either replacing one occurrence of <code>&quot;XL&quot;</code> with <code>&quot;LX&quot;</code>, or replacing one occurrence of <code>&quot;RX&quot;</code> with <code>&quot;XR&quot;</code>. Given the starting string <code>start</code> and the ending string <code>end</code>, return <code>True</code> if and only if there exists a sequence of moves to transform one string to the other.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> start = &quot;RXXLRXRXL&quot;, end = &quot;XRLXXRRLX&quot;\r\n<strong>Output:</strong> True\r\n<strong>Explanation:</strong>\r\nWe can transform start to end following these steps:\r\nRXXLRXRXL -&gt;\r\nXRXLRXRXL -&gt;\r\nXRLXRXRXL -&gt;\r\nXRLXXRRXL -&gt;\r\nXRLXXRRLX\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= len(start) = len(end) &lt;= 10000</code>.</li>\r\n\t<li>Both start and end will only consist of characters in <code>{&#39;L&#39;, &#39;R&#39;, &#39;X&#39;}</code>.</li>\r\n</ol>\r\n",
    "tags": "Brainteaser",
    "difficulty": 2,
    "frontend_article_id": 777,
    "article_content": ""
},
{
    "frontend_question_id": 704,
    "article_live": false,
    "title": "Binary Search",
    "title_slug": "binary-search",
    "content": "<p>Given a <strong>sorted</strong> (in ascending order) integer array <code>nums</code> of <code>n</code> elements and a <code>target</code> value, write a function to search <code>target</code> in <code>nums</code>. If <code>target</code> exists, then return its index, otherwise return <code>-1</code>.</p>\r\n\r\n<p><br />\r\n<strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> <code>nums</code> = [-1,0,3,5,9,12], <code>target</code> = 9\r\n<strong>Output:</strong> 4\r\n<strong>Explanation:</strong> 9 exists in <code>nums</code> and its index is 4\r\n\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> <code>nums</code> = [-1,0,3,5,9,12], <code>target</code> = 2\r\n<strong>Output:</strong> -1\r\n<strong>Explanation:</strong> 2 does not exist in <code>nums</code> so return -1\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li>You may assume that all elements in <code>nums</code> are unique.</li>\r\n\t<li><code>n</code> will be in the range <code>[1, 10000]</code>.</li>\r\n\t<li>The value of each element in <code>nums</code> will be in the range <code>[-9999, 9999]</code>.</li>\r\n</ol>\r\n",
    "tags": "Binary Search",
    "difficulty": 1,
    "frontend_article_id": 704
},
{
    "frontend_question_id": 776,
    "article_live": true,
    "article_slug": "split-bst",
    "title": "Split BST",
    "title_slug": "split-bst",
    "tags": "Binary Search Tree",
    "difficulty": 2,
    "frontend_article_id": 776,
    "article_content": ""
},
{
    "frontend_question_id": 775,
    "article_live": true,
    "article_slug": "global-and-local-inversions",
    "title": "Global and Local Inversions",
    "title_slug": "global-and-local-inversions",
    "content": "<p>We have some permutation <code>A</code> of <code>[0, 1, ..., N - 1]</code>, where <code>N</code> is the length of <code>A</code>.</p>\r\n\r\n<p>The number of (global) inversions is the number of <code>i &lt; j</code> with <code>0 &lt;= i &lt; j &lt; N</code> and <code>A[i] &gt; A[j]</code>.</p>\r\n\r\n<p>The number of local inversions is the number of <code>i</code> with <code>0 &lt;= i &lt; N</code> and <code>A[i] &gt; A[i+1]</code>.</p>\r\n\r\n<p>Return <code>true</code>&nbsp;if and only if the number of global inversions is equal to the number of local inversions.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> A = [1,0,2]\r\n<strong>Output:</strong> true\r\n<strong>Explanation:</strong> There is 1 global inversion, and 1 local inversion.\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> A = [1,2,0]\r\n<strong>Output:</strong> false\r\n<strong>Explanation:</strong> There are 2 global inversions, and 1 local inversion.\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>A</code> will be a permutation of <code>[0, 1, ..., A.length - 1]</code>.</li>\r\n\t<li><code>A</code> will have length in range <code>[1, 5000]</code>.</li>\r\n\t<li>The time limit for this problem has been reduced.</li>\r\n</ul>\r\n",
    "tags": "Array, Math",
    "difficulty": 2,
    "frontend_article_id": 775,
    "article_content": ""
},
{
    "frontend_question_id": 703,
    "article_live": false,
    "title": "Kth Largest Element in a Stream",
    "title_slug": "kth-largest-element-in-a-stream",
    "content": "<p>Design a class to find&nbsp;the <strong>k</strong>th largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p>\r\n\r\n<p>Your&nbsp;<code>KthLargest</code>&nbsp;class will have a constructor which accepts an integer <code>k</code> and an integer array <code>nums</code>, which contains initial elements from&nbsp;the stream. For each call to the method <code>KthLargest.add</code>, return the element representing the kth largest element in the stream.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\nint k = 3;\r\nint[] arr = [4,5,8,2];\r\nKthLargest kthLargest = new KthLargest(3, arr);\r\nkthLargest.add(3);&nbsp; &nbsp;// returns 4\r\nkthLargest.add(5);&nbsp; &nbsp;// returns 5\r\nkthLargest.add(10);&nbsp; // returns 5\r\nkthLargest.add(9);&nbsp; &nbsp;// returns 8\r\nkthLargest.add(4);&nbsp; &nbsp;// returns 8\r\n</pre>\r\n\r\n<p><strong>Note: </strong><br />\r\nYou may assume that&nbsp;<code>nums</code>&#39; length&nbsp;&ge;&nbsp;<code>k-1</code>&nbsp;and <code>k</code> &ge;&nbsp;1.</p>\r\n",
    "tags": "Heap",
    "difficulty": 1,
    "frontend_article_id": 703
},
{
    "frontend_question_id": 774,
    "article_live": true,
    "article_slug": "minimize-max-distance-to-gas-station",
    "title": "Minimize Max Distance to Gas Station",
    "title_slug": "minimize-max-distance-to-gas-station",
    "tags": "Binary Search",
    "difficulty": 3,
    "frontend_article_id": 774,
    "article_content": ""
},
{
    "frontend_question_id": 773,
    "article_live": true,
    "article_slug": "sliding-puzzle",
    "title": "Sliding Puzzle",
    "title_slug": "sliding-puzzle",
    "content": "<p>On a 2x3 <code>board</code>, there are 5 tiles represented by the integers 1 through 5, and an empty square represented by 0.</p>\r\n\r\n<p>A move consists of choosing <code>0</code>&nbsp;and a 4-directionally adjacent number and swapping it.</p>\r\n\r\n<p>The state of the board is <em>solved</em> if and only if the <code>board</code> is <code>[[1,2,3],[4,5,0]].</code></p>\r\n\r\n<p>Given a puzzle board, return the least number of moves required so that the state of the board is solved. If it is impossible for the state of the board to be solved, return -1.</p>\r\n\r\n<p><strong>Examples:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> board = [[1,2,3],[4,0,5]]\r\n<strong>Output:</strong> 1\r\n<strong>Explanation:</strong> Swap the 0 and the 5 in one move.\r\n</pre>\r\n\r\n<pre>\r\n<strong>Input:</strong> board = [[1,2,3],[5,4,0]]\r\n<strong>Output:</strong> -1\r\n<strong>Explanation:</strong> No number of moves will make the board solved.\r\n</pre>\r\n\r\n<pre>\r\n<strong>Input:</strong> board = [[4,1,2],[5,0,3]]\r\n<strong>Output:</strong> 5\r\n<strong>Explanation:</strong> 5 is the smallest number of moves that solves the board.\r\nAn example path:\r\nAfter move 0: [[4,1,2],[5,0,3]]\r\nAfter move 1: [[4,1,2],[0,5,3]]\r\nAfter move 2: [[0,1,2],[4,5,3]]\r\nAfter move 3: [[1,0,2],[4,5,3]]\r\nAfter move 4: [[1,2,0],[4,5,3]]\r\nAfter move 5: [[1,2,3],[4,5,0]]\r\n</pre>\r\n\r\n<pre>\r\n<strong>Input:</strong> board = [[3,2,4],[1,5,0]]\r\n<strong>Output:</strong> 14\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>board</code> will be a 2 x 3 array as described above.</li>\r\n\t<li><code>board[i][j]</code> will be a permutation of <code>[0, 1, 2, 3, 4, 5]</code>.</li>\r\n</ul>\r\n",
    "tags": "Breadth-first Search",
    "difficulty": 3,
    "frontend_article_id": 773,
    "article_content": ""
},
{
    "frontend_question_id": 702,
    "article_live": false,
    "title": "Search in a Sorted Array of Unknown Size",
    "title_slug": "search-in-a-sorted-array-of-unknown-size",
    "tags": "Binary Search",
    "difficulty": 2,
    "frontend_article_id": 702
},
{
    "frontend_question_id": 772,
    "article_live": false,
    "title": "Basic Calculator III",
    "title_slug": "basic-calculator-iii",
    "tags": "String, Stack",
    "difficulty": 3,
    "frontend_article_id": 772
},
{
    "frontend_question_id": 701,
    "article_live": false,
    "title": "Insert into a Binary Search Tree",
    "title_slug": "insert-into-a-binary-search-tree",
    "content": "<p>Given the root node of a binary search tree (BST) and a value to be inserted into the tree,&nbsp;insert the value into the BST. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST.</p>\r\n\r\n<p>Note that there may exist&nbsp;multiple valid ways for the&nbsp;insertion, as long as the tree remains a BST after insertion. You can return any of them.</p>\r\n\r\n<p>For example,&nbsp;</p>\r\n\r\n<pre>\r\nGiven the tree:\r\n        4\r\n       / \\\r\n      2   7\r\n     / \\\r\n    1   3\r\nAnd the value to insert: 5\r\n</pre>\r\n\r\n<p>You can return this binary search tree:</p>\r\n\r\n<pre>\r\n         4\r\n       /   \\\r\n      2     7\r\n     / \\   /\r\n    1   3 5\r\n</pre>\r\n\r\n<p>This tree is also valid:</p>\r\n\r\n<pre>\r\n         5\r\n       /   \\\r\n      2     7\r\n     / \\   \r\n    1   3\r\n         \\\r\n          4\r\n</pre>\r\n",
    "tags": "Tree",
    "difficulty": 2,
    "frontend_article_id": 701
},
{
    "frontend_question_id": 700,
    "article_live": false,
    "title": "Search in a Binary Search Tree",
    "title_slug": "search-in-a-binary-search-tree",
    "content": "<p>Given the root node of a binary search tree (BST) and a value. You need to find the node in the BST that the node&#39;s value equals the given value. Return the subtree rooted with that node. If such node doesn&#39;t exist, you should return NULL.</p>\r\n\r\n<p>For example,&nbsp;</p>\r\n\r\n<pre>\r\nGiven the tree:\r\n        4\r\n       / \\\r\n      2   7\r\n     / \\\r\n    1   3\r\n\r\nAnd the value to search: 2\r\n</pre>\r\n\r\n<p>You should return this subtree:</p>\r\n\r\n<pre>\r\n      2     \r\n     / \\   \r\n    1   3\r\n</pre>\r\n\r\n<p>In the example above, if we want to search the value <code>5</code>, since there is no node with value <code>5</code>, we should return <code>NULL</code>.</p>\r\n\r\n<p>Note that an empty tree is represented by <code>NULL</code>, therefore you would see the expected output (serialized tree format) as&nbsp;<code>[]</code>, not <code>null</code>.</p>\r\n",
    "tags": "Tree",
    "difficulty": 1,
    "frontend_article_id": 700
},
{
    "frontend_question_id": 771,
    "article_live": true,
    "article_slug": "jewels-and-stones",
    "title": "Jewels and Stones",
    "title_slug": "jewels-and-stones",
    "content": "<p>You&#39;re given strings <code>J</code> representing the types of stones that are jewels, and <code>S</code> representing the stones you have.&nbsp; Each character in <code>S</code> is a type of stone you have.&nbsp; You want to know how many of the stones you have are also jewels.</p>\r\n\r\n<p>The letters in <code>J</code> are guaranteed distinct, and all characters in <code>J</code> and <code>S</code> are letters. Letters are case sensitive, so <code>&quot;a&quot;</code> is considered a different type of stone from <code>&quot;A&quot;</code>.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> J = &quot;aA&quot;, S = &quot;aAAbbbb&quot;\r\n<strong>Output:</strong> 3\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> J = &quot;z&quot;, S = &quot;ZZ&quot;\r\n<strong>Output:</strong> 0\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>S</code> and <code>J</code> will consist of letters and have length at most 50.</li>\r\n\t<li>The characters in <code>J</code> are distinct.</li>\r\n</ul>\r\n",
    "tags": "Hash Table",
    "difficulty": 1,
    "frontend_article_id": 771,
    "article_content": ""
},
{
    "frontend_question_id": 770,
    "article_live": true,
    "article_slug": "basic-calculator-iv",
    "title": "Basic Calculator IV",
    "title_slug": "basic-calculator-iv",
    "content": "<p>Given an <code>expression</code>&nbsp;such as <code>expression = &quot;e + 8 - a + 5&quot;</code> and an evaluation map such as <code>{&quot;e&quot;: 1}</code> (given in terms of <code>evalvars = [&quot;e&quot;]</code> and <code>evalints = [1]</code>), return a list of tokens representing the simplified expression, such as <code>[&quot;-1*a&quot;,&quot;14&quot;]</code></p>\r\n\r\n<ul>\r\n\t<li>An expression alternates chunks and symbols, with a space separating each chunk and symbol.</li>\r\n\t<li>A chunk is either an expression in parentheses, a variable, or a non-negative integer.</li>\r\n\t<li>A variable is a string of lowercase letters (not including digits.) Note that variables can be multiple letters, and note that variables never have a leading coefficient or unary operator like <code>&quot;2x&quot;</code> or <code>&quot;-x&quot;</code>.</li>\r\n</ul>\r\n\r\n<p>Expressions are evaluated in the usual order: brackets first, then multiplication, then addition and subtraction. For example, <code>expression = &quot;1 + 2 * 3&quot;</code> has an answer of <code>[&quot;7&quot;]</code>.</p>\r\n\r\n<p>The format of the output is as follows:</p>\r\n\r\n<ul>\r\n\t<li>For each term of free variables with non-zero coefficient, we write the free variables within a term in sorted order lexicographically. For example, we would never write a term like <code>&quot;b*a*c&quot;</code>, only <code>&quot;a*b*c&quot;</code>.</li>\r\n\t<li>Terms have degree equal to the number of free variables being multiplied, counting multiplicity. (For example, <code>&quot;a*a*b*c&quot;</code> has degree 4.) We write the largest degree terms of our answer first, breaking ties by lexicographic order ignoring the leading coefficient of the term.</li>\r\n\t<li>The leading coefficient of the term is placed directly to the left with an asterisk separating it from the variables (if they exist.)&nbsp; A leading coefficient of 1 is still printed.</li>\r\n\t<li>An example of a well formatted answer is <code>[&quot;-2*a*a*a&quot;, &quot;3*a*a*b&quot;, &quot;3*b*b&quot;, &quot;4*a&quot;, &quot;5*c&quot;, &quot;-6&quot;]</code>&nbsp;</li>\r\n\t<li>Terms (including constant terms) with coefficient 0 are not included.&nbsp; For example, an expression of &quot;0&quot; has an output of [].</li>\r\n</ul>\r\n\r\n<p><strong>Examples:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> expression = &quot;e + 8 - a + 5&quot;, evalvars = [&quot;e&quot;], evalints = [1]\r\n<strong>Output:</strong> [&quot;-1*a&quot;,&quot;14&quot;]\r\n\r\n<strong>Input:</strong> expression = &quot;e - 8 + temperature - pressure&quot;,\r\nevalvars = [&quot;e&quot;, &quot;temperature&quot;], evalints = [1, 12]\r\n<strong>Output:</strong> [&quot;-1*pressure&quot;,&quot;5&quot;]\r\n\r\n<strong>Input:</strong> expression = &quot;(e + 8) * (e - 8)&quot;, evalvars = [], evalints = []\r\n<strong>Output:</strong> [&quot;1*e*e&quot;,&quot;-64&quot;]\r\n\r\n<strong>Input:</strong> expression = &quot;7 - 7&quot;, evalvars = [], evalints = []\r\n<strong>Output:</strong> []\r\n\r\n<strong>Input:</strong> expression = &quot;a * b * c + b * a * c * 4&quot;, evalvars = [], evalints = []\r\n<strong>Output:</strong> [&quot;5*a*b*c&quot;]\r\n\r\n<strong>Input:</strong> expression = &quot;((a - b) * (b - c) + (c - a)) * ((a - b) + (b - c) * (c - a))&quot;,\r\nevalvars = [], evalints = []\r\n<strong>Output:</strong> [&quot;-1*a*a*b*b&quot;,&quot;2*a*a*b*c&quot;,&quot;-1*a*a*c*c&quot;,&quot;1*a*b*b*b&quot;,&quot;-1*a*b*b*c&quot;,&quot;-1*a*b*c*c&quot;,&quot;1*a*c*c*c&quot;,&quot;-1*b*b*b*c&quot;,&quot;2*b*b*c*c&quot;,&quot;-1*b*c*c*c&quot;,&quot;2*a*a*b&quot;,&quot;-2*a*a*c&quot;,&quot;-2*a*b*b&quot;,&quot;2*a*c*c&quot;,&quot;1*b*b*b&quot;,&quot;-1*b*b*c&quot;,&quot;1*b*c*c&quot;,&quot;-1*c*c*c&quot;,&quot;-1*a*a&quot;,&quot;1*a*b&quot;,&quot;1*a*c&quot;,&quot;-1*b*c&quot;]\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>expression</code> will have length in range <code>[1, 250]</code>.</li>\r\n\t<li><code>evalvars, evalints</code> will have equal lengths in range <code>[0, 100]</code>.</li>\r\n</ol>\r\n",
    "tags": "Hash Table, String, Stack",
    "difficulty": 3,
    "frontend_article_id": 770,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-polynomial-class-accepted\">Approach #1: Polynomial Class [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-polynomial-class-accepted\">Approach #1: Polynomial Class [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Keep a class <code>Poly</code> that knows a map from a list of free variables to a coefficient, and support operations on this class.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Each function is straightforward individually. Let's list the functions we use:</p> \n  <ul> \n   <li><code>Poly:add(this, that)</code> returns the result of <code>this + that</code>.</li> \n   <li><code>Poly:sub(this, that)</code> returns the result of <code>this - that</code>.</li> \n   <li><code>Poly:mul(this, that)</code> returns the result of <code>this * that</code>.</li> \n   <li><code>Poly:evaluate(this, evalmap)</code> returns the polynomial after replacing all free variables with constants as specified by <code>evalmap</code>.</li> \n   <li> <p><code>Poly:toList(this)</code> returns the polynomial in the correct output format.</p> </li> \n   <li> <p><code>Solution::combine(left, right, symbol)</code> returns the result of applying the binary operator represented by <code>symbol</code> to <code>left</code> and <code>right</code>.</p> </li> \n   <li><code>Solution::make(expr)</code> makes a new <code>Poly</code> represented by either the constant or free variable specified by <code>expr</code>.</li> \n   <li><code>Solution::parse(expr)</code> parses an expression into a new <code>Poly</code>.</li> \n  </ul> \n  <iframe src=\"https://leetcode.com/playground/9KquDr4P/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"9KquDr4P\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: Let <script type=\"math/tex; mode=display\">N</script> is the length of <code>expression</code> and <script type=\"math/tex; mode=display\">M</script> is the length of <code>evalvars</code> and <code>evalints</code>. With an expression like <code>(a + b) * (c + d) * (e + f) * ...</code> the complexity is <script type=\"math/tex; mode=display\">O(2^N + M)</script>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N + M)</script>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 769,
    "article_live": true,
    "article_slug": "max-chunks-to-make-sorted-i",
    "title": "Max Chunks To Make Sorted",
    "title_slug": "max-chunks-to-make-sorted",
    "content": "<p>Given an array <code>arr</code> that is a permutation of <code>[0, 1, ..., arr.length - 1]</code>, we split the array into some number of &quot;chunks&quot; (partitions), and individually sort each chunk.&nbsp; After concatenating them,&nbsp;the result equals the sorted array.</p>\r\n\r\n<p>What is the most number of chunks we could have made?</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> arr = [4,3,2,1,0]\r\n<strong>Output:</strong> 1\r\n<strong>Explanation:</strong>\r\nSplitting into two or more chunks will not return the required result.\r\nFor example, splitting into [4, 3], [2, 1, 0] will result in [3, 4, 0, 1, 2], which isn&#39;t sorted.\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> arr = [1,0,2,3,4]\r\n<strong>Output:</strong> 4\r\n<strong>Explanation:</strong>\r\nWe can split into two chunks, such as [1, 0], [2, 3, 4].\r\nHowever, splitting into [1, 0], [2], [3], [4] is the highest number of chunks possible.\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>arr</code> will have length in range <code>[1, 10]</code>.</li>\r\n\t<li><code>arr[i]</code> will be a permutation of <code>[0, 1, ..., arr.length - 1]</code>.</li>\r\n</ul>\r\n\r\n<p>&nbsp;</p>\r\n",
    "tags": "Array",
    "difficulty": 2,
    "frontend_article_id": 769,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-brute-force-accepted\">Approach #1: Brute Force [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-brute-force-accepted\">Approach #1: Brute Force [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Let's try to find the smallest left-most chunk. If the first <code>k</code> elements are <code>[0, 1, ..., k-1]</code>, then it can be broken into a chunk, and we have a smaller instance of the same problem.</p> \n  <p>We can check whether <code>k+1</code> elements chosen from <code>[0, 1, ..., n-1]</code> are <code>[0, 1, ..., k]</code> by checking whether the maximum of that choice is <code>k</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/62RMHZZv/shared\" frameborder=\"0\" width=\"100%\" height=\"225\" name=\"62RMHZZv\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>arr</code></p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n  </ul> \n  <hr> \n  <p>For more approaches, please visit the article for the companion problem <a href=\"https://leetcode.com/articles/max-chunks-to-make-sorted-ii/\">Max Chunks To Make Sorted II</a>.</p> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 768,
    "article_live": true,
    "article_slug": "max-chunks-to-make-sorted-ii",
    "title": "Max Chunks To Make Sorted II",
    "title_slug": "max-chunks-to-make-sorted-ii",
    "content": "<p><em>This question is the same as &quot;Max Chunks to Make Sorted&quot; except the integers of the given array are not necessarily distinct, the input array could be up to length <code>2000</code>, and the elements could be up to <code>10**8</code>.</em></p>\r\n\r\n<hr />\r\n\r\n<p>Given an array <code>arr</code> of integers (<strong>not necessarily distinct</strong>), we split the array into some number of &quot;chunks&quot; (partitions), and individually sort each chunk.&nbsp; After concatenating them,&nbsp;the result equals the sorted array.</p>\r\n\r\n<p>What is the most number of chunks we could have made?</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> arr = [5,4,3,2,1]\r\n<strong>Output:</strong> 1\r\n<strong>Explanation:</strong>\r\nSplitting into two or more chunks will not return the required result.\r\nFor example, splitting into [5, 4], [3, 2, 1] will result in [4, 5, 1, 2, 3], which isn&#39;t sorted.\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> arr = [2,1,3,4,4]\r\n<strong>Output:</strong> 4\r\n<strong>Explanation:</strong>\r\nWe can split into two chunks, such as [2, 1], [3, 4, 4].\r\nHowever, splitting into [2, 1], [3], [4], [4] is the highest number of chunks possible.\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>arr</code> will have length in range <code>[1, 2000]</code>.</li>\r\n\t<li><code>arr[i]</code> will be an integer in range <code>[0, 10**8]</code>.</li>\r\n</ul>\r\n\r\n<p>&nbsp;</p>\r\n",
    "tags": "Array",
    "difficulty": 3,
    "frontend_article_id": 768,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-sliding-window-accepted\">Approach #1: Sliding Window [Accepted]</a></li> \n    <li><a href=\"#approach-2-sorted-count-pairs-accepted\">Approach #2: Sorted Count Pairs [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-sliding-window-accepted\">Approach #1: Sliding Window [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Let's try to find the smallest left-most chunk.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Notice that if <script type=\"math/tex; mode=display\">a_1, a_2, \\dots, a_m</script> is a chunk, and <script type=\"math/tex; mode=display\">a_1, a_2, \\dots, a_n</script> is a chunk (<script type=\"math/tex; mode=display\">m < n</script>), then <script type=\"math/tex; mode=display\">a_{m+1}, a_{m+2}, \\dots, a_n</script> is a chunk too. This shows that a greedy approach produces the highest number of chunks.</p> \n  <p>We know the array <code>arr</code> should end up like <code>expect = sorted(arr)</code>. If the count of the first <code>k</code> elements minus the count what those elements should be is zero everywhere, then the first <code>k</code> elements form a valid chunk. We repeatedly perform this process.</p> \n  <p>We can use a variable <code>nonzero</code> to count the number of letters where the current count is non-zero.</p> \n  <iframe src=\"https://leetcode.com/playground/B8GKxQrY/shared\" frameborder=\"0\" width=\"100%\" height=\"480\" name=\"B8GKxQrY\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N \\log N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>arr</code></p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-sorted-count-pairs-accepted\">Approach #2: Sorted Count Pairs [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>As in <em>Approach #1</em>, let's try to find the smallest left-most chunk, where we have some expectation <code>expect = sorted(arr)</code></p> \n  <p>If the elements were distinct, then it is enough to find the smallest <code>k</code> with <code>max(arr[:k+1]) == expect[k]</code>, as this must mean the elements of <code>arr[:k+1]</code> are some permutation of <code>expect[:k+1]</code>.</p> \n  <p>Since the elements are not distinct, this fails; but we can amend the cumulative multiplicity of each element to itself to make the elements distinct.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Instead of elements <code>x</code>, have counted elements <code>(x, count)</code> where <code>count</code> ranges from <code>1</code> to the total number of <code>x</code> present in <code>arr</code>.</p> \n  <p>Now <code>cur</code> will be the cumulative maximum of <code>counted[:k+1]</code>, where we expect a result of <code>Y = expect[k]</code>. We count the number of times they are equal.</p> \n  <iframe src=\"https://leetcode.com/playground/jLmjinpa/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"jLmjinpa\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N \\log N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>arr</code></p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 767,
    "article_live": true,
    "article_slug": "reorganized-string",
    "title": "Reorganize String",
    "title_slug": "reorganize-string",
    "content": "<p>Given a string <code>S</code>, check if the letters can be rearranged so that two characters that are adjacent to each other are not the same.</p>\r\n\r\n<p>If possible, output any possible result.&nbsp; If not possible, return the empty string.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> S = &quot;aab&quot;\r\n<strong>Output:</strong> &quot;aba&quot;\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> S = &quot;aaab&quot;\r\n<strong>Output:</strong> &quot;&quot;\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>S</code> will consist of lowercase letters and have length in range <code>[1, 500]</code>.</li>\r\n</ul>\r\n\r\n<p>&nbsp;</p>\r\n",
    "tags": "String, Heap, Greedy, Sort",
    "difficulty": 2,
    "frontend_article_id": 767,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-sort-by-count-accepted\">Approach #1: Sort by Count [Accepted]</a></li> \n    <li><a href=\"#approach-2-greedy-with-heap-accepted\">Approach #2: Greedy with Heap [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-sort-by-count-accepted\">Approach #1: Sort by Count [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>If we should make no two <code>'a'</code>s adjacent, it is natural to write <code>\"aXaXaXa...\"</code> where <code>\"X\"</code> is some letter. For now, let's assume that the task is possible (ie. the answer is not <code>\"\"</code>.)</p> \n  <p>Let's sort the string <code>S</code>, so all of the same kind of letter occur in continuous <em>blocks</em>. Then when writing in the following interleaving pattern, like <code>S[3], S[0], S[4], S[1], S[5], S[2]</code>, adjacent letters never touch. (The specific interleaving pattern is that we start writing at index 1 and step by 2; then start from index 0 and step by 2.)</p> \n  <p>The exception to this rule is if <code>N</code> is odd, and then when interleaving like <code>S[2], S[0], S[3], S[1], S[4]</code>, we might fail incorrectly if there is a block of the same 3 letters starting at <code>S[0]</code> or <code>S[1]</code>. To prevent failing erroneously in this case, we need to make sure that the most common letters all occur at the end.</p> \n  <p>Finally, it is easy to see that if <code>N</code> is the length of the string, and the count of some letter is greater than <code>(N+1) / 2</code>, the task is impossible.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Find the count of each character, and use it to sort the string by count.</p> \n  <p>If at some point the number of occurrences of some character is greater than <code>(N + 1) / 2</code>, the task is impossible.</p> \n  <p>Otherwise, interleave the characters in the order described above.</p> \n  <iframe src=\"https://leetcode.com/playground/HYKSoqaR/shared\" frameborder=\"0\" width=\"100%\" height=\"480\" name=\"HYKSoqaR\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(\\mathcal{A}(N + \\log{\\mathcal{A}}))</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <script type=\"math/tex; mode=display\">S</script>, and <script type=\"math/tex; mode=display\">\\mathcal{A}</script> is the size of the alphabet. In Java, our implementation is <script type=\"math/tex; mode=display\">O(N + \\mathcal{A} \\log {\\mathcal{A}})</script>. If <script type=\"math/tex; mode=display\">\\mathcal{A}</script> is fixed, this complexity is <script type=\"math/tex; mode=display\">O(N)</script>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. In Java, our implementation is <script type=\"math/tex; mode=display\">O(N + \\mathcal{A})</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-greedy-with-heap-accepted\">Approach #2: Greedy with Heap [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>One consequence of the reasoning in <em>Approach #1</em>, is that a greedy approach that tries to write the most common letter (that isn't the same as the previous letter written) will work.</p> \n  <p>The reason is that the task is only impossible if the frequency of a letter exceeds <code>(N+1) / 2</code>. Writing the most common letter followed by the second most common letter keeps this invariant.</p> \n  <p>A heap is a natural structure to repeatedly return the current top 2 letters with the largest remaining counts.</p> \n  <p><strong>Approach</strong></p> \n  <p>We store a heap of (count, letter). [In Python, our implementation stores negative counts.]</p> \n  <p>We pop the top two elements from the heap (representing different letters with positive remaining count), and then write the most frequent one that isn't the same as the most recent one written. After, we push the correct counts back onto the heap.</p> \n  <p>Actually, we don't even need to keep track of the most recent one written. If it is possible to organize the string, the letter written second can never be written first in the very next writing.</p> \n  <p>At the end, we might have one element still on the heap, which must have a count of one. If we do, we'll add that to the answer too.</p> \n  <p><strong>Proof of Invariant</strong></p> \n  <p>The invariant mentioned in the <em>[Intuition]</em> section seems true when playing with it, but here is a proof. Let <script type=\"math/tex; mode=display\">C_i</script> be the count of each letter yet to be written, and <script type=\"math/tex; mode=display\">N</script> be the number of letters left to write. We want to show this procedure maintains the invariant <script type=\"math/tex; mode=display\">2 * \\max\\limits_i(C_i) \\leq N+1</script>.</p> \n  <p>Say <script type=\"math/tex; mode=display\">C'_i</script> are the counts after one writing step.</p> \n  <ul> \n   <li> <p>If <script type=\"math/tex; mode=display\">\\max(C_i) > \\text{3rdmax}(C_i)</script>, then <script type=\"math/tex; mode=display\">\\max(C'_i) \\leq \\max(C_i) - 1</script>, and so <script type=\"math/tex; mode=display\">2\\max(C'_i) \\leq 2\\max(C_i) - 2 \\leq N-1</script> as desired.</p> </li> \n   <li> <p>If <script type=\"math/tex; mode=display\">M = \\max(C_i) = \\text{3rdmax}(C_i)</script>, then <script type=\"math/tex; mode=display\">3M \\leq N</script>. Also, because <script type=\"math/tex; mode=display\">M \\geq 1</script>, <script type=\"math/tex; mode=display\">N \\geq 3</script>. Then, <script type=\"math/tex; mode=display\">2M \\leq \\frac{2N}{3} \\leq N-1</script> as desired.</p> </li> \n  </ul> \n  <p>This completes the proof of this invariant.</p> \n  <iframe src=\"https://leetcode.com/playground/Emwok2sq/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"Emwok2sq\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N \\log{\\mathcal{A}}))</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <script type=\"math/tex; mode=display\">S</script>, and <script type=\"math/tex; mode=display\">\\mathcal{A}</script> is the size of the alphabet. If <script type=\"math/tex; mode=display\">\\mathcal{A}</script> is fixed, this complexity is <script type=\"math/tex; mode=display\">O(N)</script>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(\\mathcal{A})</script>. If <script type=\"math/tex; mode=display\">\\mathcal{A}</script> is fixed, this complexity is <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 766,
    "article_live": true,
    "article_slug": "toeplitz-matrix",
    "title": "Toeplitz Matrix",
    "title_slug": "toeplitz-matrix",
    "content": "<p>A matrix is <em>Toeplitz</em> if every diagonal from top-left to bottom-right has the same element.</p>\r\n\r\n<p>Now given an <code>M x N</code> matrix, return&nbsp;<code>True</code>&nbsp;if and only if the matrix is <em>Toeplitz</em>.<br />\r\n&nbsp;</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:\r\n</strong>matrix = [\r\n&nbsp; [1,2,3,4],\r\n&nbsp; [5,1,2,3],\r\n&nbsp; [9,5,1,2]\r\n]\r\n<strong>Output:</strong> True\r\n<strong>Explanation:</strong>\r\nIn the above grid, the&nbsp;diagonals are:\r\n&quot;[9]&quot;, &quot;[5, 5]&quot;, &quot;[1, 1, 1]&quot;, &quot;[2, 2, 2]&quot;, &quot;[3, 3]&quot;, &quot;[4]&quot;.\r\nIn each diagonal all elements are the same, so the answer is True.\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:\r\n</strong>matrix = [\r\n&nbsp; [1,2],\r\n&nbsp; [2,2]\r\n]\r\n<strong>Output:</strong> False\r\n<strong>Explanation:</strong>\r\nThe diagonal &quot;[1, 2]&quot; has different elements.\r\n</pre>\r\n\r\n<p><br />\r\n<strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>matrix</code> will be a 2D array of integers.</li>\r\n\t<li><code>matrix</code> will have a number of rows and columns in range <code>[1, 20]</code>.</li>\r\n\t<li><code>matrix[i][j]</code> will be integers in range <code>[0, 99]</code>.</li>\r\n</ol>\r\n\r\n<p><br />\r\n<strong>Follow up:</strong></p>\r\n\r\n<ol>\r\n\t<li>What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?</li>\r\n\t<li>What if the matrix is so large that you can only load up a partial row into the memory at once?</li>\r\n</ol>\r\n",
    "tags": "Array",
    "difficulty": 1,
    "frontend_article_id": 766,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-group-by-category-accepted\">Approach #1: Group by Category [Accepted]</a></li> \n    <li><a href=\"#approach-2-compare-with-top-left-neighbor-accepted\">Approach #2: Compare With Top-Left Neighbor [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-group-by-category-accepted\">Approach #1: Group by Category [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>We ask what feature makes two coordinates <code>(r1, c1)</code> and <code>(r2, c2)</code> belong to the same diagonal?</p> \n  <p>It turns out two coordinates are on the same diagonal if and only if <code>r1 - c1 == r2 - c2</code>.</p> \n  <p>This leads to the following idea: remember the value of that diagonal as <code>groups[r-c]</code>. If we see a mismatch, the matrix is not Toeplitz; otherwise it is.</p> \n  <iframe src=\"https://leetcode.com/playground/aPydaE7r/shared\" frameborder=\"0\" width=\"100%\" height=\"293\" name=\"aPydaE7r\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(M*N)</script>. (Recall in the problem statement that <script type=\"math/tex; mode=display\">M, N</script> are the number of rows and columns in <code>matrix</code>.)</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(M+N)</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-compare-with-top-left-neighbor-accepted\">Approach #2: Compare With Top-Left Neighbor [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>For each diagonal with elements in order <script type=\"math/tex; mode=display\">a_1, a_2, a_3, \\dots, a_k</script>, we can check <script type=\"math/tex; mode=display\">a_1 = a_2, a_2 = a_3, \\dots, a_{k-1} = a_k</script>. The matrix is <em>Toeplitz</em> if and only if all of these conditions are true for all (top-left to bottom-right) diagonals.</p> \n  <p>Every element belongs to some diagonal, and it's previous element (if it exists) is it's top-left neighbor. Thus, for the square <code>(r, c)</code>, we only need to check <code>r == 0 OR c == 0 OR matrix[r-1][c-1] == matrix[r][c]</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/bfeF5wnM/shared\" frameborder=\"0\" width=\"100%\" height=\"208\" name=\"bfeF5wnM\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(M*N)</script>, as defined in the problem statement.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 590,
    "article_live": true,
    "article_slug": "n-ary-tree-postorder-transversal",
    "title": "N-ary Tree Postorder Traversal",
    "title_slug": "n-ary-tree-postorder-traversal",
    "content": "<p>Given an n-ary tree, return the <i>postorder</i> traversal of its nodes&#39; values.</p>\r\n\r\n<p>For example, given a <code>3-ary</code> tree:</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png\" style=\"width: 100%; max-width: 300px;\" /></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Return its postorder traversal as: <code>[5,6,3,2,4,1]</code>.</p>\r\n&nbsp;\r\n\r\n<p><b>Note:</b></p>\r\n\r\n<p>Recursive solution is trivial, could you do it iteratively?</p>\r\n",
    "tags": "Tree",
    "difficulty": 1,
    "frontend_article_id": 590,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#how-to-transverse-the-tree\">How to transverse the tree</a></li> \n      <li><a href=\"#approach-1-iterations\">Approach 1: Iterations</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"how-to-transverse-the-tree\">How to transverse the tree</h4> \n  <p>First of all, please refer to <a href=\"https://leetcode.com/articles/binary-tree-postorder-transversal/\">this article</a> for the solution in case of binary tree. This article offers the same ideas with a bit of generalisation. </p> \n  <p>There are two general strategies to transverse a tree:</p> \n  <ul> \n   <li> <p><em>Breadth First Search</em> (<code>BFS</code>)</p> <p>We scan through the tree level by level, following the order of height, from top to bottom. The nodes on higher level would be visited before the ones with lower levels.</p> </li> \n   <li> <p><em>Depth First Search</em> (<code>DFS</code>)</p> <p>In this strategy, we adopt the <code>depth</code> as the priority, so that one would start from a root and reach all the way down to certain leaf, and then back to root to reach another branch.</p> <p>The DFS strategy can further be distinguished as <code>preorder</code>, <code>inorder</code>, and <code>postorder</code> depending on the relative order among the root node, left node and right node.</p> </li> \n  </ul> \n  <p>On the following figure the nodes are numerated in the order you visit them, please follow <code>1-2-3-4-5</code> to compare different strategies.</p> \n  <p><img alt=\"postorder\" src=\"../Figures/145_transverse.png\"></p> \n  <p>Here the problem is to implement postorder transversal using iterations. <br> <br></p> \n  <hr> \n  <h4 id=\"approach-1-iterations\">Approach 1: Iterations</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>First of all, here is the definition of the <code>TreeNode</code> which we would use in the following implementation.</p> \n  <iframe src=\"https://leetcode.com/playground/PRVwEYsQ/shared\" frameborder=\"0\" width=\"100%\" height=\"259\" name=\"PRVwEYsQ\"></iframe> \n  <p>Let's start from the root and then at each iteration pop the current node out of the stack and push its child nodes. In the implemented strategy we push nodes into stack following the order <code>Top-&gt;Bottom</code> and <code>Left-&gt;Right</code>. Since DFS postorder transversal is <code>Bottom-&gt;Top</code> and <code>Left-&gt;Right</code> the output list should be reverted after the end of loop.</p> \n  <iframe src=\"https://leetcode.com/playground/iqMZtskW/shared\" frameborder=\"0\" width=\"100%\" height=\"412\" name=\"iqMZtskW\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : we visit each node exactly once, thus the time complexity is <script type=\"math/tex; mode=display\">\\mathcal{O}(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of nodes, <em>i.e.</em> the size of tree.</p> </li> \n   <li> <p>Space complexity : depending on the tree structure, we could keep up to the entire tree, therefore, the space complexity is <script type=\"math/tex; mode=display\">\\mathcal{O}(N)</script>.</p> </li> \n  </ul> \n  <p>Analysis written by @<a href=\"https://leetcode.com/liaison/\">liaison</a> and @<a href=\"https://leetcode.com/andvary/\">andvary</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 589,
    "article_live": true,
    "article_slug": "n-ary-tree-preorder-traversal",
    "title": "N-ary Tree Preorder Traversal",
    "title_slug": "n-ary-tree-preorder-traversal",
    "content": "<p>Given an n-ary tree, return the <i>preorder</i> traversal of its nodes&#39; values.</p>\r\n\r\n<p>For example, given a <code>3-ary</code> tree:</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png\" style=\"width: 100%; max-width: 300px;\" /></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Return its preorder traversal as: <code>[1,3,5,6,2,4]</code>.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Note:</b></p>\r\n\r\n<p>Recursive solution is trivial, could you do it iteratively?</p>\r\n",
    "tags": "Tree",
    "difficulty": 1,
    "frontend_article_id": 589,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-iterations\">Approach 1: Iterations</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-iterations\">Approach 1: Iterations</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>First of all, please refer to <a href=\"https://leetcode.com/articles/binary-tree-preorder-transversal/\">this article</a> for the solution in case of binary tree. This article offers the same ideas with a bit of generalisation. </p> \n  <p>First of all, here is the definition of the tree <code>Node</code> which we would use in the following implementation.</p> \n  <iframe src=\"https://leetcode.com/playground/orsDM3Dk/shared\" frameborder=\"0\" width=\"100%\" height=\"259\" name=\"orsDM3Dk\"></iframe> \n  <p>Let's start from the root and then at each iteration pop the current node out of the stack and push its child nodes. In the implemented strategy we push nodes into output list following the order <code>Top-&gt;Bottom</code> and <code>Left-&gt;Right</code>, that naturally reproduces preorder traversal.</p> \n  <iframe src=\"https://leetcode.com/playground/g89P9BDh/shared\" frameborder=\"0\" width=\"100%\" height=\"395\" name=\"g89P9BDh\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : we visit each node exactly once, and for each visit, the complexity of the operation (<em>i.e.</em> appending the child nodes) is proportional to the number of child nodes <code>n</code> (n-ary tree). Therefore the overall time complexity is <script type=\"math/tex; mode=display\">\\mathcal{O}(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of nodes, <em>i.e.</em> the size of tree.</p> </li> \n   <li> <p>Space complexity : depending on the tree structure, we could keep up to the entire tree, therefore, the space complexity is <script type=\"math/tex; mode=display\">\\mathcal{O}(N)</script>.</p> </li> \n  </ul> \n  <p>Analysis written by @<a href=\"https://leetcode.com/liaison/\">liaison</a> and @<a href=\"https://leetcode.com/andvary/\">andvary</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 559,
    "article_live": true,
    "article_slug": "maximum-depth-of-n-ary-tree",
    "title": "Maximum Depth of N-ary Tree",
    "title_slug": "maximum-depth-of-n-ary-tree",
    "content": "<p>Given a n-ary tree, find its maximum depth.</p>\r\n\r\n<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>\r\n\r\n<p>For example, given a <code>3-ary</code> tree:</p>\r\n&nbsp;\r\n\r\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png\" style=\"width: 100%; max-width: 300px;\" /></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>We should return its max depth, which is 3.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Note:</b></p>\r\n\r\n<ol>\r\n\t<li>The depth of the tree is at most <code>1000</code>.</li>\r\n\t<li>The total number of nodes is at most <code>5000</code>.</li>\r\n</ol>\r\n",
    "tags": "Tree, Depth-first Search, Breadth-first Search",
    "difficulty": 1,
    "frontend_article_id": 559,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-recursion\">Approach 1: Recursion</a></li> \n      <li><a href=\"#approach-2-iteration\">Approach 2: Iteration</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <p><strong>Tree definition</strong></p> \n  <p>First of all, please refer to <a href=\"https://leetcode.com/articles/maximum-depth-of-binary-tree/\">this article</a> for the solution in case of binary tree. This article offers the same ideas with a bit of generalisation. </p> \n  <p>Here is the definition of the <code>TreeNode</code> which we would use.</p> \n  <iframe src=\"https://leetcode.com/playground/nehdHiL3/shared\" frameborder=\"0\" width=\"100%\" height=\"259\" name=\"nehdHiL3\"></iframe> \n  <p><br> <br></p> \n  <hr> \n  <h4 id=\"approach-1-recursion\">Approach 1: Recursion</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>The intuitive approach is to solve the problem by recursion. Here we demonstrate an example with the DFS (Depth First Search) strategy. </p> \n  <iframe src=\"https://leetcode.com/playground/LQd42Czz/shared\" frameborder=\"0\" width=\"100%\" height=\"310\" name=\"LQd42Czz\"></iframe> \n  <p><strong>Complexity analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : we visit each node exactly once, thus the time complexity is <script type=\"math/tex; mode=display\">\\mathcal{O}(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of nodes.</p> </li> \n   <li> <p>Space complexity : in the worst case, the tree is completely unbalanced, <em>e.g.</em> each node has only one child node, the recursion call would occur <script type=\"math/tex; mode=display\">N</script> times (the height of the tree), therefore the storage to keep the call stack would be <script type=\"math/tex; mode=display\">\\mathcal{O}(N)</script>. But in the best case (the tree is completely balanced), the height of the tree would be <script type=\"math/tex; mode=display\">\\log(N)</script>. Therefore, the space complexity in this case would be <script type=\"math/tex; mode=display\">\\mathcal{O}(\\log(N))</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-iteration\">Approach 2: Iteration</h4> \n  <p>We could also convert the above recursion into iteration, with the help of stack.</p> \n  <blockquote> \n   <p>The idea is to visit each node with the DFS strategy, while updating the max depth at each visit.</p> \n  </blockquote> \n  <p>So we start from a stack which contains the root node and the corresponding depth which is <code>1</code>. Then we proceed to the iterations: pop the current node out of the stack and push the child nodes. The depth is updated at each step. </p> \n  <iframe src=\"https://leetcode.com/playground/QDJ3dtzM/shared\" frameborder=\"0\" width=\"100%\" height=\"480\" name=\"QDJ3dtzM\"></iframe> \n  <p><strong>Complexity analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">\\mathcal{O}(N)</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">\\mathcal{O}(N)</script>.</p> </li> \n  </ul> \n  <p>Analysis written by @<a href=\"https://leetcode.com/liaison/\">liaison</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 558,
    "article_live": false,
    "title": "Quad Tree Intersection",
    "title_slug": "quad-tree-intersection",
    "content": "<p>A quadtree is a tree data in which each internal node has exactly four children: <code>topLeft</code>, <code>topRight</code>, <code>bottomLeft</code> and <code>bottomRight</code>. Quad trees are often used to partition a two-dimensional space by recursively subdividing it into four quadrants or regions.</p>\r\n\r\n<p>We want to store True/False information in our quad tree. The quad tree is used to represent a <code>N * N</code> boolean grid. For each node, it will be subdivided into four children nodes <strong>until the values in the region it represents are all the same</strong>. Each node has another two boolean attributes : <code>isLeaf</code> and <code>val</code>. <code>isLeaf</code> is true if and only if the node is a leaf node. The <code>val</code> attribute for a leaf node contains the value of the region it represents.</p>\r\n\r\n<p>For example, below are two quad trees A and B:</p>\r\n\r\n<pre>\r\nA:\r\n+-------+-------+   T: true\r\n|       |       |   F: false\r\n|   T   |   T   |\r\n|       |       |\r\n+-------+-------+\r\n|       |       |\r\n|   F   |   F   |\r\n|       |       |\r\n+-------+-------+\r\ntopLeft: T\r\ntopRight: T\r\nbottomLeft: F\r\nbottomRight: F\r\n\r\nB:               \r\n+-------+---+---+\r\n|       | F | F |\r\n|   T   +---+---+\r\n|       | T | T |\r\n+-------+---+---+\r\n|       |       |\r\n|   T   |   F   |\r\n|       |       |\r\n+-------+-------+\r\ntopLeft: T\r\ntopRight:\r\n     topLeft: F\r\n     topRight: F\r\n     bottomLeft: T\r\n     bottomRight: T\r\nbottomLeft: T\r\nbottomRight: F\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Your task is to implement a function that will take two quadtrees and return a quadtree that represents the logical OR (or union) of the two trees.</p>\r\n\r\n<pre>\r\nA:                 B:                 C (A or B):\r\n+-------+-------+  +-------+---+---+  +-------+-------+\r\n|       |       |  |       | F | F |  |       |       |\r\n|   T   |   T   |  |   T   +---+---+  |   T   |   T   |\r\n|       |       |  |       | T | T |  |       |       |\r\n+-------+-------+  +-------+---+---+  +-------+-------+\r\n|       |       |  |       |       |  |       |       |\r\n|   F   |   F   |  |   T   |   F   |  |   T   |   F   |\r\n|       |       |  |       |       |  |       |       |\r\n+-------+-------+  +-------+-------+  +-------+-------+\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li>Both <code>A</code> and <code>B</code>&nbsp;represent grids of size <code>N * N</code>.</li>\r\n\t<li><code>N</code> is guaranteed to be a power of 2.</li>\r\n\t<li>If you want to know more about the quad tree, you can refer to its <a href=\"https://en.wikipedia.org/wiki/Quadtree\">wiki</a>.</li>\r\n\t<li>The logic OR operation is defined as this: &quot;A or B&quot; is true if <code>A is true</code>, or if <code>B is true</code>, or if <code>both A and B are true</code>.</li>\r\n</ol>\r\n",
    "tags": "",
    "difficulty": 1,
    "frontend_article_id": 558
},
{
    "frontend_question_id": 427,
    "article_live": false,
    "title": "Construct Quad Tree",
    "title_slug": "construct-quad-tree",
    "content": "<p>We want to use quad trees to store an <code>N x N</code> boolean grid. Each cell in the grid can only be true or false. The root node represents the whole grid. For each node, it will be subdivided into four children nodes <strong>until the values in the region it represents are all the same</strong>.</p>\r\n\r\n<p>Each node has another two boolean attributes : <code>isLeaf</code> and <code>val</code>. <code>isLeaf</code> is true if and only if the node is a leaf node. The <code>val</code> attribute for a leaf node contains the value of the region it represents.</p>\r\n\r\n<p>Your task is to use a quad tree to represent a given grid. The following example may help you understand the problem better:</p>\r\n\r\n<p>Given the <code>8 x 8</code> grid below, we want to construct the corresponding quad tree:</p>\r\n\r\n<p><img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/02/01/962_grid.png\" style=\"height:27%; max-height:300px; max-width:299px; width:27%\" /></p>\r\n\r\n<p>It can be divided according to the definition above:</p>\r\n\r\n<p><img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/02/01/962_grid_divided.png\" style=\"height:100%; max-height:300px; max-width:1107px; width:100%\" /></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>The corresponding quad tree should be as following, where each node is represented as a <code>(isLeaf, val)</code> pair.</p>\r\n\r\n<p>For the non-leaf&nbsp;nodes,&nbsp;<code>val</code> can be arbitrary, so it is represented as <code>*</code>.</p>\r\n\r\n<p><img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/02/01/962_quad_tree.png\" style=\"height:100%; max-height:300px; max-width:836px; width:100%\" /></p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>N</code> is less than <code>1000</code> and guaranteened to be a power of 2.</li>\r\n\t<li>If you want to know more about the quad tree, you can refer to its <a href=\"https://en.wikipedia.org/wiki/Quadtree\">wiki</a>.</li>\r\n</ol>\r\n",
    "tags": "",
    "difficulty": 1,
    "frontend_article_id": 427
},
{
    "frontend_question_id": 431,
    "article_live": false,
    "title": "Encode N-ary Tree to Binary Tree",
    "title_slug": "encode-n-ary-tree-to-binary-tree",
    "tags": "Tree",
    "difficulty": 3,
    "frontend_article_id": 431
},
{
    "frontend_question_id": 765,
    "article_live": true,
    "article_slug": "couples-holding-hands",
    "title": "Couples Holding Hands",
    "title_slug": "couples-holding-hands",
    "content": "<p>\r\nN couples sit in 2N seats arranged in a row and want to hold hands.  We want to know the minimum number of swaps so that every couple is sitting side by side.  A <i>swap</i> consists of choosing <b>any</b> two people, then they stand up and switch seats. \r\n</p><p>\r\nThe people and seats are represented by an integer from <code>0</code> to <code>2N-1</code>, the couples are numbered in order, the first couple being <code>(0, 1)</code>, the second couple being <code>(2, 3)</code>, and so on with the last couple being <code>(2N-2, 2N-1)</code>.\r\n</p><p>\r\nThe couples' initial seating is given by <code>row[i]</code> being the value of the person who is initially sitting in the i-th seat.\r\n\r\n<p><b>Example 1:</b><br /><pre>\r\n<b>Input:</b> row = [0, 2, 1, 3]\r\n<b>Output:</b> 1\r\n<b>Explanation:</b> We only need to swap the second (row[1]) and third (row[2]) person.\r\n</pre></p>\r\n\r\n<p><b>Example 2:</b><br /><pre>\r\n<b>Input:</b> row = [3, 2, 0, 1]\r\n<b>Output:</b> 0\r\n<b>Explanation:</b> All couples are already seated side by side.\r\n</pre></p>\r\n\r\n<p>\r\n<b>Note:</b>\r\n<ol> \r\n<li> <code>len(row)</code> is even and in the range of <code>[4, 60]</code>.</li>\r\n<li> <code>row</code> is guaranteed to be a permutation of <code>0...len(row)-1</code>.</li>\r\n</ol>",
    "tags": "Greedy, Union Find, Graph",
    "difficulty": 3,
    "frontend_article_id": 765,
    "article_content": ""
},
{
    "frontend_question_id": 764,
    "article_live": true,
    "article_slug": "largest-plus-sign",
    "title": "Largest Plus Sign",
    "title_slug": "largest-plus-sign",
    "content": "<p>\r\nIn a 2D <code>grid</code> from (0, 0) to (N-1, N-1), every cell contains a <code>1</code>, except those cells in the given list <code>mines</code> which are <code>0</code>.  What is the largest axis-aligned plus sign of <code>1</code>s contained in the grid?  Return the order of the plus sign.  If there is none, return 0.\r\n</p><p>\r\nAn \"<i>axis-aligned plus sign of <code>1</code>s</i> of order <b>k</b>\" has some center <code>grid[x][y] = 1</code> along with 4 arms of length <code>k-1</code> going up, down, left, and right, and made of <code>1</code>s.  This is demonstrated in the diagrams below.  Note that there could be <code>0</code>s or <code>1</code>s beyond the arms of the plus sign, only the relevant area of the plus sign is checked for 1s.\r\n</p><p>\r\n\r\n<p><b>Examples of Axis-Aligned Plus Signs of Order k:</b><br /><pre>\r\nOrder 1:\r\n000\r\n0<b>1</b>0\r\n000\r\n\r\nOrder 2:\r\n00000\r\n00<b>1</b>00\r\n0<b>111</b>0\r\n00<b>1</b>00\r\n00000\r\n\r\nOrder 3:\r\n0000000\r\n000<b>1</b>000\r\n000<b>1</b>000\r\n0<b>11111</b>0\r\n000<b>1</b>000\r\n000<b>1</b>000\r\n0000000\r\n</pre></p>\r\n\r\n<p><b>Example 1:</b><br /><pre>\r\n<b>Input:</b> N = 5, mines = [[4, 2]]\r\n<b>Output:</b> 2\r\n<b>Explanation:</b>\r\n11111\r\n11111\r\n1<b>1</b>111\r\n<b>111</b>11\r\n1<b>1</b>011\r\nIn the above grid, the largest plus sign can only be order 2.  One of them is marked in bold.\r\n</pre></p>\r\n\r\n<p><b>Example 2:</b><br /><pre>\r\n<b>Input:</b> N = 2, mines = []\r\n<b>Output:</b> 1\r\n<b>Explanation:</b>\r\nThere is no plus sign of order 2, but there is of order 1.\r\n</pre></p>\r\n\r\n<p><b>Example 3:</b><br /><pre>\r\n<b>Input:</b> N = 1, mines = [[0, 0]]\r\n<b>Output:</b> 0\r\n<b>Explanation:</b>\r\nThere is no plus sign, so return 0.\r\n</pre></p>\r\n\r\n<p><b>Note:</b><br><ol>\r\n<li><code>N</code> will be an integer in the range <code>[1, 500]</code>.</li>\r\n<li><code>mines</code> will have length at most <code>5000</code>.</li>\r\n<li><code>mines[i]</code> will be length 2 and consist of integers in the range <code>[0, N-1]</code>.</li>\r\n<li><i>(Additionally, programs submitted in C, C++, or C# will be judged with a slightly smaller time limit.)</i></li>\r\n</ol></p>",
    "tags": "Dynamic Programming",
    "difficulty": 2,
    "frontend_article_id": 764,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-brute-force-time-limit-exceeded\">Approach #1: Brute Force [Time Limit Exceeded]</a></li> \n    <li><a href=\"#approach-2-dynamic-programming-accepted\">Approach #2: Dynamic Programming [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-brute-force-time-limit-exceeded\">Approach #1: Brute Force [Time Limit Exceeded]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>For each possible center, find the largest plus sign that could be placed by repeatedly expanding it. We expect this algorithm to be <script type=\"math/tex; mode=display\">O(N^3)</script>, and so take roughly <script type=\"math/tex; mode=display\">500^3 = (1.25) * 10^8</script> operations. This is a little bit too big for us to expect it to run in time.</p> \n  <iframe src=\"https://leetcode.com/playground/pVcrm4PA/shared\" frameborder=\"0\" width=\"100%\" height=\"412\" name=\"pVcrm4PA\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^3)</script>, as we perform two outer loops (<script type=\"math/tex; mode=display\">O(N^2)</script>), plus the inner loop involving <code>k</code> is <script type=\"math/tex; mode=display\">O(N)</script>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(\\text{mines.length})</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-dynamic-programming-accepted\">Approach #2: Dynamic Programming [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>How can we improve our bruteforce? One way is to try to speed up the inner loop involving <code>k</code>, the order of the candidate plus sign. If we knew the longest possible arm length <script type=\"math/tex; mode=display\">L_u, L_l, L_d, L_r</script> in each direction from a center, we could know the order <script type=\"math/tex; mode=display\">\\min(L_u, L_l, L_d, L_r)</script> of a plus sign at that center. We could find these lengths separately using dynamic programming.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>For each (cardinal) direction, and for each coordinate <code>(r, c)</code> let's compute the <code>count</code> of that coordinate: the longest line of <code>'1'</code>s starting from <code>(r, c)</code> and going in that direction. With dynamic programming, it is either 0 if <code>grid[r][c]</code> is zero, else it is <code>1</code> plus the count of the coordinate in the same direction. For example, if the direction is left and we have a row like <code>01110110</code>, the corresponding count values are <code>01230120</code>, and the integers are either 1 more than their successor, or 0. For each square, we want <code>dp[r][c]</code> to end up being the minimum of the 4 possible counts. At the end, we take the maximum value in <code>dp</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/JxbvtwM9/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"JxbvtwM9\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, as the work we do under two nested for loops is <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, the size of <code>dp</code>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 763,
    "article_live": true,
    "article_slug": "partition-labels",
    "title": "Partition Labels",
    "title_slug": "partition-labels",
    "content": "<p>\r\nA string <code>S</code> of lowercase letters is given.  We want to partition this string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts.\r\n</p><p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> S = \"ababcbacadefegdehijhklij\"\r\n<b>Output:</b> [9,7,8]\r\n<b>Explanation:</b>\r\nThe partition is \"ababcbaca\", \"defegde\", \"hijhklij\".\r\nThis is a partition so that each letter appears in at most one part.\r\nA partition like \"ababcbacadefegde\", \"hijhklij\" is incorrect, because it splits S into less parts.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br><ol>\r\n<li><code>S</code> will have length in range <code>[1, 500]</code>.</li>\r\n<li><code>S</code> will consist of lowercase letters (<code>'a'</code> to <code>'z'</code>) only.</li>\r\n</ol></p>",
    "tags": "Two Pointers, Greedy",
    "difficulty": 2,
    "frontend_article_id": 763,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-greedy-accepted\">Approach #1: Greedy [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-greedy-accepted\">Approach #1: Greedy [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Let's try to repeatedly choose the smallest left-justified partition. Consider the first label, say it's <code>'a'</code>. The first partition must include it, and also the last occurrence of <code>'a'</code>. However, between those two occurrences of <code>'a'</code>, there could be other labels that make the minimum size of this partition bigger. For example, in <code>\"abccaddbeffe\"</code>, the minimum first partition is <code>\"abccaddb\"</code>. This gives us the idea for the algorithm: For each letter encountered, process the last occurrence of that letter, extending the current partition <code>[anchor, j]</code> appropriately.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>We need an array <code>last[char] -&gt; index of S where char occurs last</code>. Then, let <code>anchor</code> and <code>j</code> be the start and end of the current partition. If we are at a label that occurs last at some index after <code>j</code>, we'll extend the partition <code>j = last[c]</code>. If we are at the end of the partition (<code>i == j</code>) then we'll append a partition size to our answer, and set the start of our new partition to <code>i+1</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/sSLPrXHh/shared\" frameborder=\"0\" width=\"100%\" height=\"361\" name=\"sSLPrXHh\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <script type=\"math/tex; mode=display\">S</script>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 762,
    "article_live": true,
    "article_slug": "prime-number-of-set-bits-in-binary-representation",
    "title": "Prime Number of Set Bits in Binary Representation",
    "title_slug": "prime-number-of-set-bits-in-binary-representation",
    "content": "<p>\r\nGiven two integers <code>L</code> and <code>R</code>, find the count of numbers in the range <code>[L, R]</code> (inclusive) having a prime number of set bits in their binary representation.\r\n</p><p>\r\n(Recall that the number of set bits an integer has is the number of <code>1</code>s present when written in binary.  For example, <code>21</code> written in binary is <code>10101</code> which has 3 set bits.  Also, 1 is not a prime.)\r\n</p><p>\r\n\r\n<p><b>Example 1:</b><br /><pre>\r\n<b>Input:</b> L = 6, R = 10\r\n<b>Output:</b> 4\r\n<b>Explanation:</b>\r\n6 -> 110 (2 set bits, 2 is prime)\r\n7 -> 111 (3 set bits, 3 is prime)\r\n9 -> 1001 (2 set bits , 2 is prime)\r\n10->1010 (2 set bits , 2 is prime)\r\n</pre></p>\r\n\r\n<p><b>Example 2:</b><br /><pre>\r\n<b>Input:</b> L = 10, R = 15\r\n<b>Output:</b> 5\r\n<b>Explanation:</b>\r\n10 -> 1010 (2 set bits, 2 is prime)\r\n11 -> 1011 (3 set bits, 3 is prime)\r\n12 -> 1100 (2 set bits, 2 is prime)\r\n13 -> 1101 (3 set bits, 3 is prime)\r\n14 -> 1110 (3 set bits, 3 is prime)\r\n15 -> 1111 (4 set bits, 4 is not prime)\r\n</pre></p>\r\n\r\n<p><b>Note:</b><br><ol>\r\n<li><code>L, R</code> will be integers <code>L <= R</code> in the range <code>[1, 10^6]</code>.</li>\r\n<li><code>R - L</code> will be at most 10000.</li>\r\n</ol></p>",
    "tags": "Bit Manipulation",
    "difficulty": 1,
    "frontend_article_id": 762,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-direct-accepted\">Approach #1: Direct [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-direct-accepted\">Approach #1: Direct [Accepted]</h4> \n  <p><strong>Intuition and Approach</strong></p> \n  <p>For each number from <code>L</code> to <code>R</code>, let's find out how many set bits it has. If that number is <code>2, 3, 5, 7, 11, 13, 17</code>, or <code>19</code>, then we add one to our count. We only need primes up to 19 because <script type=\"math/tex; mode=display\">R \\leq 10^6 < 2^{20}</script>.</p> \n  <iframe src=\"https://leetcode.com/playground/GCVcZ6pE/shared\" frameborder=\"0\" width=\"100%\" height=\"276\" name=\"GCVcZ6pE\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(D)</script>, where <script type=\"math/tex; mode=display\">D = R-L</script> is the number of integers considered. In a bit complexity model, this would be <script type=\"math/tex; mode=display\">O(D\\log D)</script> as we have to count the bits in <script type=\"math/tex; mode=display\">O(\\log D)</script> time.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 430,
    "article_live": false,
    "title": "Flatten a Multilevel Doubly Linked List",
    "title_slug": "flatten-a-multilevel-doubly-linked-list",
    "content": "<p>You are given a doubly linked list which in addition to the next and previous pointers, it could have a child pointer, which may or may not point to a separate doubly linked list. These child lists may have one or more children of their own, and so on, to produce a multilevel data structure, as shown in the example below.</p>\r\n\r\n<p>Flatten the list so that all the nodes appear in a single-level, doubly linked list. You are given the head of the first level of the list.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>\r\n 1---2---3---4---5---6--NULL\r\n         |\r\n         7---8---9---10--NULL\r\n             |\r\n             11--12--NULL\r\n\r\n<strong>Output:</strong>\r\n1-2-3-7-8-11-12-9-10-4-5-6-NULL\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Explanation for the above example:</strong></p>\r\n\r\n<p>Given the following multilevel doubly linked list:</p>\r\n\r\n<pre>\r\n<img src=\"https://assets.leetcode.com/uploads/2018/10/12/multilevellinkedlist.png\" style=\"width: 640px;\" /></pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>We should return the following flattened doubly linked list:</p>\r\n\r\n<pre>\r\n<img src=\"https://assets.leetcode.com/uploads/2018/10/12/multilevellinkedlistflattened.png\" style=\"width: 1100px;\" /></pre>\r\n",
    "tags": "Linked List, Depth-first Search",
    "difficulty": 2,
    "frontend_article_id": 430
},
{
    "frontend_question_id": 428,
    "article_live": false,
    "title": "Serialize and Deserialize N-ary Tree",
    "title_slug": "serialize-and-deserialize-n-ary-tree",
    "tags": "Tree",
    "difficulty": 3,
    "frontend_article_id": 428
},
{
    "frontend_question_id": 429,
    "article_live": false,
    "title": "N-ary Tree Level Order Traversal",
    "title_slug": "n-ary-tree-level-order-traversal",
    "content": "<p>Given an n-ary tree, return the level order traversal of its nodes&#39; values. (ie, from left to right, level by level).</p>\r\n\r\n<p>For example, given a <code>3-ary</code> tree:</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png\" style=\"width: 100%; max-width: 300px;\" /></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>We should return its level order traversal:</p>\r\n\r\n<pre>\r\n[\r\n     [1],\r\n     [3,2,4],\r\n     [5,6]\r\n]\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Note:</b></p>\r\n\r\n<ol>\r\n\t<li>The depth of the tree is at most <code>1000</code>.</li>\r\n\t<li>The total number of nodes is at most <code>5000</code>.</li>\r\n</ol>\r\n",
    "tags": "Tree, Breadth-first Search",
    "difficulty": 1,
    "frontend_article_id": 429
},
{
    "frontend_question_id": 761,
    "article_live": true,
    "article_slug": "special-binary-string",
    "title": "Special Binary String",
    "title_slug": "special-binary-string",
    "content": "<p>\r\n<i>Special</i> binary strings are binary strings with the following two properties:\r\n</p><p>\r\n<li>The number of 0's is equal to the number of 1's.</li>\r\n<li>Every prefix of the binary string has at least as many 1's as 0's.</li>\r\n</p><p>\r\nGiven a special string <code>S</code>, a <i>move</i> consists of choosing two consecutive, non-empty, special substrings of <code>S</code>, and swapping them.  <i>(Two strings are consecutive if the last character of the first string is exactly one index before the first character of the second string.)</i>\r\n</p><p>\r\nAt the end of any number of moves, what is the lexicographically largest resulting string possible?\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> S = \"11011000\"\r\n<b>Output:</b> \"11100100\"\r\n<b>Explanation:</b>\r\nThe strings \"10\" [occuring at S[1]] and \"1100\" [at S[3]] are swapped.\r\nThis is the lexicographically largest string possible after some number of swaps.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><ol>\r\n<li><code>S</code> has length at most <code>50</code>.</li>\r\n<li><code>S</code> is guaranteed to be a <i>special</i> binary string as defined above.</li>\r\n</ol></p>",
    "tags": "String, Recursion",
    "difficulty": 3,
    "frontend_article_id": 761,
    "article_content": ""
},
{
    "frontend_question_id": 760,
    "article_live": true,
    "article_slug": "find-anagram-mappings",
    "title": "Find Anagram Mappings",
    "title_slug": "find-anagram-mappings",
    "tags": "Hash Table",
    "difficulty": 1,
    "frontend_article_id": 760,
    "article_content": ""
},
{
    "frontend_question_id": 759,
    "article_live": true,
    "article_slug": "employee-free-time",
    "title": "Employee Free Time",
    "title_slug": "employee-free-time",
    "tags": "Heap, Greedy",
    "difficulty": 3,
    "frontend_article_id": 759,
    "article_content": ""
},
{
    "frontend_question_id": 758,
    "article_live": true,
    "article_slug": "bold-words-in-string",
    "title": "Bold Words in String",
    "title_slug": "bold-words-in-string",
    "tags": "String",
    "difficulty": 1,
    "frontend_article_id": 758,
    "article_content": ""
},
{
    "frontend_question_id": 757,
    "article_live": true,
    "article_slug": "set-intersection-size-at-least-two",
    "title": "Set Intersection Size At Least Two",
    "title_slug": "set-intersection-size-at-least-two",
    "content": "<p>\r\nAn integer interval <code>[a, b]</code> (for integers <code>a < b</code>) is a set of all consecutive integers from <code>a</code> to <code>b</code>, including <code>a</code> and <code>b</code>.\r\n</p><p>\r\nFind the minimum size of a set S such that for every integer interval A in <code>intervals</code>, the intersection of S with A has size at least 2.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> intervals = [[1, 3], [1, 4], [2, 5], [3, 5]]\r\n<b>Output:</b> 3\r\n<b>Explanation:</b>\r\nConsider the set S = {2, 3, 4}.  For each interval, there are at least 2 elements from S in the interval.\r\nAlso, there isn't a smaller size set that fulfills the above condition.\r\nThus, we output the size of this set, which is 3.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> intervals = [[1, 2], [2, 3], [2, 4], [4, 5]]\r\n<b>Output:</b> 5\r\n<b>Explanation:</b>\r\nAn example of a minimum sized set is {1, 2, 3, 4, 5}.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br><ol>\r\n<li><code>intervals</code> will have length in range <code>[1, 3000]</code>.</li>\r\n<li><code>intervals[i]</code> will have length <code>2</code>, representing some integer interval.</li>\r\n<li><code>intervals[i][j]</code> will be an integer in <code>[0, 10^8]</code>.</li>\r\n</ol></p>",
    "tags": "Greedy",
    "difficulty": 3,
    "frontend_article_id": 757,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-greedy-accepted\">Approach #1: Greedy [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-greedy-accepted\">Approach #1: Greedy [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Let's try to solve a simpler problem: what is the answer when the set intersection size is at least <em>one</em>?</p> \n  <p>Sort the points. Take the last interval <code>[s, e]</code>, which point on this interval will be in <code>S</code>? Since every other interval has start point <code>&lt;= s</code>, it is strictly better to choose <code>s</code> as the start. So we can repeatedly take <code>s</code> in our set <code>S</code> and remove all intervals containing <code>s</code>.</p> \n  <p>We will try to extend this solution to the case when we want an intersection of size two.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>For each interval, we will perform the algorithm described above, storing a <code>todo</code> <em>multiplicity</em> which starts at <code>2</code>. As we identify points in <code>S</code>, we will subtract from these multiplicities as appropriate.</p> \n  <p>One case that is important to handle is the following: <code>[[1, 2], [2, 3], [2, 4], [4, 5]]</code>. If we put <code>4, 5</code> in <code>S</code>, then we put <code>2</code> in <code>S</code>, when handling <code>[2, 3]</code> we need to put <code>3</code> in <code>S</code>, not <code>2</code> which was already put.</p> \n  <p>We can handle this case succinctly by sorting intervals <code>[s, e]</code> by <code>s</code> ascending, then <code>e</code> descending. This makes it so that any interval encountered with the same <code>s</code> has the lowest possible <code>e</code>, and so it has the highest <em>multiplicity</em>. When at interval <code>[s, e]</code> and choosing points to be included into <code>S</code>, it will always be the case that the start of the interval (either <code>s</code> or <code>s, s+1</code>) will be unused.</p> \n  <iframe src=\"https://leetcode.com/playground/w4QM4e3U/shared\" frameborder=\"0\" width=\"100%\" height=\"412\" name=\"w4QM4e3U\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>intervals</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 426,
    "article_live": false,
    "title": "Convert Binary Search Tree to Sorted Doubly Linked List",
    "title_slug": "convert-binary-search-tree-to-sorted-doubly-linked-list",
    "tags": "Linked List, Divide and Conquer, Tree",
    "difficulty": 2,
    "frontend_article_id": 426
},
{
    "frontend_question_id": 756,
    "article_live": true,
    "article_slug": "pyramid-transition-matrix",
    "title": "Pyramid Transition Matrix",
    "title_slug": "pyramid-transition-matrix",
    "content": "<p>\r\nWe are stacking blocks to form a pyramid.  Each block has a color which is a one letter string, like `'Z'`.\r\n</p><p>\r\nFor every block of color `C` we place not in the bottom row, we are placing it on top of a left block of color `A` and right block of color `B`.  We are allowed to place the block there only if `(A, B, C)` is an allowed triple.\r\n</p><p>\r\nWe start with a bottom row of <code>bottom</code>, represented as a single string.  We also start with a list of allowed triples <code>allowed</code>.  Each allowed triple is represented as a string of length 3.\r\n</p><p>\r\nReturn true if we can build the pyramid all the way to the top, otherwise false.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> bottom = \"XYZ\", allowed = [\"XYD\", \"YZE\", \"DEA\", \"FFF\"]\r\n<b>Output:</b> true\r\n<b>Explanation:</b>\r\nWe can stack the pyramid like this:\r\n    A\r\n   / \\\r\n  D   E\r\n / \\ / \\\r\nX   Y   Z\r\n\r\nThis works because ('X', 'Y', 'D'), ('Y', 'Z', 'E'), and ('D', 'E', 'A') are allowed triples.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> bottom = \"XXYX\", allowed = [\"XXX\", \"XXY\", \"XYX\", \"XYY\", \"YXZ\"]\r\n<b>Output:</b> false\r\n<b>Explanation:</b>\r\nWe can't stack the pyramid to the top.\r\nNote that there could be allowed triples (A, B, C) and (A, B, D) with C != D.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li><code>bottom</code> will be a string with length in range <code>[2, 8]</code>.</li>\r\n<li><code>allowed</code> will have length in range <code>[0, 200]</code>.</li>\r\n<li>Letters in all strings will be chosen from the set <code>{'A', 'B', 'C', 'D', 'E', 'F', 'G'}</code>.</li>\r\n</ol>\r\n</p>",
    "tags": "Bit Manipulation, Depth-first Search",
    "difficulty": 2,
    "frontend_article_id": 756,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-state-to-state-transition-wrong-answer\">Approach #1: State to State Transition [Wrong Answer]</a></li> \n    <li><a href=\"#approach-2-depth-first-search-accepted\">Approach #2: Depth-First Search [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-state-to-state-transition-wrong-answer\">Approach #1: State to State Transition [Wrong Answer]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>We model the states that blocks can be in. Each state is a binary number where the <code>k</code>th bit is set if the <code>k</code>th type of block is a possibility. Then, we create a transition map <code>T[state1][state2] -&gt; state</code> that takes a left state and a right state and outputs all possible parent states.</p> \n  <p>At the end, applying these transitions is straightforward. However, this approach is not correct, because the transitions are not independent. If for example we have states in a row <code>A, {B or C}, A</code>, and allowed triples <code>(A, B, D)</code>, <code>(C, A, D)</code>, then regardless of the choice of <code>{B or C}</code> we cannot create the next row of the pyramid.</p> \n  <iframe src=\"https://leetcode.com/playground/FoBNczLu/shared\" frameborder=\"0\" width=\"100%\" height=\"429\" name=\"FoBNczLu\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(2^{2\\mathcal{A}}A + N^2)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>bottom</code>, <script type=\"math/tex; mode=display\">A</script> is the length of <code>allowed</code>, and <script type=\"math/tex; mode=display\">\\mathcal{A}</script> is the size of the alphabet.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(2^{2\\mathcal{A}})</script> in additional space complexity.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-depth-first-search-accepted\">Approach #2: Depth-First Search [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>We exhaustively try every combination of blocks.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>We can work in either strings or integers, but we need to create a transition map <code>T</code> from the list of allowed triples. This map <code>T[x][y] = {set of z}</code> will be all possible parent blocks for a left child of <code>x</code> and a right child of <code>y</code>. When we work in strings, we use <code>Set</code>, and when we work in integers, we will use the set bits of the result integer.</p> \n  <p>Afterwards, to <code>solve</code> a row, we generate every possible combination of the next row and solve them. If any of those new rows are solvable, we return <code>True</code>, otherwise <code>False</code>.</p> \n  <p>We can also cache intermediate results, saving us time. This is illustrated in the comments for Python. For Java, all caching is done with lines of code that mention the integer <code>R</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/W723Lgci/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"W723Lgci\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(\\mathcal{A}^{N})</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>bottom</code>, and <script type=\"math/tex; mode=display\">\\mathcal{A}</script> is the size of the alphabet, and assuming we cache intermediate results. We might try every sequence of letters for each row. [The total complexity is because <script type=\"math/tex; mode=display\">O(\\sum_{k}^n \\mathcal{A}^{k})</script> is a geometric series equal to <script type=\"math/tex; mode=display\">O(\\frac{\\mathcal{A^{n+1}}-1}{\\mathcal{A}-1})</script>.] Without intermediate caching, this would be <script type=\"math/tex; mode=display\">O(\\mathcal{A}^{N^2})</script>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script> additional space complexity.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 755,
    "article_live": true,
    "article_slug": "pour-water",
    "title": "Pour Water",
    "title_slug": "pour-water",
    "tags": "Array",
    "difficulty": 2,
    "frontend_article_id": 755,
    "article_content": ""
},
{
    "frontend_question_id": 754,
    "article_live": true,
    "article_slug": "reach-a-number",
    "title": "Reach a Number",
    "title_slug": "reach-a-number",
    "content": "<p>\r\nYou are standing at position <code>0</code> on an infinite number line.  There is a goal at position <code>target</code>.\r\n</p><p>\r\nOn each move, you can either go left or right.  During the <i>n</i>-th move (starting from 1), you take <i>n</i> steps.\r\n</p><p>\r\nReturn the minimum number of steps required to reach the destination.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> target = 3\r\n<b>Output:</b> 2\r\n<b>Explanation:</b>\r\nOn the first move we step from 0 to 1.\r\nOn the second step we step from 1 to 3.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> target = 2\r\n<b>Output:</b> 3\r\n<b>Explanation:</b>\r\nOn the first move we step from 0 to 1.\r\nOn the second move we step  from 1 to -1.\r\nOn the third move we step from -1 to 2.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<li><code>target</code> will be a non-zero integer in the range <code>[-10^9, 10^9]</code>.</li>\r\n</p>",
    "tags": "Math",
    "difficulty": 1,
    "frontend_article_id": 754,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-mathematical-accepted\">Approach #1: Mathematical [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-mathematical-accepted\">Approach #1: Mathematical [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>The crux of the problem is to put <code>+</code> and <code>-</code> signs on the numbers <code>1, 2, 3, ..., k</code> so that the sum is <code>target</code>.</p> \n  <p>When <code>target &lt; 0</code> and we made a sum of <code>target</code>, we could switch the signs of all the numbers so that it equals <code>Math.abs(target)</code>. Thus, the answer for <code>target</code> is the same as <code>Math.abs(target)</code>, and so without loss of generality, we can consider only <code>target &gt; 0</code>.</p> \n  <p>Now let's say <code>k</code> is the smallest number with <code>S = 1 + 2 + ... + k &gt;= target</code>. If <code>S == target</code>, the answer is clearly <code>k</code>.</p> \n  <p>If <code>S &gt; target</code>, we need to change some number signs. If <code>delta = S - target</code> is even, then we can always find a subset of <code>{1, 2, ..., k}</code> equal to <code>delta / 2</code> and switch the signs, so the answer is <code>k</code>. (This depends on <code>T = delta / 2</code> being at most <code>S</code>.) [The proof is simple: either <code>T &lt;= k</code> and we choose it, or we choose <code>k</code> in our subset and try to solve the same instance of the problem for <code>T -= k</code> and the set <code>{1, 2, ..., k-1}</code>.]</p> \n  <p>Otherwise, if <code>delta</code> is odd, we can't do it, as every sign change from positive to negative changes the sum by an even number. So let's consider a candidate answer of <code>k+1</code>, which changes <code>delta</code> by <code>k+1</code>. If this is odd, then <code>delta</code> will be even and we can have an answer of <code>k+1</code>. Otherwise, <code>delta</code> will be odd, and we will have an answer of <code>k+2</code>.</p> \n  <p>For concrete examples of the above four cases, consider the following:</p> \n  <ul> \n   <li>If <code>target = 3</code>, then <code>k = 2, delta = 0</code> and the answer is <code>k = 2</code>.</li> \n   <li>If <code>target = 4</code>, then <code>k = 3, delta = 2</code>, delta is even and the answer is <code>k = 3</code>.</li> \n   <li>If <code>target = 7</code>, then <code>k = 4, delta = 3</code>, delta is odd and adding <code>k+1</code> makes delta even. The answer is <code>k+1 = 5</code>.</li> \n   <li>If <code>target = 5</code>, then <code>k = 3, delta = 1</code>, delta is odd and adding <code>k+1</code> keeps delta odd. The answer is <code>k+2 = 5</code>.</li> \n  </ul> \n  <p><strong>Algorithm</strong></p> \n  <p>Subtract <code>++k</code> from <code>target</code> until it goes non-positive. Then <code>k</code> will be as described, and <code>target</code> will be <code>delta</code> as described. We can output the four cases above: if <code>delta</code> is even then the answer is <code>k</code>, if <code>delta</code> is odd then the answer is <code>k+1</code> or <code>k+2</code> depending on the parity of <code>k</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/VZd5DozE/shared\" frameborder=\"0\" width=\"100%\" height=\"208\" name=\"VZd5DozE\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(\\sqrt{\\text{target}})</script>. Our while loop needs this many steps, as <script type=\"math/tex; mode=display\">1 + 2 + \\dots + k = \\frac{k(k+1)}{2}</script>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 753,
    "article_live": true,
    "article_slug": "cracking-the-safe",
    "title": "Cracking the Safe",
    "title_slug": "cracking-the-safe",
    "content": "<p>\r\nThere is a box protected by a password.  The password is <code>n</code> digits, where each letter can be one of the first <code>k</code> digits <code>0, 1, ..., k-1</code>.\r\n</p><p>\r\nYou can keep inputting the password, the password will automatically be matched against the last <code>n</code> digits entered.\r\n</p><p>\r\nFor example, assuming the password is <code>\"345\"</code>, I can open it when I type <code>\"012345\"</code>, but I enter a total of 6 digits.\r\n</p><p>\r\nPlease return any string of minimum length that is guaranteed to open the box after the entire string is inputted.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> n = 1, k = 2\r\n<b>Output:</b> \"01\"\r\n<b>Note:</b> \"10\" will be accepted too.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> n = 2, k = 2\r\n<b>Output:</b> \"00110\"\r\n<b>Note:</b> \"01100\", \"10011\", \"11001\" will be accepted too.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li><code>n</code> will be in the range <code>[1, 4]</code>.</li>\r\n<li><code>k</code> will be in the range <code>[1, 10]</code>.</li>\r\n<li><code>k^n</code> will be at most <code>4096</code>.</li>\r\n</ol>\r\n</p>",
    "tags": "Math, Depth-first Search",
    "difficulty": 3,
    "frontend_article_id": 753,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-hierholzers-algorithm-accepted\">Approach #1: Hierholzer's Algorithm [Accepted]</a></li> \n    <li><a href=\"#approach-2-inverse-burrows-wheeler-transform-accepted\">Approach #2: Inverse Burrows-Wheeler Transform [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-hierholzers-algorithm-accepted\">Approach #1: Hierholzer's Algorithm [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>We can think of this problem as the problem of finding an Euler path (a path visiting every edge exactly once) on the following graph: there are <script type=\"math/tex; mode=display\">k^{n-1}</script> nodes with each node having <script type=\"math/tex; mode=display\">k</script> edges.</p> \n  <p>For example, when <code>k = 4, n = 3</code>, the nodes are <code>'00', '01', '02', ..., '32', '33'</code> and each node has 4 edges <code>'0', '1', '2', '3'</code>. A node plus edge represents a <em>complete edge</em> and viewing that substring in our answer.</p> \n  <p>Any connected directed graph where all nodes have equal in-degree and out-degree has an Euler circuit (an Euler path ending where it started.) Because our graph is highly connected and symmetric, we should expect intuitively that taking any path greedily in some order will probably result in an Euler path. </p> \n  <p>This intuition is called Hierholzer's algorithm: whenever there is an Euler cycle, we can construct it greedily. The algorithm goes as follows:</p> \n  <ul> \n   <li> <p>Starting from a vertex <code>u</code>, we walk through (unwalked) edges until we get stuck. Because the in-degrees and out-degrees of each node are equal, we can only get stuck at <code>u</code>, which forms a cycle.</p> </li> \n   <li> <p>Now, for any node <code>v</code> we had visited that has unwalked edges, we start a new cycle from <code>v</code> with the same procedure as above, and then merge the cycles together to form a new cycle <script type=\"math/tex; mode=display\">u \\rightarrow \\dots \\rightarrow v \\rightarrow \\dots \\rightarrow v \\rightarrow \\dots \\rightarrow u</script>.</p> </li> \n  </ul> \n  <p><strong>Algorithm</strong></p> \n  <p>We will modify our standard depth-first search: instead of keeping track of nodes, we keep track of (complete) edges: <code>seen</code> records if an edge has been visited.</p> \n  <p>Also, we'll need to visit in a sort of \"post-order\", recording the answer after visiting the edge. This is to prevent getting stuck. For example, with <code>k = 2, n = 2</code>, we have the nodes <code>'0', '1'</code>. If we greedily visit complete edges <code>'00', '01', '10'</code>, we will be stuck at the node <code>'0'</code> prematurely. However, if we visit in post-order, we'll end up visiting <code>'00', '01', '11', '10'</code> correctly.</p> \n  <p>In general, during our Hierholzer walk, we will record the results of other subcycles first, before recording the main cycle we started from, just as in our first description of the algorithm. Technically, we are recording backwards, as we exit the nodes.</p> \n  <p>For example, we will walk (in the \"original cycle\") until we get stuck, then record the node as we exit. (Every edge walked is always marked immediately so that it can no longer be used.) Then in the penultimate node of our original cycle, we will do a Hierholzer walk and then record this node; then in the third-last node of our original cycle we will do a Hierholzer walk and then record this node, and so on.</p> \n  <iframe src=\"https://leetcode.com/playground/6FQhQc9V/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"6FQhQc9V\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(n * k^n)</script>. We visit every edge once in our depth-first search, and nodes take <script type=\"math/tex; mode=display\">O(n)</script> space.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(n * k^n)</script>, the size of <code>seen</code>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-inverse-burrows-wheeler-transform-accepted\">Approach #2: Inverse Burrows-Wheeler Transform [Accepted]</h4> \n  <p><strong>Explanation</strong></p> \n  <p>If we are familiar with the theory of combinatorics on words, recall that a <em>Lyndon Word</em> <code>L</code> is a word that is the unique minimum of it's rotations.</p> \n  <p>One important mathematical result (due to <a href=\"http://www-igm.univ-mlv.fr/~perrin/Recherche/Publications/Articles/debruijnRevised3.pdf\">Fredericksen and Maiorana</a>), is that the concatenation in lexicographic order of Lyndon words with length dividing <code>n</code>, forms a <em>de Bruijin</em> sequence: a sequence where every every word (from the <script type=\"math/tex; mode=display\">k^n</script> available) appears as a substring of length <code>n</code> (where we are allowed to wrap around.)</p> \n  <p>For example, when <code>n = 6, k = 2</code>, all the Lyndon words with length dividing <code>n</code> in lexicographic order are (spaces for convenience): <code>0 000001 000011 000101 000111 001 001011 001101 001111 01 010111 011 011111 1</code>. It turns out this is the smallest de Bruijin sequence.</p> \n  <p>We can use the <em>Inverse Burrows-Wheeler Transform</em> (IBWT) to generate these Lyndon words. Consider two sequences: <code>S</code> is the alphabet repeated <script type=\"math/tex; mode=display\">k^{n-1}</script> times: <code>S = 0123...0123...0123....</code>, and <code>S'</code> is the alphabet repeated <script type=\"math/tex; mode=display\">k^{n-1}</script> times for each letter: <code>S' = 00...0011...1122....</code> We can think of <code>S'</code> and <code>S</code> as defining a permutation, where the <code>j</code>-th occurrence of each letter of the alphabet in <code>S'</code> maps to the corresponding <code>j</code>-th occurrence in <code>S</code>. The cycles of this permutation turn out to be the corresponding smallest de Bruijin sequence (<a href=\"http://www.macs.hw.ac.uk/~markl/Higgins.pdf\">link</a>).</p> \n  <p>Under this view, the permutation <script type=\"math/tex; mode=display\">S' \\rightarrow S</script> [mapping permutation indices <script type=\"math/tex; mode=display\">(i * k^{n-1} + q) \\rightarrow (q * k + i)</script>] form the desired Lyndon words.</p> \n  <iframe src=\"https://leetcode.com/playground/Xcx7eTBD/shared\" frameborder=\"0\" width=\"100%\" height=\"463\" name=\"Xcx7eTBD\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(k^n)</script>. We loop through every possible substring.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(k^n)</script>, the size of <code>P</code> and <code>ans</code>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 752,
    "article_live": true,
    "article_slug": "open-the-lock",
    "title": "Open the Lock",
    "title_slug": "open-the-lock",
    "content": "<p>\r\nYou have a lock in front of you with 4 circular wheels.  Each wheel has 10 slots: <code>'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'</code>.  The wheels can rotate freely and wrap around: for example we can turn <code>'9'</code> to be <code>'0'</code>, or <code>'0'</code> to be <code>'9'</code>.  Each move consists of turning one wheel one slot.\r\n</p><p>\r\nThe lock initially starts at <code>'0000'</code>, a string representing the state of the 4 wheels.\r\n</p><p>\r\nYou are given a list of <code>deadends</code> dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.\r\n</p><p>\r\nGiven a <code>target</code> representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> deadends = [\"0201\",\"0101\",\"0102\",\"1212\",\"2002\"], target = \"0202\"\r\n<b>Output:</b> 6\r\n<b>Explanation:</b>\r\nA sequence of valid moves would be \"0000\" -> \"1000\" -> \"1100\" -> \"1200\" -> \"1201\" -> \"1202\" -> \"0202\".\r\nNote that a sequence like \"0000\" -> \"0001\" -> \"0002\" -> \"0102\" -> \"0202\" would be invalid,\r\nbecause the wheels of the lock become stuck after the display becomes the dead end \"0102\".\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> deadends = [\"8888\"], target = \"0009\"\r\n<b>Output:</b> 1\r\n<b>Explanation:</b>\r\nWe can turn the last wheel in reverse to move from \"0000\" -> \"0009\".\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 3:</b><br />\r\n<pre>\r\n<b>Input:</b> deadends = [\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9888\"], target = \"8888\"\r\n<b>Output:</b> -1\r\n<b>Explanation:</b>\r\nWe can't reach the target without getting stuck.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 4:</b><br />\r\n<pre>\r\n<b>Input:</b> deadends = [\"0000\"], target = \"8888\"\r\n<b>Output:</b> -1\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The length of <code>deadends</code> will be in the range <code>[1, 500]</code>.</li>\r\n<li><code>target</code> will not be in the list <code>deadends</code>.</li>\r\n<li>Every string in <code>deadends</code> and the string <code>target</code> will be a string of 4 digits from the 10,000 possibilities <code>'0000'</code> to <code>'9999'</code>.</li>\r\n</ol>\r\n</p>",
    "tags": "Breadth-first Search",
    "difficulty": 2,
    "frontend_article_id": 752,
    "article_content": ""
},
{
    "frontend_question_id": 751,
    "article_live": true,
    "article_slug": "ip-to-cidr",
    "title": "IP to CIDR",
    "title_slug": "ip-to-cidr",
    "tags": "Bit Manipulation",
    "difficulty": 1,
    "frontend_article_id": 751,
    "article_content": ""
},
{
    "frontend_question_id": 750,
    "article_live": true,
    "article_slug": "number-of-corner-rectangles",
    "title": "Number Of Corner Rectangles",
    "title_slug": "number-of-corner-rectangles",
    "tags": "Dynamic Programming",
    "difficulty": 2,
    "frontend_article_id": 750,
    "article_content": ""
},
{
    "frontend_question_id": 749,
    "article_live": true,
    "article_slug": "contain-virus",
    "title": "Contain Virus",
    "title_slug": "contain-virus",
    "content": "<p>\r\nA virus is spreading rapidly, and your task is to quarantine the infected area by installing walls.\r\n</p><p>\r\nThe world is modeled as a 2-D array of cells, where <code>0</code> represents uninfected cells, and <code>1</code> represents cells contaminated with the virus.  A wall (and only one wall) can be installed <b>between any two 4-directionally adjacent cells</b>, on the shared boundary.\r\n</p><p>\r\nEvery night, the virus spreads to all neighboring cells in all four directions unless blocked by a wall.\r\nResources are limited. Each day, you can install walls around only one region -- the affected area (continuous block of infected cells) that threatens the most uninfected cells the following night. There will never be a tie.\r\n</p><p>\r\nCan you save the day? If so, what is the number of walls required? If not, and the world becomes fully infected, return the number of walls used.\r\n</p><p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> grid = \r\n[[0,1,0,0,0,0,0,1],\r\n [0,1,0,0,0,0,0,1],\r\n [0,0,0,0,0,0,0,1],\r\n [0,0,0,0,0,0,0,0]]\r\n<b>Output:</b> 10\r\n<b>Explanation:</b>\r\nThere are 2 contaminated regions.\r\nOn the first day, add 5 walls to quarantine the viral region on the left. The board after the virus spreads is:\r\n\r\n[[0,1,0,0,0,0,1,1],\r\n [0,1,0,0,0,0,1,1],\r\n [0,0,0,0,0,0,1,1],\r\n [0,0,0,0,0,0,0,1]]\r\n\r\nOn the second day, add 5 walls to quarantine the viral region on the right. The virus is fully contained.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> grid = \r\n[[1,1,1],\r\n [1,0,1],\r\n [1,1,1]]\r\n<b>Output:</b> 4\r\n<b>Explanation:</b> Even though there is only one cell saved, there are 4 walls built.\r\nNotice that walls are only built on the shared boundary of two different cells.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 3:</b><br />\r\n<pre>\r\n<b>Input:</b> grid = \r\n[[1,1,1,0,0,0,0,0,0],\r\n [1,0,1,0,1,1,1,1,1],\r\n [1,1,1,0,0,0,0,0,0]]\r\n<b>Output:</b> 13\r\n<b>Explanation:</b> The region on the left only builds two new walls.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The number of rows and columns of <code>grid</code> will each be in the range <code>[1, 50]</code>.</li>\r\n<li>Each <code>grid[i][j]</code> will be either <code>0</code> or <code>1</code>.</li>\r\n<li>Throughout the described process, there is always a contiguous viral region that will infect <b>strictly more</b> uncontaminated squares in the next round.</li>\r\n</ol>\r\n</p>",
    "tags": "Depth-first Search",
    "difficulty": 3,
    "frontend_article_id": 749,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-simulation-accepted\">Approach #1: Simulation [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-simulation-accepted\">Approach #1: Simulation [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Let's work on simulating one turn of the process. We can repeat this as necessary while there are still infected regions.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Though the implementation is long, the algorithm is straightforward. We perform the following steps:</p> \n  <ul> \n   <li> <p>Find all viral regions (connected components), additionally for each region keeping track of the frontier (neighboring uncontaminated cells), and the perimeter of the region.</p> </li> \n   <li> <p>Disinfect the most viral region, adding it's perimeter to the answer.</p> </li> \n   <li> <p>Spread the virus in the remaining regions outward by 1 square.</p> </li> \n  </ul> \n  <iframe src=\"https://leetcode.com/playground/VFSzJzRe/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"VFSzJzRe\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O((R*C)^{\\frac{4}{3}})</script> where <script type=\"math/tex; mode=display\">R, C</script> is the number of rows and columns. After time <script type=\"math/tex; mode=display\">t</script>, viral regions that are alive must have size at least <script type=\"math/tex; mode=display\">t^2 + (t-1)^2</script>, so the total number removed across all time is <script type=\"math/tex; mode=display\">\\Omega(t^3) \\leq R*C</script>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(R*C)</script> in additional space.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 748,
    "article_live": true,
    "article_slug": "shortest-completing-word",
    "title": "Shortest Completing Word",
    "title_slug": "shortest-completing-word",
    "content": "<p>\r\nFind the minimum length word from a given dictionary <code>words</code>, which has all the letters from the string <code>licensePlate</code>.  Such a word is said to <i>complete</i> the given string <code>licensePlate</code>\r\n</p><p>\r\nHere, for letters we ignore case.  For example, <code>\"P\"</code> on the <code>licensePlate</code> still matches <code>\"p\"</code> on the word.\r\n</p><p>\r\nIt is guaranteed an answer exists.  If there are multiple answers, return the one that occurs first in the array.\r\n</p><p>\r\nThe license plate might have the same letter occurring multiple times.  For example, given a <code>licensePlate</code> of <code>\"PP\"</code>, the word <code>\"pair\"</code> does not complete the <code>licensePlate</code>, but the word <code>\"supper\"</code> does.\r\n</p><p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> licensePlate = \"1s3 PSt\", words = [\"step\", \"steps\", \"stripe\", \"stepple\"]\r\n<b>Output:</b> \"steps\"\r\n<b>Explanation:</b> The smallest length word that contains the letters \"S\", \"P\", \"S\", and \"T\".\r\nNote that the answer is not \"step\", because the letter \"s\" must occur in the word twice.\r\nAlso note that we ignored case for the purposes of comparing whether a letter exists in the word.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> licensePlate = \"1s3 456\", words = [\"looks\", \"pest\", \"stew\", \"show\"]\r\n<b>Output:</b> \"pest\"\r\n<b>Explanation:</b> There are 3 smallest length words that contains the letters \"s\".\r\nWe return the one that occurred first.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li><code>licensePlate</code> will be a string with length in range <code>[1, 7]</code>.</li>\r\n<li><code>licensePlate</code> will contain digits, spaces, or letters (uppercase or lowercase).</li>\r\n<li><code>words</code> will have a length in the range <code>[10, 1000]</code>.</li>\r\n<li>Every <code>words[i]</code> will consist of lowercase letters, and have length in range <code>[1, 15]</code>.</li>\r\n</ol>\r\n</p>",
    "tags": "Hash Table",
    "difficulty": 1,
    "frontend_article_id": 748,
    "article_content": ""
},
{
    "frontend_question_id": 747,
    "article_live": true,
    "article_slug": "largest-number-at-least-twice-of-others",
    "title": "Largest Number At Least Twice of Others",
    "title_slug": "largest-number-at-least-twice-of-others",
    "content": "<p>In a given integer array <code>nums</code>, there is always exactly one largest element.</p>\r\n\r\n<p>Find whether the largest element in the array is at least twice as much as every other number in the array.</p>\r\n\r\n<p>If it is, return the <strong>index</strong> of the largest element, otherwise return -1.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [3, 6, 1, 0]\r\n<strong>Output:</strong> 1\r\n<strong>Explanation:</strong> 6 is the largest integer, and for every other number in the array x,\r\n6 is more than twice as big as x.  The index of value 6 is 1, so we return 1.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [1, 2, 3, 4]\r\n<strong>Output:</strong> -1\r\n<strong>Explanation:</strong> 4 isn&#39;t at least as big as twice the value of 3, so we return -1.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>nums</code> will have a length in the range <code>[1, 50]</code>.</li>\r\n\t<li>Every <code>nums[i]</code> will be an integer in the range <code>[0, 99]</code>.</li>\r\n</ol>\r\n\r\n<p>&nbsp;</p>\r\n",
    "tags": "Array",
    "difficulty": 1,
    "frontend_article_id": 747,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-linear-scan-accepted\">Approach #1: Linear Scan [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-linear-scan-accepted\">Approach #1: Linear Scan [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Scan through the array to find the unique largest element <code>m</code>, keeping track of it's index <code>maxIndex</code>.</p> \n  <p>Scan through the array again. If we find some <code>x != m</code> with <code>m &lt; 2*x</code>, we should return <code>-1</code>.</p> \n  <p>Otherwise, we should return <code>maxIndex</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/j3xuZ4yh/shared\" frameborder=\"0\" width=\"100%\" height=\"293\" name=\"j3xuZ4yh\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script> where <script type=\"math/tex; mode=display\">N</script> is the length of <code>nums</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>, the space used by our <code>int</code> variables.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 746,
    "article_live": true,
    "article_slug": "min-cost-climbing-stairs",
    "title": "Min Cost Climbing Stairs",
    "title_slug": "min-cost-climbing-stairs",
    "content": "<p>\r\nOn a staircase, the <code>i</code>-th step has some non-negative cost <code>cost[i]</code> assigned (0 indexed).\r\n</p><p>\r\nOnce you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> cost = [10, 15, 20]\r\n<b>Output:</b> 15\r\n<b>Explanation:</b> Cheapest is start on cost[1], pay that cost and go to the top.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]\r\n<b>Output:</b> 6\r\n<b>Explanation:</b> Cheapest is start on cost[0], and only step on 1s, skipping cost[3].\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li><code>cost</code> will have a length in the range <code>[2, 1000]</code>.</li>\r\n<li>Every <code>cost[i]</code> will be an integer in the range <code>[0, 999]</code>.</li>\r\n</ol>\r\n</p>",
    "tags": "Array, Dynamic Programming",
    "difficulty": 1,
    "frontend_article_id": 746,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-dynamic-programming-accepted\">Approach #1: Dynamic Programming [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-dynamic-programming-accepted\">Approach #1: Dynamic Programming [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>There is a clear recursion available: the final cost <code>f[i]</code> to climb the staircase from some step <code>i</code> is <code>f[i] = cost[i] + min(f[i+1], f[i+2])</code>. This motivates <em>dynamic programming</em>.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Let's evaluate <code>f</code> backwards in order. That way, when we are deciding what <code>f[i]</code> will be, we've already figured out <code>f[i+1]</code> and <code>f[i+2]</code>.</p> \n  <p>We can do even better than that. At the <code>i</code>-th step, let <code>f1, f2</code> be the old value of <code>f[i+1]</code>, <code>f[i+2]</code>, and update them to be the new values <code>f[i], f[i+1]</code>. We keep these updated as we iterate through <code>i</code> backwards. At the end, we want <code>min(f1, f2)</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/R8h7KgV3/shared\" frameborder=\"0\" width=\"100%\" height=\"242\" name=\"R8h7KgV3\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script> where <script type=\"math/tex; mode=display\">N</script> is the length of <code>cost</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>, the space used by <code>f1, f2</code>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 745,
    "article_live": true,
    "article_slug": "prefix-and-suffix-search",
    "title": "Prefix and Suffix Search",
    "title_slug": "prefix-and-suffix-search",
    "content": "<p>\r\nGiven many <code>words</code>, <code>words[i]</code> has weight <code>i</code>.\r\n</p><p>\r\nDesign a class <code>WordFilter</code> that supports one function, <code>WordFilter.f(String prefix, String suffix)</code>.\r\nIt will return the word with given <code>prefix</code> and <code>suffix</code> with maximum weight.  If no word exists, return -1.\r\n</p>\r\n\r\n<p><b>Examples:</b><br />\r\n<pre>\r\n<b>Input:</b>\r\nWordFilter([\"apple\"])\r\nWordFilter.f(\"a\", \"e\") // returns 0\r\nWordFilter.f(\"b\", \"\") // returns -1\r\n</pre></p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li><code>words</code> has length in range <code>[1, 15000]</code>.</li>\r\n<li>For each test case, up to <code>words.length</code> queries <code>WordFilter.f</code> may be made.</li>\r\n<li><code>words[i]</code> has length in range <code>[1, 10]</code>.</li>\r\n<li><code>prefix, suffix</code> have lengths in range <code>[0, 10]</code>.</li>\r\n<li><code>words[i]</code> and <code>prefix, suffix</code> queries consist of lowercase letters only.</li>\r\n</ol>\r\n</p>",
    "tags": "Trie",
    "difficulty": 3,
    "frontend_article_id": 745,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-trie-set-intersection-time-limit-exceeded\">Approach #1: Trie + Set Intersection [Time Limit Exceeded]</a></li> \n    <li><a href=\"#approach-2-paired-trie-accepted\">Approach #2: Paired Trie [Accepted]</a></li> \n    <li><a href=\"#approach-3-trie-of-suffix-wrapped-words-accepted\">Approach #3: Trie of Suffix Wrapped Words [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-trie-set-intersection-time-limit-exceeded\">Approach #1: Trie + Set Intersection [Time Limit Exceeded]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>We use two tries to separately find all words that match the prefix, plus all words that match the suffix. Then, we try to find the highest weight element in the intersection of these sets.</p> \n  <p>Of course, these sets could still be large, so we might TLE if we aren't careful.</p> \n  <iframe src=\"https://leetcode.com/playground/ihA9cm57/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"ihA9cm57\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(NK + Q(N+K))</script> where <script type=\"math/tex; mode=display\">N</script> is the number of words, <script type=\"math/tex; mode=display\">K</script> is the maximum length of a word, and <script type=\"math/tex; mode=display\">Q</script> is the number of queries. If we use memoization in our solution, we could produce tighter bounds for this complexity, as the complex queries are somewhat disjoint.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(NK)</script>, the size of the tries.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-paired-trie-accepted\">Approach #2: Paired Trie [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Say we are inserting the word <code>apple</code>. We could insert <code>('a', 'e'), ('p', 'l'), ('p', 'p'), ('l', 'p'), ('e', 'a')</code> into our trie. Then, if we had equal length queries like <code>prefix = \"ap\", suffix = \"le\"</code>, we could find the node <code>trie['a', 'e']['p', 'l']</code> in our trie. This seems promising.</p> \n  <p>What about queries that aren't equal? We should just insert them like normal. For example, to capture a case like <code>prefix = \"app\", suffix = \"e\"</code>, we could create nodes <code>trie['a', 'e']['p', None]['p', None]</code>.</p> \n  <p>After inserting these pairs into our trie, our searches are straightforward.</p> \n  <iframe src=\"https://leetcode.com/playground/rphE5ncp/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"rphE5ncp\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(NK^2 + QK)</script> where <script type=\"math/tex; mode=display\">N</script> is the number of words, <script type=\"math/tex; mode=display\">K</script> is the maximum length of a word, and <script type=\"math/tex; mode=display\">Q</script> is the number of queries.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(NK^2)</script>, the size of the trie.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-trie-of-suffix-wrapped-words-accepted\">Approach #3: Trie of Suffix Wrapped Words [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Consider the word <code>'apple'</code>. For each suffix of the word, we could insert that suffix, followed by <code>'#'</code>, followed by the word, all into the trie.</p> \n  <p>For example, we will insert <code>'#apple', 'e#apple', 'le#apple', 'ple#apple', 'pple#apple', 'apple#apple'</code> into the trie. Then for a query like <code>prefix = \"ap\", suffix = \"le\"</code>, we can find it by querying our trie for <code>le#ap</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/hSdRfBf4/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"hSdRfBf4\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(NK^2 + QK)</script> where <script type=\"math/tex; mode=display\">N</script> is the number of words, <script type=\"math/tex; mode=display\">K</script> is the maximum length of a word, and <script type=\"math/tex; mode=display\">Q</script> is the number of queries.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(NK^2)</script>, the size of the trie.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 744,
    "article_live": true,
    "article_slug": "find-smallest-letter-greater-than-target",
    "title": "Find Smallest Letter Greater Than Target",
    "title_slug": "find-smallest-letter-greater-than-target",
    "content": "<p>\r\nGiven a list of sorted characters <code>letters</code> containing only lowercase letters, and given a target letter <code>target</code>, find the smallest element in the list that is larger than the given target.\r\n</p><p>\r\nLetters also wrap around.  For example, if the target is <code>target = 'z'</code> and <code>letters = ['a', 'b']</code>, the answer is <code>'a'</code>.\r\n</p>\r\n\r\n<p><b>Examples:</b><br />\r\n<pre>\r\n<b>Input:</b>\r\nletters = [\"c\", \"f\", \"j\"]\r\ntarget = \"a\"\r\n<b>Output:</b> \"c\"\r\n\r\n<b>Input:</b>\r\nletters = [\"c\", \"f\", \"j\"]\r\ntarget = \"c\"\r\n<b>Output:</b> \"f\"\r\n\r\n<b>Input:</b>\r\nletters = [\"c\", \"f\", \"j\"]\r\ntarget = \"d\"\r\n<b>Output:</b> \"f\"\r\n\r\n<b>Input:</b>\r\nletters = [\"c\", \"f\", \"j\"]\r\ntarget = \"g\"\r\n<b>Output:</b> \"j\"\r\n\r\n<b>Input:</b>\r\nletters = [\"c\", \"f\", \"j\"]\r\ntarget = \"j\"\r\n<b>Output:</b> \"c\"\r\n\r\n<b>Input:</b>\r\nletters = [\"c\", \"f\", \"j\"]\r\ntarget = \"k\"\r\n<b>Output:</b> \"c\"\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li><code>letters</code> has a length in range <code>[2, 10000]</code>.</li>\r\n<li><code>letters</code> consists of lowercase letters, and contains at least 2 unique letters.</li>\r\n<li><code>target</code> is a lowercase letter.</li>\r\n</ol>\r\n</p>",
    "tags": "Binary Search",
    "difficulty": 1,
    "frontend_article_id": 744,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-record-letters-seen-accepted\">Approach #1: Record Letters Seen [Accepted]</a></li> \n    <li><a href=\"#approach-2-linear-scan-accepted\">Approach #2: Linear Scan [Accepted]</a></li> \n    <li><a href=\"#approach-3-binary-search-accepted\">Approach #3: Binary Search [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-record-letters-seen-accepted\">Approach #1: Record Letters Seen [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Let's scan through <code>letters</code> and record if we see a letter or not. We could do this with an array of size 26, or with a Set structure.</p> \n  <p>Then, for every next letter (starting with the letter that is one greater than the target), let's check if we've seen it. If we have, it must be the answer.</p> \n  <iframe src=\"https://leetcode.com/playground/auZQ7CwK/shared\" frameborder=\"0\" width=\"100%\" height=\"276\" name=\"auZQ7CwK\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>letters</code>. We scan every element of the array.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>, the maximum size of <code>seen</code>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-linear-scan-accepted\">Approach #2: Linear Scan [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Since <code>letters</code> are sorted, if we see something larger when scanning form left to right, it must be the answer. Otherwise, (since <code>letters</code> is non-empty), the answer is <code>letters[0]</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/RvMYaXpq/shared\" frameborder=\"0\" width=\"100%\" height=\"174\" name=\"RvMYaXpq\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>letters</code>. We scan every element of the array.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>, as we maintain only pointers.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-binary-search-accepted\">Approach #3: Binary Search [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Like in <em>Approach #2</em>, we want to find something larger than target in a sorted array. This is ideal for a <em>binary search</em>: Let's find the rightmost position to insert <code>target</code> into <code>letters</code> so that it remains sorted.</p> \n  <p>Our binary search (a typical one) proceeds in a number of rounds. At each round, let's maintain the <em>loop invariant</em> that the answer must be in the interval <code>[lo, hi]</code>. Let <code>mi = (lo + hi) / 2</code>. If <code>letters[mi] &lt;= target</code>, then we must insert it in the interval <code>[mi + 1, hi]</code>. Otherwise, we must insert it in the interval <code>[lo, mi]</code>.</p> \n  <p>At the end, if our insertion position says to insert <code>target</code> into the last position <code>letters.length</code>, we return <code>letters[0]</code> instead. This is what the modulo operation does.</p> \n  <iframe src=\"https://leetcode.com/playground/bQDjgxiu/shared\" frameborder=\"0\" width=\"100%\" height=\"242\" name=\"bQDjgxiu\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(\\log N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>letters</code>. We peek only at <script type=\"math/tex; mode=display\">\\log N</script> elements in the array.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>, as we maintain only pointers.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 743,
    "article_live": true,
    "article_slug": "network-delay-time",
    "title": "Network Delay Time",
    "title_slug": "network-delay-time",
    "content": "<p>\r\nThere are <code>N</code> network nodes, labelled <code>1</code> to <code>N</code>.\r\n</p><p>\r\nGiven <code>times</code>, a list of travel times as <b>directed</b> edges <code>times[i] = (u, v, w)</code>, where <code>u</code> is the source node, <code>v</code> is the target node, and <code>w</code> is the time it takes for a signal to travel from source to target.\r\n</p><p>\r\nNow, we send a signal from a certain node <code>K</code>.  How long will it take for all nodes to receive the signal?  If it is impossible, return <code>-1</code>.\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li><code>N</code> will be in the range <code>[1, 100]</code>.</li>\r\n<li><code>K</code> will be in the range <code>[1, N]</code>.</li>\r\n<li>The length of <code>times</code> will be in the range <code>[1, 6000]</code>.</li>\r\n<li>All edges <code>times[i] = (u, v, w)</code> will have <code>1 <= u, v <= N</code> and <code>1 <= w <= 100</code>.</li>\r\n</ol>\r\n</p>",
    "tags": "Heap, Depth-first Search, Breadth-first Search, Graph",
    "difficulty": 1,
    "frontend_article_id": 743,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-depth-first-search-accepted\">Approach #1: Depth-First Search [Accepted]</a></li> \n    <li><a href=\"#approach-2-dijkstras-algorithm-accepted\">Approach #2: Dijkstra's Algorithm [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-depth-first-search-accepted\">Approach #1: Depth-First Search [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Let's record the time <code>dist[node]</code> when the signal reaches the node. If some signal arrived earlier, we don't need to broadcast it anymore. Otherwise, we should broadcast the signal.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>We'll maintain <code>dist[node]</code>, the earliest that we arrived at each <code>node</code>. When visiting a <code>node</code> while <code>elapsed</code> time has elapsed, if this is the currently-fastest signal at this node, let's broadcast signals from this node.</p> \n  <p>To speed things up, at each visited node we'll consider signals exiting the node that are faster first, by sorting the edges.</p> \n  <iframe src=\"https://leetcode.com/playground/YadsYraY/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"YadsYraY\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^N + E \\log E)</script> where <script type=\"math/tex; mode=display\">E</script> is the length of <code>times</code>. We can only fully visit each node up to <script type=\"math/tex; mode=display\">N-1</script> times, one per each other node. Plus, we have to explore every edge and sort them. Sorting each small bucket of outgoing edges is bounded by sorting all of them, because of repeated use of the inequality <script type=\"math/tex; mode=display\">x \\log x + y \\log y \\leq (x+y) \\log (x+y)</script>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N + E)</script>, the size of the graph (<script type=\"math/tex; mode=display\">O(E)</script>), plus the size of the implicit call stack in our DFS (<script type=\"math/tex; mode=display\">O(N)</script>).</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-dijkstras-algorithm-accepted\">Approach #2: Dijkstra's Algorithm [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>We use <em>Dijkstra's algorithm</em> to find the shortest path from our source to all targets. This is a textbook algorithm, refer to <a href=\"https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\">this link</a> for more details.</p> \n  <p>Dijkstra's algorithm is based on repeatedly making the candidate move that has the least distance travelled.</p> \n  <p>In our implementations below, we showcase both <script type=\"math/tex; mode=display\">O(N^2)</script> (basic) and <script type=\"math/tex; mode=display\">O(N \\log N)</script> (heap) approaches.</p> \n  <p><em>Basic Implementation</em> <iframe src=\"https://leetcode.com/playground/HxrhmhUo/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"HxrhmhUo\"></iframe></p> \n  <p><em>Heap Implementation</em></p> \n  <iframe src=\"https://leetcode.com/playground/FAHPcmsE/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"FAHPcmsE\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2 + E)</script>m where <script type=\"math/tex; mode=display\">E</script> is the length of <code>times</code> in the basic implementation, and <script type=\"math/tex; mode=display\">O(E \\log E)</script> in the heap implementation, as potentially every edge gets added to the heap.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N + E)</script>, the size of the graph (<script type=\"math/tex; mode=display\">O(E)</script>), plus the size of the other objects used (<script type=\"math/tex; mode=display\">O(N)</script>).</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 742,
    "article_live": true,
    "article_slug": "closest-leaf-in-binary-tree",
    "title": "Closest Leaf in a Binary Tree",
    "title_slug": "closest-leaf-in-a-binary-tree",
    "tags": "Tree",
    "difficulty": 2,
    "frontend_article_id": 742,
    "article_content": ""
},
{
    "frontend_question_id": 709,
    "article_live": false,
    "title": "To Lower Case",
    "title_slug": "to-lower-case",
    "content": "<p>Implement function ToLowerCase() that has a string parameter str, and returns the same string in lowercase.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">&quot;Hello&quot;</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">&quot;hello&quot;</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">&quot;here&quot;</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">&quot;here&quot;</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-3-1\">&quot;LOVELY&quot;</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">&quot;lovely&quot;</span>\r\n</pre>\r\n</div>\r\n</div>\r\n</div>\r\n",
    "tags": "String",
    "difficulty": 1,
    "frontend_article_id": 709
},
{
    "frontend_question_id": 741,
    "article_live": true,
    "article_slug": "cherry-pickup",
    "title": "Cherry Pickup",
    "title_slug": "cherry-pickup",
    "content": "<p>\r\nIn a N x N <code>grid</code> representing a field of cherries, each cell is one of three possible integers.\r\n</p><p>\r\n<li>0 means the cell is empty, so you can pass through;</li>\r\n<li>1 means the cell contains a cherry, that you can pick up and pass through;</li>\r\n<li>-1 means the cell contains a thorn that blocks your way.</li>\r\n</p><p>\r\nYour task is to collect maximum number of cherries possible by following the rules below:\r\n</p><p>\r\n<li>Starting at the position (0, 0) and reaching (N-1, N-1) by moving right or down through valid path cells (cells with value 0 or 1);</li>\r\n<li>After reaching (N-1, N-1), returning to (0, 0) by moving left or up through valid path cells;</li>\r\n<li>When passing through a path cell containing a cherry, you pick it up and the cell becomes an empty cell (0);</li>\r\n<li>If there is no valid path between (0, 0) and (N-1, N-1), then no cherries can be collected.</li>\r\n</p><p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> grid =\r\n[[0, 1, -1],\r\n [1, 0, -1],\r\n [1, 1,  1]]\r\n<b>Output:</b> 5\r\n<b>Explanation:</b> \r\nThe player started at (0, 0) and went down, down, right right to reach (2, 2).\r\n4 cherries were picked up during this single trip, and the matrix becomes [[0,1,-1],[0,0,-1],[0,0,0]].\r\nThen, the player went left, up, up, left to return home, picking up one more cherry.\r\nThe total number of cherries picked up is 5, and this is the maximum possible.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\n<li><code>grid</code> is an <code>N</code> by <code>N</code> 2D array, with <code>1 <= N <= 50</code>.</li>\r\n<li>Each <code>grid[i][j]</code> is an integer in the set <code>{-1, 0, 1}</code>.</li>\r\n<li>It is guaranteed that grid[0][0] and grid[N-1][N-1] are not -1.<li>\r\n</p>",
    "tags": "Dynamic Programming",
    "difficulty": 3,
    "frontend_article_id": 741,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-greedy-wrong-answer\">Approach #1: Greedy [Wrong Answer]</a></li> \n    <li><a href=\"#approach-2-dynamic-programming-top-down-accepted\">Approach #2: Dynamic Programming (Top Down) [Accepted]</a></li> \n    <li><a href=\"#approach-3-dynamic-programming-bottom-up-accepted\">Approach #3: Dynamic Programming (Bottom Up) [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-greedy-wrong-answer\">Approach #1: Greedy [Wrong Answer]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Let's find the most cherries we can pick up with one path, pick them up, then find the most cherries we can pick up with a second path on the remaining field.</p> \n  <p>Though a counter example might be hard to think of, this approach fails to find the best answer to this case:</p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"mi\">11100</span>\n<span class=\"mo\">00101</span>\n<span class=\"mi\">10100</span>\n<span class=\"mo\">00100</span>\n<span class=\"mo\">00111</span>\n</pre>\n  </div> \n  <p><strong>Algorithm</strong></p> \n  <p>We can use dynamic programming to find the most number of cherries <code>dp[i][j]</code> that can be picked up from any location <code>(i, j)</code> to the bottom right corner. This is a classic question very similar to <a href=\"https://leetcode.com/problems/minimum-path-sum/description/\">Minimum Path Sum</a>, refer to the link if you are not familiar with this type of question.</p> \n  <p>After, we can find an first path that maximizes the number of cherries taken by using our completed <code>dp</code> as an oracle for deciding where to move. We'll choose the move that allows us to pick up more cherries (based on comparing <code>dp[i+1][j]</code> and <code>dp[i][j+1]</code>).</p> \n  <p>After taking the cherries from that path (and removing it from the grid), we'll take the cherries again.</p> \n  <iframe src=\"https://leetcode.com/playground/UVn8oEww/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"UVn8oEww\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>grid</code>. Our dynamic programming consists of two for-loops of length <code>N</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, the size of <code>dp</code>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-dynamic-programming-top-down-accepted\">Approach #2: Dynamic Programming (Top Down) [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Instead of walking from end to beginning, let's reverse the second leg of the path, so we are only considering two paths from the beginning to the end.</p> \n  <p>Notice after <code>t</code> steps, each position <code>(r, c)</code> we could be, is on the line <code>r + c = t</code>. So if we have two people at positions <code>(r1, c1)</code> and <code>(r2, c2)</code>, then <code>r2 = r1 + c1 - c2</code>. That means the variables <code>r1, c1, c2</code> uniquely determine 2 people who have walked the same <code>r1 + c1</code> number of steps. This sets us up for dynamic programming quite nicely.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Let <code>dp[r1][c1][c2]</code> be the most number of cherries obtained by two people starting at <code>(r1, c1)</code> and <code>(r2, c2)</code> and walking towards <code>(N-1, N-1)</code> picking up cherries, where <code>r2 = r1+c1-c2</code>.</p> \n  <p>If <code>grid[r1][c1]</code> and <code>grid[r2][c2]</code> are not thorns, then the value of <code>dp[r1][c1][c2]</code> is <code>(grid[r1][c1] + grid[r2][c2])</code>, plus the maximum of <code>dp[r1+1][c1][c2]</code>, <code>dp[r1][c1+1][c2]</code>, <code>dp[r1+1][c1][c2+1]</code>, <code>dp[r1][c1+1][c2+1]</code> as appropriate. We should also be careful to not double count in case <code>(r1, c1) == (r2, c2)</code>.</p> \n  <p>Why did we say it was the maximum of <code>dp[r+1][c1][c2]</code> etc.? It corresponds to the 4 possibilities for person 1 and 2 moving down and right:</p> \n  <ul> \n   <li>Person 1 down and person 2 down: <code>dp[r1+1][c1][c2]</code>;</li> \n   <li>Person 1 right and person 2 down: <code>dp[r1][c1+1][c2]</code>;</li> \n   <li>Person 1 down and person 2 right: <code>dp[r1+1][c1][c2+1]</code>;</li> \n   <li>Person 1 right and person 2 right: <code>dp[r1][c1+1][c2+1]</code>;</li> \n  </ul> \n  <iframe src=\"https://leetcode.com/playground/BbN9rraL/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"BbN9rraL\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^3)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>grid</code>. Our dynamic programming has <script type=\"math/tex; mode=display\">O(N^3)</script> states.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N^3)</script>, the size of <code>memo</code>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-dynamic-programming-bottom-up-accepted\">Approach #3: Dynamic Programming (Bottom Up) [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Like in <em>Approach #2</em>, we have the idea of dynamic programming.</p> \n  <p>Say <code>r1 + c1 = t</code> is the <code>t</code>-th layer. Since our recursion only references the next layer, we only need to keep two layers in memory at a time.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>At time <code>t</code>, let <code>dp[c1][c2]</code> be the most cherries that we can pick up for two people going from <code>(0, 0)</code> to <code>(r1, c1)</code> and <code>(0, 0)</code> to <code>(r2, c2)</code>, where <code>r1 = t-c1, r2 = t-c2</code>. Our dynamic program proceeds similarly to <em>Approach #2</em>.</p> \n  <iframe src=\"https://leetcode.com/playground/SAAR75Ui/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"SAAR75Ui\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^3)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>grid</code>. We have three for-loops of size <script type=\"math/tex; mode=display\">O(N)</script>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, the sizes of <code>dp</code> and <code>dp2</code>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>. Solution 3 inspired by <a href=\"https://leetcode.com/contest/weekly-contest-61/ranking\">@uwi</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 740,
    "article_live": true,
    "article_slug": "delete-and-earn",
    "title": "Delete and Earn",
    "title_slug": "delete-and-earn",
    "content": "<p>\r\nGiven an array <code>nums</code> of integers, you can perform operations on the array.\r\n</p><p>\r\nIn each operation, you pick any <code>nums[i]</code> and delete it to earn <code>nums[i]</code> points.  After, you must delete <b>every</b> element equal to <code>nums[i] - 1</code> or <code>nums[i] + 1</code>.\r\n</p><p>\r\nYou start with 0 points.  Return the maximum number of points you can earn by applying such operations.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> nums = [3, 4, 2]\r\n<b>Output:</b> 6\r\n<b>Explanation:</b> \r\nDelete 4 to earn 4 points, consequently 3 is also deleted.\r\nThen, delete 2 to earn 2 points. 6 total points are earned.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> nums = [2, 2, 3, 3, 3, 4]\r\n<b>Output:</b> 9\r\n<b>Explanation:</b> \r\nDelete 3 to earn 3 points, deleting both 2's and the 4.\r\nThen, delete 3 again to earn 3 points, and 3 again to earn 3 points.\r\n9 total points are earned.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\n<li>The length of <code>nums</code> is at most <code>20000</code>.</li>\r\n<li>Each element <code>nums[i]</code> is an integer in the range <code>[1, 10000]</code>.</li>\r\n</p>",
    "tags": "Dynamic Programming",
    "difficulty": 2,
    "frontend_article_id": 740,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-dynamic-programming-accepted\">Approach #1: Dynamic Programming [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-dynamic-programming-accepted\">Approach #1: Dynamic Programming [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Because all numbers are positive, if we \"take\" a number (use it to score points), we might as well take all copies of it, since we've already erased all its neighbors. We could keep a count of each number so we know how many points taking a number is worth total.</p> \n  <p>Now let's investigate what happens when we add a new number <code>X</code> (plus copies) that is larger than all previous numbers. Naively, our answer would be the previous answer, plus the value of <code>X</code> - which can be solved with dynamic programming. However, this fails if our previous answer had a number taken that was adjacent to <code>X</code>.</p> \n  <p>Luckily, we can remedy this. Let's say we knew <code>using</code>, the value of our previous answer, and <code>avoid</code>, the value of our previous answer that doesn't use the previously largest value <code>prev</code>. Then we could compute new values of <code>using</code> and <code>avoid</code> appropriately.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>For each unique value <code>k</code> of <code>nums</code> in increasing order, let's maintain the correct values of <code>avoid</code> and <code>using</code>, which represent the answer if we don't take or take <code>k</code> respectively.</p> \n  <p>If the new value <code>k</code> is adjacent to the previously largest value <code>prev</code>, then the answer if we must take <code>k</code> is <code>(the point value of k) + avoid</code>, while the answer if we must not take <code>k</code> is <code>max(avoid, using)</code>. Similarly, if <code>k</code> is not adjacent to <code>prev</code>, the answer if we must take <code>k</code> is <code>(the point value of k) + max(avoid, using)</code>, and the answer if we must not take <code>k</code> is <code>max(avoid, using)</code>.</p> \n  <p>At the end, the best answer may or may not use the largest value in <code>nums</code>, so we return <code>max(avoid, using)</code>.</p> \n  <p>Our demonstrated solutions showcase two different kinds of sorts: a library one, and a radix sort. For each language, the other kind of solution can be done without much difficulty, by using an array (Python) or HashMap (Java) respectively.</p> \n  <iframe src=\"https://leetcode.com/playground/TBKVkiLD/shared\" frameborder=\"0\" width=\"100%\" height=\"395\" name=\"TBKVkiLD\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity (Python): <script type=\"math/tex; mode=display\">O(N \\log N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>nums</code>. We make a single pass through the sorted keys of <script type=\"math/tex; mode=display\">N</script>, and the complexity is dominated by the sorting step.</p> </li> \n   <li> <p>Space Complexity (Python): <script type=\"math/tex; mode=display\">O(N)</script>, the size of our <code>count</code>.</p> </li> \n   <li> <p>Time Complexity (Java): We performed a radix sort instead, so our complexity is <script type=\"math/tex; mode=display\">O(N+W)</script> where <script type=\"math/tex; mode=display\">W</script> is the range of allowable values for <code>nums[i]</code>.</p> </li> \n   <li> <p>Space Complexity (Java): <script type=\"math/tex; mode=display\">O(W)</script>, the size of our <code>count</code>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 739,
    "article_live": true,
    "article_slug": "daily-temperatures",
    "title": "Daily Temperatures",
    "title_slug": "daily-temperatures",
    "content": "<p>\r\nGiven a list of daily temperatures <code>T</code>, return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature.  If there is no future day for which this is possible, put <code>0</code> instead.\r\n</p><p>\r\nFor example, given the list of temperatures <code>T = [73, 74, 75, 71, 69, 72, 76, 73]</code>, your output should be <code>[1, 1, 4, 2, 1, 1, 0, 0]</code>.\r\n</p>\r\n\r\n<p><b>Note:</b>\r\nThe length of <code>temperatures</code> will be in the range <code>[1, 30000]</code>.\r\nEach temperature will be an integer in the range <code>[30, 100]</code>.\r\n</p>",
    "tags": "Hash Table, Stack",
    "difficulty": 2,
    "frontend_article_id": 739,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-next-array-accepted\">Approach #1: Next Array [Accepted]</a></li> \n    <li><a href=\"#approach-2-stack-accepted\">Approach #2: Stack [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-next-array-accepted\">Approach #1: Next Array [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>The problem statement asks us to find the next occurrence of a warmer temperature. Because temperatures can only be in <code>[30, 100]</code>, if the temperature right now is say, <code>T[i] = 50</code>, we only need to check for the next occurrence of <code>51</code>, <code>52</code>, ..., <code>100</code> and take the one that occurs soonest.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Let's process each <code>i</code> in reverse (decreasing order). At each <code>T[i]</code>, to know when the next occurrence of say, temperature <code>100</code> is, we should just remember the last one we've seen, <code>next[100]</code>.</p> \n  <p>Then, the first occurrence of a warmer value occurs at <code>warmer_index</code>, the minimum of <code>next[T[i]+1], next[T[i]+2], ..., next[100]</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/zXoveQ5r/shared\" frameborder=\"0\" width=\"100%\" height=\"361\" name=\"zXoveQ5r\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(NW)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>T</code> and <script type=\"math/tex; mode=display\">W</script> is the number of allowed values for <code>T[i]</code>. Since <script type=\"math/tex; mode=display\">W = 71</script>, we can consider this complexity <script type=\"math/tex; mode=display\">O(N)</script>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N + W)</script>, the size of the answer and the next array.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-stack-accepted\">Approach #2: Stack [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Consider trying to find the next warmer occurrence at <code>T[i]</code>. What information (about <code>T[j]</code> for <code>j &gt; i</code>) must we remember?</p> \n  <p>Say we are trying to find <code>T[0]</code>. If we remembered <code>T[10] = 50</code>, knowing <code>T[20] = 50</code> wouldn't help us, as any <code>T[i]</code> that has its next warmer ocurrence at <code>T[20]</code> would have it at <code>T[10]</code> instead. However, <code>T[20] = 100</code> would help us, since if <code>T[0]</code> were <code>80</code>, then <code>T[20]</code> might be its next warmest occurrence, while <code>T[10]</code> couldn't.</p> \n  <p>Thus, we should remember a list of indices representing a strictly increasing list of temperatures. For example, <code>[10, 20, 30]</code> corresponding to temperatures <code>[50, 80, 100]</code>. When we get a new temperature like <code>T[i] = 90</code>, we will have <code>[5, 30]</code> as our list of indices (corresponding to temperatures <code>[90, 100]</code>). The most basic structure that will satisfy our requirements is a <em>stack</em>, where the top of the stack is the first value in the list, and so on.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>As in <em>Approach #1</em>, process indices <code>i</code> in descending order. We'll keep a <code>stack</code> of indices such that <code>T[stack[-1]] &lt; T[stack[-2]] &lt; ...</code>, where <code>stack[-1]</code> is the top of the stack, <code>stack[-2]</code> is second from the top, and so on; and where <code>stack[-1] &gt; stack[-2] &gt; ...</code>; and we will maintain this invariant as we process each temperature.</p> \n  <p>After, it is easy to know the next occurrence of a warmer temperature: it's simply the top index in the stack.</p> \n  <p>Here is a worked example of the contents of the <code>stack</code> as we work through <code>T = [73, 74, 75, 71, 69, 72, 76, 73]</code> in reverse order, at the end of the loop (after we add <code>T[i]</code>). For clarity, <code>stack</code> only contains indices <code>i</code>, but we will write the value of <code>T[i]</code> beside it in brackets, such as <code>0 (73)</code>.</p> \n  <ul> \n   <li>When <code>i = 7</code>, <code>stack = [7 (73)]</code>. <code>ans[i] = 0</code>.</li> \n   <li>When <code>i = 6</code>, <code>stack = [6 (76)]</code>. <code>ans[i] = 0</code>.</li> \n   <li>When <code>i = 5</code>, <code>stack = [5 (72), 6 (76)]</code>. <code>ans[i] = 1</code>.</li> \n   <li>When <code>i = 4</code>, <code>stack = [4 (69), 5 (72), 6 (76)]</code>. <code>ans[i] = 1</code>.</li> \n   <li>When <code>i = 3</code>, <code>stack = [3 (71), 5 (72), 6 (76)]</code>. <code>ans[i] = 2</code>.</li> \n   <li>When <code>i = 2</code>, <code>stack = [2 (75), 6 (76)]</code>. <code>ans[i] = 4</code>.</li> \n   <li>When <code>i = 1</code>, <code>stack = [1 (74), 2 (75), 6 (76)]</code>. <code>ans[i] = 1</code>.</li> \n   <li>When <code>i = 0</code>, <code>stack = [0 (73), 1 (74), 2 (75), 6 (76)]</code>. <code>ans[i] = 1</code>.</li> \n  </ul> \n  <iframe src=\"https://leetcode.com/playground/GrKNCrcf/shared\" frameborder=\"0\" width=\"100%\" height=\"259\" name=\"GrKNCrcf\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>T</code> and <script type=\"math/tex; mode=display\">W</script> is the number of allowed values for <code>T[i]</code>. Each index gets pushed and popped at most once from the stack.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(W)</script>. The size of the stack is bounded as it represents strictly increasing temperatures.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 738,
    "article_live": true,
    "article_slug": "monotone-increasing-digits",
    "title": "Monotone Increasing Digits",
    "title_slug": "monotone-increasing-digits",
    "content": "<p>\r\nGiven a non-negative integer <code>N</code>, find the largest number that is less than or equal to <code>N</code> with monotone increasing digits.\r\n</p><p>\r\n(Recall that an integer has <i>monotone increasing digits</i> if and only if each pair of adjacent digits <code>x</code> and <code>y</code> satisfy <code>x <= y</code>.)\r\n</p><p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> N = 10\r\n<b>Output:</b> 9\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> N = 1234\r\n<b>Output:</b> 1234\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 3:</b><br />\r\n<pre>\r\n<b>Input:</b> N = 332\r\n<b>Output:</b> 299\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\n<code>N</code> is an integer in the range <code>[0, 10^9]</code>.\r\n</p>",
    "tags": "Greedy",
    "difficulty": 2,
    "frontend_article_id": 738,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-greedy-accepted\">Approach #1: Greedy [Accepted]</a></li> \n    <li><a href=\"#approach-2-truncate-after-cliff-accepted\">Approach #2: Truncate After Cliff [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-greedy-accepted\">Approach #1: Greedy [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Let's construct the answer digit by digit.</p> \n  <p>If the current answer is say, <code>123</code>, and the next digit is <code>5</code>, then the answer must be at least <code>123555...5</code>, since the digits in the answer must be monotonically increasing. If this is larger than <code>N</code>, then it's impossible.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>For each digit of <code>N</code>, let's build the next digit of our answer <code>ans</code>. We'll find the smallest possible digit <code>d</code> such that <code>ans + (d repeating) &gt; N</code> when comparing by string; that means <code>d-1</code> must have satisfied <code>ans + (d-1 repeating) &lt;= N</code>, and so we'll add <code>d-1</code> to our answer. If we don't find such a digit, we can add a <code>9</code> instead.</p> \n  <iframe src=\"https://leetcode.com/playground/FBLCwPuk/shared\" frameborder=\"0\" width=\"100%\" height=\"429\" name=\"FBLCwPuk\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(D^2)</script>, where <script type=\"math/tex; mode=display\">D \\approx \\log N</script> is the number of digits in <script type=\"math/tex; mode=display\">N</script>. We do <script type=\"math/tex; mode=display\">O(D)</script> work building and comparing each candidate, and we do this <script type=\"math/tex; mode=display\">O(D)</script> times.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(D)</script>, the size of the answer and the temporary string we are comparing.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-truncate-after-cliff-accepted\">Approach #2: Truncate After Cliff [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>One initial thought that comes to mind is we can always have a candidate answer of <code>d999...9</code> (a digit <code>0 &lt;= d &lt;= 9</code> followed by some number of nines.) For example if <code>N = 432543654</code>, we could always have an answer of at least <code>399999999</code>.</p> \n  <p>We can do better. For example, when the number is <code>123454321</code>, we could have a candidate of <code>123449999</code>. It seems like a decent strategy is to take a monotone increasing prefix of <code>N</code>, then decrease the number before the \"cliff\" (the index where adjacent digits decrease for the first time) if it exists, and replace the rest of the characters with <code>9</code>s.</p> \n  <p>When does that strategy fail? If <code>N = 333222</code>, then our strategy would give us the candidate answer of <code>332999</code> - but this isn't monotone increasing. However, since we are looking at all indexes before the original first occurrence of a cliff, the only place where a cliff could exist, is next to where we just decremented a digit.</p> \n  <p>Thus, we can repair our strategy, by successfully morphing our answer <code>332999 -&gt; 329999 -&gt; 299999</code> with a linear scan.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>We'll find the first cliff <code>S[i-1] &gt; S[i]</code>. Then, while the cliff exists, we'll decrement the appropriate digit and move <code>i</code> back. Finally, we'll make the rest of the digits <code>9</code>s and return our work.</p> \n  <p>We can prove our algorithm is correct because every time we encounter a cliff, the digit we decrement has to decrease by at least 1. Then, the largest possible selection for the rest of the digits is all nines, which is always going to be monotone increasing with respect to the other digits occurring earlier in the number.</p> \n  <iframe src=\"https://leetcode.com/playground/yeDAMaRm/shared\" frameborder=\"0\" width=\"100%\" height=\"242\" name=\"yeDAMaRm\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(D)</script>, where <script type=\"math/tex; mode=display\">D \\approx \\log N</script> is the number of digits in <script type=\"math/tex; mode=display\">N</script>. Each step in the algorithm is a linear scan of the digits.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(D)</script>, the size of the answer.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 737,
    "article_live": true,
    "article_slug": "sentence-similarity-ii",
    "title": "Sentence Similarity II",
    "title_slug": "sentence-similarity-ii",
    "tags": "Depth-first Search, Union Find",
    "difficulty": 2,
    "frontend_article_id": 737,
    "article_content": ""
},
{
    "frontend_question_id": 736,
    "article_live": true,
    "article_slug": "parse-lisp-expression",
    "title": "Parse Lisp Expression",
    "title_slug": "parse-lisp-expression",
    "content": "<p>\r\nYou are given a string <code>expression</code> representing a Lisp-like expression to return the integer value of.\r\n</p><p>\r\nThe syntax for these expressions is given as follows.\r\n</p><p>\r\n<li>An expression is either an integer, a let-expression, an add-expression, a mult-expression, or an assigned variable.  Expressions always evaluate to a single integer.</li>\r\n</p><p>\r\n<li>(An integer could be positive or negative.)</li>\r\n</p><p>\r\n<li>A let-expression takes the form <code>(let v1 e1 v2 e2 ... vn en expr)</code>, where <code>let</code> is always the string <code>\"let\"</code>, then there are 1 or more pairs of alternating variables and expressions, meaning that the first variable <code>v1</code> is assigned the value of the expression <code>e1</code>, the second variable <code>v2</code> is assigned the value of the expression <code>e2</code>, and so on <b>sequentially</b>; and then the value of this let-expression is the value of the expression <code>expr</code>.</li>\r\n</p><p>\r\n<li>An add-expression takes the form <code>(add e1 e2)</code> where <code>add</code> is always the string <code>\"add\"</code>, there are always two expressions <code>e1, e2</code>, and this expression evaluates to the addition of the evaluation of <code>e1</code> and the evaluation of <code>e2</code>.</li>\r\n</p><p>\r\n<li>A mult-expression takes the form <code>(mult e1 e2)</code> where <code>mult</code> is always the string <code>\"mult\"</code>, there are always two expressions <code>e1, e2</code>, and this expression evaluates to the multiplication of the evaluation of <code>e1</code> and the evaluation of <code>e2</code>.</li>\r\n</p><p>\r\n<li>For the purposes of this question, we will use a smaller subset of variable names.  A variable starts with a lowercase letter, then zero or more lowercase letters or digits.  Additionally for your convenience, the names \"add\", \"let\", or \"mult\" are protected and will never be used as variable names.</li>\r\n</p><p>\r\n<li>Finally, there is the concept of scope.  When an expression of a variable name is evaluated, <b>within the context of that evaluation</b>, the innermost scope (in terms of parentheses) is checked first for the value of that variable, and then outer scopes are checked sequentially.  It is guaranteed that every expression is legal.  Please see the examples for more details on scope.</li>\r\n</p>\r\n\r\n<p><b>Evaluation Examples:</b><br />\r\n<pre>\r\n<b>Input:</b> (add 1 2)\r\n<b>Output:</b> 3\r\n\r\n<b>Input:</b> (mult 3 (add 2 3))\r\n<b>Output:</b> 15\r\n\r\n<b>Input:</b> (let x 2 (mult x 5))\r\n<b>Output:</b> 10\r\n\r\n<b>Input:</b> (let x 2 (mult x (let x 3 y 4 (add x y))))\r\n<b>Output:</b> 14\r\n<b>Explanation:</b> In the expression (add x y), when checking for the value of the variable x,\r\nwe check from the innermost scope to the outermost in the context of the variable we are trying to evaluate.\r\nSince x = 3 is found first, the value of x is 3.\r\n\r\n<b>Input:</b> (let x 3 x 2 x)\r\n<b>Output:</b> 2\r\n<b>Explanation:</b> Assignment in let statements is processed sequentially.\r\n\r\n<b>Input:</b> (let x 1 y 2 x (add x y) (add x y))\r\n<b>Output:</b> 5\r\n<b>Explanation:</b> The first (add x y) evaluates as 3, and is assigned to x.\r\nThe second (add x y) evaluates as 3+2 = 5.\r\n\r\n<b>Input:</b> (let x 2 (add (let x 3 (let x 4 x)) x))\r\n<b>Output:</b> 6\r\n<b>Explanation:</b> Even though (let x 4 x) has a deeper scope, it is outside the context\r\nof the final x in the add-expression.  That final x will equal 2.\r\n\r\n<b>Input:</b> (let a1 3 b2 (add a1 1) b2) \r\n<b>Output</b> 4\r\n<b>Explanation:</b> Variable names can contain digits after the first character.\r\n\r\n</pre>\r\n\r\n<p><b>Note:</b>\r\n<li>The given string <code>expression</code> is well formatted: There are no leading or trailing spaces, there is only a single space separating different components of the string, and no space between adjacent parentheses.  The expression is guaranteed to be legal and evaluate to an integer.</li>\r\n<li>The length of <code>expression</code> is at most 2000.  (It is also non-empty, as that would not be a legal expression.)</li>\r\n<li>The answer and all intermediate calculations of that answer are guaranteed to fit in a 32-bit integer.</li>\r\n</p>",
    "tags": "String",
    "difficulty": 3,
    "frontend_article_id": 736,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-recursive-parsing-accepted\">Approach #1: Recursive Parsing [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-recursive-parsing-accepted\">Approach #1: Recursive Parsing [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>This question is relatively straightforward in terms of the idea of the solution, but presents substantial difficulties in the implementation.</p> \n  <p>Expressions may involve the evaluation of other expressions, which motivates a recursive approach.</p> \n  <p>One difficulty is managing the correct scope of the variables. We can use a stack of hashmaps. As we enter an inner scope defined by parentheses, we need to add that scope to our stack, and when we exit, we need to pop that scope off.</p> \n  <p>Our main <code>evaluate</code> function will go through each case of what form the <code>expression</code> could take.</p> \n  <ul> \n   <li> <p>If the expression starts with a digit or '-', it's an integer: return it.</p> </li> \n   <li> <p>If the expression starts with a letter, it's a variable. Recall it by checking the current scope in reverse order.</p> </li> \n   <li> <p>Otherwise, group the tokens (variables or expressions) within this expression by counting the \"balance\" <code>bal</code> of the occurrences of <code>'('</code> minus the number of occurrences of <code>')'</code>. When the balance is zero, we have ended a token. For example, <code>(add 1 (add 2 3))</code> should have tokens <code>'1'</code> and <code>'(add 2 3)'</code>.</p> </li> \n   <li> <p>For add and mult expressions, evaluate each token and return the addition or multiplication of them.</p> </li> \n   <li> <p>For let expressions, evaluate each expression sequentially and assign it to the variable in the current scope, then return the evaluation of the final expression.</p> </li> \n  </ul> \n  <iframe src=\"https://leetcode.com/playground/NPtxmW53/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"NPtxmW53\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>expression</code>. Each expression is evaluated once, but within that evaluation we may search the entire scope.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>. We may pass <script type=\"math/tex; mode=display\">O(N)</script> new strings to our <code>evaluate</code> function when making intermediate evaluations, each of length <script type=\"math/tex; mode=display\">O(N)</script>. With effort, we could reduce the total space complexity to <script type=\"math/tex; mode=display\">O(N)</script> with interning or passing pointers.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 735,
    "article_live": true,
    "article_slug": "asteroid-collision",
    "title": "Asteroid Collision",
    "title_slug": "asteroid-collision",
    "content": "<p>\r\nWe are given an array <code>asteroids</code> of integers representing asteroids in a row.\r\n</p><p>\r\nFor each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left).  Each asteroid moves at the same speed.\r\n</p><p>\r\nFind out the state of the asteroids after all collisions.  If two asteroids meet, the smaller one will explode.  If both are the same size, both will explode.  Two asteroids moving in the same direction will never meet.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\nasteroids = [5, 10, -5]\r\n<b>Output:</b> [5, 10]\r\n<b>Explanation:</b> \r\nThe 10 and -5 collide resulting in 10.  The 5 and 10 never collide.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\nasteroids = [8, -8]\r\n<b>Output:</b> []\r\n<b>Explanation:</b> \r\nThe 8 and -8 collide exploding each other.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 3:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\nasteroids = [10, 2, -5]\r\n<b>Output:</b> [10]\r\n<b>Explanation:</b> \r\nThe 2 and -5 collide resulting in -5.  The 10 and -5 collide resulting in 10.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 4:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\nasteroids = [-2, -1, 1, 2]\r\n<b>Output:</b> [-2, -1, 1, 2]\r\n<b>Explanation:</b> \r\nThe -2 and -1 are moving left, while the 1 and 2 are moving right.\r\nAsteroids moving the same direction never meet, so no asteroids will meet each other.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\n<li>The length of <code>asteroids</code> will be at most <code>10000</code>.</li>\r\n<li>Each asteroid will be a non-zero integer in the range <code>[-1000, 1000].</code>.</li>\r\n</p>",
    "tags": "Stack",
    "difficulty": 2,
    "frontend_article_id": 735,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-stack-accepted\">Approach #1: Stack [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-stack-accepted\">Approach #1: Stack [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>A row of asteroids is stable if no further collisions will occur. After adding a new asteroid to the right, some more collisions may happen before it becomes stable again, and all of those collisions (if they happen) must occur right to left. This is the perfect situation for using a <em>stack</em>.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Say we have our answer as a stack with rightmost asteroid <code>top</code>, and a <code>new</code> asteroid comes in. If <code>new</code> is moving right (<code>new &gt; 0</code>), or if <code>top</code> is moving left (<code>top &lt; 0</code>), no collision occurs.</p> \n  <p>Otherwise, if <code>abs(new) &lt; abs(top)</code>, then the <code>new</code> asteroid will blow up; if <code>abs(new) == abs(top)</code> then both asteroids will blow up; and if <code>abs(new) &gt; abs(top)</code>, then the <code>top</code> asteroid will blow up (and possibly more asteroids will, so we should continue checking.)</p> \n  <iframe src=\"https://leetcode.com/playground/CyN24YU5/shared\" frameborder=\"0\" width=\"100%\" height=\"480\" name=\"CyN24YU5\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of asteroids. Our stack pushes and pops each asteroid at most once.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the size of <code>ans</code>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 734,
    "article_live": true,
    "article_slug": "sentence-similarity",
    "title": "Sentence Similarity",
    "title_slug": "sentence-similarity",
    "tags": "Hash Table",
    "difficulty": 1,
    "frontend_article_id": 734,
    "article_content": ""
},
{
    "frontend_question_id": 733,
    "article_live": true,
    "article_slug": "flood-fill",
    "title": "Flood Fill",
    "title_slug": "flood-fill",
    "content": "<p>\r\nAn <code>image</code> is represented by a 2-D array of integers, each integer representing the pixel value of the image (from 0 to 65535).\r\n</p><p>\r\nGiven a coordinate <code>(sr, sc)</code> representing the starting pixel (row and column) of the flood fill, and a pixel value <code>newColor</code>, \"flood fill\" the image.\r\n</p><p>\r\nTo perform a \"flood fill\", consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel), and so on.  Replace the color of all of the aforementioned pixels with the newColor.\r\n</p><p>\r\nAt the end, return the modified image.\r\n</p>\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\nimage = [[1,1,1],[1,1,0],[1,0,1]]\r\nsr = 1, sc = 1, newColor = 2\r\n<b>Output:</b> [[2,2,2],[2,2,0],[2,0,1]]\r\n<b>Explanation:</b> \r\nFrom the center of the image (with position (sr, sc) = (1, 1)), all pixels connected \r\nby a path of the same color as the starting pixel are colored with the new color.\r\nNote the bottom corner is not colored 2, because it is not 4-directionally connected\r\nto the starting pixel.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\n<li>The length of <code>image</code> and <code>image[0]</code> will be in the range <code>[1, 50]</code>.</li>\r\n<li>The given starting pixel will satisfy <code>0 <= sr < image.length</code> and <code>0 <= sc < image[0].length</code>.</li>\r\n<li>The value of each color in <code>image[i][j]</code> and <code>newColor</code> will be an integer in <code>[0, 65535]</code>.</li>\r\n</p>",
    "tags": "Depth-first Search",
    "difficulty": 1,
    "frontend_article_id": 733,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-depth-first-search-accepted\">Approach #1: Depth-First Search [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-depth-first-search-accepted\">Approach #1: Depth-First Search [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>We perform the algorithm explained in the problem description: paint the starting pixels, plus adjacent pixels of the same color, and so on.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Say <code>color</code> is the color of the starting pixel. Let's floodfill the starting pixel: we change the color of that pixel to the new color, then check the 4 neighboring pixels to make sure they are valid pixels of the same <code>color</code>, and of the valid ones, we floodfill those, and so on.</p> \n  <p>We can use a function <code>dfs</code> to perform a floodfill on a target pixel.</p> \n  <iframe src=\"https://leetcode.com/playground/iMoEAq7k/shared\" frameborder=\"0\" width=\"100%\" height=\"327\" name=\"iMoEAq7k\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of pixels in the image. We might process every pixel.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the size of the implicit call stack when calling <code>dfs</code>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 732,
    "article_live": true,
    "article_slug": "my-calendar-iii",
    "title": "My Calendar III",
    "title_slug": "my-calendar-iii",
    "content": "<p>Implement a <code>MyCalendarThree</code> class to store your events. A new event can <b>always</b> be added.</p>\r\n\r\n<p>Your class will have one method, <code>book(int start, int end)</code>. Formally, this represents a booking on the half open interval <code>[start, end)</code>, the range of real numbers <code>x</code> such that <code>start &lt;= x &lt; end</code>.</p>\r\n\r\n<p>A <i>K-booking</i> happens when <b>K</b> events have some non-empty intersection (ie., there is some time that is common to all K events.)</p>\r\n\r\n<p>For each call to the method <code>MyCalendar.book</code>, return an integer <code>K</code> representing the largest integer such that there exists a <code>K</code>-booking in the calendar.</p>\r\nYour class will be called like this: <code>MyCalendarThree cal = new MyCalendarThree();</code> <code>MyCalendarThree.book(start, end)</code>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\nMyCalendarThree();\r\nMyCalendarThree.book(10, 20); // returns 1\r\nMyCalendarThree.book(50, 60); // returns 1\r\nMyCalendarThree.book(10, 40); // returns 2\r\nMyCalendarThree.book(5, 15); // returns 3\r\nMyCalendarThree.book(5, 10); // returns 3\r\nMyCalendarThree.book(25, 55); // returns 3\r\n<b>Explanation:</b> \r\nThe first two events can be booked and are disjoint, so the maximum K-booking is a 1-booking.\r\nThe third event [10, 40) intersects the first event, and the maximum K-booking is a 2-booking.\r\nThe remaining events cause the maximum K-booking to be only a 3-booking.\r\nNote that the last event locally causes a 2-booking, but the answer is still 3 because\r\neg. [10, 20), [10, 40), and [5, 15) are still triple booked.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Note:</b></p>\r\n\r\n<ul>\r\n\t<li>The number of calls to <code>MyCalendarThree.book</code> per test case will be at most <code>400</code>.</li>\r\n\t<li>In calls to <code>MyCalendarThree.book(start, end)</code>, <code>start</code> and <code>end</code> are integers in the range <code>[0, 10^9]</code>.</li>\r\n</ul>\r\n\r\n<p>&nbsp;</p>\r\n",
    "tags": "Segment Tree, Binary Search Tree",
    "difficulty": 3,
    "frontend_article_id": 732,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-boundary-count-accepted\">Approach #1: Boundary Count [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-boundary-count-accepted\">Approach #1: Boundary Count [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>When booking a new event <code>[start, end)</code>, count <code>delta[start]++</code> and <code>delta[end]--</code>. When processing the values of <code>delta</code> in sorted order of their keys, the largest such value is the answer.</p> \n  <p>In Python, we sort the set each time instead, as there is no analog to <em>TreeMap</em> available.</p> \n  <iframe src=\"https://leetcode.com/playground/yJnnXvTf/shared\" frameborder=\"0\" width=\"100%\" height=\"378\" name=\"yJnnXvTf\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of events booked. For each new event, we traverse <code>delta</code> in <script type=\"math/tex; mode=display\">O(N)</script> time. In Python, this is <script type=\"math/tex; mode=display\">O(N^2 \\log N)</script> owing to the extra sort step.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the size of <code>delta</code>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>. Solution in Approach #2 inspired by <a href=\"https://discuss.leetcode.com/topic/111276/simplified-winner-s-solution\">@cchao</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 731,
    "article_live": true,
    "article_slug": "my-calendar-ii",
    "title": "My Calendar II",
    "title_slug": "my-calendar-ii",
    "content": "<p>\r\nImplement a <code>MyCalendarTwo</code> class to store your events. A new event can be added if adding the event will not cause a <b>triple</b> booking.\r\n</p><p>\r\nYour class will have one method, <code>book(int start, int end)</code>.  Formally, this represents a booking on the half open interval <code>[start, end)</code>, the range of real numbers <code>x</code> such that <code>start <= x < end</code>.\r\n</p><p>\r\nA <i>triple booking</i> happens when <b>three</b> events have some non-empty intersection (ie., there is some time that is common to all 3 events.)\r\n</p><p>\r\nFor each call to the method <code>MyCalendar.book</code>, return <code>true</code> if the event can be added to the calendar successfully without causing a <b>triple</b> booking.  Otherwise, return <code>false</code> and do not add the event to the calendar.\r\n</p>\r\n\r\nYour class will be called like this:\r\n<code>MyCalendar cal = new MyCalendar();</code>\r\n<code>MyCalendar.book(start, end)</code>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\nMyCalendar();\r\nMyCalendar.book(10, 20); // returns true\r\nMyCalendar.book(50, 60); // returns true\r\nMyCalendar.book(10, 40); // returns true\r\nMyCalendar.book(5, 15); // returns false\r\nMyCalendar.book(5, 10); // returns true\r\nMyCalendar.book(25, 55); // returns true\r\n<b>Explanation:</b> \r\nThe first two events can be booked.  The third event can be double booked.\r\nThe fourth event (5, 15) can't be booked, because it would result in a triple booking.\r\nThe fifth event (5, 10) can be booked, as it does not use time 10 which is already double booked.\r\nThe sixth event (25, 55) can be booked, as the time in [25, 40) will be double booked with the third event;\r\nthe time [40, 50) will be single booked, and the time [50, 55) will be double booked with the second event.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\n<li>The number of calls to <code>MyCalendar.book</code> per test case will be at most <code>1000</code>.</li>\r\n<li>In calls to <code>MyCalendar.book(start, end)</code>, <code>start</code> and <code>end</code> are integers in the range <code>[0, 10^9]</code>.</li>\r\n</p>",
    "tags": "Array, Binary Search Tree",
    "difficulty": 2,
    "frontend_article_id": 731,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-brute-force-accepted\">Approach #1: Brute Force [Accepted]</a></li> \n    <li><a href=\"#approach-2-boundary-count-accepted\">Approach #2: Boundary Count [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-brute-force-accepted\">Approach #1: Brute Force [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Maintain a list of bookings and a list of double bookings. When booking a new event <code>[start, end)</code>, if it conflicts with a double booking, it will have a triple booking and be invalid. Otherwise, parts that overlap the calendar will be a double booking.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Evidently, two events <code>[s1, e1)</code> and <code>[s2, e2)</code> do <em>not</em> conflict if and only if one of them starts after the other one ends: either <code>e1 &lt;= s2</code> OR <code>e2 &lt;= s1</code>. By De Morgan's laws, this means the events conflict when <code>s1 &lt; e2</code> AND <code>s2 &lt; e1</code>.</p> \n  <p>If our event conflicts with a double booking, it's invalid. Otherwise, we add conflicts with the calendar to our double bookings, and add the event to our calendar.</p> \n  <iframe src=\"https://leetcode.com/playground/joRUVwzm/shared\" frameborder=\"0\" width=\"100%\" height=\"395\" name=\"joRUVwzm\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of events booked. For each new event, we process every previous event to decide whether the new event can be booked. This leads to <script type=\"math/tex; mode=display\">\\sum_k^N O(k) = O(N^2)</script> complexity.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the size of the <code>calendar</code>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-boundary-count-accepted\">Approach #2: Boundary Count [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>When booking a new event <code>[start, end)</code>, count <code>delta[start]++</code> and <code>delta[end]--</code>. When processing the values of <code>delta</code> in sorted order of their keys, the running sum <code>active</code> is the number of events open at that time. If the sum is 3 or more, that time is (at least) triple booked.</p> \n  <p>A Python implementation was not included for this approach because there is no analog to <em>TreeMap</em> available.</p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">class</span> <span class=\"nc\">MyCalendarTwo</span> <span class=\"o\">{</span>\n    <span class=\"n\">TreeMap</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">,</span> <span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">delta</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"nf\">MyCalendarTwo</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">delta</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">TreeMap</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">book</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">start</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">end</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">delta</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"n\">start</span><span class=\"o\">,</span> <span class=\"n\">delta</span><span class=\"o\">.</span><span class=\"na\">getOrDefault</span><span class=\"o\">(</span><span class=\"n\">start</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n        <span class=\"n\">delta</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"n\">end</span><span class=\"o\">,</span> <span class=\"n\">delta</span><span class=\"o\">.</span><span class=\"na\">getOrDefault</span><span class=\"o\">(</span><span class=\"n\">end</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n\n        <span class=\"kt\">int</span> <span class=\"n\">active</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">d</span><span class=\"o\">:</span> <span class=\"n\">delta</span><span class=\"o\">.</span><span class=\"na\">values</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n            <span class=\"n\">active</span> <span class=\"o\">+=</span> <span class=\"n\">d</span><span class=\"o\">;</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">active</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"n\">delta</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"n\">start</span><span class=\"o\">,</span> <span class=\"n\">delta</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">start</span><span class=\"o\">)</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n                <span class=\"n\">delta</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"n\">end</span><span class=\"o\">,</span> <span class=\"n\">delta</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">end</span><span class=\"o\">)</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n                <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">delta</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">start</span><span class=\"o\">)</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n                    <span class=\"n\">delta</span><span class=\"o\">.</span><span class=\"na\">remove</span><span class=\"o\">(</span><span class=\"n\">start</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of events booked. For each new event, we traverse <code>delta</code> in <script type=\"math/tex; mode=display\">O(N)</script> time.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the size of <code>delta</code>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>. Solution in Approach #2 inspired by <a href=\"https://discuss.leetcode.com/topic/111276/simplified-winner-s-solution\">@cchao</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 730,
    "article_live": true,
    "article_slug": "count-different-palindromic-subsequences",
    "title": "Count Different Palindromic Subsequences",
    "title_slug": "count-different-palindromic-subsequences",
    "content": "<p>\r\nGiven a string S, find the number of different non-empty palindromic subsequences in S, and <b>return that number modulo <code>10^9 + 7</code>.</b>\r\n</p><p>\r\nA subsequence of a string S is obtained by deleting 0 or more characters from S.\r\n</p><p>\r\nA sequence is palindromic if it is equal to the sequence reversed.\r\n</p><p>\r\nTwo sequences <code>A_1, A_2, ...</code> and <code>B_1, B_2, ...</code> are different if there is some <code>i</code> for which <code>A_i != B_i</code>.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\nS = 'bccb'\r\n<b>Output:</b> 6\r\n<b>Explanation:</b> \r\nThe 6 different non-empty palindromic subsequences are 'b', 'c', 'bb', 'cc', 'bcb', 'bccb'.\r\nNote that 'bcb' is counted only once, even though it occurs twice.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\nS = 'abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba'\r\n<b>Output:</b> 104860361\r\n<b>Explanation:</b> \r\nThere are 3104860382 different non-empty palindromic subsequences, which is 104860361 modulo 10^9 + 7.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\n<li>The length of <code>S</code> will be in the range <code>[1, 1000]</code>.</li>\r\n<li>Each character <code>S[i]</code> will be in the set <code>{'a', 'b', 'c', 'd'}</code>.</li>\r\n</p>",
    "tags": "String, Dynamic Programming",
    "difficulty": 3,
    "frontend_article_id": 730,
    "article_content": ""
},
{
    "frontend_question_id": 729,
    "article_live": true,
    "article_slug": "my-calendar-i",
    "title": "My Calendar I",
    "title_slug": "my-calendar-i",
    "content": "<p>\r\nImplement a <code>MyCalendar</code> class to store your events. A new event can be added if adding the event will not cause a double booking.\r\n</p><p>\r\nYour class will have the method, <code>book(int start, int end)</code>.  Formally, this represents a booking on the half open interval <code>[start, end)</code>, the range of real numbers <code>x</code> such that <code>start <= x < end</code>.\r\n</p><p>\r\nA <i>double booking</i> happens when two events have some non-empty intersection (ie., there is some time that is common to both events.)\r\n</p><p>\r\nFor each call to the method <code>MyCalendar.book</code>, return <code>true</code> if the event can be added to the calendar successfully without causing a double booking.  Otherwise, return <code>false</code> and do not add the event to the calendar.\r\n</p>\r\n\r\nYour class will be called like this:\r\n<code>MyCalendar cal = new MyCalendar();</code>\r\n<code>MyCalendar.book(start, end)</code>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\nMyCalendar();\r\nMyCalendar.book(10, 20); // returns true\r\nMyCalendar.book(15, 25); // returns false\r\nMyCalendar.book(20, 30); // returns true\r\n<b>Explanation:</b> \r\nThe first event can be booked.  The second can't because time 15 is already booked by another event.\r\nThe third event can be booked, as the first event takes every time less than 20, but not including 20.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\n<li>The number of calls to <code>MyCalendar.book</code> per test case will be at most <code>1000</code>.</li>\r\n<li>In calls to <code>MyCalendar.book(start, end)</code>, <code>start</code> and <code>end</code> are integers in the range <code>[0, 10^9]</code>.</li>\r\n</p>",
    "tags": "Array",
    "difficulty": 2,
    "frontend_article_id": 729,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-brute-force-accepted\">Approach #1: Brute Force [Accepted]</a></li> \n    <li><a href=\"#approach-2-balanced-tree-accepted\">Approach #2: Balanced Tree [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-brute-force-accepted\">Approach #1: Brute Force [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>When booking a new event <code>[start, end)</code>, check if every current event conflicts with the new event. If none of them do, we can book the event.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>We will maintain a list of interval <em>events</em> (not necessarily sorted). Evidently, two events <code>[s1, e1)</code> and <code>[s2, e2)</code> do <em>not</em> conflict if and only if one of them starts after the other one ends: either <code>e1 &lt;= s2</code> OR <code>e2 &lt;= s1</code>. By De Morgan's laws, this means the events conflict when <code>s1 &lt; e2</code> AND <code>s2 &lt; e1</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/RbxQb2Zj/shared\" frameborder=\"0\" width=\"100%\" height=\"310\" name=\"RbxQb2Zj\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of events booked. For each new event, we process every previous event to decide whether the new event can be booked. This leads to <script type=\"math/tex; mode=display\">\\sum_k^N O(k) = O(N^2)</script> complexity.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the size of the <code>calendar</code>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-balanced-tree-accepted\">Approach #2: Balanced Tree [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>If we maintained our events in <em>sorted</em> order, we could check whether an event could be booked in <script type=\"math/tex; mode=display\">O(\\log N)</script> time (where <script type=\"math/tex; mode=display\">N</script> is the number of events already booked) by binary searching for where the event should be placed. We would also have to insert the event in our sorted structure.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>We need a data structure that keeps elements sorted and supports fast insertion. In Java, a <code>TreeMap</code> is the perfect candidate. In Python, we can build our own binary tree structure.</p> \n  <p>For Java, we will have a <code>TreeMap</code> where the keys are the start of each interval, and the values are the ends of those intervals. When inserting the interval <code>[start, end)</code>, we check if there is a conflict on each side with neighboring intervals: we would like <code>calendar.get(prev)) &lt;= start &lt;= end &lt;= next</code> for the booking to be valid (or for <code>prev</code> or <code>next</code> to be null respectively.)</p> \n  <p>For Python, we will create a binary tree. Each node represents some interval <code>[self.start, self.end)</code> while <code>self.left, self.right</code> represents nodes that are smaller or larger than the current node.</p> \n  <iframe src=\"https://leetcode.com/playground/huRxLsMu/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"huRxLsMu\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity (Java): <script type=\"math/tex; mode=display\">O(N \\log N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of events booked. For each new event, we search that the event is legal in <script type=\"math/tex; mode=display\">O(\\log N)</script> time, then insert it in <script type=\"math/tex; mode=display\">O(1)</script> time.</p> </li> \n   <li> <p>Time Complexity (Python): <script type=\"math/tex; mode=display\">O(N^2)</script> worst case, with <script type=\"math/tex; mode=display\">O(N \\log N)</script> on random data. For each new event, we insert the event into our binary tree. As this tree may not be balanced, it may take a linear number of steps to add each event.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the size of the data structures used.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>. Solutions in Approach #2 inspired by <a href=\"https://discuss.leetcode.com/topic/111205/java-8-liner-treemap\">@shawngao</a> and <a href=\"https://discuss.leetcode.com/topic/111203/binary-search-tree-python\">@persianPanda</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 728,
    "article_live": true,
    "article_slug": "self-dividing-numbers",
    "title": "Self Dividing Numbers",
    "title_slug": "self-dividing-numbers",
    "content": "<p>\r\nA <i>self-dividing number</i> is a number that is divisible by every digit it contains.\r\n</p><p>\r\nFor example, 128 is a self-dividing number because <code>128 % 1 == 0</code>, <code>128 % 2 == 0</code>, and <code>128 % 8 == 0</code>.\r\n</p><p>\r\nAlso, a self-dividing number is not allowed to contain the digit zero.\r\n</p><p>\r\nGiven a lower and upper number bound, output a list of every possible self dividing number, including the bounds if possible.\r\n</p>\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\nleft = 1, right = 22\r\n<b>Output:</b> [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\n<li>The boundaries of each input argument are <code>1 <= left <= right <= 10000</code>.</li>\r\n</p>",
    "tags": "Math",
    "difficulty": 1,
    "frontend_article_id": 728,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-brute-force-accepted\">Approach #1: Brute Force [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-brute-force-accepted\">Approach #1: Brute Force [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>For each number in the given range, we will directly test if that number is self-dividing.</p> \n  <p>By definition, we want to test each whether each digit is non-zero and divides the number. For example, with <code>128</code>, we want to test <code>d != 0 &amp;&amp; 128 % d == 0</code> for <code>d = 1, 2, 8</code>. To do that, we need to iterate over each digit of the number.</p> \n  <p>A straightforward approach to that problem would be to convert the number into a character array (string in Python), and then convert back to integer to perform the modulo operation when checking <code>n % d == 0</code>.</p> \n  <p>We could also continually divide the number by 10 and peek at the last digit. That is shown as a variation in a comment.</p> \n  <iframe src=\"https://leetcode.com/playground/6GUVmusj/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"6GUVmusj\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(D)</script>, where <script type=\"math/tex; mode=display\">D</script> is the number of integers in the range <script type=\"math/tex; mode=display\">[L, R]</script>, and assuming <script type=\"math/tex; mode=display\">\\log(R)</script> is bounded. (In general, the complexity would be <script type=\"math/tex; mode=display\">O(D\\log R)</script>.)</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(D)</script>, the length of the answer.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 727,
    "article_live": true,
    "article_slug": "minimum-window-subsequence",
    "title": "Minimum Window Subsequence",
    "title_slug": "minimum-window-subsequence",
    "tags": "Dynamic Programming",
    "difficulty": 3,
    "frontend_article_id": 727,
    "article_content": ""
},
{
    "frontend_question_id": 726,
    "article_live": true,
    "article_slug": "number-of-atoms",
    "title": "Number of Atoms",
    "title_slug": "number-of-atoms",
    "content": "<p>Given a chemical <code>formula</code> (given as a string), return the count of each atom.\r\n</p><p>\r\nAn atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.\r\n</p><p>\r\n1 or more digits representing the count of that element may follow if the count is greater than 1.  If the count is 1, no digits will follow.  For example, H2O and H2O2 are possible, but H1O2 is impossible.\r\n</p><p>\r\nTwo formulas concatenated together produce another formula.  For example, H2O2He3Mg4 is also a formula.  \r\n</p><p>\r\nA formula placed in parentheses, and a count (optionally added) is also a formula.  For example, (H2O2) and (H2O2)3 are formulas.\r\n</p><p>\r\nGiven a formula, output the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than 1), followed by the second name (in sorted order), followed by its count (if that count is more than 1), and so on.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\nformula = \"H2O\"\r\n<b>Output:</b> \"H2O\"\r\n<b>Explanation:</b> \r\nThe count of elements are {'H': 2, 'O': 1}.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\nformula = \"Mg(OH)2\"\r\n<b>Output:</b> \"H2MgO2\"\r\n<b>Explanation:</b> \r\nThe count of elements are {'H': 2, 'Mg': 1, 'O': 2}.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 3:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\nformula = \"K4(ON(SO3)2)2\"\r\n<b>Output:</b> \"K4N2O14S4\"\r\n<b>Explanation:</b> \r\nThe count of elements are {'K': 4, 'N': 2, 'O': 14, 'S': 4}.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\n<li>All atom names consist of lowercase letters, except for the first character which is uppercase.</li>\r\n<li>The length of <code>formula</code> will be in the range <code>[1, 1000]</code>.</li>\r\n<li><code>formula</code> will only consist of letters, digits, and round parentheses, and is a valid formula as defined in the problem.</li>\r\n</p>",
    "tags": "Hash Table, Stack, Recursion",
    "difficulty": 3,
    "frontend_article_id": 726,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-recursion-accepted\">Approach #1: Recursion [Accepted]</a></li> \n    <li><a href=\"#approach-2-stack-accepted\">Approach #2: Stack [Accepted]</a></li> \n    <li><a href=\"#approach-3-regular-expressions-accepted\">Approach #3: Regular Expressions [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-recursion-accepted\">Approach #1: Recursion [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Write a function <code>parse</code> that parses the formula from index <code>i</code>, returning a map <code>count</code> from names to multiplicities (the number of times that name is recorded).</p> \n  <p>We will put <code>i</code> in global state: our <code>parse</code> function increments <code>i</code> throughout any future calls to <code>parse</code>.</p> \n  <ul> \n   <li> <p>When we see a <code>'('</code>, we will parse whatever is inside the brackets (up to the closing ending bracket) and add it to our count.</p> </li> \n   <li> <p>Otherwise, we should see an uppercase character: we will parse the rest of the letters to get the name, and add that (plus the multiplicity if there is one.)</p> </li> \n   <li> <p>At the end, if there is a final multiplicity (representing the multiplicity of a bracketed sequence), we'll multiply our answer by this.</p> </li> \n  </ul> \n  <iframe src=\"https://leetcode.com/playground/pdZAZ5dG/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"pdZAZ5dG\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of the formula. It is <script type=\"math/tex; mode=display\">O(N)</script> to parse through the formula, but each of <script type=\"math/tex; mode=display\">O(N)</script> multiplicities after a bracket may increment the count of each name in the formula (inside those brackets), leading to an <script type=\"math/tex; mode=display\">O(N^2)</script> complexity.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. We aren't recording more intermediate information than what is contained in the formula.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-stack-accepted\">Approach #2: Stack [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Instead of recursion, we can simulate the call stack by using a stack of <code>count</code>s directly.</p> \n  <iframe src=\"https://leetcode.com/playground/KLEWBfKw/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"KLEWBfKw\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time Complexity <script type=\"math/tex; mode=display\">O(N^2)</script>, and Space Complexity <script type=\"math/tex; mode=display\">O(N)</script>. The analysis is the same as <em>Approach #1</em>.</li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-regular-expressions-accepted\">Approach #3: Regular Expressions [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Whenever parsing is involved, we can use <em>regular expressions</em>, a language for defining patterns in text.</p> \n  <p>Our regular expression will be <code>\"([A-Z][a-z]*)(\\d*)|(\\()|(\\))(\\d*)\"</code>. Breaking this down by <em>capture group</em>, this is:</p> \n  <ul> \n   <li><code>([A-Z][a-z]*)</code> Match an uppercase character followed by any number of lowercase characters, then (<code>(\\d*)</code>) match any number of digits.</li> \n   <li>OR, <code>(\\()</code> match a left bracket or <code>(\\))</code> right bracket, then <code>(\\d*)</code> match any number of digits.</li> \n  </ul> \n  <p>Now we can proceed as in <em>Approach #2</em>.</p> \n  <ul> \n   <li> <p>If we parsed a name and multiplicity <code>([A-Z][a-z]*)(\\d*)</code>, we will add it to our current count.</p> </li> \n   <li> <p>If we parsed a left bracket, we will append a new <code>count</code> to our stack, representing the nested depth of parentheses.</p> </li> \n   <li> <p>If we parsed a right bracket (and possibly another multiplicity), we will multiply our deepest level <code>count</code>, <code>top = stack.pop()</code>, and add those entries to our current count.</p> </li> \n  </ul> \n  <iframe src=\"https://leetcode.com/playground/rnaR7xpb/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"rnaR7xpb\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time Complexity <script type=\"math/tex; mode=display\">O(N^2)</script>, and Space Complexity <script type=\"math/tex; mode=display\">O(N)</script>. The analysis is the same as <em>Approach #1</em>, as this regular expression did not look backwards when parsing.</li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>. Approaches #1 and #2 inspired by <a href=\"https://leetcode.com/zestypanda/\">@zestypanda</a>. Java solution for #3 by <a href=\"https://discuss.leetcode.com/user/jianchao-li-fighter\">@jianchao.li.fighter</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 725,
    "article_live": true,
    "article_slug": "split-linked-list-in-parts",
    "title": "Split Linked List in Parts",
    "title_slug": "split-linked-list-in-parts",
    "content": "<p>Given a (singly) linked list with head node <code>root</code>, write a function to split the linked list into <code>k</code> consecutive linked list \"parts\".\r\n</p><p>\r\nThe length of each part should be as equal as possible: no two parts should have a size differing by more than 1.  This may lead to some parts being null.\r\n</p><p>\r\nThe parts should be in order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal parts occurring later.\r\n</p><p>\r\nReturn a List of ListNode's representing the linked list parts that are formed.\r\n</p>\r\n\r\nExamples\r\n1->2->3->4, k = 5 // 5 equal parts\r\n[ [1], \r\n[2],\r\n[3],\r\n[4],\r\nnull ]\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre style=\"white-space: pre-line\">\r\n<b>Input:</b> \r\nroot = [1, 2, 3], k = 5\r\n<b>Output:</b> [[1],[2],[3],[],[]]\r\n<b>Explanation:</b>\r\nThe input and each element of the output are ListNodes, not arrays.\r\nFor example, the input root has root.val = 1, root.next.val = 2, \\root.next.next.val = 3, and root.next.next.next = null.\r\nThe first element output[0] has output[0].val = 1, output[0].next = null.\r\nThe last element output[4] is null, but it's string representation as a ListNode is [].\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\nroot = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3\r\n<b>Output:</b> [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]\r\n<b>Explanation:</b>\r\nThe input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\n<li>The length of <code>root</code> will be in the range <code>[0, 1000]</code>.</li>\r\n<li>Each value of a node in the input will be an integer in the range <code>[0, 999]</code>.</li>\r\n<li><code>k</code> will be an integer in the range <code>[1, 50]</code>.</li>\r\n</p>",
    "tags": "Linked List",
    "difficulty": 2,
    "frontend_article_id": 725,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-create-new-lists-accepted\">Approach #1: Create New Lists [Accepted]</a></li> \n    <li><a href=\"#approach-2-split-input-list-accepted\">Approach #2: Split Input List [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-create-new-lists-accepted\">Approach #1: Create New Lists [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>If there are <script type=\"math/tex; mode=display\">N</script> nodes in the linked list <code>root</code>, then there are <script type=\"math/tex; mode=display\">N / k</script> items in each part, plus the first <script type=\"math/tex; mode=display\">N \\% k</script> parts have an extra item. We can count <script type=\"math/tex; mode=display\">N</script> with a simple loop.</p> \n  <p>Now for each part, we have calculated how many nodes that part will have: <code>width + (i &lt; remainder ? 1 : 0)</code>. We create a new list and write the part to that list.</p> \n  <p>Our solution showcases constructs of the form <code>a = b = c</code>. Note that this syntax behaves differently for different languages.</p> \n  <iframe src=\"https://leetcode.com/playground/mPv7qf7R/shared\" frameborder=\"0\" width=\"100%\" height=\"463\" name=\"mPv7qf7R\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N + k)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of nodes in the given list. If <script type=\"math/tex; mode=display\">k</script> is large, it could still require creating many new empty lists.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(max(N, k))</script>, the space used in writing the answer.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-split-input-list-accepted\">Approach #2: Split Input List [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>As in <em>Approach #1</em>, we know the size of each part. Instead of creating new lists, we will split the input list directly and return a list of pointers to nodes in the original list as appropriate.</p> \n  <p>Our solution proceeds similarly. For a part of size <code>L = width + (i &lt; remainder ? 1 : 0)</code>, instead of stepping <code>L</code> times, we will step <code>L-1</code> times, and our final time will also sever the link between the last node from the previous part and the first node from the next part.</p> \n  <iframe src=\"https://leetcode.com/playground/RmD7xooU/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"RmD7xooU\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N + k)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of nodes in the given list. If <script type=\"math/tex; mode=display\">k</script> is large, it could still require creating many new empty lists.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(k)</script>, the additional space used in writing the answer.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 724,
    "article_live": true,
    "article_slug": "find-pivot-index",
    "title": "Find Pivot Index",
    "title_slug": "find-pivot-index",
    "content": "<p>Given an array of integers <code>nums</code>, write a method that returns the \"pivot\" index of this array.\r\n</p><p>\r\nWe define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index.\r\n</p><p>\r\nIf no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\nnums = [1, 7, 3, 6, 5, 6]\r\n<b>Output:</b> 3\r\n<b>Explanation:</b> \r\nThe sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3.\r\nAlso, 3 is the first index where this occurs.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\nnums = [1, 2, 3]\r\n<b>Output:</b> -1\r\n<b>Explanation:</b> \r\nThere is no index that satisfies the conditions in the problem statement.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\n<li>The length of <code>nums</code> will be in the range <code>[0, 10000]</code>.</li>\r\n<li>Each element <code>nums[i]</code> will be an integer in the range <code>[-1000, 1000]</code>.</li>\r\n</p>",
    "tags": "Array",
    "difficulty": 1,
    "frontend_article_id": 724,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-prefix-sum-accepted\">Approach #1: Prefix Sum [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-prefix-sum-accepted\">Approach #1: Prefix Sum [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>We need to quickly compute the sum of values to the left and the right of every index.</p> \n  <p>Let's say we knew <code>S</code> as the sum of the numbers, and we are at index <code>i</code>. If we knew the sum of numbers <code>leftsum</code> that are to the left of index <code>i</code>, then the other sum to the right of the index would just be <code>S - nums[i] - leftsum</code>. </p> \n  <p>As such, we only need to know about <code>leftsum</code> to check whether an index is a pivot index in constant time. Let's do that: as we iterate through candidate indexes <code>i</code>, we will maintain the correct value of <code>leftsum</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/332EfbBV/shared\" frameborder=\"0\" width=\"100%\" height=\"242\" name=\"332EfbBV\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>nums</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>, the space used by <code>leftsum</code> and <code>S</code>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 723,
    "article_live": true,
    "article_slug": "candy-crush",
    "title": "Candy Crush",
    "title_slug": "candy-crush",
    "tags": "Array, Two Pointers",
    "difficulty": 2,
    "frontend_article_id": 723,
    "article_content": ""
},
{
    "frontend_question_id": 722,
    "article_live": true,
    "article_slug": "remove-comments",
    "title": "Remove Comments",
    "title_slug": "remove-comments",
    "content": "<p>Given a C++ program, remove comments from it. The program <code>source</code> is an array where <code>source[i]</code> is the <code>i</code>-th line of the source code.  This represents the result of splitting the original source code string by the newline character <code>\\n</code>.</p>\r\n\r\n<p>In C++, there are two types of comments, line comments, and block comments.</p>\r\n<p>\r\nThe string <code>//</code> denotes a line comment, which represents that it and rest of the characters to the right of it in the same line should be ignored.\r\n</p><p>\r\nThe string <code>/*</code> denotes a block comment, which represents that all characters until the next (non-overlapping) occurrence of <code>*/</code> should be ignored.  (Here, occurrences happen in reading order: line by line from left to right.)  To be clear, the string <code>/*/</code> does not yet end the block comment, as the ending would be overlapping the beginning.\r\n</p><p>\r\nThe first effective comment takes precedence over others: if the string <code>//</code> occurs in a block comment, it is ignored. Similarly, if the string <code>/*</code> occurs in a line or block comment, it is also ignored.\r\n</p><p>\r\nIf a certain line of code is empty after removing comments, you must not output that line: each string in the answer list will be non-empty.\r\n</p><p>\r\nThere will be no control characters, single quote, or double quote characters.  For example, <code>source = \"string s = \"/* Not a comment. */\";\"</code> will not be a test case.  (Also, nothing else such as defines or macros will interfere with the comments.)\r\n</p><p>\r\nIt is guaranteed that every open block comment will eventually be closed, so <code>/*</code> outside of a line or block comment always starts a new comment.\r\n</p><p>\r\nFinally, implicit newline characters can be deleted by block comments.  Please see the examples below for details.\r\n</p>\r\n\r\n<p>After removing the comments from the source code, return the source code in the same format.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre style=\"white-space: pre-wrap\">\r\n<b>Input:</b> \r\nsource = [\"/*Test program */\", \"int main()\", \"{ \", \"  // variable declaration \", \"int a, b, c;\", \"/* This is a test\", \"   multiline  \", \"   comment for \", \"   testing */\", \"a = b + c;\", \"}\"]\r\n\r\nThe line by line code is visualized as below:\r\n/*Test program */\r\nint main()\r\n{ \r\n  // variable declaration \r\nint a, b, c;\r\n/* This is a test\r\n   multiline  \r\n   comment for \r\n   testing */\r\na = b + c;\r\n}\r\n\r\n<b>Output:</b> [\"int main()\",\"{ \",\"  \",\"int a, b, c;\",\"a = b + c;\",\"}\"]\r\n\r\nThe line by line code is visualized as below:\r\nint main()\r\n{ \r\n  \r\nint a, b, c;\r\na = b + c;\r\n}\r\n\r\n<b>Explanation:</b> \r\nThe string <code>/*</code> denotes a block comment, including line 1 and lines 6-9. The string <code>//</code> denotes line 4 as comments.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre style=\"white-space: pre-wrap\">\r\n<b>Input:</b> \r\nsource = [\"a/*comment\", \"line\", \"more_comment*/b\"]\r\n<b>Output:</b> [\"ab\"]\r\n<b>Explanation:</b> The original source string is \"a/*comment<b>\\n</b>line<b>\\n</b>more_comment*/b\", where we have bolded the newline characters.  After deletion, the <i>implicit</i> newline characters are deleted, leaving the string \"ab\", which when delimited by newline characters becomes [\"ab\"].\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\n<li>The length of <code>source</code> is in the range <code>[1, 100]</code>.</li>\r\n<li>The length of <code>source[i]</code> is in the range <code>[0, 80]</code>.</li>\r\n<li>Every open block comment is eventually closed.</li>\r\n<li>There are no single-quote, double-quote, or control characters in the source code.</li>\r\n</p>",
    "tags": "String",
    "difficulty": 2,
    "frontend_article_id": 722,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-parsing-accepted\">Approach #1: Parsing [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-parsing-accepted\">Approach #1: Parsing [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>We need to parse the <code>source</code> line by line. Our state is that we either are in a block comment or not.</p> \n  <ul> \n   <li> <p>If we start a block comment and we aren't in a block, then we will skip over the next two characters and change our state to be in a block.</p> </li> \n   <li> <p>If we end a block comment and we are in a block, then we will skip over the next two characters and change our state to be <em>not</em> in a block.</p> </li> \n   <li> <p>If we start a line comment and we aren't in a block, then we will ignore the rest of the line.</p> </li> \n   <li> <p>If we aren't in a block comment (and it wasn't the start of a comment), we will record the character we are at.</p> </li> \n   <li> <p>At the end of each line, if we aren't in a block, we will record the line.</p> </li> \n  </ul> \n  <p><strong>Python</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">removeComments</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">source</span><span class=\"p\">):</span>\n        <span class=\"n\">in_block</span> <span class=\"o\">=</span> <span class=\"bp\">False</span>\n        <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n        <span class=\"k\">for</span> <span class=\"n\">line</span> <span class=\"ow\">in</span> <span class=\"n\">source</span><span class=\"p\">:</span>\n            <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n            <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">in_block</span><span class=\"p\">:</span>\n                <span class=\"n\">newline</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n            <span class=\"k\">while</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">line</span><span class=\"p\">):</span>\n                <span class=\"k\">if</span> <span class=\"n\">line</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">:</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"s1\">'/*'</span> <span class=\"ow\">and</span> <span class=\"ow\">not</span> <span class=\"n\">in_block</span><span class=\"p\">:</span>\n                    <span class=\"n\">in_block</span> <span class=\"o\">=</span> <span class=\"bp\">True</span>\n                    <span class=\"n\">i</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n                <span class=\"k\">elif</span> <span class=\"n\">line</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">:</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"s1\">'*/'</span> <span class=\"ow\">and</span> <span class=\"n\">in_block</span><span class=\"p\">:</span>\n                    <span class=\"n\">in_block</span> <span class=\"o\">=</span> <span class=\"bp\">False</span>\n                    <span class=\"n\">i</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n                <span class=\"k\">elif</span> <span class=\"ow\">not</span> <span class=\"n\">in_block</span> <span class=\"ow\">and</span> <span class=\"n\">line</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">:</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"s1\">'//'</span><span class=\"p\">:</span>\n                    <span class=\"k\">break</span>\n                <span class=\"k\">elif</span> <span class=\"ow\">not</span> <span class=\"n\">in_block</span><span class=\"p\">:</span>\n                    <span class=\"n\">newline</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">line</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">])</span>\n                <span class=\"n\">i</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n            <span class=\"k\">if</span> <span class=\"n\">newline</span> <span class=\"ow\">and</span> <span class=\"ow\">not</span> <span class=\"n\">in_block</span><span class=\"p\">:</span>\n                <span class=\"n\">ans</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"s2\">\"\"</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"n\">newline</span><span class=\"p\">))</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">ans</span>\n</pre>\n  </div> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;</span> <span class=\"nf\">removeComments</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">source</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">boolean</span> <span class=\"n\">inBlock</span> <span class=\"o\">=</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n        <span class=\"n\">StringBuilder</span> <span class=\"n\">newline</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">StringBuilder</span><span class=\"o\">();</span>\n        <span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">();</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">line</span><span class=\"o\">:</span> <span class=\"n\">source</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n            <span class=\"kt\">char</span><span class=\"o\">[]</span> <span class=\"n\">chars</span> <span class=\"o\">=</span> <span class=\"n\">line</span><span class=\"o\">.</span><span class=\"na\">toCharArray</span><span class=\"o\">();</span>\n            <span class=\"k\">if</span> <span class=\"o\">(!</span><span class=\"n\">inBlock</span><span class=\"o\">)</span> <span class=\"n\">newline</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">StringBuilder</span><span class=\"o\">();</span>\n            <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">line</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n                <span class=\"k\">if</span> <span class=\"o\">(!</span><span class=\"n\">inBlock</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span> <span class=\"o\">&lt;</span> <span class=\"n\">line</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">chars</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">==</span> <span class=\"sc\">'/'</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">chars</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"o\">==</span> <span class=\"sc\">'*'</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                    <span class=\"n\">inBlock</span> <span class=\"o\">=</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n                    <span class=\"n\">i</span><span class=\"o\">++;</span>\n                <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">inBlock</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span> <span class=\"o\">&lt;</span> <span class=\"n\">line</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">chars</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">==</span> <span class=\"sc\">'*'</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">chars</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"o\">==</span> <span class=\"sc\">'/'</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                    <span class=\"n\">inBlock</span> <span class=\"o\">=</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n                    <span class=\"n\">i</span><span class=\"o\">++;</span>\n                <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(!</span><span class=\"n\">inBlock</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span> <span class=\"o\">&lt;</span> <span class=\"n\">line</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">chars</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">==</span> <span class=\"sc\">'/'</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">chars</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"o\">==</span> <span class=\"sc\">'/'</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                    <span class=\"k\">break</span><span class=\"o\">;</span>\n                <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(!</span><span class=\"n\">inBlock</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                    <span class=\"n\">newline</span><span class=\"o\">.</span><span class=\"na\">append</span><span class=\"o\">(</span><span class=\"n\">chars</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]);</span>\n                <span class=\"o\">}</span>\n                <span class=\"n\">i</span><span class=\"o\">++;</span>\n            <span class=\"o\">}</span>\n            <span class=\"k\">if</span> <span class=\"o\">(!</span><span class=\"n\">inBlock</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">newline</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"n\">ans</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"n\">String</span><span class=\"o\">(</span><span class=\"n\">newline</span><span class=\"o\">));</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">ans</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(S)</script>, where <script type=\"math/tex; mode=display\">S</script> is the total length of the source code.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(S)</script>, the space used by recording the source code into <code>ans</code>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 721,
    "article_live": true,
    "article_slug": "accounts-merge",
    "title": "Accounts Merge",
    "title_slug": "accounts-merge",
    "content": "<p>Given a list <code>accounts</code>, each element <code>accounts[i]</code> is a list of strings, where the first element <code>accounts[i][0]</code> is a <i>name</i>, and the rest of the elements are <i>emails</i> representing emails of the account.</p>\r\n\r\n<p>Now, we would like to merge these accounts.  Two accounts definitely belong to the same person if there is some email that is common to both accounts.  Note that even if two accounts have the same name, they may belong to different people as people could have the same name.  A person can have any number of accounts initially, but all of their accounts definitely have the same name.</p>\r\n\r\n<p>After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails <b>in sorted order</b>.  The accounts themselves can be returned in any order.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre style=\"white-space: pre-wrap\">\r\n<b>Input:</b> \r\naccounts = [[\"John\", \"johnsmith@mail.com\", \"john00@mail.com\"], [\"John\", \"johnnybravo@mail.com\"], [\"John\", \"johnsmith@mail.com\", \"john_newyork@mail.com\"], [\"Mary\", \"mary@mail.com\"]]\r\n<b>Output:</b> [[\"John\", 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],  [\"John\", \"johnnybravo@mail.com\"], [\"Mary\", \"mary@mail.com\"]]\r\n<b>Explanation:</b> \r\nThe first and third John's are the same person as they have the common email \"johnsmith@mail.com\".\r\nThe second John and Mary are different people as none of their email addresses are used by other accounts.\r\nWe could return these lists in any order, for example the answer [['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com'], \r\n['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com']] would still be accepted.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\n<li>The length of <code>accounts</code> will be in the range <code>[1, 1000]</code>.</li>\r\n<li>The length of <code>accounts[i]</code> will be in the range <code>[1, 10]</code>.</li>\r\n<li>The length of <code>accounts[i][j]</code> will be in the range <code>[1, 30]</code>.</li>\r\n</p>",
    "tags": "Depth-first Search, Union Find",
    "difficulty": 2,
    "frontend_article_id": 721,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-depth-first-search-accepted\">Approach #1: Depth-First Search [Accepted]</a></li> \n    <li><a href=\"#approach-2-union-find-accepted\">Approach #2: Union-Find [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-depth-first-search-accepted\">Approach #1: Depth-First Search [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Draw an edge between two emails if they occur in the same account. The problem comes down to finding connected components of this graph.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>For each account, draw the edge from the first email to all other emails. Additionally, we'll remember a map from emails to names on the side. After finding each connected component using a depth-first search, we'll add that to our answer.</p> \n  <p><strong>Python</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">accountsMerge</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">accounts</span><span class=\"p\">):</span>\n        <span class=\"n\">em_to_name</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n        <span class=\"n\">graph</span> <span class=\"o\">=</span> <span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">defaultdict</span><span class=\"p\">(</span><span class=\"nb\">set</span><span class=\"p\">)</span>\n        <span class=\"k\">for</span> <span class=\"n\">acc</span> <span class=\"ow\">in</span> <span class=\"n\">accounts</span><span class=\"p\">:</span>\n            <span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"n\">acc</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n            <span class=\"k\">for</span> <span class=\"n\">email</span> <span class=\"ow\">in</span> <span class=\"n\">acc</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">:]:</span>\n                <span class=\"n\">graph</span><span class=\"p\">[</span><span class=\"n\">acc</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]]</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">email</span><span class=\"p\">)</span>\n                <span class=\"n\">graph</span><span class=\"p\">[</span><span class=\"n\">email</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">acc</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">])</span>\n                <span class=\"n\">em_to_name</span><span class=\"p\">[</span><span class=\"n\">email</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">name</span>\n\n        <span class=\"n\">seen</span> <span class=\"o\">=</span> <span class=\"nb\">set</span><span class=\"p\">()</span>\n        <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n        <span class=\"k\">for</span> <span class=\"n\">email</span> <span class=\"ow\">in</span> <span class=\"n\">graph</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"n\">email</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"n\">seen</span><span class=\"p\">:</span>\n                <span class=\"n\">seen</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">email</span><span class=\"p\">)</span>\n                <span class=\"n\">stack</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">email</span><span class=\"p\">]</span>\n                <span class=\"n\">component</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n                <span class=\"k\">while</span> <span class=\"n\">stack</span><span class=\"p\">:</span>\n                    <span class=\"n\">node</span> <span class=\"o\">=</span> <span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"n\">pop</span><span class=\"p\">()</span>\n                    <span class=\"n\">component</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">node</span><span class=\"p\">)</span>\n                    <span class=\"k\">for</span> <span class=\"n\">nei</span> <span class=\"ow\">in</span> <span class=\"n\">graph</span><span class=\"p\">[</span><span class=\"n\">node</span><span class=\"p\">]:</span>\n                        <span class=\"k\">if</span> <span class=\"n\">nei</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"n\">seen</span><span class=\"p\">:</span>\n                            <span class=\"n\">seen</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">nei</span><span class=\"p\">)</span>\n                            <span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">nei</span><span class=\"p\">)</span>\n                <span class=\"n\">ans</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">([</span><span class=\"n\">em_to_name</span><span class=\"p\">[</span><span class=\"n\">email</span><span class=\"p\">]]</span> <span class=\"o\">+</span> <span class=\"nb\">sorted</span><span class=\"p\">(</span><span class=\"n\">component</span><span class=\"p\">))</span>\n        <span class=\"k\">return</span> <span class=\"n\">ans</span>\n</pre>\n  </div> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;&gt;</span> <span class=\"nf\">accountsMerge</span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">accounts</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">Map</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">,</span> <span class=\"n\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">emailToName</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HashMap</span><span class=\"o\">();</span>\n        <span class=\"n\">Map</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">,</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">graph</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HashMap</span><span class=\"o\">();</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">account</span><span class=\"o\">:</span> <span class=\"n\">accounts</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">String</span> <span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"s\">\"\"</span><span class=\"o\">;</span>\n            <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">email</span><span class=\"o\">:</span> <span class=\"n\">account</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">==</span> <span class=\"s\">\"\"</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                    <span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"n\">email</span><span class=\"o\">;</span>\n                    <span class=\"k\">continue</span><span class=\"o\">;</span>\n                <span class=\"o\">}</span>\n                <span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"na\">computeIfAbsent</span><span class=\"o\">(</span><span class=\"n\">email</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">-&gt;</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;()).</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">account</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">));</span>\n                <span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"na\">computeIfAbsent</span><span class=\"o\">(</span><span class=\"n\">account</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">x</span><span class=\"o\">-&gt;</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;()).</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">email</span><span class=\"o\">);</span>\n                <span class=\"n\">emailToName</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"n\">email</span><span class=\"o\">,</span> <span class=\"n\">name</span><span class=\"o\">);</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"n\">Set</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">seen</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HashSet</span><span class=\"o\">();</span>\n        <span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">();</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">email</span><span class=\"o\">:</span> <span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"na\">keySet</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n            <span class=\"k\">if</span> <span class=\"o\">(!</span><span class=\"n\">seen</span><span class=\"o\">.</span><span class=\"na\">contains</span><span class=\"o\">(</span><span class=\"n\">email</span><span class=\"o\">))</span> <span class=\"o\">{</span>\n                <span class=\"n\">seen</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">email</span><span class=\"o\">);</span>\n                <span class=\"n\">Stack</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">stack</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Stack</span><span class=\"o\">();</span>\n                <span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"na\">push</span><span class=\"o\">(</span><span class=\"n\">email</span><span class=\"o\">);</span>\n                <span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">component</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">();</span>\n                <span class=\"k\">while</span> <span class=\"o\">(!</span><span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"na\">empty</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n                    <span class=\"n\">String</span> <span class=\"n\">node</span> <span class=\"o\">=</span> <span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"na\">pop</span><span class=\"o\">();</span>\n                    <span class=\"n\">component</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">node</span><span class=\"o\">);</span>\n                    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">nei</span><span class=\"o\">:</span> <span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">node</span><span class=\"o\">))</span> <span class=\"o\">{</span>\n                        <span class=\"k\">if</span> <span class=\"o\">(!</span><span class=\"n\">seen</span><span class=\"o\">.</span><span class=\"na\">contains</span><span class=\"o\">(</span><span class=\"n\">nei</span><span class=\"o\">))</span> <span class=\"o\">{</span>\n                            <span class=\"n\">seen</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">nei</span><span class=\"o\">);</span>\n                            <span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"na\">push</span><span class=\"o\">(</span><span class=\"n\">nei</span><span class=\"o\">);</span>\n                        <span class=\"o\">}</span>\n                    <span class=\"o\">}</span>\n                <span class=\"o\">}</span>\n                <span class=\"n\">Collections</span><span class=\"o\">.</span><span class=\"na\">sort</span><span class=\"o\">(</span><span class=\"n\">component</span><span class=\"o\">);</span>\n                <span class=\"n\">component</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">emailToName</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">email</span><span class=\"o\">));</span>\n                <span class=\"n\">ans</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">component</span><span class=\"o\">);</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">ans</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(\\sum a_i \\log a_i)</script>, where <script type=\"math/tex; mode=display\">a_i</script> is the length of <code>accounts[i]</code>. Without the log factor, this is the complexity to build the graph and search for each component. The log factor is for sorting each component at the end.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(\\sum a_i)</script>, the space used by our graph and our search.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-union-find-accepted\">Approach #2: Union-Find [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>As in <em>Approach #1</em>, our problem comes down to finding the connected components of a graph. This is a natural fit for a <em>Disjoint Set Union</em> (DSU) structure.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>As in <em>Approach #1</em>, draw edges between emails if they occur in the same account. For easier interoperability between our DSU template, we will map each email to some integer index by using <code>emailToID</code>. Then, <code>dsu.find(email)</code> will tell us a unique id representing what component that email is in.</p> \n  <p>For more information on DSU, please look at <em>Approach #2</em> in the <a href=\"https://leetcode.com/articles/redundant-connection/\">article here</a>. For brevity, the solutions showcased below do not use <em>union-by-rank</em>.</p> \n  <p><strong>Python</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"k\">class</span> <span class=\"nc\">DSU</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"nf\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">10001</span><span class=\"p\">)</span>\n    <span class=\"k\">def</span> <span class=\"nf\">find</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">p</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">]</span> <span class=\"o\">!=</span> <span class=\"n\">x</span><span class=\"p\">:</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">p</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">find</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">p</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">])</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">p</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">]</span>\n    <span class=\"k\">def</span> <span class=\"nf\">union</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">p</span><span class=\"p\">[</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">find</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)]</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">find</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">)</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">accountsMerge</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">accounts</span><span class=\"p\">):</span>\n        <span class=\"n\">dsu</span> <span class=\"o\">=</span> <span class=\"n\">DSU</span><span class=\"p\">()</span>\n        <span class=\"n\">em_to_name</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n        <span class=\"n\">em_to_id</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n        <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n        <span class=\"k\">for</span> <span class=\"n\">acc</span> <span class=\"ow\">in</span> <span class=\"n\">accounts</span><span class=\"p\">:</span>\n            <span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"n\">acc</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n            <span class=\"k\">for</span> <span class=\"n\">email</span> <span class=\"ow\">in</span> <span class=\"n\">acc</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">:]:</span>\n                <span class=\"n\">em_to_name</span><span class=\"p\">[</span><span class=\"n\">email</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">name</span>\n                <span class=\"k\">if</span> <span class=\"n\">email</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"n\">em_to_id</span><span class=\"p\">:</span>\n                    <span class=\"n\">em_to_id</span><span class=\"p\">[</span><span class=\"n\">email</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">i</span>\n                    <span class=\"n\">i</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n                <span class=\"n\">dsu</span><span class=\"o\">.</span><span class=\"n\">union</span><span class=\"p\">(</span><span class=\"n\">em_to_id</span><span class=\"p\">[</span><span class=\"n\">acc</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]],</span> <span class=\"n\">em_to_id</span><span class=\"p\">[</span><span class=\"n\">email</span><span class=\"p\">])</span>\n\n        <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">defaultdict</span><span class=\"p\">(</span><span class=\"nb\">list</span><span class=\"p\">)</span>\n        <span class=\"k\">for</span> <span class=\"n\">email</span> <span class=\"ow\">in</span> <span class=\"n\">em_to_name</span><span class=\"p\">:</span>\n            <span class=\"n\">ans</span><span class=\"p\">[</span><span class=\"n\">dsu</span><span class=\"o\">.</span><span class=\"n\">find</span><span class=\"p\">(</span><span class=\"n\">em_to_id</span><span class=\"p\">[</span><span class=\"n\">email</span><span class=\"p\">])]</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">email</span><span class=\"p\">)</span>\n\n        <span class=\"k\">return</span> <span class=\"p\">[[</span><span class=\"n\">em_to_name</span><span class=\"p\">[</span><span class=\"n\">v</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]]]</span> <span class=\"o\">+</span> <span class=\"nb\">sorted</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">v</span> <span class=\"ow\">in</span> <span class=\"n\">ans</span><span class=\"o\">.</span><span class=\"n\">values</span><span class=\"p\">()]</span>\n</pre>\n  </div> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;&gt;</span> <span class=\"nf\">accountsMerge</span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">accounts</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">DSU</span> <span class=\"n\">dsu</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">DSU</span><span class=\"o\">();</span>\n        <span class=\"n\">Map</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">,</span> <span class=\"n\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">emailToName</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HashMap</span><span class=\"o\">();</span>\n        <span class=\"n\">Map</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">,</span> <span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">emailToID</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HashMap</span><span class=\"o\">();</span>\n        <span class=\"kt\">int</span> <span class=\"n\">id</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">account</span><span class=\"o\">:</span> <span class=\"n\">accounts</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">String</span> <span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"s\">\"\"</span><span class=\"o\">;</span>\n            <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">email</span><span class=\"o\">:</span> <span class=\"n\">account</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">==</span> <span class=\"s\">\"\"</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                    <span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"n\">email</span><span class=\"o\">;</span>\n                    <span class=\"k\">continue</span><span class=\"o\">;</span>\n                <span class=\"o\">}</span>\n                <span class=\"n\">emailToName</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"n\">email</span><span class=\"o\">,</span> <span class=\"n\">name</span><span class=\"o\">);</span>\n                <span class=\"k\">if</span> <span class=\"o\">(!</span><span class=\"n\">emailToID</span><span class=\"o\">.</span><span class=\"na\">containsKey</span><span class=\"o\">(</span><span class=\"n\">email</span><span class=\"o\">))</span> <span class=\"o\">{</span>\n                    <span class=\"n\">emailToID</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"n\">email</span><span class=\"o\">,</span> <span class=\"n\">id</span><span class=\"o\">++);</span>\n                <span class=\"o\">}</span>\n                <span class=\"n\">dsu</span><span class=\"o\">.</span><span class=\"na\">union</span><span class=\"o\">(</span><span class=\"n\">emailToID</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">account</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">)),</span> <span class=\"n\">emailToID</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">email</span><span class=\"o\">));</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"n\">Map</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">,</span> <span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HashMap</span><span class=\"o\">();</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">email</span><span class=\"o\">:</span> <span class=\"n\">emailToName</span><span class=\"o\">.</span><span class=\"na\">keySet</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n            <span class=\"kt\">int</span> <span class=\"n\">index</span> <span class=\"o\">=</span> <span class=\"n\">dsu</span><span class=\"o\">.</span><span class=\"na\">find</span><span class=\"o\">(</span><span class=\"n\">emailToID</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">email</span><span class=\"o\">));</span>\n            <span class=\"n\">ans</span><span class=\"o\">.</span><span class=\"na\">computeIfAbsent</span><span class=\"o\">(</span><span class=\"n\">index</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">-&gt;</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">()).</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">email</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">component</span><span class=\"o\">:</span> <span class=\"n\">ans</span><span class=\"o\">.</span><span class=\"na\">values</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n            <span class=\"n\">Collections</span><span class=\"o\">.</span><span class=\"na\">sort</span><span class=\"o\">(</span><span class=\"n\">component</span><span class=\"o\">);</span>\n            <span class=\"n\">component</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">emailToName</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">component</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">)));</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">(</span><span class=\"n\">ans</span><span class=\"o\">.</span><span class=\"na\">values</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">class</span> <span class=\"nc\">DSU</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">parent</span><span class=\"o\">;</span>\n    <span class=\"kd\">public</span> <span class=\"nf\">DSU</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">parent</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"mi\">10001</span><span class=\"o\">];</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;=</span> <span class=\"mi\">10000</span><span class=\"o\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"o\">)</span>\n            <span class=\"n\">parent</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">i</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">find</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">parent</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"o\">!=</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">parent</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">find</span><span class=\"o\">(</span><span class=\"n\">parent</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]);</span>\n        <span class=\"k\">return</span> <span class=\"n\">parent</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">];</span>\n    <span class=\"o\">}</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">union</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">parent</span><span class=\"o\">[</span><span class=\"n\">find</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)]</span> <span class=\"o\">=</span> <span class=\"n\">find</span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(A \\log A)</script>, where <script type=\"math/tex; mode=display\">A = \\sum a_i</script>, and <script type=\"math/tex; mode=display\">a_i</script> is the length of <code>accounts[i]</code>. If we used union-by-rank, this complexity improves to <script type=\"math/tex; mode=display\">O(A \\alpha(A)) \\approx O(A)</script>, where <script type=\"math/tex; mode=display\">\\alpha</script> is the <em>Inverse-Ackermann</em> function.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(A)</script>, the space used by our DSU structure.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 720,
    "article_live": true,
    "article_slug": "longest-word-in-dictionary",
    "title": "Longest Word in Dictionary",
    "title_slug": "longest-word-in-dictionary",
    "content": "<p>Given a list of strings <code>words</code> representing an English Dictionary, find the longest word in <code>words</code> that can be built one character at a time by other words in <code>words</code>.  If there is more than one possible answer, return the longest word with the smallest lexicographical order.</p>  If there is no answer, return the empty string.\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\nwords = [\"w\",\"wo\",\"wor\",\"worl\", \"world\"]\r\n<b>Output:</b> \"world\"\r\n<b>Explanation:</b> \r\nThe word \"world\" can be built one character at a time by \"w\", \"wo\", \"wor\", and \"worl\".\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\nwords = [\"a\", \"banana\", \"app\", \"appl\", \"ap\", \"apply\", \"apple\"]\r\n<b>Output:</b> \"apple\"\r\n<b>Explanation:</b> \r\nBoth \"apply\" and \"apple\" can be built from other words in the dictionary. However, \"apple\" is lexicographically smaller than \"apply\".\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\n<li>All the strings in the input will only contain lowercase letters.</li>\r\n<li>The length of <code>words</code> will be in the range <code>[1, 1000]</code>.</li>\r\n<li>The length of <code>words[i]</code> will be in the range <code>[1, 30]</code>.</li>\r\n</p>",
    "tags": "Hash Table, Trie",
    "difficulty": 1,
    "frontend_article_id": 720,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-brute-force-accepted\">Approach #1: Brute Force [Accepted]</a></li> \n    <li><a href=\"#approach-2-trie-depth-first-search-accepted\">Approach #2: Trie + Depth-First Search [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-brute-force-accepted\">Approach #1: Brute Force [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>For each word, check if all prefixes word[:k] are present. We can use a <code>Set</code> structure to check this quickly.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Whenever our found word would be superior, we check if all it's prefixes are present, then replace our answer.</p> \n  <p>Alternatively, we could have sorted the words beforehand, so that we know the word we are considering would be the answer if all it's prefixes are present.</p> \n  <p><strong>Python</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">longestWord</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">words</span><span class=\"p\">):</span>\n    <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"s2\">\"\"</span>\n    <span class=\"n\">wordset</span> <span class=\"o\">=</span> <span class=\"nb\">set</span><span class=\"p\">(</span><span class=\"n\">words</span><span class=\"p\">)</span>\n    <span class=\"k\">for</span> <span class=\"n\">word</span> <span class=\"ow\">in</span> <span class=\"n\">words</span><span class=\"p\">:</span>\n        <span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">word</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">ans</span><span class=\"p\">)</span> <span class=\"ow\">or</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">word</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">ans</span><span class=\"p\">)</span> <span class=\"ow\">and</span> <span class=\"n\">word</span> <span class=\"o\">&lt;</span> <span class=\"n\">ans</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"nb\">all</span><span class=\"p\">(</span><span class=\"n\">word</span><span class=\"p\">[:</span><span class=\"n\">k</span><span class=\"p\">]</span> <span class=\"ow\">in</span> <span class=\"n\">wordset</span> <span class=\"k\">for</span> <span class=\"n\">k</span> <span class=\"ow\">in</span> <span class=\"nb\">xrange</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">word</span><span class=\"p\">))):</span>\n                <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"n\">word</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">ans</span>\n</pre>\n  </div> \n  <p><em>Alternate Implementation</em></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">longestWord</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">words</span><span class=\"p\">):</span>\n        <span class=\"n\">wordset</span> <span class=\"o\">=</span> <span class=\"nb\">set</span><span class=\"p\">(</span><span class=\"n\">words</span><span class=\"p\">)</span>\n        <span class=\"n\">words</span><span class=\"o\">.</span><span class=\"n\">sort</span><span class=\"p\">(</span><span class=\"n\">key</span> <span class=\"o\">=</span> <span class=\"k\">lambda</span> <span class=\"n\">c</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"o\">-</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">),</span> <span class=\"n\">c</span><span class=\"p\">))</span>\n        <span class=\"k\">for</span> <span class=\"n\">word</span> <span class=\"ow\">in</span> <span class=\"n\">words</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"nb\">all</span><span class=\"p\">(</span><span class=\"n\">word</span><span class=\"p\">[:</span><span class=\"n\">k</span><span class=\"p\">]</span> <span class=\"ow\">in</span> <span class=\"n\">wordset</span> <span class=\"k\">for</span> <span class=\"n\">k</span> <span class=\"ow\">in</span> <span class=\"nb\">xrange</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">word</span><span class=\"p\">))):</span>\n                <span class=\"k\">return</span> <span class=\"n\">word</span>\n\n        <span class=\"k\">return</span> <span class=\"s2\">\"\"</span>\n</pre>\n  </div> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"n\">String</span> <span class=\"nf\">longestWord</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">words</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">String</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"s\">\"\"</span><span class=\"o\">;</span>\n        <span class=\"n\">Set</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">wordset</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HashSet</span><span class=\"o\">();</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">word</span><span class=\"o\">:</span> <span class=\"n\">words</span><span class=\"o\">)</span> <span class=\"n\">wordset</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">word</span><span class=\"o\">);</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">word</span><span class=\"o\">:</span> <span class=\"n\">words</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">word</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()</span> <span class=\"o\">&gt;</span> <span class=\"n\">ans</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()</span> <span class=\"o\">||</span>\n                    <span class=\"n\">word</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()</span> <span class=\"o\">==</span> <span class=\"n\">ans</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">word</span><span class=\"o\">.</span><span class=\"na\">compareTo</span><span class=\"o\">(</span><span class=\"n\">ans</span><span class=\"o\">)</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"kt\">boolean</span> <span class=\"n\">good</span> <span class=\"o\">=</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n                <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"o\">;</span> <span class=\"n\">k</span> <span class=\"o\">&lt;</span> <span class=\"n\">word</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">();</span> <span class=\"o\">++</span><span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                    <span class=\"k\">if</span> <span class=\"o\">(!</span><span class=\"n\">wordset</span><span class=\"o\">.</span><span class=\"na\">contains</span><span class=\"o\">(</span><span class=\"n\">word</span><span class=\"o\">.</span><span class=\"na\">substring</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">k</span><span class=\"o\">)))</span> <span class=\"o\">{</span>\n                        <span class=\"n\">good</span> <span class=\"o\">=</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n                        <span class=\"k\">break</span><span class=\"o\">;</span>\n                    <span class=\"o\">}</span>\n                <span class=\"o\">}</span>\n                <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">good</span><span class=\"o\">)</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"n\">word</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span>    \n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">ans</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><em>Alternate Implementation</em></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"n\">String</span> <span class=\"nf\">longestWord</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">words</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">Set</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">wordset</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HashSet</span><span class=\"o\">();</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">word</span><span class=\"o\">:</span> <span class=\"n\">words</span><span class=\"o\">)</span> <span class=\"n\">wordset</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">word</span><span class=\"o\">);</span>\n        <span class=\"n\">Arrays</span><span class=\"o\">.</span><span class=\"na\">sort</span><span class=\"o\">(</span><span class=\"n\">words</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">a</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()</span> <span class=\"o\">==</span> <span class=\"n\">b</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()</span>\n                    <span class=\"o\">?</span> <span class=\"n\">a</span><span class=\"o\">.</span><span class=\"na\">compareTo</span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">b</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()</span> <span class=\"o\">-</span> <span class=\"n\">a</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">());</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">word</span><span class=\"o\">:</span> <span class=\"n\">words</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kt\">boolean</span> <span class=\"n\">good</span> <span class=\"o\">=</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n            <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"o\">;</span> <span class=\"n\">k</span> <span class=\"o\">&lt;</span> <span class=\"n\">word</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">();</span> <span class=\"o\">++</span><span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"k\">if</span> <span class=\"o\">(!</span><span class=\"n\">wordset</span><span class=\"o\">.</span><span class=\"na\">contains</span><span class=\"o\">(</span><span class=\"n\">word</span><span class=\"o\">.</span><span class=\"na\">substring</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">k</span><span class=\"o\">)))</span> <span class=\"o\">{</span>\n                    <span class=\"n\">good</span> <span class=\"o\">=</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n                    <span class=\"k\">break</span><span class=\"o\">;</span>\n                <span class=\"o\">}</span>\n            <span class=\"o\">}</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">good</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"n\">word</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"k\">return</span> <span class=\"s\">\"\"</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(\\sum w_i^2)</script>, where <script type=\"math/tex; mode=display\">w_i</script> is the length of <code>words[i]</code>. Checking whether all prefixes of <code>words[i]</code> are in the set is <script type=\"math/tex; mode=display\">O(\\sum w_i^2)</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(\\sum w_i^2)</script> to create the substrings.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-trie-depth-first-search-accepted\">Approach #2: Trie + Depth-First Search [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>As prefixes of strings are involved, this is usually a natural fit for a <em>trie</em> (a prefix tree.)</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Put every word in a trie, then depth-first-search from the start of the trie, only searching nodes that ended a word. Every node found (except the root, which is a special case) then represents a word with all it's prefixes present. We take the best such word.</p> \n  <p>In Python, we showcase a method using defaultdict, while in Java, we stick to a more general object-oriented approach.</p> \n  <p><strong>Python</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">longestWord</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">words</span><span class=\"p\">):</span>\n        <span class=\"n\">Trie</span> <span class=\"o\">=</span> <span class=\"k\">lambda</span><span class=\"p\">:</span> <span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">defaultdict</span><span class=\"p\">(</span><span class=\"n\">Trie</span><span class=\"p\">)</span>\n        <span class=\"n\">trie</span> <span class=\"o\">=</span> <span class=\"n\">Trie</span><span class=\"p\">()</span>\n        <span class=\"n\">END</span> <span class=\"o\">=</span> <span class=\"bp\">True</span>\n\n        <span class=\"k\">for</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">word</span> <span class=\"ow\">in</span> <span class=\"nb\">enumerate</span><span class=\"p\">(</span><span class=\"n\">words</span><span class=\"p\">):</span>\n            <span class=\"nb\">reduce</span><span class=\"p\">(</span><span class=\"nb\">dict</span><span class=\"o\">.</span><span class=\"n\">__getitem__</span><span class=\"p\">,</span> <span class=\"n\">word</span><span class=\"p\">,</span> <span class=\"n\">trie</span><span class=\"p\">)[</span><span class=\"n\">END</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">i</span>\n\n        <span class=\"n\">stack</span> <span class=\"o\">=</span> <span class=\"n\">trie</span><span class=\"o\">.</span><span class=\"n\">values</span><span class=\"p\">()</span>\n        <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"s2\">\"\"</span>\n        <span class=\"k\">while</span> <span class=\"n\">stack</span><span class=\"p\">:</span>\n            <span class=\"n\">cur</span> <span class=\"o\">=</span> <span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"n\">pop</span><span class=\"p\">()</span>\n            <span class=\"k\">if</span> <span class=\"n\">END</span> <span class=\"ow\">in</span> <span class=\"n\">cur</span><span class=\"p\">:</span>\n                <span class=\"n\">word</span> <span class=\"o\">=</span> <span class=\"n\">words</span><span class=\"p\">[</span><span class=\"n\">cur</span><span class=\"p\">[</span><span class=\"n\">END</span><span class=\"p\">]]</span>\n                <span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">word</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">ans</span><span class=\"p\">)</span> <span class=\"ow\">or</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">word</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">ans</span><span class=\"p\">)</span> <span class=\"ow\">and</span> <span class=\"n\">word</span> <span class=\"o\">&lt;</span> <span class=\"n\">ans</span><span class=\"p\">:</span>\n                    <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"n\">word</span>\n                <span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"n\">extend</span><span class=\"p\">([</span><span class=\"n\">cur</span><span class=\"p\">[</span><span class=\"n\">letter</span><span class=\"p\">]</span> <span class=\"k\">for</span> <span class=\"n\">letter</span> <span class=\"ow\">in</span> <span class=\"n\">cur</span> <span class=\"k\">if</span> <span class=\"n\">letter</span> <span class=\"o\">!=</span> <span class=\"n\">END</span><span class=\"p\">])</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">ans</span>\n</pre>\n  </div> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"n\">String</span> <span class=\"nf\">longestWord</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">words</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">Trie</span> <span class=\"n\">trie</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Trie</span><span class=\"o\">();</span>\n        <span class=\"kt\">int</span> <span class=\"n\">index</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">word</span><span class=\"o\">:</span> <span class=\"n\">words</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">trie</span><span class=\"o\">.</span><span class=\"na\">insert</span><span class=\"o\">(</span><span class=\"n\">word</span><span class=\"o\">,</span> <span class=\"o\">++</span><span class=\"n\">index</span><span class=\"o\">);</span> <span class=\"c1\">//indexed by 1</span>\n        <span class=\"o\">}</span>\n        <span class=\"n\">trie</span><span class=\"o\">.</span><span class=\"na\">words</span> <span class=\"o\">=</span> <span class=\"n\">words</span><span class=\"o\">;</span>\n        <span class=\"k\">return</span> <span class=\"n\">trie</span><span class=\"o\">.</span><span class=\"na\">dfs</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">class</span> <span class=\"nc\">Node</span> <span class=\"o\">{</span>\n    <span class=\"kt\">char</span> <span class=\"n\">c</span><span class=\"o\">;</span>\n    <span class=\"n\">HashMap</span><span class=\"o\">&lt;</span><span class=\"n\">Character</span><span class=\"o\">,</span> <span class=\"n\">Node</span><span class=\"o\">&gt;</span> <span class=\"n\">children</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HashMap</span><span class=\"o\">();</span>\n    <span class=\"kt\">int</span> <span class=\"n\">end</span><span class=\"o\">;</span>\n    <span class=\"kd\">public</span> <span class=\"nf\">Node</span><span class=\"o\">(</span><span class=\"kt\">char</span> <span class=\"n\">c</span><span class=\"o\">){</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">c</span> <span class=\"o\">=</span> <span class=\"n\">c</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"nc\">Trie</span> <span class=\"o\">{</span>\n    <span class=\"n\">Node</span> <span class=\"n\">root</span><span class=\"o\">;</span>\n    <span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">words</span><span class=\"o\">;</span>\n    <span class=\"kd\">public</span> <span class=\"nf\">Trie</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">root</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Node</span><span class=\"o\">(</span><span class=\"sc\">'0'</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">insert</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">word</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">index</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">Node</span> <span class=\"n\">cur</span> <span class=\"o\">=</span> <span class=\"n\">root</span><span class=\"o\">;</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">char</span> <span class=\"n\">c</span><span class=\"o\">:</span> <span class=\"n\">word</span><span class=\"o\">.</span><span class=\"na\">toCharArray</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n            <span class=\"n\">cur</span><span class=\"o\">.</span><span class=\"na\">children</span><span class=\"o\">.</span><span class=\"na\">putIfAbsent</span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"k\">new</span> <span class=\"n\">Node</span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">));</span>\n            <span class=\"n\">cur</span> <span class=\"o\">=</span> <span class=\"n\">cur</span><span class=\"o\">.</span><span class=\"na\">children</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n        <span class=\"n\">cur</span><span class=\"o\">.</span><span class=\"na\">end</span> <span class=\"o\">=</span> <span class=\"n\">index</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"n\">String</span> <span class=\"nf\">dfs</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">String</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"s\">\"\"</span><span class=\"o\">;</span>\n        <span class=\"n\">Stack</span><span class=\"o\">&lt;</span><span class=\"n\">Node</span><span class=\"o\">&gt;</span> <span class=\"n\">stack</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Stack</span><span class=\"o\">();</span>\n        <span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"na\">push</span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"o\">);</span>\n        <span class=\"k\">while</span> <span class=\"o\">(!</span><span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"na\">empty</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n            <span class=\"n\">Node</span> <span class=\"n\">node</span> <span class=\"o\">=</span> <span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"na\">pop</span><span class=\"o\">();</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">end</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span> <span class=\"o\">||</span> <span class=\"n\">node</span> <span class=\"o\">==</span> <span class=\"n\">root</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">node</span> <span class=\"o\">!=</span> <span class=\"n\">root</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                    <span class=\"n\">String</span> <span class=\"n\">word</span> <span class=\"o\">=</span> <span class=\"n\">words</span><span class=\"o\">[</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">end</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">];</span>\n                    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">word</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()</span> <span class=\"o\">&gt;</span> <span class=\"n\">ans</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()</span> <span class=\"o\">||</span>\n                            <span class=\"n\">word</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()</span> <span class=\"o\">==</span> <span class=\"n\">ans</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">word</span><span class=\"o\">.</span><span class=\"na\">compareTo</span><span class=\"o\">(</span><span class=\"n\">ans</span><span class=\"o\">)</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                        <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"n\">word</span><span class=\"o\">;</span>\n                    <span class=\"o\">}</span>\n                <span class=\"o\">}</span>\n                <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"n\">Node</span> <span class=\"n\">nei</span><span class=\"o\">:</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">children</span><span class=\"o\">.</span><span class=\"na\">values</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n                    <span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"na\">push</span><span class=\"o\">(</span><span class=\"n\">nei</span><span class=\"o\">);</span>\n                <span class=\"o\">}</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">ans</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time Complexity: <script type=\"math/tex; mode=display\">O(\\sum w_i)</script>, where <script type=\"math/tex; mode=display\">w_i</script> is the length of <code>words[i]</code>. This is the complexity to build the trie and to search it.</li> \n  </ul> \n  <p>If we used a BFS instead of a DFS, and ordered the children in an array, we could drop the need to check whether the candidate word at each node is better than the answer, by forcing that the last node visited will be the best answer.</p> \n  <ul> \n   <li>Space Complexity: <script type=\"math/tex; mode=display\">O(\\sum w_i)</script>, the space used by our trie.</li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 719,
    "article_live": true,
    "article_slug": "find-k-th-smallest-pair-distance",
    "title": "Find K-th Smallest Pair Distance",
    "title_slug": "find-k-th-smallest-pair-distance",
    "content": "<p>Given an integer array, return the k-th smallest <b>distance</b> among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B. </p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b>\r\nnums = [1,3,1]\r\nk = 1\r\n<b>Output: 0</b> \r\n<b>Explanation:</b>\r\nHere are all the pairs:\r\n(1,3) -> 2\r\n(1,1) -> 0\r\n(3,1) -> 2\r\nThen the 1st smallest distance pair is (1,1), and its distance is 0.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li><code>2 <= len(nums) <= 10000</code>.</li>\r\n<li><code>0 <= nums[i] < 1000000</code>.</li>\r\n<li><code>1 <= k <= len(nums) * (len(nums) - 1) / 2</code>.</li>\r\n</ol>\r\n</p>",
    "tags": "Array, Binary Search, Heap",
    "difficulty": 3,
    "frontend_article_id": 719,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-heap-time-limit-exceeded\">Approach #1: Heap [Time Limit Exceeded]</a></li> \n    <li><a href=\"#approach-2-binary-search-prefix-sum-accepted\">Approach #2: Binary Search + Prefix Sum [Accepted]</a></li> \n    <li><a href=\"#approach-3-binary-search-sliding-window-accepted\">Approach #3: Binary Search + Sliding Window [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-heap-time-limit-exceeded\">Approach #1: Heap [Time Limit Exceeded]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Sort the points. For every point with index <code>i</code>, the pairs with indexes <code>(i, j)</code> [by order of distance] are <code>(i, i+1), (i, i+2), ..., (i, N-1)</code>.</p> \n  <p>Let's keep a heap of pairs, initially <code>heap = [(i, i+1) for all i]</code>, and ordered by distance (the distance of <code>(i, j)</code> is <code>nums[j] - nums[i]</code>.) Whenever we use a pair <code>(i, x)</code> from our heap, we will add <code>(i, x+1)</code> to our heap when appropriate.</p> \n  <iframe src=\"https://leetcode.com/playground/haWM6KvQ/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"haWM6KvQ\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O((k+N) \\log{N})</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>nums</code>. As <script type=\"math/tex; mode=display\">k = O(N^2)</script>, this is <script type=\"math/tex; mode=display\">O(N^2 \\log {N})</script> in the worst case. The complexity added by our heap operations is either <script type=\"math/tex; mode=display\">O((k+N) \\log N)</script> in the Java solution, or <script type=\"math/tex; mode=display\">O(k \\log{N} + N)</script> in the Python solution because the <code>heapq.heapify</code> operation is linear time. Additionally, we add <script type=\"math/tex; mode=display\">O(N \\log N)</script> complexity due to sorting.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the space used to store our <code>heap</code> of at most <code>N-1</code> elements.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-binary-search-prefix-sum-accepted\">Approach #2: Binary Search + Prefix Sum [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Let's binary search for the answer. It's definitely in the range <code>[0, W]</code>, where <code>W = max(nums) - min(nums)]</code>. </p> \n  <p>Let <code>possible(guess)</code> be true if and only if there are <code>k</code> or more pairs with distance less than or equal to <code>guess</code>. We will focus on evaluating our <code>possible</code> function quickly.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Let <code>prefix[v]</code> be the number of points in <code>nums</code> less than or equal to <code>v</code>. Also, let <code>multiplicity[j]</code> be the number of points <code>i</code> with <code>i &lt; j and nums[i] == nums[j]</code>. We can record both of these with a simple linear scan.</p> \n  <p>Now, for every point <code>i</code>, the number of points <code>j</code> with <code>i &lt; j</code> and <code>nums[j] - nums[i] &lt;= guess</code> is <code>prefix[x+guess] - prefix[x] + (count[i] - multiplicity[i])</code>, where <code>count[i]</code> is the number of ocurrences of <code>nums[i]</code> in <code>nums</code>. The sum of this over all <code>i</code> is the number of pairs with distance <code>&lt;= guess</code>. </p> \n  <p>Finally, because the sum of <code>count[i] - multiplicity[i]</code> is the same as the sum of <code>multiplicity[i]</code>, we could just replace that term with <code>multiplicity[i]</code> without affecting the answer. (Actually, the sum of multiplicities in total will be a constant used in the answer, so we could precalculate it if we wanted.)</p> \n  <p>In our Java solution, we computed <code>possible = count &gt;= k</code> directly in the binary search instead of using a helper function.</p> \n  <iframe src=\"https://leetcode.com/playground/upbfbVHa/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"upbfbVHa\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(W + N \\log{W} + N \\log{N})</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>nums</code>, and <script type=\"math/tex; mode=display\">W</script> is equal to <code>nums[nums.length - 1] - nums[0]</code>. We do <script type=\"math/tex; mode=display\">O(W)</script> work to calculate <code>prefix</code> initially. The <script type=\"math/tex; mode=display\">\\log W</script> factor comes from our binary search, and we do <script type=\"math/tex; mode=display\">O(N)</script> work inside our call to <code>possible</code> (or to calculate <code>count</code> in Java). The final <script type=\"math/tex; mode=display\">O(N\\log N)</script> factor comes from sorting.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N+W)</script>, the space used to store <code>multiplicity</code> and <code>prefix</code>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-binary-search-sliding-window-accepted\">Approach #3: Binary Search + Sliding Window [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>As in <em>Approach #2</em>, let's binary search for the answer, and we will focus on evaluating our <code>possible</code> function quickly.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>We will use a sliding window approach to count the number of pairs with distance <code>&lt;=</code> guess. </p> \n  <p>For every possible <code>right</code>, we maintain the loop invariant: <code>left</code> is the smallest value such that <code>nums[right] - nums[left] &lt;= guess</code>. Then, the number of pairs with <code>right</code> as it's right-most endpoint is <code>right - left</code>, and we add all of these up.</p> \n  <iframe src=\"https://leetcode.com/playground/UD6QK4gU/shared\" frameborder=\"0\" width=\"100%\" height=\"429\" name=\"UD6QK4gU\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N \\log{W} + N \\log{N})</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>nums</code>, and <script type=\"math/tex; mode=display\">W</script> is equal to <code>nums[nums.length - 1] - nums[0]</code>. The <script type=\"math/tex; mode=display\">\\log W</script> factor comes from our binary search, and we do <script type=\"math/tex; mode=display\">O(N)</script> work inside our call to <code>possible</code> (or to calculate <code>count</code> in Java). The final <script type=\"math/tex; mode=display\">O(N\\log N)</script> factor comes from sorting.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>. No additional space is used except for integer variables.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 718,
    "article_live": true,
    "article_slug": "maximum-length-of-repeated-subarray",
    "title": "Maximum Length of Repeated Subarray",
    "title_slug": "maximum-length-of-repeated-subarray",
    "content": "<p>Given two integer arrays <code>A</code> and <code>B</code>, return the maximum length of an subarray that appears in both arrays.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b>\r\nA: [1,2,3,2,1]\r\nB: [3,2,1,4,7]\r\n<b>Output:</b> 3\r\n<b>Explanation:</b> \r\nThe repeated subarray with maximum length is [3, 2, 1].\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>1 <= len(A), len(B) <= 1000</li>\r\n<li>0 <= A[i], B[i] < 100</li>\r\n</ol>\r\n</p>",
    "tags": "Array, Hash Table, Binary Search, Dynamic Programming",
    "difficulty": 2,
    "frontend_article_id": 718,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-brute-force-with-initial-character-map-time-limit-exceeded\">Approach #1: Brute Force with Initial Character Map [Time Limit Exceeded]</a></li> \n    <li><a href=\"#approach-2-binary-search-with-naive-check-time-limit-exceeded\">Approach #2: Binary Search with Naive Check [Time Limit Exceeded]</a></li> \n    <li><a href=\"#approach-3-dynamic-programming-accepted\">Approach #3: Dynamic Programming [Accepted]</a></li> \n    <li><a href=\"#approach-4-binary-search-with-rolling-hash-accepted\">Approach #4: Binary Search with Rolling Hash [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-brute-force-with-initial-character-map-time-limit-exceeded\">Approach #1: Brute Force with Initial Character Map [Time Limit Exceeded]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>In a typical brute force, for all starting indices <code>i</code> of <code>A</code> and <code>j</code> of <code>B</code>, we will check for the longest matching subarray <code>A[i:i+k] == B[j:j+k]</code> of length <code>k</code>. This would look roughly like the following psuedocode:</p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n<span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"p\">[</span><span class=\"mi\">0</span> <span class=\"o\">..</span> <span class=\"n\">A</span><span class=\"o\">.</span><span class=\"n\">length</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">]:</span>\n    <span class=\"k\">for</span> <span class=\"n\">j</span> <span class=\"ow\">in</span> <span class=\"p\">[</span><span class=\"mi\">0</span> <span class=\"o\">..</span> <span class=\"n\">B</span><span class=\"o\">.</span><span class=\"n\">length</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">]:</span>\n        <span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n        <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"n\">k</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"n\">B</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"o\">+</span><span class=\"n\">k</span><span class=\"p\">]):</span> <span class=\"n\">k</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span> <span class=\"c1\">#and i+k &lt; A.length etc.</span>\n        <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">ans</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">)</span>\n</pre>\n  </div> \n  <p>Our insight is that in typical cases, most of the time <code>A[i] != B[j]</code>. We could instead keep a hashmap <code>Bstarts[A[i]] = all j such that B[j] == A[i]</code>, and only loop through those in our <code>j</code> loop.</p> \n  <p><strong>Python</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">findLength</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">A</span><span class=\"p\">,</span> <span class=\"n\">B</span><span class=\"p\">):</span>\n        <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n        <span class=\"n\">Bstarts</span> <span class=\"o\">=</span> <span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">defaultdict</span><span class=\"p\">(</span><span class=\"nb\">list</span><span class=\"p\">)</span>\n        <span class=\"k\">for</span> <span class=\"n\">j</span><span class=\"p\">,</span> <span class=\"n\">y</span> <span class=\"ow\">in</span> <span class=\"nb\">enumerate</span><span class=\"p\">(</span><span class=\"n\">B</span><span class=\"p\">):</span>\n            <span class=\"n\">Bstarts</span><span class=\"p\">[</span><span class=\"n\">y</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">j</span><span class=\"p\">)</span>\n\n        <span class=\"k\">for</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">x</span> <span class=\"ow\">in</span> <span class=\"nb\">enumerate</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">):</span>\n            <span class=\"k\">for</span> <span class=\"n\">j</span> <span class=\"ow\">in</span> <span class=\"n\">Bstarts</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">]:</span>\n                <span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n                <span class=\"k\">while</span> <span class=\"n\">i</span><span class=\"o\">+</span><span class=\"n\">k</span> <span class=\"o\">&lt;</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">)</span> <span class=\"ow\">and</span> <span class=\"n\">j</span><span class=\"o\">+</span><span class=\"n\">k</span> <span class=\"o\">&lt;</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">B</span><span class=\"p\">)</span> <span class=\"ow\">and</span> <span class=\"n\">A</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"n\">k</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"n\">B</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"o\">+</span><span class=\"n\">k</span><span class=\"p\">]:</span>\n                    <span class=\"n\">k</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n                <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">ans</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">ans</span>\n</pre>\n  </div> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">findLength</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n        <span class=\"n\">Map</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">,</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">Bstarts</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HashMap</span><span class=\"o\">();</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;</span> <span class=\"n\">B</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">j</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"n\">Bstarts</span><span class=\"o\">.</span><span class=\"na\">computeIfAbsent</span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">],</span> <span class=\"n\">x</span> <span class=\"o\">-&gt;</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">()).</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">j</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">A</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">Bstarts</span><span class=\"o\">.</span><span class=\"na\">containsKey</span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]))</span> <span class=\"o\">{</span>\n            <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span><span class=\"o\">:</span> <span class=\"n\">Bstarts</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]))</span> <span class=\"o\">{</span>\n                <span class=\"kt\">int</span> <span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n                <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"n\">k</span> <span class=\"o\">&lt;</span> <span class=\"n\">A</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">j</span><span class=\"o\">+</span><span class=\"n\">k</span> <span class=\"o\">&lt;</span> <span class=\"n\">B</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">A</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">==</span> <span class=\"n\">B</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">+</span><span class=\"n\">k</span><span class=\"o\">])</span> <span class=\"o\">{</span>\n                    <span class=\"n\">k</span><span class=\"o\">++</span>\n                <span class=\"o\">}</span>\n                <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">ans</span><span class=\"o\">,</span> <span class=\"n\">k</span><span class=\"o\">);</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">ans</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(M*N*\\min(M, N))</script>, where <script type=\"math/tex; mode=display\">M, N</script> are the lengths of <code>A, B</code>. The worst case is when all the elements are equal.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the space used by <code>Bstarts</code>. (Of course, we could amend our algorithm to make this <script type=\"math/tex; mode=display\">O(\\min(M, N))</script>.)</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-binary-search-with-naive-check-time-limit-exceeded\">Approach #2: Binary Search with Naive Check [Time Limit Exceeded]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>If there is a length <code>k</code> subarray common to <code>A</code> and <code>B</code>, then there is a length <code>j &lt;= k</code> subarray as well. </p> \n  <p>Let <code>check(length)</code> be the answer to the question \"Is there a subarray with <code>length</code> length, common to <code>A</code> and <code>B</code>?\" This is a function with range that must take the form <code>[True, True, ..., True, False, False, ..., False]</code> with at least one <code>True</code>. We can binary search on this function.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Focusing on the binary search, our invariant is that <code>check(hi)</code> will always be <code>False</code>. We'll start with <code>hi = min(len(A), len(B)) + 1</code>; clearly <code>check(hi) is False</code>.</p> \n  <p>Now we perform our check in the midpoint <code>mi</code> of <code>lo</code> and <code>hi</code>. When it is possible, then <code>lo = mi + 1</code>, and when it isn't, <code>hi = mi</code>. This maintains the invariant. At the end of our binary search, <code>hi == lo</code> and <code>lo</code> is the lowest value such that <code>check(lo) is False</code>, so we want <code>lo - 1</code>.</p> \n  <p>As for the check itself, we can naively check whether any <code>A[i:i+k] == B[j:j+k]</code> using set structures.</p> \n  <p><strong>Python</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">findLength</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">A</span><span class=\"p\">,</span> <span class=\"n\">B</span><span class=\"p\">):</span>\n        <span class=\"k\">def</span> <span class=\"nf\">check</span><span class=\"p\">(</span><span class=\"n\">length</span><span class=\"p\">):</span>\n            <span class=\"n\">seen</span> <span class=\"o\">=</span> <span class=\"nb\">set</span><span class=\"p\">(</span><span class=\"nb\">tuple</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">:</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"n\">length</span><span class=\"p\">])</span>\n                       <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">xrange</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"n\">length</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">))</span>\n            <span class=\"k\">return</span> <span class=\"nb\">any</span><span class=\"p\">(</span><span class=\"nb\">tuple</span><span class=\"p\">(</span><span class=\"n\">B</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">:</span><span class=\"n\">j</span><span class=\"o\">+</span><span class=\"n\">length</span><span class=\"p\">])</span> <span class=\"ow\">in</span> <span class=\"n\">seen</span>\n                       <span class=\"k\">for</span> <span class=\"n\">j</span> <span class=\"ow\">in</span> <span class=\"nb\">xrange</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">B</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"n\">length</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">))</span>\n\n        <span class=\"n\">lo</span><span class=\"p\">,</span> <span class=\"n\">hi</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"nb\">min</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">),</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">B</span><span class=\"p\">))</span> <span class=\"o\">+</span> <span class=\"mi\">1</span>\n        <span class=\"k\">while</span> <span class=\"n\">lo</span> <span class=\"o\">&lt;</span> <span class=\"n\">hi</span><span class=\"p\">:</span>\n            <span class=\"n\">mi</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">lo</span> <span class=\"o\">+</span> <span class=\"n\">hi</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"mi\">2</span>\n            <span class=\"k\">if</span> <span class=\"n\">check</span><span class=\"p\">(</span><span class=\"n\">mi</span><span class=\"p\">):</span>\n                <span class=\"n\">lo</span> <span class=\"o\">=</span> <span class=\"n\">mi</span> <span class=\"o\">+</span> <span class=\"mi\">1</span>\n            <span class=\"k\">else</span><span class=\"p\">:</span>\n                <span class=\"n\">hi</span> <span class=\"o\">=</span> <span class=\"n\">mi</span>\n        <span class=\"k\">return</span> <span class=\"n\">lo</span> <span class=\"o\">-</span> <span class=\"mi\">1</span>\n</pre>\n  </div> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">check</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">length</span><span class=\"o\">,</span> <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">Set</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">seen</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HashSet</span><span class=\"o\">();</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"n\">length</span> <span class=\"o\">&lt;=</span> <span class=\"n\">A</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">seen</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">Arrays</span><span class=\"o\">.</span><span class=\"na\">toString</span><span class=\"o\">(</span><span class=\"n\">Arrays</span><span class=\"o\">.</span><span class=\"na\">copyOfRange</span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">+</span><span class=\"n\">length</span><span class=\"o\">)));</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">j</span> <span class=\"o\">+</span> <span class=\"n\">length</span> <span class=\"o\">&lt;=</span> <span class=\"n\">B</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"o\">++</span><span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">seen</span><span class=\"o\">.</span><span class=\"na\">contains</span><span class=\"o\">(</span><span class=\"n\">Arrays</span><span class=\"o\">.</span><span class=\"na\">toString</span><span class=\"o\">(</span><span class=\"n\">Arrays</span><span class=\"o\">.</span><span class=\"na\">copyOfRange</span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"o\">,</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">j</span><span class=\"o\">+</span><span class=\"n\">length</span><span class=\"o\">))))</span> <span class=\"o\">{</span>\n                <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">findLength</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">lo</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">hi</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">min</span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">,</span> <span class=\"n\">B</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">;</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">lo</span> <span class=\"o\">&lt;</span> <span class=\"n\">hi</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kt\">int</span> <span class=\"n\">mi</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">lo</span> <span class=\"o\">+</span> <span class=\"n\">hi</span><span class=\"o\">)</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"o\">;</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">check</span><span class=\"o\">(</span><span class=\"n\">mi</span><span class=\"o\">,</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">B</span><span class=\"o\">))</span> <span class=\"n\">lo</span> <span class=\"o\">=</span> <span class=\"n\">mi</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">;</span>\n            <span class=\"k\">else</span> <span class=\"n\">hi</span> <span class=\"o\">=</span> <span class=\"n\">mi</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">lo</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O((M + N) * \\min(M, N) * \\log{(\\min(M, N))})</script>, where <script type=\"math/tex; mode=display\">M, N</script> are the lengths of <code>A, B</code>. The log factor comes from the binary search. The complexity of our naive check of a given <script type=\"math/tex; mode=display\">\\text{length}</script> is <script type=\"math/tex; mode=display\">O((M+N) * \\text{length})</script>, as we will create the <code>seen</code> strings with complexity <script type=\"math/tex; mode=display\">O(M * \\text{length})</script>, then search for them with complexity <script type=\"math/tex; mode=display\">O(N * \\text{length})</script>, and our total complexity when performing our <code>check</code> is the addition of these two.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(M^2)</script>, the space used by <code>seen</code>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-dynamic-programming-accepted\">Approach #3: Dynamic Programming [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Since a common subarray of <code>A</code> and <code>B</code> must start at some <code>A[i]</code> and <code>B[j]</code>, let <code>dp[i][j]</code> be the longest common prefix of <code>A[i:]</code> and <code>B[j:]</code>. Whenever <code>A[i] == B[j]</code>, we know <code>dp[i][j] = dp[i+1][j+1] + 1</code>. Also, the answer is <code>max(dp[i][j])</code> over all <code>i, j</code>.</p> \n  <p>We can perform bottom-up dynamic programming to find the answer based on this recurrence. Our loop invariant is that the answer is already calculated correctly and stored in <code>dp</code> for any larger <code>i, j</code>.</p> \n  <p><strong>Python</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">findLength</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">A</span><span class=\"p\">,</span> <span class=\"n\">B</span><span class=\"p\">):</span>\n        <span class=\"n\">memo</span> <span class=\"o\">=</span> <span class=\"p\">[[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">B</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">_</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)]</span>\n        <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">):</span>\n            <span class=\"k\">for</span> <span class=\"n\">j</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">B</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">):</span>\n                <span class=\"k\">if</span> <span class=\"n\">A</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"n\">B</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">]:</span>\n                    <span class=\"n\">memo</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"n\">j</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">memo</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"n\">j</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">+</span><span class=\"mi\">1</span>\n        <span class=\"k\">return</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">row</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">row</span> <span class=\"ow\">in</span> <span class=\"n\">memo</span><span class=\"p\">)</span>\n</pre>\n  </div> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">findLength</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n        <span class=\"kt\">int</span><span class=\"o\">[][]</span> <span class=\"n\">memo</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">][</span><span class=\"n\">B</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">];</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">A</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"o\">--</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">B</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">;</span> <span class=\"n\">j</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"o\">--</span><span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">==</span> <span class=\"n\">B</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">])</span> <span class=\"o\">{</span>\n                    <span class=\"n\">memo</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">][</span><span class=\"n\">j</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">memo</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"o\">][</span><span class=\"n\">j</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">;</span>\n                    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">ans</span> <span class=\"o\">&lt;</span> <span class=\"n\">memo</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">][</span><span class=\"n\">j</span><span class=\"o\">])</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"n\">memo</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">][</span><span class=\"n\">j</span><span class=\"o\">];</span>\n                <span class=\"o\">}</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">ans</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(M*N)</script>, where <script type=\"math/tex; mode=display\">M, N</script> are the lengths of <code>A, B</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(M*N)</script>, the space used by <code>dp</code>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-4-binary-search-with-rolling-hash-accepted\">Approach #4: Binary Search with Rolling Hash [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>As in <em>Approach #2</em>, we will binary search for the answer. However, we will use a <em>rolling hash</em> (Rabin-Karp algorithm) to store hashes in our set structure.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>For some prime <script type=\"math/tex; mode=display\">p</script>, consider the following function modulo some prime modulus <script type=\"math/tex; mode=display\">\\mathcal{M}</script>:</p> \n  <p> <script type=\"math/tex; mode=display\">\\text{hash}(S) = \\sum_{0 \\leq i < len(S)} p^i * S[i]</script> </p> \n  <p>Notably, <script type=\"math/tex; mode=display\">\\text{hash}(S[1:] + x) = \\frac{(\\text{hash}(S) - S[0])}{p} + p^{n-1} x</script>. This shows we can get the hash of all <script type=\"math/tex; mode=display\">A[i:i+\\text{guess}]</script> in linear time. We will also use the fact that <script type=\"math/tex; mode=display\">p^{-1} = p^{\\mathcal{M}-2} \\mod \\mathcal{M}</script>.</p> \n  <p>For every <code>i &gt;= length - 1</code>, we will want to record the hash of <code>A[i-length+1], A[i-length+2], ..., A[i]</code>. After, we will truncate the first element by <code>h = (h - A[i - (length - 1)]) * Pinv % MOD</code> to get ready to add the next element.</p> \n  <p>To make our algorithm air tight, we also make a naive check when our work with rolling hashes says that we have found a match.</p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">findLength</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">A</span><span class=\"p\">,</span> <span class=\"n\">B</span><span class=\"p\">):</span>\n        <span class=\"n\">P</span><span class=\"p\">,</span> <span class=\"n\">MOD</span> <span class=\"o\">=</span> <span class=\"mi\">113</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"o\">**</span><span class=\"mi\">9</span> <span class=\"o\">+</span> <span class=\"mi\">7</span>\n        <span class=\"n\">Pinv</span> <span class=\"o\">=</span> <span class=\"nb\">pow</span><span class=\"p\">(</span><span class=\"n\">P</span><span class=\"p\">,</span> <span class=\"n\">MOD</span><span class=\"o\">-</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">MOD</span><span class=\"p\">)</span>\n        <span class=\"k\">def</span> <span class=\"nf\">check</span><span class=\"p\">(</span><span class=\"n\">guess</span><span class=\"p\">):</span>\n            <span class=\"k\">def</span> <span class=\"nf\">rolling</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">,</span> <span class=\"n\">length</span><span class=\"p\">):</span>\n                <span class=\"k\">if</span> <span class=\"n\">length</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n                    <span class=\"k\">yield</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span>\n                    <span class=\"k\">return</span>\n\n                <span class=\"n\">h</span><span class=\"p\">,</span> <span class=\"n\">power</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span>\n                <span class=\"k\">for</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">x</span> <span class=\"ow\">in</span> <span class=\"nb\">enumerate</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">):</span>\n                    <span class=\"n\">h</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">h</span> <span class=\"o\">+</span> <span class=\"n\">x</span> <span class=\"o\">*</span> <span class=\"n\">power</span><span class=\"p\">)</span> <span class=\"o\">%</span> <span class=\"n\">MOD</span>\n                    <span class=\"k\">if</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">length</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">:</span>\n                        <span class=\"n\">power</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">power</span> <span class=\"o\">*</span> <span class=\"n\">P</span><span class=\"p\">)</span> <span class=\"o\">%</span> <span class=\"n\">MOD</span>\n                    <span class=\"k\">else</span><span class=\"p\">:</span>\n                        <span class=\"k\">yield</span> <span class=\"n\">h</span><span class=\"p\">,</span> <span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"p\">(</span><span class=\"n\">length</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n                        <span class=\"n\">h</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">h</span> <span class=\"o\">-</span> <span class=\"n\">A</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"p\">(</span><span class=\"n\">length</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">)])</span> <span class=\"o\">*</span> <span class=\"n\">Pinv</span> <span class=\"o\">%</span> <span class=\"n\">MOD</span>\n\n            <span class=\"n\">hashes</span> <span class=\"o\">=</span> <span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">defaultdict</span><span class=\"p\">(</span><span class=\"nb\">list</span><span class=\"p\">)</span>\n            <span class=\"k\">for</span> <span class=\"n\">ha</span><span class=\"p\">,</span> <span class=\"n\">start</span> <span class=\"ow\">in</span> <span class=\"n\">rolling</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">,</span> <span class=\"n\">guess</span><span class=\"p\">):</span>\n                <span class=\"n\">hashes</span><span class=\"p\">[</span><span class=\"n\">ha</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">start</span><span class=\"p\">)</span>\n            <span class=\"k\">for</span> <span class=\"n\">ha</span><span class=\"p\">,</span> <span class=\"n\">start</span> <span class=\"ow\">in</span> <span class=\"n\">rolling</span><span class=\"p\">(</span><span class=\"n\">B</span><span class=\"p\">,</span> <span class=\"n\">guess</span><span class=\"p\">):</span>\n                <span class=\"n\">iarr</span> <span class=\"o\">=</span> <span class=\"n\">hashes</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">ha</span><span class=\"p\">,</span> <span class=\"p\">[])</span>\n                <span class=\"k\">if</span> <span class=\"nb\">any</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">:</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"n\">guess</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"n\">B</span><span class=\"p\">[</span><span class=\"n\">start</span><span class=\"p\">:</span><span class=\"n\">start</span><span class=\"o\">+</span><span class=\"n\">guess</span><span class=\"p\">]</span> <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"n\">iarr</span><span class=\"p\">):</span>\n                    <span class=\"k\">return</span> <span class=\"bp\">True</span>\n            <span class=\"k\">return</span> <span class=\"bp\">False</span>\n\n        <span class=\"n\">lo</span><span class=\"p\">,</span> <span class=\"n\">hi</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"nb\">min</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">),</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">B</span><span class=\"p\">))</span> <span class=\"o\">+</span> <span class=\"mi\">1</span>\n        <span class=\"k\">while</span> <span class=\"n\">lo</span> <span class=\"o\">&lt;</span> <span class=\"n\">hi</span><span class=\"p\">:</span>\n            <span class=\"n\">mi</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">lo</span> <span class=\"o\">+</span> <span class=\"n\">hi</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"mi\">2</span>\n            <span class=\"k\">if</span> <span class=\"n\">check</span><span class=\"p\">(</span><span class=\"n\">mi</span><span class=\"p\">):</span>\n                <span class=\"n\">lo</span> <span class=\"o\">=</span> <span class=\"n\">mi</span> <span class=\"o\">+</span> <span class=\"mi\">1</span>\n            <span class=\"k\">else</span><span class=\"p\">:</span>\n                <span class=\"n\">hi</span> <span class=\"o\">=</span> <span class=\"n\">mi</span>\n        <span class=\"k\">return</span> <span class=\"n\">lo</span> <span class=\"o\">-</span> <span class=\"mi\">1</span>\n</pre>\n  </div> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kn\">import</span> <span class=\"nn\">java.math.BigInteger</span><span class=\"o\">;</span>\n\n<span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">P</span> <span class=\"o\">=</span> <span class=\"mi\">113</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">MOD</span> <span class=\"o\">=</span> <span class=\"mi\">1_000_000_007</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">Pinv</span> <span class=\"o\">=</span> <span class=\"n\">BigInteger</span><span class=\"o\">.</span><span class=\"na\">valueOf</span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"o\">).</span><span class=\"na\">modInverse</span><span class=\"o\">(</span><span class=\"n\">BigInteger</span><span class=\"o\">.</span><span class=\"na\">valueOf</span><span class=\"o\">(</span><span class=\"n\">MOD</span><span class=\"o\">)).</span><span class=\"na\">intValue</span><span class=\"o\">();</span>\n\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"nf\">rolling</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">source</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">length</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">source</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">-</span> <span class=\"n\">length</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">];</span>\n        <span class=\"kt\">long</span> <span class=\"n\">h</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">power</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"o\">;</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">length</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"n\">ans</span><span class=\"o\">;</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">source</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">h</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">+</span> <span class=\"n\">source</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">*</span> <span class=\"n\">power</span><span class=\"o\">)</span> <span class=\"o\">%</span> <span class=\"n\">MOD</span><span class=\"o\">;</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">length</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"n\">power</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">power</span> <span class=\"o\">*</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">%</span> <span class=\"n\">MOD</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>\n                <span class=\"n\">ans</span><span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"o\">(</span><span class=\"n\">length</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">)]</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">)</span> <span class=\"n\">h</span><span class=\"o\">;</span>\n                <span class=\"n\">h</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">-</span> <span class=\"n\">source</span><span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"o\">(</span><span class=\"n\">length</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">)])</span> <span class=\"o\">*</span> <span class=\"n\">Pinv</span> <span class=\"o\">%</span> <span class=\"n\">MOD</span><span class=\"o\">;</span>\n                <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"n\">h</span> <span class=\"o\">+=</span> <span class=\"n\">MOD</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">ans</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">private</span> <span class=\"kt\">boolean</span> <span class=\"nf\">check</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">guess</span><span class=\"o\">,</span> <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">Map</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">,</span> <span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">hashes</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HashMap</span><span class=\"o\">();</span>\n        <span class=\"kt\">int</span> <span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">rolling</span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">guess</span><span class=\"o\">))</span> <span class=\"o\">{</span>\n            <span class=\"n\">hashes</span><span class=\"o\">.</span><span class=\"na\">computeIfAbsent</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">z</span> <span class=\"o\">-&gt;</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">()).</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"o\">++);</span>\n        <span class=\"o\">}</span>\n        <span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">rolling</span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"o\">,</span> <span class=\"n\">guess</span><span class=\"o\">))</span> <span class=\"o\">{</span>\n            <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">:</span> <span class=\"n\">hashes</span><span class=\"o\">.</span><span class=\"na\">getOrDefault</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;()))</span>\n                <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">Arrays</span><span class=\"o\">.</span><span class=\"na\">equals</span><span class=\"o\">(</span><span class=\"n\">Arrays</span><span class=\"o\">.</span><span class=\"na\">copyOfRange</span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">+</span><span class=\"n\">guess</span><span class=\"o\">),</span>\n                                  <span class=\"n\">Arrays</span><span class=\"o\">.</span><span class=\"na\">copyOfRange</span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"o\">,</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">j</span><span class=\"o\">+</span><span class=\"n\">guess</span><span class=\"o\">)))</span> <span class=\"o\">{</span>\n                    <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n                <span class=\"o\">}</span>\n            <span class=\"n\">j</span><span class=\"o\">++;</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">findLength</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">lo</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">hi</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">min</span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">,</span> <span class=\"n\">B</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">;</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">lo</span> <span class=\"o\">&lt;</span> <span class=\"n\">hi</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kt\">int</span> <span class=\"n\">mi</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">lo</span> <span class=\"o\">+</span> <span class=\"n\">hi</span><span class=\"o\">)</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"o\">;</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">check</span><span class=\"o\">(</span><span class=\"n\">mi</span><span class=\"o\">,</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">B</span><span class=\"o\">))</span> <span class=\"n\">lo</span> <span class=\"o\">=</span> <span class=\"n\">mi</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">;</span>\n            <span class=\"k\">else</span> <span class=\"n\">hi</span> <span class=\"o\">=</span> <span class=\"n\">mi</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">lo</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O((M+N) * \\log{(\\min(M, N))})</script>, where <script type=\"math/tex; mode=display\">M, N</script> are the lengths of <code>A, B</code>. The log factor is contributed by the binary search, while creating the rolling hashes is <script type=\"math/tex; mode=display\">O(M + N)</script>. The checks for duplicate hashes are <script type=\"math/tex; mode=display\">O(1)</script>. If we perform a naive check to make sure our answer is correct, it adds a factor of <script type=\"math/tex; mode=display\">O(\\min(M, N))</script> to our cost of <code>check</code>, which keeps the complexity the same.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(M)</script>, the space used to store <code>hashes</code> and the subarrays in our final naive check.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>. Idea for Solution #2 by <a href=\"https://leetcode.com/stefanpochmann\">@StefanPochmann</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 717,
    "article_live": true,
    "article_slug": "1-bit-and-2-bit-characters",
    "title": "1-bit and 2-bit Characters",
    "title_slug": "1-bit-and-2-bit-characters",
    "content": "<p>We have two special characters. The first character can be represented by one bit <code>0</code>. The second character can be represented by two bits (<code>10</code> or <code>11</code>).  </p>\r\n\r\n<p>Now given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\nbits = [1, 0, 0]\r\n<b>Output:</b> True\r\n<b>Explanation:</b> \r\nThe only way to decode it is two-bit character and one-bit character. So the last character is one-bit character.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\nbits = [1, 1, 1, 0]\r\n<b>Output:</b> False\r\n<b>Explanation:</b> \r\nThe only way to decode it is two-bit character and two-bit character. So the last character is NOT one-bit character.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\n<li><code>1 <= len(bits) <= 1000</code>.</li>\r\n<li><code>bits[i]</code> is always <code>0</code> or <code>1</code>.</li>\r\n</p>",
    "tags": "Array",
    "difficulty": 1,
    "frontend_article_id": 717,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-increment-pointer-accepted\">Approach #1: Increment Pointer [Accepted]</a></li> \n    <li><a href=\"#approach-2-greedy-accepted\">Approach #2: Greedy [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-increment-pointer-accepted\">Approach #1: Increment Pointer [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>When reading from the <code>i</code>-th position, if <code>bits[i] == 0</code>, the next character must have 1 bit; else if <code>bits[i] == 1</code>, the next character must have 2 bits. We increment our read-pointer <code>i</code> to the start of the next character appropriately. At the end, if our pointer is at <code>bits.length - 1</code>, then the last character must have a size of 1 bit.</p> \n  <p><strong>Python</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">isOneBitCharacter</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">bits</span><span class=\"p\">):</span>\n        <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n        <span class=\"k\">while</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">bits</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">:</span>\n            <span class=\"n\">i</span> <span class=\"o\">+=</span> <span class=\"n\">bits</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"mi\">1</span>\n        <span class=\"k\">return</span> <span class=\"n\">i</span> <span class=\"o\">==</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">bits</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"mi\">1</span>\n</pre>\n  </div> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">isOneBitCharacter</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">bits</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">bits</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">i</span> <span class=\"o\">+=</span> <span class=\"n\">bits</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">i</span> <span class=\"o\">==</span> <span class=\"n\">bits</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>bits</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>, the space used by <code>i</code>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-greedy-accepted\">Approach #2: Greedy [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>The second-last <code>0</code> must be the end of a character (or, the beginning of the array if it doesn't exist). Looking from that position forward, the array <code>bits</code> takes the form <code>[1, 1, ..., 1, 0]</code> where there are zero or more <code>1</code>'s present in total. It is easy to show that the answer is <code>true</code> if and only if there are an even number of ones present.</p> \n  <p>In our algorithm, we will find the second last zero by performing a linear scan from the right. We present two slightly different approaches below.</p> \n  <p><strong>Python</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">isOneBitCharacter</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">bits</span><span class=\"p\">):</span>\n        <span class=\"n\">parity</span> <span class=\"o\">=</span> <span class=\"n\">bits</span><span class=\"o\">.</span><span class=\"n\">pop</span><span class=\"p\">()</span>\n        <span class=\"k\">while</span> <span class=\"n\">bits</span> <span class=\"ow\">and</span> <span class=\"n\">bits</span><span class=\"o\">.</span><span class=\"n\">pop</span><span class=\"p\">():</span> <span class=\"n\">parity</span> <span class=\"o\">^=</span> <span class=\"mi\">1</span>\n        <span class=\"k\">return</span> <span class=\"n\">parity</span> <span class=\"o\">==</span> <span class=\"mi\">0</span>\n</pre>\n  </div> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">isOneBitCharacter</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">bits</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">bits</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">-</span> <span class=\"mi\">2</span><span class=\"o\">;</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">0</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">bits</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"n\">i</span><span class=\"o\">--;</span>\n        <span class=\"k\">return</span> <span class=\"o\">(</span><span class=\"n\">bits</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">-</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">%</span> <span class=\"mi\">2</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>bits</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>, the space used by <code>parity</code> (or <code>i</code>).</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 716,
    "article_live": true,
    "article_slug": "max-stack",
    "title": "Max Stack",
    "title_slug": "max-stack",
    "tags": "Design",
    "difficulty": 1,
    "frontend_article_id": 716,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-two-stacks-accepted\">Approach #1: Two Stacks [Accepted]</a></li> \n    <li><a href=\"#approach-2-double-linked-list-treemap-accepted\">Approach #2: Double Linked List + TreeMap [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-two-stacks-accepted\">Approach #1: Two Stacks [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>A regular stack already supports the first 3 operations, so we focus on the last two.</p> \n  <p>For <code>peekMax</code>, we remember the largest value we've seen on the side. For example if we add <code>[2, 1, 5, 3, 9]</code>, we'll remember <code>[2, 2, 5, 5, 9]</code>. This works seamlessly with <code>pop</code> operations, and also it's easy to compute: it's just the maximum of the element we are adding and the previous maximum.</p> \n  <p>For <code>popMax</code>, we know what the current maximum (<code>peekMax</code>) is. We can pop until we find that maximum, then push the popped elements back on the stack.</p> \n  <p>Our implementation in Python will showcase extending the <code>list</code> class.</p> \n  <iframe src=\"https://leetcode.com/playground/49Y3VvUj/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"49Y3VvUj\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script> for the <code>popMax</code> operation, and <script type=\"math/tex; mode=display\">O(1)</script> for the other operations, where <script type=\"math/tex; mode=display\">N</script> is the number of operations performed.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the maximum size of the stack.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-double-linked-list-treemap-accepted\">Approach #2: Double Linked List + TreeMap [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Using structures like Array or Stack will never let us <code>popMax</code> quickly. We turn our attention to tree and linked-list structures that have a lower time complexity for removal, with the aim of making <code>popMax</code> faster than <script type=\"math/tex; mode=display\">O(N)</script> time complexity.</p> \n  <p>Say we have a double linked list as our \"stack\". This reduces the problem to finding which node to remove, since we can remove nodes in <script type=\"math/tex; mode=display\">O(1)</script> time.</p> \n  <p>We can use a TreeMap mapping values to a list of nodes to answer this question. TreeMap can find the largest value, insert values, and delete values, all in <script type=\"math/tex; mode=display\">O(\\log N)</script> time.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Let's store the stack as a double linked list <code>dll</code>, and store a <code>map</code> from <code>value</code> to a <code>List</code> of <code>Node</code>.</p> \n  <ul> \n   <li> <p>When we <code>MaxStack.push(x)</code>, we add a node to our <code>dll</code>, and add or update our entry <code>map.get(x).add(node)</code>.</p> </li> \n   <li> <p>When we <code>MaxStack.pop()</code>, we find the value <code>val = dll.pop()</code>, and remove the node from our <code>map</code>, deleting the entry if it was the last one.</p> </li> \n   <li> <p>When we <code>MaxStack.popMax()</code>, we use the <code>map</code> to find the relevant node to <code>unlink</code>, and return it's value.</p> </li> \n  </ul> \n  <p>The above operations are more clear given that we have a working <code>DoubleLinkedList</code> class. The implementation provided uses <code>head</code> and <code>tail</code> <em>sentinels</em> to simplify the relevant <code>DoubleLinkedList</code> operations.</p> \n  <p>A Python implementation was not included for this approach because there is no analog to <em>TreeMap</em> available.</p> \n  <iframe src=\"https://leetcode.com/playground/7cWp6DCL/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"7cWp6DCL\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(\\log N)</script> for all operations except <code>peek</code> which is <script type=\"math/tex; mode=display\">O(1)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of operations performed. Most operations involving <code>TreeMap</code> are <script type=\"math/tex; mode=display\">O(\\log N)</script>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the size of the data structures used.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 715,
    "article_live": true,
    "article_slug": "range-module",
    "title": "Range Module",
    "title_slug": "range-module",
    "content": "<p>A Range Module is a module that tracks ranges of numbers. Your task is to design and implement the following interfaces in an efficient manner.</p>\r\n\r\n<p><li><code>addRange(int left, int right)</code> Adds the half-open interval <code>[left, right)</code>, tracking every real number in that interval.  Adding an interval that partially overlaps with currently tracked numbers should add any numbers in the interval <code>[left, right)</code> that are not already tracked.</li></p>\r\n\r\n<p><li><code>queryRange(int left, int right)</code> Returns true if and only if every real number in the interval <code>[left, right)</code>\r\n is currently being tracked.</li></p>\r\n\r\n<p><li><code>removeRange(int left, int right)</code> Stops tracking every real number currently being tracked in the interval <code>[left, right)</code>.</li></p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>addRange(10, 20)</b>: null\r\n<b>removeRange(14, 16)</b>: null\r\n<b>queryRange(10, 14)</b>: true (Every number in [10, 14) is being tracked)\r\n<b>queryRange(13, 15)</b>: false (Numbers like 14, 14.03, 14.17 in [13, 15) are not being tracked)\r\n<b>queryRange(16, 17)</b>: true (The number 16 in [16, 17) is still being tracked, despite the remove operation)\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\n<li>A half open interval <code>[left, right)</code> denotes all real numbers <code>left <= x < right</code>.</li>\r\n\r\n<li><code>0 < left < right < 10^9</code> in all calls to <code>addRange, queryRange, removeRange</code>.</li>\r\n<li>The total number of calls to <code>addRange</code> in a single test case is at most <code>1000</code>.</li>\r\n<li>The total number of calls to <code>queryRange</code> in a single test case is at most <code>5000</code>.</li>\r\n<li>The total number of calls to <code>removeRange</code> in a single test case is at most <code>1000</code>.</li>\r\n</p>",
    "tags": "Array, Segment Tree, Binary Search Tree",
    "difficulty": 3,
    "frontend_article_id": 715,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-maintain-sorted-disjoint-intervals-accepted\">Approach #1: Maintain Sorted Disjoint Intervals [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-maintain-sorted-disjoint-intervals-accepted\">Approach #1: Maintain Sorted Disjoint Intervals [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Because <code>left, right &lt; 10^9</code>, we need to deal with the coordinates abstractly. Let's maintain some sorted structure of disjoint intervals. These intervals will be closed (eg. we don't store <code>[[1, 2], [2, 3]]</code>; we would store <code>[[1, 3]]</code> instead.)</p> \n  <p>In this article, we will go over Python and Java versions separately, as the data structures available to us that are relevant to the problem are substantially different.</p> \n  <p><strong>Algorithm (Python)</strong></p> \n  <p>We will maintain the structure as a <em>list</em> <code>self.ranges = []</code>. </p> \n  <p><em>Adding a Range</em></p> \n  <p>When we want to add a range, we first find the indices <code>i, j = self._bounds(left, right)</code> for which <code>self.ranges[i: j+1]</code> touches (in a closed sense - not halfopen) the given interval <code>[left, right]</code>. We can find this in log time by making steps of size 100, 10, then 1 in our linear search from both sides.</p> \n  <p>Every interval touched by <code>[left, right]</code> will be replaced by the single interval <code>[min(left, self.ranges[i][0]), max(right, self.ranges[j][1])]</code>.</p> \n  <p><em>Removing a Range</em></p> \n  <p>Again, we use <code>i, j = self._bounds(...)</code> to only work in the relevant subset of <code>self.ranges</code> that is in the neighborhood of our given range <code>[left, right)</code>. For each interval <code>[x, y)</code> from <code>self.ranges[i:j+1]</code>, we may have some subset of that interval to the left and/or right of <code>[left, right)</code>. We replace our current interval <code>[x, y)</code> with those (up to 2) new intervals.</p> \n  <p><em>Querying a Range</em></p> \n  <p>As the intervals are sorted, we use binary search to find the single interval that could intersect <code>[left, right)</code>, then verify that it does.</p> \n  <p><strong>Python</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"k\">class</span> <span class=\"nc\">RangeModule</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">ranges</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">_bounds</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">left</span><span class=\"p\">,</span> <span class=\"n\">right</span><span class=\"p\">):</span>\n        <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">ranges</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"mi\">1</span>\n        <span class=\"k\">for</span> <span class=\"n\">d</span> <span class=\"ow\">in</span> <span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">):</span>\n            <span class=\"k\">while</span> <span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"n\">d</span> <span class=\"o\">-</span> <span class=\"mi\">1</span> <span class=\"o\">&lt;</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">ranges</span><span class=\"p\">)</span> <span class=\"ow\">and</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">ranges</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"n\">d</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">&lt;</span> <span class=\"n\">left</span><span class=\"p\">:</span>\n                <span class=\"n\">i</span> <span class=\"o\">+=</span> <span class=\"n\">d</span>\n            <span class=\"k\">while</span> <span class=\"n\">j</span> <span class=\"o\">&gt;=</span> <span class=\"n\">d</span> <span class=\"o\">-</span> <span class=\"mi\">1</span> <span class=\"ow\">and</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">ranges</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"o\">-</span><span class=\"n\">d</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">&gt;</span> <span class=\"n\">right</span><span class=\"p\">:</span>\n                <span class=\"n\">j</span> <span class=\"o\">-=</span> <span class=\"n\">d</span>\n        <span class=\"k\">return</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">j</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">addRange</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">left</span><span class=\"p\">,</span> <span class=\"n\">right</span><span class=\"p\">):</span>\n        <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_bounds</span><span class=\"p\">(</span><span class=\"n\">left</span><span class=\"p\">,</span> <span class=\"n\">right</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"n\">i</span> <span class=\"o\">&lt;=</span> <span class=\"n\">j</span><span class=\"p\">:</span>\n            <span class=\"n\">left</span> <span class=\"o\">=</span> <span class=\"nb\">min</span><span class=\"p\">(</span><span class=\"n\">left</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">ranges</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">])</span>\n            <span class=\"n\">right</span> <span class=\"o\">=</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">right</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">ranges</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">])</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">ranges</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">:</span><span class=\"n\">j</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">[(</span><span class=\"n\">left</span><span class=\"p\">,</span> <span class=\"n\">right</span><span class=\"p\">)]</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">queryRange</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">left</span><span class=\"p\">,</span> <span class=\"n\">right</span><span class=\"p\">):</span>\n        <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">bisect</span><span class=\"o\">.</span><span class=\"n\">bisect_left</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">ranges</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">left</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">(</span><span class=\"s1\">'inf'</span><span class=\"p\">)))</span>\n        <span class=\"k\">if</span> <span class=\"n\">i</span><span class=\"p\">:</span> <span class=\"n\">i</span> <span class=\"o\">-=</span> <span class=\"mi\">1</span>\n        <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"nb\">bool</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">ranges</span><span class=\"p\">)</span> <span class=\"ow\">and</span>\n                <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">ranges</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">&lt;=</span> <span class=\"n\">left</span> <span class=\"ow\">and</span>\n                <span class=\"n\">right</span> <span class=\"o\">&lt;=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">ranges</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">])</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">removeRange</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">left</span><span class=\"p\">,</span> <span class=\"n\">right</span><span class=\"p\">):</span>\n        <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_bounds</span><span class=\"p\">(</span><span class=\"n\">left</span><span class=\"p\">,</span> <span class=\"n\">right</span><span class=\"p\">)</span>\n        <span class=\"n\">merge</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n        <span class=\"k\">for</span> <span class=\"n\">k</span> <span class=\"ow\">in</span> <span class=\"nb\">xrange</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">j</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">):</span>\n            <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">ranges</span><span class=\"p\">[</span><span class=\"n\">k</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">&lt;</span> <span class=\"n\">left</span><span class=\"p\">:</span>\n                <span class=\"n\">merge</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">((</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">ranges</span><span class=\"p\">[</span><span class=\"n\">k</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">left</span><span class=\"p\">))</span>\n            <span class=\"k\">if</span> <span class=\"n\">right</span> <span class=\"o\">&lt;</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">ranges</span><span class=\"p\">[</span><span class=\"n\">k</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]:</span>\n                <span class=\"n\">merge</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">((</span><span class=\"n\">right</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">ranges</span><span class=\"p\">[</span><span class=\"n\">k</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]))</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">ranges</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">:</span><span class=\"n\">j</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">merge</span>\n</pre>\n  </div> \n  <hr> \n  <p><strong>Algorithm (Java)</strong></p> \n  <p>We will maintain the structure as a <em>TreeSet</em> <code>ranges = new TreeSet&lt;Interval&gt;();</code>. We introduce a new <em>Comparable</em> class <code>Interval</code> to represent our half-open intervals. They compare by <em>right-most</em> coordinate as later we will see that it simplifies our work. Also note that this ordering is consistent with equals, which is important when dealing with <em>Sets</em>.</p> \n  <p><em>Adding and Removing a Range</em></p> \n  <p>The basic structure of adding and removing a range is the same. First, we must iterate over the relevant subset of <code>ranges</code>. This is done using iterators so that we can <code>itr.remove</code> on the fly, and breaking when the intervals go too far to the right.</p> \n  <p>The critical logic of <code>addRange</code> is simply to make <code>left, right</code> the smallest and largest seen coordinates. After, we add one giant interval representing the union of all intervals seen that touched <code>[left, right]</code>.</p> \n  <p>The logic of <code>removeRange</code> is to remember in <code>todo</code> the intervals we wanted to replace the removed interval with. After, we can add them all back in.</p> \n  <p><em>Querying a Range</em></p> \n  <p>As the intervals are sorted, we search to find the single interval that could intersect <code>[left, right)</code>, then verify that it does. As the TreeSet uses a balanced (red-black) tree, this has logarithmic complexity.</p> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">class</span> <span class=\"nc\">RangeModule</span> <span class=\"o\">{</span>\n    <span class=\"n\">TreeSet</span><span class=\"o\">&lt;</span><span class=\"n\">Interval</span><span class=\"o\">&gt;</span> <span class=\"n\">ranges</span><span class=\"o\">;</span>\n    <span class=\"kd\">public</span> <span class=\"nf\">RangeModule</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">ranges</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">TreeSet</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">addRange</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">right</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">Iterator</span><span class=\"o\">&lt;</span><span class=\"n\">Interval</span><span class=\"o\">&gt;</span> <span class=\"n\">itr</span> <span class=\"o\">=</span> <span class=\"n\">ranges</span><span class=\"o\">.</span><span class=\"na\">tailSet</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"n\">Interval</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">left</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">)).</span><span class=\"na\">iterator</span><span class=\"o\">();</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">itr</span><span class=\"o\">.</span><span class=\"na\">hasNext</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n            <span class=\"n\">Interval</span> <span class=\"n\">iv</span> <span class=\"o\">=</span> <span class=\"n\">itr</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">();</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">right</span> <span class=\"o\">&lt;</span> <span class=\"n\">iv</span><span class=\"o\">.</span><span class=\"na\">left</span><span class=\"o\">)</span> <span class=\"k\">break</span><span class=\"o\">;</span>\n            <span class=\"n\">left</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">min</span><span class=\"o\">(</span><span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">iv</span><span class=\"o\">.</span><span class=\"na\">left</span><span class=\"o\">);</span>\n            <span class=\"n\">right</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">iv</span><span class=\"o\">.</span><span class=\"na\">right</span><span class=\"o\">);</span>\n            <span class=\"n\">itr</span><span class=\"o\">.</span><span class=\"na\">remove</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n        <span class=\"n\">ranges</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"n\">Interval</span><span class=\"o\">(</span><span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">right</span><span class=\"o\">));</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">queryRange</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">right</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">Interval</span> <span class=\"n\">iv</span> <span class=\"o\">=</span> <span class=\"n\">ranges</span><span class=\"o\">.</span><span class=\"na\">higher</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"n\">Interval</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">left</span><span class=\"o\">));</span>\n        <span class=\"k\">return</span> <span class=\"o\">(</span><span class=\"n\">iv</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">iv</span><span class=\"o\">.</span><span class=\"na\">left</span> <span class=\"o\">&lt;=</span> <span class=\"n\">left</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">right</span> <span class=\"o\">&lt;=</span> <span class=\"n\">iv</span><span class=\"o\">.</span><span class=\"na\">right</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">removeRange</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">right</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">Iterator</span><span class=\"o\">&lt;</span><span class=\"n\">Interval</span><span class=\"o\">&gt;</span> <span class=\"n\">itr</span> <span class=\"o\">=</span> <span class=\"n\">ranges</span><span class=\"o\">.</span><span class=\"na\">tailSet</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"n\">Interval</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">left</span><span class=\"o\">)).</span><span class=\"na\">iterator</span><span class=\"o\">();</span>\n        <span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">Interval</span><span class=\"o\">&gt;</span> <span class=\"n\">todo</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">();</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">itr</span><span class=\"o\">.</span><span class=\"na\">hasNext</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n            <span class=\"n\">Interval</span> <span class=\"n\">iv</span> <span class=\"o\">=</span> <span class=\"n\">itr</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">();</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">right</span> <span class=\"o\">&lt;</span> <span class=\"n\">iv</span><span class=\"o\">.</span><span class=\"na\">left</span><span class=\"o\">)</span> <span class=\"k\">break</span><span class=\"o\">;</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">iv</span><span class=\"o\">.</span><span class=\"na\">left</span> <span class=\"o\">&lt;</span> <span class=\"n\">left</span><span class=\"o\">)</span> <span class=\"n\">todo</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"n\">Interval</span><span class=\"o\">(</span><span class=\"n\">iv</span><span class=\"o\">.</span><span class=\"na\">left</span><span class=\"o\">,</span> <span class=\"n\">left</span><span class=\"o\">));</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">right</span> <span class=\"o\">&lt;</span> <span class=\"n\">iv</span><span class=\"o\">.</span><span class=\"na\">right</span><span class=\"o\">)</span> <span class=\"n\">todo</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"n\">Interval</span><span class=\"o\">(</span><span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">iv</span><span class=\"o\">.</span><span class=\"na\">right</span><span class=\"o\">));</span>\n            <span class=\"n\">itr</span><span class=\"o\">.</span><span class=\"na\">remove</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"n\">Interval</span> <span class=\"n\">iv</span><span class=\"o\">:</span> <span class=\"n\">todo</span><span class=\"o\">)</span> <span class=\"n\">ranges</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">iv</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"nc\">Interval</span> <span class=\"kd\">implements</span> <span class=\"n\">Comparable</span><span class=\"o\">&lt;</span><span class=\"n\">Interval</span><span class=\"o\">&gt;{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">left</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">right</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"nf\">Interval</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">right</span><span class=\"o\">){</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">left</span> <span class=\"o\">=</span> <span class=\"n\">left</span><span class=\"o\">;</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">right</span> <span class=\"o\">=</span> <span class=\"n\">right</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">compareTo</span><span class=\"o\">(</span><span class=\"n\">Interval</span> <span class=\"n\">that</span><span class=\"o\">){</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">right</span> <span class=\"o\">==</span> <span class=\"n\">that</span><span class=\"o\">.</span><span class=\"na\">right</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">left</span> <span class=\"o\">-</span> <span class=\"n\">that</span><span class=\"o\">.</span><span class=\"na\">left</span><span class=\"o\">;</span>\n        <span class=\"k\">return</span> <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">right</span> <span class=\"o\">-</span> <span class=\"n\">that</span><span class=\"o\">.</span><span class=\"na\">right</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: Let <script type=\"math/tex; mode=display\">K</script> be the number of elements in <code>ranges</code>. <code>addRange</code> and <code>removeRange</code> operations have <script type=\"math/tex; mode=display\">O(K)</script> complexity. <code>queryRange</code> has <script type=\"math/tex; mode=display\">O(\\log K)</script> complexity. Because <code>addRange, removeRange</code> adds at most 1 interval at a time, you can bound these further. For example, if there are <script type=\"math/tex; mode=display\">A</script> <code>addRange</code>, <script type=\"math/tex; mode=display\">R</script> <code>removeRange</code>, and <script type=\"math/tex; mode=display\">Q</script> <code>queryRange</code> number of operations respectively, we can express our complexity as <script type=\"math/tex; mode=display\">O((A+R)^2 Q \\log(A+R))</script>. </p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(A+R)</script>, the space used by <code>ranges</code>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 714,
    "article_live": true,
    "article_slug": "best-time-to-buy-and-sell-stock-with-transaction-fee",
    "title": "Best Time to Buy and Sell Stock with Transaction Fee",
    "title_slug": "best-time-to-buy-and-sell-stock-with-transaction-fee",
    "content": "<p>Your are given an array of integers <code>prices</code>, for which the <code>i</code>-th element is the price of a given stock on day <code>i</code>; and a non-negative integer <code>fee</code> representing a transaction fee.</p>\r\n<p>You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.  You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.)</p>\r\n<p>Return the maximum profit you can make.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> prices = [1, 3, 2, 8, 4, 9], fee = 2\r\n<b>Output:</b> 8\r\n<b>Explanation:</b> The maximum profit can be achieved by:\r\n<li>Buying at prices[0] = 1</li><li>Selling at prices[3] = 8</li><li>Buying at prices[4] = 4</li><li>Selling at prices[5] = 9</li>The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\n<li><code>0 < prices.length <= 50000</code>.</li>\r\n<li><code>0 < prices[i] < 50000</code>.</li>\r\n<li><code>0 <= fee < 50000</code>.</li>\r\n</p>",
    "tags": "Array, Dynamic Programming, Greedy",
    "difficulty": 2,
    "frontend_article_id": 714,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-dynamic-programming-accepted\">Approach #1: Dynamic Programming [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-dynamic-programming-accepted\">Approach #1: Dynamic Programming [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>At the end of the <code>i</code>-th day, we maintain <code>cash</code>, the maximum profit we could have if we did not have a share of stock, and <code>hold</code>, the maximum profit we could have if we owned a share of stock.</p> \n  <p>To transition from the <code>i</code>-th day to the <code>i+1</code>-th day, we either sell our stock <code>cash = max(cash, hold + prices[i] - fee)</code> or buy a stock <code>hold = max(hold, cash - prices[i])</code>. At the end, we want to return <code>cash</code>. We can transform <code>cash</code> first without using temporary variables because selling and buying on the same day can't be better than just continuing to hold the stock.</p> \n  <p><strong>Python</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">maxProfit</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">prices</span><span class=\"p\">,</span> <span class=\"n\">fee</span><span class=\"p\">):</span>\n        <span class=\"n\">cash</span><span class=\"p\">,</span> <span class=\"n\">hold</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"n\">prices</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n        <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">prices</span><span class=\"p\">)):</span>\n            <span class=\"n\">cash</span> <span class=\"o\">=</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">cash</span><span class=\"p\">,</span> <span class=\"n\">hold</span> <span class=\"o\">+</span> <span class=\"n\">prices</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"n\">fee</span><span class=\"p\">)</span>\n            <span class=\"n\">hold</span> <span class=\"o\">=</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">hold</span><span class=\"p\">,</span> <span class=\"n\">cash</span> <span class=\"o\">-</span> <span class=\"n\">prices</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">])</span>\n        <span class=\"k\">return</span> <span class=\"n\">cash</span>\n</pre>\n  </div> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">maxProfit</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">prices</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">fee</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">cash</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">hold</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"n\">prices</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">];</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">prices</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"n\">cash</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">cash</span><span class=\"o\">,</span> <span class=\"n\">hold</span> <span class=\"o\">+</span> <span class=\"n\">prices</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">-</span> <span class=\"n\">fee</span><span class=\"o\">);</span>\n            <span class=\"n\">hold</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">hold</span><span class=\"o\">,</span> <span class=\"n\">cash</span> <span class=\"o\">-</span> <span class=\"n\">prices</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]);</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">cash</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of prices.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>, the space used by <code>cash</code> and <code>hold</code>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 713,
    "article_live": true,
    "article_slug": "subarray-product-less-than-k",
    "title": "Subarray Product Less Than K",
    "title_slug": "subarray-product-less-than-k",
    "content": "<p>Your are given an array of positive integers <code>nums</code>.</p>\r\n<p>Count and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than <code>k</code>.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> nums = [10, 5, 2, 6], k = 100\r\n<b>Output:</b> 8\r\n<b>Explanation:</b> The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6].\r\nNote that [10, 5, 2] is not included as the product of 100 is not strictly less than k.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\n<li><code>0 < nums.length <= 50000</code>.</li>\r\n<li><code>0 < nums[i] < 1000</code>.</li>\r\n<li><code>0 <= k < 10^6</code>.</li>\r\n</p>",
    "tags": "Array, Two Pointers",
    "difficulty": 2,
    "frontend_article_id": 713,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-binary-search-on-logarithms-accepted\">Approach #1: Binary Search on Logarithms [Accepted]</a></li> \n    <li><a href=\"#approach-2-sliding-window-accepted\">Approach #2: Sliding Window [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-binary-search-on-logarithms-accepted\">Approach #1: Binary Search on Logarithms [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Because <script type=\"math/tex; mode=display\">\\log(\\prod_i x_i) = \\sum_i \\log x_i</script>, we can reduce the problem to subarray <em>sums</em> instead of subarray products. The motivation for this is that the product of some arbitrary subarray may be way too large (potentially <code>1000^50000</code>), and also dealing with sums gives us some more familiarity as it becomes similar to other problems we may have solved before.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>After this transformation where every value <code>x</code> becomes <code>log(x)</code>, let us take prefix sums <code>prefix[i+1] = nums[0] + nums[1] + ... + nums[i]</code>. Now we are left with the problem of finding, for each <code>i</code>, the largest <code>j</code> so that <code>nums[i] + ... + nums[j] = prefix[j] - prefix[i] &lt; k</code>.</p> \n  <p>Because <code>prefix</code> is a monotone increasing array, this can be solved with binary search. We add the width of the interval <code>[i, j]</code> to our answer, which counts all subarrays <code>[i, k]</code> with <code>k &lt;= j</code>.</p> \n  <p><strong>Python</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">numSubarrayProductLessThanK</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">nums</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"n\">k</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">:</span> <span class=\"k\">return</span> <span class=\"mi\">0</span>\n        <span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"n\">math</span><span class=\"o\">.</span><span class=\"n\">log</span><span class=\"p\">(</span><span class=\"n\">k</span><span class=\"p\">)</span>\n\n        <span class=\"n\">prefix</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n        <span class=\"k\">for</span> <span class=\"n\">x</span> <span class=\"ow\">in</span> <span class=\"n\">nums</span><span class=\"p\">:</span>\n            <span class=\"n\">prefix</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">prefix</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">math</span><span class=\"o\">.</span><span class=\"n\">log</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">))</span>\n\n        <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n        <span class=\"k\">for</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">x</span> <span class=\"ow\">in</span> <span class=\"nb\">enumerate</span><span class=\"p\">(</span><span class=\"n\">prefix</span><span class=\"p\">):</span>\n            <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">bisect</span><span class=\"o\">.</span><span class=\"n\">bisect</span><span class=\"p\">(</span><span class=\"n\">prefix</span><span class=\"p\">,</span> <span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">k</span> <span class=\"o\">-</span> <span class=\"mf\">1e-9</span><span class=\"p\">,</span> <span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n            <span class=\"n\">ans</span> <span class=\"o\">+=</span> <span class=\"n\">j</span> <span class=\"o\">-</span> <span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span>\n        <span class=\"k\">return</span> <span class=\"n\">ans</span>\n</pre>\n  </div> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">numSubarrayProductLessThanK</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n        <span class=\"kt\">double</span> <span class=\"n\">logk</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">log</span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"o\">);</span>\n        <span class=\"kt\">double</span><span class=\"o\">[]</span> <span class=\"n\">prefix</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">double</span><span class=\"o\">[</span><span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">];</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"n\">prefix</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">prefix</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">+</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">log</span><span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]);</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"kt\">int</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">prefix</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"kt\">int</span> <span class=\"n\">lo</span> <span class=\"o\">=</span> <span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">hi</span> <span class=\"o\">=</span> <span class=\"n\">prefix</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span>\n            <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">lo</span> <span class=\"o\">&lt;</span> <span class=\"n\">hi</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"kt\">int</span> <span class=\"n\">mi</span> <span class=\"o\">=</span> <span class=\"n\">lo</span> <span class=\"o\">+</span> <span class=\"o\">(</span><span class=\"n\">hi</span> <span class=\"o\">-</span> <span class=\"n\">lo</span><span class=\"o\">)</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"o\">;</span>\n                <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">prefix</span><span class=\"o\">[</span><span class=\"n\">mi</span><span class=\"o\">]</span> <span class=\"o\">&lt;</span> <span class=\"n\">prefix</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">+</span> <span class=\"n\">logk</span> <span class=\"o\">-</span> <span class=\"mf\">1e-9</span><span class=\"o\">)</span> <span class=\"n\">lo</span> <span class=\"o\">=</span> <span class=\"n\">mi</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">;</span>\n                <span class=\"k\">else</span> <span class=\"n\">hi</span> <span class=\"o\">=</span> <span class=\"n\">mi</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span>\n            <span class=\"n\">ans</span> <span class=\"o\">+=</span> <span class=\"n\">lo</span> <span class=\"o\">-</span> <span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">ans</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N\\log N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>nums</code>. Inside our for loop, each binary search operation takes <script type=\"math/tex; mode=display\">O(\\log N)</script> time.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the space used by <code>prefix</code>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-sliding-window-accepted\">Approach #2: Sliding Window [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>For each <code>right</code>, call <code>opt(right)</code> the smallest <code>left</code> so that the product of the subarray <code>nums[left] * nums[left + 1] * ... * nums[right]</code> is less than <code>k</code>. <code>opt</code> is a monotone increasing function, so we can use a sliding window.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Our loop invariant is that <code>left</code> is the smallest value so that the product in the window <code>prod = nums[left] * nums[left + 1] * ... * nums[right]</code> is less than <code>k</code>.</p> \n  <p>For every right, we update <code>left</code> and <code>prod</code> to maintain this invariant. Then, the number of intervals with subarray product less than <code>k</code> and with right-most coordinate <code>right</code>, is <code>right - left + 1</code>. We'll count all of these for each value of <code>right</code>.</p> \n  <p><strong>Python</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">numSubarrayProductLessThanK</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">nums</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"n\">k</span> <span class=\"o\">&lt;=</span> <span class=\"mi\">1</span><span class=\"p\">:</span> <span class=\"k\">return</span> <span class=\"mi\">0</span>\n        <span class=\"n\">prod</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n        <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"n\">left</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n        <span class=\"k\">for</span> <span class=\"n\">right</span><span class=\"p\">,</span> <span class=\"n\">val</span> <span class=\"ow\">in</span> <span class=\"nb\">enumerate</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">):</span>\n            <span class=\"n\">prod</span> <span class=\"o\">*=</span> <span class=\"n\">val</span>\n            <span class=\"k\">while</span> <span class=\"n\">prod</span> <span class=\"o\">&gt;=</span> <span class=\"n\">k</span><span class=\"p\">:</span>\n                <span class=\"n\">prod</span> <span class=\"o\">/=</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">left</span><span class=\"p\">]</span>\n                <span class=\"n\">left</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n            <span class=\"n\">ans</span> <span class=\"o\">+=</span> <span class=\"n\">right</span> <span class=\"o\">-</span> <span class=\"n\">left</span> <span class=\"o\">+</span> <span class=\"mi\">1</span>\n        <span class=\"k\">return</span> <span class=\"n\">ans</span>\n</pre>\n  </div> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">numSubarrayProductLessThanK</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">&lt;=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n        <span class=\"kt\">int</span> <span class=\"n\">prod</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">left</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">right</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">right</span> <span class=\"o\">&lt;</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">right</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"n\">prod</span> <span class=\"o\">*=</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">right</span><span class=\"o\">];</span>\n            <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">prod</span> <span class=\"o\">&gt;=</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"n\">prod</span> <span class=\"o\">/=</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">left</span><span class=\"o\">++];</span>\n            <span class=\"n\">ans</span> <span class=\"o\">+=</span> <span class=\"n\">right</span> <span class=\"o\">-</span> <span class=\"n\">left</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">ans</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>nums</code>. <code>left</code> can only be incremented at most <code>N</code> times.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>, the space used by <code>prod</code>, <code>left</code>, and <code>ans</code>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 712,
    "article_live": true,
    "article_slug": "minimum-ascii-delete-sum-for-two-strings",
    "title": "Minimum ASCII Delete Sum for Two Strings",
    "title_slug": "minimum-ascii-delete-sum-for-two-strings",
    "content": "<p>Given two strings <code>s1, s2</code>, find the lowest ASCII sum of deleted characters to make two strings equal.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> s1 = \"sea\", s2 = \"eat\"\r\n<b>Output:</b> 231\r\n<b>Explanation:</b> Deleting \"s\" from \"sea\" adds the ASCII value of \"s\" (115) to the sum.\r\nDeleting \"t\" from \"eat\" adds 116 to the sum.\r\nAt the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> s1 = \"delete\", s2 = \"leet\"\r\n<b>Output:</b> 403\r\n<b>Explanation:</b> Deleting \"dee\" from \"delete\" to turn the string into \"let\",\r\nadds 100[d]+101[e]+101[e] to the sum.  Deleting \"e\" from \"leet\" adds 101[e] to the sum.\r\nAt the end, both strings are equal to \"let\", and the answer is 100+101+101+101 = 403.\r\nIf instead we turned both strings into \"lee\" or \"eet\", we would get answers of 433 or 417, which are higher.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\n<li><code>0 < s1.length, s2.length <= 1000</code>.</li>\r\n<li>All elements of each string will have an ASCII value in <code>[97, 122]</code>.</li> \r\n</p>",
    "tags": "Dynamic Programming",
    "difficulty": 2,
    "frontend_article_id": 712,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-dynamic-programming-accepted\">Approach #1: Dynamic Programming [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-dynamic-programming-accepted\">Approach #1: Dynamic Programming [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Let <code>dp[i][j]</code> be the answer to the problem for the strings <code>s1[i:], s2[j:]</code>.</p> \n  <p>When one of the input strings is empty, the answer is the ASCII-sum of the other string. We can calculate this cumulatively using code like <code>dp[i][s2.length()] = dp[i+1][s2.length()] + s1.codePointAt(i)</code>.</p> \n  <p>When <code>s1[i] == s2[j]</code>, we have <code>dp[i][j] = dp[i+1][j+1]</code> as we can ignore these two characters.</p> \n  <p>When <code>s1[i] != s2[j]</code>, we will have to delete at least one of them. We'll have <code>dp[i][j]</code> as the minimum of the answers after both deletion options.</p> \n  <p>The solutions presented will use <em>bottom-up</em> dynamic programming.</p> \n  <p><strong>Python</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">minimumDeleteSum</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">s1</span><span class=\"p\">,</span> <span class=\"n\">s2</span><span class=\"p\">):</span>\n        <span class=\"n\">dp</span> <span class=\"o\">=</span> <span class=\"p\">[[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">s2</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">_</span> <span class=\"ow\">in</span> <span class=\"nb\">xrange</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">s1</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)]</span>\n\n        <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">xrange</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">s1</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">):</span>\n            <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">s2</span><span class=\"p\">)]</span> <span class=\"o\">=</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">s2</span><span class=\"p\">)]</span> <span class=\"o\">+</span> <span class=\"nb\">ord</span><span class=\"p\">(</span><span class=\"n\">s1</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">])</span>\n        <span class=\"k\">for</span> <span class=\"n\">j</span> <span class=\"ow\">in</span> <span class=\"nb\">xrange</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">s2</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">):</span>\n            <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">s1</span><span class=\"p\">)][</span><span class=\"n\">j</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">s1</span><span class=\"p\">)][</span><span class=\"n\">j</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"nb\">ord</span><span class=\"p\">(</span><span class=\"n\">s2</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">])</span>\n\n        <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">xrange</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">s1</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">):</span>\n            <span class=\"k\">for</span> <span class=\"n\">j</span> <span class=\"ow\">in</span> <span class=\"nb\">xrange</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">s2</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">):</span>\n                <span class=\"k\">if</span> <span class=\"n\">s1</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"n\">s2</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">]:</span>\n                    <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"n\">j</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"n\">j</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n                <span class=\"k\">else</span><span class=\"p\">:</span>\n                    <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"n\">j</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nb\">min</span><span class=\"p\">(</span><span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"n\">j</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"nb\">ord</span><span class=\"p\">(</span><span class=\"n\">s1</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]),</span>\n                                   <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"n\">j</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"nb\">ord</span><span class=\"p\">(</span><span class=\"n\">s2</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">]))</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n</pre>\n  </div> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">minimumDeleteSum</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">s1</span><span class=\"o\">,</span> <span class=\"n\">String</span> <span class=\"n\">s2</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span><span class=\"o\">[][]</span> <span class=\"n\">dp</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">s1</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">][</span><span class=\"n\">s2</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">];</span>\n\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">s1</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">--)</span> <span class=\"o\">{</span>\n            <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">][</span><span class=\"n\">s2</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()]</span> <span class=\"o\">=</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"o\">][</span><span class=\"n\">s2</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()]</span> <span class=\"o\">+</span> <span class=\"n\">s1</span><span class=\"o\">.</span><span class=\"na\">codePointAt</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">s2</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">;</span> <span class=\"n\">j</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">j</span><span class=\"o\">--)</span> <span class=\"o\">{</span>\n            <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">s1</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()][</span><span class=\"n\">j</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">s1</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()][</span><span class=\"n\">j</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"o\">+</span> <span class=\"n\">s2</span><span class=\"o\">.</span><span class=\"na\">codePointAt</span><span class=\"o\">(</span><span class=\"n\">j</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">s1</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">--)</span> <span class=\"o\">{</span>\n            <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">s2</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">;</span> <span class=\"n\">j</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">j</span><span class=\"o\">--)</span> <span class=\"o\">{</span>\n                <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">s1</span><span class=\"o\">.</span><span class=\"na\">charAt</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">==</span> <span class=\"n\">s2</span><span class=\"o\">.</span><span class=\"na\">charAt</span><span class=\"o\">(</span><span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"o\">{</span>\n                    <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">][</span><span class=\"n\">j</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"o\">][</span><span class=\"n\">j</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"o\">];</span>\n                <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>\n                    <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">][</span><span class=\"n\">j</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">min</span><span class=\"o\">(</span><span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"o\">][</span><span class=\"n\">j</span><span class=\"o\">]</span> <span class=\"o\">+</span> <span class=\"n\">s1</span><span class=\"o\">.</span><span class=\"na\">codePointAt</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">),</span>\n                                        <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">][</span><span class=\"n\">j</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"o\">+</span> <span class=\"n\">s2</span><span class=\"o\">.</span><span class=\"na\">codePointAt</span><span class=\"o\">(</span><span class=\"n\">j</span><span class=\"o\">));</span>\n                <span class=\"o\">}</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">][</span><span class=\"mi\">0</span><span class=\"o\">];</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(M*N)</script>, where <script type=\"math/tex; mode=display\">M, N</script> are the lengths of the given strings. We use nested for loops: each loop is <script type=\"math/tex; mode=display\">O(M)</script> and <script type=\"math/tex; mode=display\">O(N)</script> respectively.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(M*N)</script>, the space used by <code>dp</code>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 711,
    "article_live": true,
    "article_slug": "number-of-distinct-islands-ii",
    "title": "Number of Distinct Islands II",
    "title_slug": "number-of-distinct-islands-ii",
    "tags": "Hash Table, Depth-first Search",
    "difficulty": 3,
    "frontend_article_id": 711,
    "article_content": ""
},
{
    "frontend_question_id": 699,
    "article_live": true,
    "article_slug": "falling-squares",
    "title": "Falling Squares",
    "title_slug": "falling-squares",
    "content": "<p>On an infinite number line (x-axis), we drop given squares in the order they are given.</p>\r\n<p>The <code>i</code>-th square dropped (<code>positions[i] = (left, side_length)</code>) is a square with the left-most point being <code>positions[i][0]</code> and sidelength <code>positions[i][1]</code>.</p>\r\n<p>The square is dropped with the bottom edge parallel to the number line, and from a higher height than all currently landed squares.  We wait for each square to stick before dropping the next.</p>\r\n<p>The squares are infinitely sticky on their bottom edge, and will remain fixed to any positive length surface they touch (either the number line or another square).  Squares dropped adjacent to each other will not stick together prematurely.</p>\r\n\r\n<br>\r\n<p>Return a list <code>ans</code> of heights.  Each height <code>ans[i]</code> represents the current highest height of any square we have dropped, after dropping squares represented by <code>positions[0], positions[1], ..., positions[i]</code>.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [[1, 2], [2, 3], [6, 1]]\r\n<b>Output:</b> [2, 5, 5]\r\n<b>Explanation:</b>\r\n<p>\r\nAfter the first drop of <code>positions[0] = [1, 2]:\r\n_aa\r\n_aa\r\n-------\r\n</code>The maximum height of any square is 2.\r\n</p><p>\r\nAfter the second drop of <code>positions[1] = [2, 3]:\r\n__aaa\r\n__aaa\r\n__aaa\r\n_aa__\r\n_aa__\r\n--------------\r\n</code>The maximum height of any square is 5.  \r\nThe larger square stays on top of the smaller square despite where its center\r\nof gravity is, because squares are infinitely sticky on their bottom edge.\r\n</p><p>\r\nAfter the third drop of <code>positions[1] = [6, 1]:\r\n__aaa\r\n__aaa\r\n__aaa\r\n_aa\r\n_aa___a\r\n--------------\r\n</code>The maximum height of any square is still 5.\r\n\r\nThus, we return an answer of <code>[2, 5, 5]</code>.\r\n</pre>\r\n</p>\r\n\r\n<br>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> [[100, 100], [200, 100]]\r\n<b>Output:</b> [100, 100]\r\n<b>Explanation:</b> Adjacent squares don't get stuck prematurely - only their bottom edge can stick to surfaces.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\n<li><code>1 <= positions.length <= 1000</code>.</li>\r\n<li><code>1 <= positions[i][0] <= 10^8</code>.</li>\r\n<li><code>1 <= positions[i][1] <= 10^6</code>.</li>\r\n</p>",
    "tags": "Segment Tree, Binary Search Tree",
    "difficulty": 3,
    "frontend_article_id": 699,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-framework\">Approach Framework</a></li> \n    <li><a href=\"#approach-1-offline-propagation-accepted\">Approach #1: Offline Propagation [Accepted]</a></li> \n    <li><a href=\"#approach-2-brute-force-with-coordinate-compression-accepted\">Approach #2: Brute Force with Coordinate Compression [Accepted]</a></li> \n    <li><a href=\"#approach-3-block-square-root-decomposition-accepted\">Approach #3: Block (Square Root) Decomposition [Accepted]</a></li> \n    <li><a href=\"#approach-4-segment-tree-with-lazy-propagation-accepted\">Approach #4: Segment Tree with Lazy Propagation [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-framework\">Approach Framework</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Intuitively, there are two operations: <code>update</code>, which updates our notion of the board (number line) after dropping a square; and <code>query</code>, which finds the largest height in the current board on some interval. We will work on implementing these operations.</p> \n  <p><strong>Coordinate Compression</strong></p> \n  <p>In the below approaches, since there are only up to <code>2 * len(positions)</code> critical points, namely the left and right edges of each square, we can use a technique called <em>coordinate compression</em> to map these critical points to adjacent integers, as shown in the code snippets below. </p> \n  <p>For brevity, these snippets are omitted from the remaining solutions.</p> \n  <p><strong>Python</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"n\">coords</span> <span class=\"o\">=</span> <span class=\"nb\">set</span><span class=\"p\">()</span>\n<span class=\"k\">for</span> <span class=\"n\">left</span><span class=\"p\">,</span> <span class=\"n\">size</span> <span class=\"ow\">in</span> <span class=\"n\">positions</span><span class=\"p\">:</span>\n    <span class=\"n\">coords</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">left</span><span class=\"p\">)</span>\n    <span class=\"n\">coords</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">left</span> <span class=\"o\">+</span> <span class=\"n\">size</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"n\">index</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">i</span> <span class=\"k\">for</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">x</span> <span class=\"ow\">in</span> <span class=\"nb\">enumerate</span><span class=\"p\">(</span><span class=\"nb\">sorted</span><span class=\"p\">(</span><span class=\"n\">coords</span><span class=\"p\">))}</span>\n</pre>\n  </div> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"n\">Set</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">coords</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HashSet</span><span class=\"o\">();</span>\n<span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">pos</span><span class=\"o\">:</span> <span class=\"n\">positions</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">coords</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">pos</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]);</span>\n    <span class=\"n\">coords</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">pos</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"o\">+</span> <span class=\"n\">pos</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n<span class=\"o\">}</span>\n<span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">sortedCoords</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">(</span><span class=\"n\">coords</span><span class=\"o\">);</span>\n<span class=\"n\">Collections</span><span class=\"o\">.</span><span class=\"na\">sort</span><span class=\"o\">(</span><span class=\"n\">sortedCoords</span><span class=\"o\">);</span>\n\n<span class=\"n\">Map</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">,</span> <span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">index</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HashMap</span><span class=\"o\">();</span>\n<span class=\"kt\">int</span> <span class=\"n\">t</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n<span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">coord</span><span class=\"o\">:</span> <span class=\"n\">sortedCoords</span><span class=\"o\">)</span> <span class=\"n\">index</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"n\">coord</span><span class=\"o\">,</span> <span class=\"n\">t</span><span class=\"o\">++);</span>\n</pre>\n  </div> \n  <hr> \n  <h4 id=\"approach-1-offline-propagation-accepted\">Approach #1: Offline Propagation [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Instead of asking the question \"what squares affect this query?\", lets ask the question \"what queries are affected by this square?\"</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Let <code>qans[i]</code> be the maximum height of the interval specified by <code>positions[i]</code>. At the end, we'll return a running max of <code>qans</code>.</p> \n  <p>For each square <code>positions[i]</code>, the maximum height will get higher by the size of the square we drop. Then, for any future squares that intersect the interval <code>[left, right)</code> (where <code>left = positions[i][0], right = positions[i][0] + positions[i][1]</code>), we'll update the maximum height of that interval.</p> \n  <p><strong>Python</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">fallingSquares</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">positions</span><span class=\"p\">):</span>\n        <span class=\"n\">qans</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">positions</span><span class=\"p\">)</span>\n        <span class=\"k\">for</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">left</span><span class=\"p\">,</span> <span class=\"n\">size</span><span class=\"p\">)</span> <span class=\"ow\">in</span> <span class=\"nb\">enumerate</span><span class=\"p\">(</span><span class=\"n\">positions</span><span class=\"p\">):</span>\n            <span class=\"n\">right</span> <span class=\"o\">=</span> <span class=\"n\">left</span> <span class=\"o\">+</span> <span class=\"n\">size</span>\n            <span class=\"n\">qans</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">+=</span> <span class=\"n\">size</span>\n            <span class=\"k\">for</span> <span class=\"n\">j</span> <span class=\"ow\">in</span> <span class=\"nb\">xrange</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">positions</span><span class=\"p\">)):</span>\n                <span class=\"n\">left2</span><span class=\"p\">,</span> <span class=\"n\">size2</span> <span class=\"o\">=</span> <span class=\"n\">positions</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">]</span>\n                <span class=\"n\">right2</span> <span class=\"o\">=</span> <span class=\"n\">left2</span> <span class=\"o\">+</span> <span class=\"n\">size2</span>\n                <span class=\"k\">if</span> <span class=\"n\">left2</span> <span class=\"o\">&lt;</span> <span class=\"n\">right</span> <span class=\"ow\">and</span> <span class=\"n\">left</span> <span class=\"o\">&lt;</span> <span class=\"n\">right2</span><span class=\"p\">:</span> <span class=\"c1\">#intersect</span>\n                    <span class=\"n\">qans</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">qans</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">],</span> <span class=\"n\">qans</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">])</span>\n\n        <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n        <span class=\"k\">for</span> <span class=\"n\">x</span> <span class=\"ow\">in</span> <span class=\"n\">qans</span><span class=\"p\">:</span>\n            <span class=\"n\">ans</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">ans</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"k\">if</span> <span class=\"n\">ans</span> <span class=\"k\">else</span> <span class=\"n\">x</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">ans</span>\n</pre>\n  </div> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"nf\">fallingSquares</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[][]</span> <span class=\"n\">positions</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">qans</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">positions</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">];</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">positions</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"kt\">int</span> <span class=\"n\">left</span> <span class=\"o\">=</span> <span class=\"n\">positions</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">][</span><span class=\"mi\">0</span><span class=\"o\">];</span>\n            <span class=\"kt\">int</span> <span class=\"n\">size</span> <span class=\"o\">=</span> <span class=\"n\">positions</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">][</span><span class=\"mi\">1</span><span class=\"o\">];</span>\n            <span class=\"kt\">int</span> <span class=\"n\">right</span> <span class=\"o\">=</span> <span class=\"n\">left</span> <span class=\"o\">+</span> <span class=\"n\">size</span><span class=\"o\">;</span>\n            <span class=\"n\">qans</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">+=</span> <span class=\"n\">size</span><span class=\"o\">;</span>\n\n            <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"o\">;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;</span> <span class=\"n\">positions</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">j</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n                <span class=\"kt\">int</span> <span class=\"n\">left2</span> <span class=\"o\">=</span> <span class=\"n\">positions</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">][</span><span class=\"mi\">0</span><span class=\"o\">];</span>\n                <span class=\"kt\">int</span> <span class=\"n\">size2</span> <span class=\"o\">=</span> <span class=\"n\">positions</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">][</span><span class=\"mi\">1</span><span class=\"o\">];</span>\n                <span class=\"kt\">int</span> <span class=\"n\">right2</span> <span class=\"o\">=</span> <span class=\"n\">left2</span> <span class=\"o\">+</span> <span class=\"n\">size2</span><span class=\"o\">;</span>\n                <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">left2</span> <span class=\"o\">&lt;</span> <span class=\"n\">right</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">left</span> <span class=\"o\">&lt;</span> <span class=\"n\">right2</span><span class=\"o\">)</span> <span class=\"o\">{</span> <span class=\"c1\">//intersect</span>\n                    <span class=\"n\">qans</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">qans</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">],</span> <span class=\"n\">qans</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]);</span>\n                <span class=\"o\">}</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">();</span>\n        <span class=\"kt\">int</span> <span class=\"n\">cur</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"o\">;</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">qans</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">cur</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">cur</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">);</span>\n            <span class=\"n\">ans</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">cur</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">ans</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>positions</code>. We use two for-loops, each of complexity <script type=\"math/tex; mode=display\">O(N)</script>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the space used by <code>qans</code> and <code>ans</code>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-brute-force-with-coordinate-compression-accepted\">Approach #2: Brute Force with Coordinate Compression [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Let <code>N = len(positions)</code>. After mapping the board to a board of length at most <script type=\"math/tex; mode=display\">2* N \\leq 2000</script>, we can brute force the answer by simulating each square's drop directly.</p> \n  <p>Our answer is either the current answer or the height of the square that was just dropped, and we'll update it appropriately.</p> \n  <p><strong>Python</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">fallingSquares</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">positions</span><span class=\"p\">):</span>\n        <span class=\"c1\">#Coordinate Compression</span>\n        <span class=\"c1\">#index = ...</span>\n\n        <span class=\"n\">heights</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">index</span><span class=\"p\">)</span>\n        <span class=\"k\">def</span> <span class=\"nf\">query</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">R</span><span class=\"p\">):</span>\n            <span class=\"k\">return</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">heights</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">xrange</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">R</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">))</span>\n\n        <span class=\"k\">def</span> <span class=\"nf\">update</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">R</span><span class=\"p\">,</span> <span class=\"n\">h</span><span class=\"p\">):</span>\n            <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">xrange</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">R</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">):</span>\n                <span class=\"n\">heights</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">heights</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">],</span> <span class=\"n\">h</span><span class=\"p\">)</span>\n\n        <span class=\"n\">best</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n        <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n        <span class=\"k\">for</span> <span class=\"n\">left</span><span class=\"p\">,</span> <span class=\"n\">size</span> <span class=\"ow\">in</span> <span class=\"n\">positions</span><span class=\"p\">:</span>\n            <span class=\"n\">L</span> <span class=\"o\">=</span> <span class=\"n\">index</span><span class=\"p\">[</span><span class=\"n\">left</span><span class=\"p\">]</span>\n            <span class=\"n\">R</span> <span class=\"o\">=</span> <span class=\"n\">index</span><span class=\"p\">[</span><span class=\"n\">left</span> <span class=\"o\">+</span> <span class=\"n\">size</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">]</span>\n            <span class=\"n\">h</span> <span class=\"o\">=</span> <span class=\"n\">query</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">R</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"n\">size</span>\n            <span class=\"n\">update</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">R</span><span class=\"p\">,</span> <span class=\"n\">h</span><span class=\"p\">)</span>\n            <span class=\"n\">best</span> <span class=\"o\">=</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">best</span><span class=\"p\">,</span> <span class=\"n\">h</span><span class=\"p\">)</span>\n            <span class=\"n\">ans</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">best</span><span class=\"p\">)</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">ans</span>\n</pre>\n  </div> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">heights</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">query</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">L</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">L</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;=</span> <span class=\"n\">R</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">ans</span><span class=\"o\">,</span> <span class=\"n\">heights</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]);</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">ans</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">update</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">L</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">L</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;=</span> <span class=\"n\">R</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"n\">heights</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">heights</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">],</span> <span class=\"n\">h</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"nf\">fallingSquares</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[][]</span> <span class=\"n\">positions</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">//Coordinate Compression</span>\n        <span class=\"c1\">//HashMap&lt;Integer, Integer&gt; index = ...;</span>\n        <span class=\"c1\">//int t = ...;</span>\n\n        <span class=\"n\">heights</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">t</span><span class=\"o\">];</span>\n        <span class=\"kt\">int</span> <span class=\"n\">best</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n        <span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">();</span>\n\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">pos</span><span class=\"o\">:</span> <span class=\"n\">positions</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kt\">int</span> <span class=\"n\">L</span> <span class=\"o\">=</span> <span class=\"n\">index</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">pos</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]);</span>\n            <span class=\"kt\">int</span> <span class=\"n\">R</span> <span class=\"o\">=</span> <span class=\"n\">index</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">pos</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"o\">+</span> <span class=\"n\">pos</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n            <span class=\"kt\">int</span> <span class=\"n\">h</span> <span class=\"o\">=</span> <span class=\"n\">query</span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"o\">,</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">+</span> <span class=\"n\">pos</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">];</span>\n            <span class=\"n\">update</span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"o\">,</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">);</span>\n            <span class=\"n\">best</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">best</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">);</span>\n            <span class=\"n\">ans</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">best</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">ans</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>positions</code>. We use two for-loops, each of complexity <script type=\"math/tex; mode=display\">O(N)</script> (because of coordinate compression.)</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the space used by <code>heights</code>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-block-square-root-decomposition-accepted\">Approach #3: Block (Square Root) Decomposition [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Whenever we perform operations (like <code>update</code> and <code>query</code>) on some interval in a domain, we could segment that domain with size <script type=\"math/tex; mode=display\">W</script> into blocks of size <script type=\"math/tex; mode=display\">\\sqrt{W}</script>. </p> \n  <p>Then, instead of a typical brute force where we update our array <code>heights</code> representing the board, we will also hold another array <code>blocks</code>, where <code>blocks[i]</code> represents the <script type=\"math/tex; mode=display\">B = \\lfloor \\sqrt{W} \\rfloor</script> elements <code>heights[B*i], heights[B*i + 1], ..., heights[B*i + B-1]</code>. This allows us to write to the array in <script type=\"math/tex; mode=display\">O(B)</script> operations.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Let's get into the details. We actually need another array, <code>blocks_read</code>. When we update some element <code>i</code> in block <code>b = i / B</code>, we'll also update <code>blocks_read[b]</code>. If later we want to read the entire block, we can read from here (and stuff written to the whole block in <code>blocks[b]</code>.)</p> \n  <p>When we write to a block, we'll write in <code>blocks[b]</code>. Later, when we want to read from an element <code>i</code> in block <code>b = i / B</code>, we'll read from <code>heights[i]</code> and <code>blocks[b]</code>.</p> \n  <p>Our process for managing <code>query</code> and <code>update</code> will be similar. While <code>left</code> isn't a multiple of <code>B</code>, we'll proceed with a brute-force-like approach, and similarly for <code>right</code>. At the end, <code>[left, right+1)</code> will represent a series of contiguous blocks: the interval will have length which is a multiple of <code>B</code>, and <code>left</code> will also be a multiple of <code>B</code>.</p> \n  <p><strong>Python</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">fallingSquares</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">positions</span><span class=\"p\">):</span>\n        <span class=\"c1\">#Coordinate compression</span>\n        <span class=\"c1\">#index = ...</span>\n\n        <span class=\"n\">W</span> <span class=\"o\">=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">index</span><span class=\"p\">)</span>\n        <span class=\"n\">B</span> <span class=\"o\">=</span> <span class=\"nb\">int</span><span class=\"p\">(</span><span class=\"n\">W</span><span class=\"o\">**.</span><span class=\"mi\">5</span><span class=\"p\">)</span>\n        <span class=\"n\">heights</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"n\">W</span>\n        <span class=\"n\">blocks</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">B</span><span class=\"o\">+</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n        <span class=\"n\">blocks_read</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">B</span><span class=\"o\">+</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n\n        <span class=\"k\">def</span> <span class=\"nf\">query</span><span class=\"p\">(</span><span class=\"n\">left</span><span class=\"p\">,</span> <span class=\"n\">right</span><span class=\"p\">):</span>\n            <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n            <span class=\"k\">while</span> <span class=\"n\">left</span> <span class=\"o\">%</span> <span class=\"n\">B</span> <span class=\"ow\">and</span> <span class=\"n\">left</span> <span class=\"o\">&lt;=</span> <span class=\"n\">right</span><span class=\"p\">:</span>\n                <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">ans</span><span class=\"p\">,</span> <span class=\"n\">heights</span><span class=\"p\">[</span><span class=\"n\">left</span><span class=\"p\">],</span> <span class=\"n\">blocks</span><span class=\"p\">[</span><span class=\"n\">left</span> <span class=\"o\">/</span> <span class=\"n\">B</span><span class=\"p\">])</span>\n                <span class=\"n\">left</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n            <span class=\"k\">while</span> <span class=\"n\">right</span> <span class=\"o\">%</span> <span class=\"n\">B</span> <span class=\"o\">!=</span> <span class=\"n\">B</span><span class=\"o\">-</span><span class=\"mi\">1</span> <span class=\"ow\">and</span> <span class=\"n\">left</span> <span class=\"o\">&lt;=</span> <span class=\"n\">right</span><span class=\"p\">:</span>\n                <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">ans</span><span class=\"p\">,</span> <span class=\"n\">heights</span><span class=\"p\">[</span><span class=\"n\">right</span><span class=\"p\">],</span> <span class=\"n\">blocks</span><span class=\"p\">[</span><span class=\"n\">right</span> <span class=\"o\">/</span> <span class=\"n\">B</span><span class=\"p\">])</span>\n                <span class=\"n\">right</span> <span class=\"o\">-=</span> <span class=\"mi\">1</span>\n            <span class=\"k\">while</span> <span class=\"n\">left</span> <span class=\"o\">&lt;=</span> <span class=\"n\">right</span><span class=\"p\">:</span>\n                <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">ans</span><span class=\"p\">,</span> <span class=\"n\">blocks</span><span class=\"p\">[</span><span class=\"n\">left</span> <span class=\"o\">/</span> <span class=\"n\">B</span><span class=\"p\">],</span> <span class=\"n\">blocks_read</span><span class=\"p\">[</span><span class=\"n\">left</span> <span class=\"o\">/</span> <span class=\"n\">B</span><span class=\"p\">])</span>\n                <span class=\"n\">left</span> <span class=\"o\">+=</span> <span class=\"n\">B</span>\n            <span class=\"k\">return</span> <span class=\"n\">ans</span>\n\n        <span class=\"k\">def</span> <span class=\"nf\">update</span><span class=\"p\">(</span><span class=\"n\">left</span><span class=\"p\">,</span> <span class=\"n\">right</span><span class=\"p\">,</span> <span class=\"n\">h</span><span class=\"p\">):</span>\n            <span class=\"k\">while</span> <span class=\"n\">left</span> <span class=\"o\">%</span> <span class=\"n\">B</span> <span class=\"ow\">and</span> <span class=\"n\">left</span> <span class=\"o\">&lt;=</span> <span class=\"n\">right</span><span class=\"p\">:</span>\n                <span class=\"n\">heights</span><span class=\"p\">[</span><span class=\"n\">left</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">heights</span><span class=\"p\">[</span><span class=\"n\">left</span><span class=\"p\">],</span> <span class=\"n\">h</span><span class=\"p\">)</span>\n                <span class=\"n\">blocks_read</span><span class=\"p\">[</span><span class=\"n\">left</span> <span class=\"o\">/</span> <span class=\"n\">B</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">blocks_read</span><span class=\"p\">[</span><span class=\"n\">left</span> <span class=\"o\">/</span> <span class=\"n\">B</span><span class=\"p\">],</span> <span class=\"n\">h</span><span class=\"p\">)</span>\n                <span class=\"n\">left</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n            <span class=\"k\">while</span> <span class=\"n\">right</span> <span class=\"o\">%</span> <span class=\"n\">B</span> <span class=\"o\">!=</span> <span class=\"n\">B</span><span class=\"o\">-</span><span class=\"mi\">1</span> <span class=\"ow\">and</span> <span class=\"n\">left</span> <span class=\"o\">&lt;=</span> <span class=\"n\">right</span><span class=\"p\">:</span>\n                <span class=\"n\">heights</span><span class=\"p\">[</span><span class=\"n\">right</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">heights</span><span class=\"p\">[</span><span class=\"n\">right</span><span class=\"p\">],</span> <span class=\"n\">h</span><span class=\"p\">)</span>\n                <span class=\"n\">blocks_read</span><span class=\"p\">[</span><span class=\"n\">right</span> <span class=\"o\">/</span> <span class=\"n\">B</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">blocks_read</span><span class=\"p\">[</span><span class=\"n\">right</span> <span class=\"o\">/</span> <span class=\"n\">B</span><span class=\"p\">],</span> <span class=\"n\">h</span><span class=\"p\">)</span>\n                <span class=\"n\">right</span> <span class=\"o\">-=</span> <span class=\"mi\">1</span>\n            <span class=\"k\">while</span> <span class=\"n\">left</span> <span class=\"o\">&lt;=</span> <span class=\"n\">right</span><span class=\"p\">:</span>\n                <span class=\"n\">blocks</span><span class=\"p\">[</span><span class=\"n\">left</span> <span class=\"o\">/</span> <span class=\"n\">B</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">blocks</span><span class=\"p\">[</span><span class=\"n\">left</span> <span class=\"o\">/</span> <span class=\"n\">B</span><span class=\"p\">],</span> <span class=\"n\">h</span><span class=\"p\">)</span>\n                <span class=\"n\">left</span> <span class=\"o\">+=</span> <span class=\"n\">B</span>\n\n        <span class=\"n\">best</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n        <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n        <span class=\"k\">for</span> <span class=\"n\">left</span><span class=\"p\">,</span> <span class=\"n\">size</span> <span class=\"ow\">in</span> <span class=\"n\">positions</span><span class=\"p\">:</span>\n            <span class=\"n\">L</span> <span class=\"o\">=</span> <span class=\"n\">index</span><span class=\"p\">[</span><span class=\"n\">left</span><span class=\"p\">]</span>\n            <span class=\"n\">R</span> <span class=\"o\">=</span> <span class=\"n\">index</span><span class=\"p\">[</span><span class=\"n\">left</span> <span class=\"o\">+</span> <span class=\"n\">size</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">]</span>\n            <span class=\"n\">h</span> <span class=\"o\">=</span> <span class=\"n\">query</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">R</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"n\">size</span>\n            <span class=\"n\">update</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">R</span><span class=\"p\">,</span> <span class=\"n\">h</span><span class=\"p\">)</span>\n            <span class=\"n\">best</span> <span class=\"o\">=</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">best</span><span class=\"p\">,</span> <span class=\"n\">h</span><span class=\"p\">)</span>\n            <span class=\"n\">ans</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">best</span><span class=\"p\">)</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">ans</span>\n</pre>\n  </div> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">heights</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">blocks</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">blocks_read</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">B</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">query</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">right</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">left</span> <span class=\"o\">%</span> <span class=\"n\">B</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">left</span> <span class=\"o\">&lt;=</span> <span class=\"n\">right</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">ans</span><span class=\"o\">,</span> <span class=\"n\">heights</span><span class=\"o\">[</span><span class=\"n\">left</span><span class=\"o\">]);</span>\n            <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">ans</span><span class=\"o\">,</span> <span class=\"n\">blocks</span><span class=\"o\">[</span><span class=\"n\">left</span> <span class=\"o\">/</span> <span class=\"n\">B</span><span class=\"o\">]);</span>\n            <span class=\"n\">left</span><span class=\"o\">++;</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">right</span> <span class=\"o\">%</span> <span class=\"n\">B</span> <span class=\"o\">!=</span> <span class=\"n\">B</span> <span class=\"o\">-</span> <span class=\"mi\">1</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">left</span> <span class=\"o\">&lt;=</span> <span class=\"n\">right</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">ans</span><span class=\"o\">,</span> <span class=\"n\">heights</span><span class=\"o\">[</span><span class=\"n\">right</span><span class=\"o\">]);</span>\n            <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">ans</span><span class=\"o\">,</span> <span class=\"n\">blocks</span><span class=\"o\">[</span><span class=\"n\">right</span> <span class=\"o\">/</span> <span class=\"n\">B</span><span class=\"o\">]);</span>\n            <span class=\"n\">right</span><span class=\"o\">--;</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">left</span> <span class=\"o\">&lt;=</span> <span class=\"n\">right</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">ans</span><span class=\"o\">,</span> <span class=\"n\">blocks</span><span class=\"o\">[</span><span class=\"n\">left</span> <span class=\"o\">/</span> <span class=\"n\">B</span><span class=\"o\">]);</span>\n            <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">ans</span><span class=\"o\">,</span> <span class=\"n\">blocks_read</span><span class=\"o\">[</span><span class=\"n\">left</span> <span class=\"o\">/</span> <span class=\"n\">B</span><span class=\"o\">]);</span>\n            <span class=\"n\">left</span> <span class=\"o\">+=</span> <span class=\"n\">B</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">ans</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">update</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">left</span> <span class=\"o\">%</span> <span class=\"n\">B</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">left</span> <span class=\"o\">&lt;=</span> <span class=\"n\">right</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">heights</span><span class=\"o\">[</span><span class=\"n\">left</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">heights</span><span class=\"o\">[</span><span class=\"n\">left</span><span class=\"o\">],</span> <span class=\"n\">h</span><span class=\"o\">);</span>\n            <span class=\"n\">blocks_read</span><span class=\"o\">[</span><span class=\"n\">left</span> <span class=\"o\">/</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">blocks_read</span><span class=\"o\">[</span><span class=\"n\">left</span> <span class=\"o\">/</span> <span class=\"n\">B</span><span class=\"o\">],</span> <span class=\"n\">h</span><span class=\"o\">);</span>\n            <span class=\"n\">left</span><span class=\"o\">++;</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">right</span> <span class=\"o\">%</span> <span class=\"n\">B</span> <span class=\"o\">!=</span> <span class=\"n\">B</span> <span class=\"o\">-</span> <span class=\"mi\">1</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">left</span> <span class=\"o\">&lt;=</span> <span class=\"n\">right</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">heights</span><span class=\"o\">[</span><span class=\"n\">right</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">heights</span><span class=\"o\">[</span><span class=\"n\">right</span><span class=\"o\">],</span> <span class=\"n\">h</span><span class=\"o\">);</span>\n            <span class=\"n\">blocks_read</span><span class=\"o\">[</span><span class=\"n\">right</span> <span class=\"o\">/</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">blocks_read</span><span class=\"o\">[</span><span class=\"n\">right</span> <span class=\"o\">/</span> <span class=\"n\">B</span><span class=\"o\">],</span> <span class=\"n\">h</span><span class=\"o\">);</span>\n            <span class=\"n\">right</span><span class=\"o\">--;</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">left</span> <span class=\"o\">&lt;=</span> <span class=\"n\">right</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">blocks</span><span class=\"o\">[</span><span class=\"n\">left</span> <span class=\"o\">/</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">blocks</span><span class=\"o\">[</span><span class=\"n\">left</span> <span class=\"o\">/</span> <span class=\"n\">B</span><span class=\"o\">],</span> <span class=\"n\">h</span><span class=\"o\">);</span>\n            <span class=\"n\">left</span> <span class=\"o\">+=</span> <span class=\"n\">B</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"nf\">fallingSquares</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[][]</span> <span class=\"n\">positions</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">//Coordinate Compression</span>\n        <span class=\"c1\">//HashMap&lt;Integer, Integer&gt; index = ...;</span>\n        <span class=\"c1\">//int t = ...;</span>\n\n        <span class=\"n\">heights</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">t</span><span class=\"o\">];</span>\n        <span class=\"n\">B</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">)</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">sqrt</span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"o\">);</span>\n        <span class=\"n\">blocks</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">B</span><span class=\"o\">+</span><span class=\"mi\">2</span><span class=\"o\">];</span>\n        <span class=\"n\">blocks_read</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">B</span><span class=\"o\">+</span><span class=\"mi\">2</span><span class=\"o\">];</span>\n\n        <span class=\"kt\">int</span> <span class=\"n\">best</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n        <span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">();</span>\n\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">pos</span><span class=\"o\">:</span> <span class=\"n\">positions</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kt\">int</span> <span class=\"n\">L</span> <span class=\"o\">=</span> <span class=\"n\">index</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">pos</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]);</span>\n            <span class=\"kt\">int</span> <span class=\"n\">R</span> <span class=\"o\">=</span> <span class=\"n\">index</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">pos</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"o\">+</span> <span class=\"n\">pos</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n            <span class=\"kt\">int</span> <span class=\"n\">h</span> <span class=\"o\">=</span> <span class=\"n\">query</span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"o\">,</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">+</span> <span class=\"n\">pos</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">];</span>\n            <span class=\"n\">update</span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"o\">,</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">);</span>\n            <span class=\"n\">best</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">best</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">);</span>\n            <span class=\"n\">ans</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">best</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">ans</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N\\sqrt{N})</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>positions</code>. Each <code>query</code> and <code>update</code> has complexity <script type=\"math/tex; mode=display\">O(\\sqrt{N})</script>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the space used by <code>heights</code>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-4-segment-tree-with-lazy-propagation-accepted\">Approach #4: Segment Tree with Lazy Propagation [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>If we were familiar with the idea of a segment tree (which supports queries and updates on intervals), we can immediately crack the problem. </p> \n  <p><strong>Algorithm</strong></p> \n  <p>Segment trees work by breaking intervals into a disjoint sum of component intervals, whose number is at most <code>log(width)</code>. The motivation is that when we change an element, we only need to change <code>log(width)</code> many intervals that aggregate on an interval containing that element.</p> \n  <p>When we want to update an interval all at once, we need to use <em>lazy propagation</em> to ensure good run-time complexity. This topic is covered in more depth <a href=\"https://leetcode.com/articles/recursive-approach-segment-trees-range-sum-queries-lazy-propagation/\">here</a>.</p> \n  <p>With such an implementation in hand, the problem falls out immediately.</p> \n  <p><strong>Python</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"k\">class</span> <span class=\"nc\">SegmentTree</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">N</span><span class=\"p\">,</span> <span class=\"n\">update_fn</span><span class=\"p\">,</span> <span class=\"n\">query_fn</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">N</span> <span class=\"o\">=</span> <span class=\"n\">N</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">H</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n        <span class=\"k\">while</span> <span class=\"mi\">1</span> <span class=\"o\">&lt;&lt;</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">H</span> <span class=\"o\">&lt;</span> <span class=\"n\">N</span><span class=\"p\">:</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">H</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">update_fn</span> <span class=\"o\">=</span> <span class=\"n\">update_fn</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">query_fn</span> <span class=\"o\">=</span> <span class=\"n\">query_fn</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">tree</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">N</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">lazy</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"n\">N</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">_apply</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">val</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">tree</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">update_fn</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">tree</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">],</span> <span class=\"n\">val</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"o\">&lt;</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">N</span><span class=\"p\">:</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">lazy</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">update_fn</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">lazy</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">],</span> <span class=\"n\">val</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">_pull</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">):</span>\n        <span class=\"k\">while</span> <span class=\"n\">x</span> <span class=\"o\">&gt;</span> <span class=\"mi\">1</span><span class=\"p\">:</span>\n            <span class=\"n\">x</span> <span class=\"o\">/=</span> <span class=\"mi\">2</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">tree</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">query_fn</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">tree</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"o\">*</span><span class=\"mi\">2</span><span class=\"p\">],</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">tree</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"o\">*</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">])</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">tree</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">update_fn</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">tree</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">],</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">lazy</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">])</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">_push</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">):</span>\n        <span class=\"k\">for</span> <span class=\"n\">h</span> <span class=\"ow\">in</span> <span class=\"nb\">xrange</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">H</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">):</span>\n            <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">x</span> <span class=\"o\">&gt;&gt;</span> <span class=\"n\">h</span>\n            <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">lazy</span><span class=\"p\">[</span><span class=\"n\">y</span><span class=\"p\">]:</span>\n                <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_apply</span><span class=\"p\">(</span><span class=\"n\">y</span> <span class=\"o\">*</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">lazy</span><span class=\"p\">[</span><span class=\"n\">y</span><span class=\"p\">])</span>\n                <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_apply</span><span class=\"p\">(</span><span class=\"n\">y</span> <span class=\"o\">*</span> <span class=\"mi\">2</span><span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">lazy</span><span class=\"p\">[</span><span class=\"n\">y</span><span class=\"p\">])</span>\n                <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">lazy</span><span class=\"p\">[</span><span class=\"n\">y</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">update</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">R</span><span class=\"p\">,</span> <span class=\"n\">h</span><span class=\"p\">):</span>\n        <span class=\"n\">L</span> <span class=\"o\">+=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">N</span>\n        <span class=\"n\">R</span> <span class=\"o\">+=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">N</span>\n        <span class=\"n\">L0</span><span class=\"p\">,</span> <span class=\"n\">R0</span> <span class=\"o\">=</span> <span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">R</span>\n        <span class=\"k\">while</span> <span class=\"n\">L</span> <span class=\"o\">&lt;=</span> <span class=\"n\">R</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"n\">L</span> <span class=\"o\">&amp;</span> <span class=\"mi\">1</span><span class=\"p\">:</span>\n                <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_apply</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">h</span><span class=\"p\">)</span>\n                <span class=\"n\">L</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n            <span class=\"k\">if</span> <span class=\"n\">R</span> <span class=\"o\">&amp;</span> <span class=\"mi\">1</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n                <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_apply</span><span class=\"p\">(</span><span class=\"n\">R</span><span class=\"p\">,</span> <span class=\"n\">h</span><span class=\"p\">)</span>\n                <span class=\"n\">R</span> <span class=\"o\">-=</span> <span class=\"mi\">1</span>\n            <span class=\"n\">L</span> <span class=\"o\">/=</span> <span class=\"mi\">2</span><span class=\"p\">;</span> <span class=\"n\">R</span> <span class=\"o\">/=</span> <span class=\"mi\">2</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_pull</span><span class=\"p\">(</span><span class=\"n\">L0</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_pull</span><span class=\"p\">(</span><span class=\"n\">R0</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">query</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">R</span><span class=\"p\">):</span>\n        <span class=\"n\">L</span> <span class=\"o\">+=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">N</span>\n        <span class=\"n\">R</span> <span class=\"o\">+=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">N</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_push</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">);</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_push</span><span class=\"p\">(</span><span class=\"n\">R</span><span class=\"p\">)</span>\n        <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n        <span class=\"k\">while</span> <span class=\"n\">L</span> <span class=\"o\">&lt;=</span> <span class=\"n\">R</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"n\">L</span> <span class=\"o\">&amp;</span> <span class=\"mi\">1</span><span class=\"p\">:</span>\n                <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">query_fn</span><span class=\"p\">(</span><span class=\"n\">ans</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">tree</span><span class=\"p\">[</span><span class=\"n\">L</span><span class=\"p\">])</span>\n                <span class=\"n\">L</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n            <span class=\"k\">if</span> <span class=\"n\">R</span> <span class=\"o\">&amp;</span> <span class=\"mi\">1</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n                <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">query_fn</span><span class=\"p\">(</span><span class=\"n\">ans</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">tree</span><span class=\"p\">[</span><span class=\"n\">R</span><span class=\"p\">])</span>\n                <span class=\"n\">R</span> <span class=\"o\">-=</span> <span class=\"mi\">1</span>\n            <span class=\"n\">L</span> <span class=\"o\">/=</span> <span class=\"mi\">2</span><span class=\"p\">;</span> <span class=\"n\">R</span> <span class=\"o\">/=</span> <span class=\"mi\">2</span>\n        <span class=\"k\">return</span> <span class=\"n\">ans</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">fallingSquares</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">positions</span><span class=\"p\">):</span>\n        <span class=\"c1\">#Coordinate compression</span>\n        <span class=\"c1\">#index = ...</span>\n\n        <span class=\"n\">tree</span> <span class=\"o\">=</span> <span class=\"n\">SegmentTree</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">index</span><span class=\"p\">),</span> <span class=\"nb\">max</span><span class=\"p\">,</span> <span class=\"nb\">max</span><span class=\"p\">)</span>\n        <span class=\"n\">best</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n        <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n        <span class=\"k\">for</span> <span class=\"n\">left</span><span class=\"p\">,</span> <span class=\"n\">size</span> <span class=\"ow\">in</span> <span class=\"n\">positions</span><span class=\"p\">:</span>\n            <span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">R</span> <span class=\"o\">=</span> <span class=\"n\">index</span><span class=\"p\">[</span><span class=\"n\">left</span><span class=\"p\">],</span> <span class=\"n\">index</span><span class=\"p\">[</span><span class=\"n\">left</span> <span class=\"o\">+</span> <span class=\"n\">size</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">]</span>\n            <span class=\"n\">h</span> <span class=\"o\">=</span> <span class=\"n\">tree</span><span class=\"o\">.</span><span class=\"n\">query</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">R</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"n\">size</span>\n            <span class=\"n\">tree</span><span class=\"o\">.</span><span class=\"n\">update</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">R</span><span class=\"p\">,</span> <span class=\"n\">h</span><span class=\"p\">)</span>\n            <span class=\"n\">best</span> <span class=\"o\">=</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">best</span><span class=\"p\">,</span> <span class=\"n\">h</span><span class=\"p\">)</span>\n            <span class=\"n\">ans</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">best</span><span class=\"p\">)</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">ans</span>\n</pre>\n  </div> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"nf\">fallingSquares</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[][]</span> <span class=\"n\">positions</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">//Coordinate Compression</span>\n        <span class=\"c1\">//HashMap&lt;Integer, Integer&gt; index = ...;</span>\n\n        <span class=\"n\">SegmentTree</span> <span class=\"n\">tree</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">SegmentTree</span><span class=\"o\">(</span><span class=\"n\">sortedCoords</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">());</span>\n        <span class=\"kt\">int</span> <span class=\"n\">best</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n        <span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">();</span>\n\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">pos</span><span class=\"o\">:</span> <span class=\"n\">positions</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kt\">int</span> <span class=\"n\">L</span> <span class=\"o\">=</span> <span class=\"n\">index</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">pos</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]);</span>\n            <span class=\"kt\">int</span> <span class=\"n\">R</span> <span class=\"o\">=</span> <span class=\"n\">index</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">pos</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"o\">+</span> <span class=\"n\">pos</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n            <span class=\"kt\">int</span> <span class=\"n\">h</span> <span class=\"o\">=</span> <span class=\"n\">tree</span><span class=\"o\">.</span><span class=\"na\">query</span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"o\">,</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">+</span> <span class=\"n\">pos</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">];</span>\n            <span class=\"n\">tree</span><span class=\"o\">.</span><span class=\"na\">update</span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"o\">,</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">);</span>\n            <span class=\"n\">best</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">best</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">);</span>\n            <span class=\"n\">ans</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">best</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">ans</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"nc\">SegmentTree</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">H</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">tree</span><span class=\"o\">,</span> <span class=\"n\">lazy</span><span class=\"o\">;</span>\n\n    <span class=\"n\">SegmentTree</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">N</span> <span class=\"o\">=</span> <span class=\"n\">N</span><span class=\"o\">;</span>\n        <span class=\"n\">H</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"o\">;</span>\n        <span class=\"k\">while</span> <span class=\"o\">((</span><span class=\"mi\">1</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">&lt;</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"n\">H</span><span class=\"o\">++;</span>\n        <span class=\"n\">tree</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">N</span><span class=\"o\">];</span>\n        <span class=\"n\">lazy</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">N</span><span class=\"o\">];</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">apply</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">tree</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">tree</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">],</span> <span class=\"n\">val</span><span class=\"o\">);</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">&lt;</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"n\">lazy</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">lazy</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">],</span> <span class=\"n\">val</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">pull</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">&gt;</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">x</span> <span class=\"o\">&gt;&gt;=</span> <span class=\"mi\">1</span><span class=\"o\">;</span>\n            <span class=\"n\">tree</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">tree</span><span class=\"o\">[</span><span class=\"n\">x</span> <span class=\"o\">*</span> <span class=\"mi\">2</span><span class=\"o\">],</span> <span class=\"n\">tree</span><span class=\"o\">[</span><span class=\"n\">x</span> <span class=\"o\">*</span> <span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">]);</span>\n            <span class=\"n\">tree</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">tree</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">],</span> <span class=\"n\">lazy</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]);</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">push</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">h</span> <span class=\"o\">=</span> <span class=\"n\">H</span><span class=\"o\">;</span> <span class=\"n\">h</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">h</span><span class=\"o\">--)</span> <span class=\"o\">{</span>\n            <span class=\"kt\">int</span> <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">x</span> <span class=\"o\">&gt;&gt;</span> <span class=\"n\">h</span><span class=\"o\">;</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">lazy</span><span class=\"o\">[</span><span class=\"n\">y</span><span class=\"o\">]</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"n\">apply</span><span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">*</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">lazy</span><span class=\"o\">[</span><span class=\"n\">y</span><span class=\"o\">]);</span>\n                <span class=\"n\">apply</span><span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">*</span> <span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">lazy</span><span class=\"o\">[</span><span class=\"n\">y</span><span class=\"o\">]);</span>\n                <span class=\"n\">lazy</span><span class=\"o\">[</span><span class=\"n\">y</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">update</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">L</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">L</span> <span class=\"o\">+=</span> <span class=\"n\">N</span><span class=\"o\">;</span> <span class=\"n\">R</span> <span class=\"o\">+=</span> <span class=\"n\">N</span><span class=\"o\">;</span>\n        <span class=\"kt\">int</span> <span class=\"n\">L0</span> <span class=\"o\">=</span> <span class=\"n\">L</span><span class=\"o\">,</span> <span class=\"n\">R0</span> <span class=\"o\">=</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">&lt;=</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"k\">if</span> <span class=\"o\">((</span><span class=\"n\">L</span> <span class=\"o\">&amp;</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">apply</span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"o\">++,</span> <span class=\"n\">h</span><span class=\"o\">);</span>\n            <span class=\"k\">if</span> <span class=\"o\">((</span><span class=\"n\">R</span> <span class=\"o\">&amp;</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"n\">apply</span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"o\">--,</span> <span class=\"n\">h</span><span class=\"o\">);</span>\n            <span class=\"n\">L</span> <span class=\"o\">&gt;&gt;=</span> <span class=\"mi\">1</span><span class=\"o\">;</span> <span class=\"n\">R</span> <span class=\"o\">&gt;&gt;=</span> <span class=\"mi\">1</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n        <span class=\"n\">pull</span><span class=\"o\">(</span><span class=\"n\">L0</span><span class=\"o\">);</span> <span class=\"n\">pull</span><span class=\"o\">(</span><span class=\"n\">R0</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">query</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">L</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">L</span> <span class=\"o\">+=</span> <span class=\"n\">N</span><span class=\"o\">;</span> <span class=\"n\">R</span> <span class=\"o\">+=</span> <span class=\"n\">N</span><span class=\"o\">;</span>\n        <span class=\"kt\">int</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n        <span class=\"n\">push</span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"o\">);</span> <span class=\"n\">push</span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"o\">);</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">&lt;=</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"k\">if</span> <span class=\"o\">((</span><span class=\"n\">L</span> <span class=\"o\">&amp;</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">ans</span><span class=\"o\">,</span> <span class=\"n\">tree</span><span class=\"o\">[</span><span class=\"n\">L</span><span class=\"o\">++]);</span>\n            <span class=\"k\">if</span> <span class=\"o\">((</span><span class=\"n\">R</span> <span class=\"o\">&amp;</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">ans</span><span class=\"o\">,</span> <span class=\"n\">tree</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">--]);</span>\n            <span class=\"n\">L</span> <span class=\"o\">&gt;&gt;=</span> <span class=\"mi\">1</span><span class=\"o\">;</span> <span class=\"n\">R</span> <span class=\"o\">&gt;&gt;=</span> <span class=\"mi\">1</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">ans</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N \\log N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>positions</code>. This is the run-time complexity of using a segment tree.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the space used by our tree.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 698,
    "article_live": true,
    "article_slug": "partition-to-k-equal-sum-subsets",
    "title": "Partition to K Equal Sum Subsets",
    "title_slug": "partition-to-k-equal-sum-subsets",
    "content": "<p>Given an array of integers <code>nums</code> and a positive integer <code>k</code>, find whether it's possible to divide this array into <code>k</code> non-empty subsets whose sums are all equal.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> nums = [4, 3, 2, 3, 5, 2, 1], k = 4\r\n<b>Output:</b> True\r\n<b>Explanation:</b> It's possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\n<li><code>1 <= k <= len(nums) <= 16</code>.</li>\r\n<li><code>0 < nums[i] < 10000</code>.</li>\r\n</p>",
    "tags": "Dynamic Programming, Recursion",
    "difficulty": 2,
    "frontend_article_id": 698,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-search-by-constructing-subset-sums-accepted\">Approach #1: Search by Constructing Subset Sums [Accepted]</a></li> \n    <li><a href=\"#approach-2-dynamic-programming-on-subsets-of-input-accepted\">Approach #2: Dynamic Programming on Subsets of Input [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-search-by-constructing-subset-sums-accepted\">Approach #1: Search by Constructing Subset Sums [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>As even when <code>k = 2</code>, the problem is a \"Subset Sum\" problem which is known to be NP-hard, (and because the given input limits are low,) our solution will focus on exhaustive search.</p> \n  <p>A natural approach is to simulate the <code>k</code> groups (disjoint subsets of nums). For each number in <code>nums</code>, we'll check whether putting it in the <code>i</code>-th group solves the problem. We can check those possibilities by recursively searching.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Firstly, we know that each of the <code>k</code> group-sums must be equal to <code>target = sum(nums) / k</code>. (If this quantity is not an integer, the task is impossible.)</p> \n  <p>For each number in <code>nums</code>, we could add it into one of <code>k</code> group-sums, as long as the group's sum would not exceed the <code>target</code>. For each of these choices, we recursively search with one less number to consider in <code>nums</code>. If we placed every number successfully, then our search was successful.</p> \n  <p>One important speedup is that we can ensure all the 0 values of each group occur at the end of the array <code>groups</code>, by enforcing <code>if (groups[i] == 0) break;</code>. This greatly reduces repeated work - for example, in the first run of search, we will make only 1 recursive call, instead of <code>k</code>. Actually, we could do better by skipping any repeated values of groups[i], but it isn't necessary.</p> \n  <p>Another speedup is we could sort the array <code>nums</code>, so that we try to place the largest elements first. When the answer is true and involves subsets with a low size, this method of placing elements will consider these lower size subsets sooner. We can also handle elements <code>nums[i] &gt;= target</code> appropriately. These tricks are not necessary to solve the problem, but they are presented in the solutions below.</p> \n  <p><strong>Python</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">canPartitionKSubsets</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">nums</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">):</span>\n        <span class=\"n\">target</span><span class=\"p\">,</span> <span class=\"n\">rem</span> <span class=\"o\">=</span> <span class=\"nb\">divmod</span><span class=\"p\">(</span><span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">),</span> <span class=\"n\">k</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"n\">rem</span><span class=\"p\">:</span> <span class=\"k\">return</span> <span class=\"bp\">False</span>\n\n        <span class=\"k\">def</span> <span class=\"nf\">search</span><span class=\"p\">(</span><span class=\"n\">groups</span><span class=\"p\">):</span>\n            <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">nums</span><span class=\"p\">:</span> <span class=\"k\">return</span> <span class=\"bp\">True</span>\n            <span class=\"n\">v</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"n\">pop</span><span class=\"p\">()</span>\n            <span class=\"k\">for</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">group</span> <span class=\"ow\">in</span> <span class=\"nb\">enumerate</span><span class=\"p\">(</span><span class=\"n\">groups</span><span class=\"p\">):</span>\n                <span class=\"k\">if</span> <span class=\"n\">group</span> <span class=\"o\">+</span> <span class=\"n\">v</span> <span class=\"o\">&lt;=</span> <span class=\"n\">target</span><span class=\"p\">:</span>\n                    <span class=\"n\">groups</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">+=</span> <span class=\"n\">v</span>\n                    <span class=\"k\">if</span> <span class=\"n\">search</span><span class=\"p\">(</span><span class=\"n\">groups</span><span class=\"p\">):</span> <span class=\"k\">return</span> <span class=\"bp\">True</span>\n                    <span class=\"n\">groups</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">-=</span> <span class=\"n\">v</span>\n                <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">group</span><span class=\"p\">:</span> <span class=\"k\">break</span>\n            <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">)</span>\n            <span class=\"k\">return</span> <span class=\"bp\">False</span>\n\n        <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"n\">sort</span><span class=\"p\">()</span>\n        <span class=\"k\">if</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">&gt;</span> <span class=\"n\">target</span><span class=\"p\">:</span> <span class=\"k\">return</span> <span class=\"bp\">False</span>\n        <span class=\"k\">while</span> <span class=\"n\">nums</span> <span class=\"ow\">and</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"n\">target</span><span class=\"p\">:</span>\n            <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"n\">pop</span><span class=\"p\">()</span>\n            <span class=\"n\">k</span> <span class=\"o\">-=</span> <span class=\"mi\">1</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">search</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"n\">k</span><span class=\"p\">)</span>\n</pre>\n  </div> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">search</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">groups</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">row</span><span class=\"o\">,</span> <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">target</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">row</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n        <span class=\"kt\">int</span> <span class=\"n\">v</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">row</span><span class=\"o\">--];</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">groups</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">groups</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">+</span> <span class=\"n\">v</span> <span class=\"o\">&lt;=</span> <span class=\"n\">target</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"n\">groups</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">+=</span> <span class=\"n\">v</span><span class=\"o\">;</span>\n                <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">search</span><span class=\"o\">(</span><span class=\"n\">groups</span><span class=\"o\">,</span> <span class=\"n\">row</span><span class=\"o\">,</span> <span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"n\">target</span><span class=\"o\">))</span> <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n                <span class=\"n\">groups</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">-=</span> <span class=\"n\">v</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">groups</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"k\">break</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">canPartitionKSubsets</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"n\">Arrays</span><span class=\"o\">.</span><span class=\"na\">stream</span><span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">).</span><span class=\"na\">sum</span><span class=\"o\">();</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">sum</span> <span class=\"o\">%</span> <span class=\"n\">k</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n        <span class=\"kt\">int</span> <span class=\"n\">target</span> <span class=\"o\">=</span> <span class=\"n\">sum</span> <span class=\"o\">/</span> <span class=\"n\">k</span><span class=\"o\">;</span>\n\n        <span class=\"n\">Arrays</span><span class=\"o\">.</span><span class=\"na\">sort</span><span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">);</span>\n        <span class=\"kt\">int</span> <span class=\"n\">row</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">;</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">row</span><span class=\"o\">]</span> <span class=\"o\">&gt;</span> <span class=\"n\">target</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">row</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">0</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">row</span><span class=\"o\">]</span> <span class=\"o\">==</span> <span class=\"n\">target</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">row</span><span class=\"o\">--;</span>\n            <span class=\"n\">k</span><span class=\"o\">--;</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">search</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">],</span> <span class=\"n\">row</span><span class=\"o\">,</span> <span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"n\">target</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(k^{N-k} k!)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>nums</code>, and <script type=\"math/tex; mode=display\">k</script> is as given. As we skip additional zeroes in <code>groups</code>, naively we will make <script type=\"math/tex; mode=display\">O(k!)</script> calls to <code>search</code>, then an additional <script type=\"math/tex; mode=display\">O(k^{N-k})</script> calls after every element of <code>groups</code> is nonzero.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the space used by recursive calls to <code>search</code> in our call stack.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-dynamic-programming-on-subsets-of-input-accepted\">Approach #2: Dynamic Programming on Subsets of Input [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>As in <em>Approach #1</em>, we investigate methods of exhaustive search, and find <code>target = sum(nums) / k</code> in the same way.</p> \n  <p>Let <code>used</code> have the <code>i</code>-th bit set if and only if <code>nums[i]</code> has already been used. Our goal is to use <code>nums</code> in some order so that placing them into groups in that order will be valid. <code>search(used, ...)</code> will answer the question: can we partition unused elements of <code>nums[i]</code> appropriately?</p> \n  <p>This will depend on <code>todo</code>, the sum of the remaining unused elements, not crossing multiples of <code>target</code> within one number. If for example our target is <code>10</code>, and our elements to be placed in order are <code>[6, 5, 5, 4]</code>, this would not work as <code>6 + 5</code> \"crosses\" <code>10</code> prematurely.</p> \n  <p>If we could choose the order, then after placing <code>5</code>, our unused elements are <code>[4, 5, 6]</code>. Using <code>6</code> would make <code>todo</code> go from <code>15</code> to <code>9</code>, which crosses <code>10</code> - something unwanted. However, we could use <code>5</code> since <code>todo</code> goes from <code>15</code> to <code>10</code>; then later we could use <code>4</code> and <code>6</code> as those placements do not cross.</p> \n  <p>It turns out the maximum value that can be chosen so as to not cross a multiple of <code>target</code>, is <code>targ = (todo - 1) % target + 1</code>. This is essentially <code>todo % target</code>, plus <code>target</code> if that would be zero.</p> \n  <p>Now for each unused number that doesn't cross, we'll search on that state, and we'll return <code>true</code> if any of those searches are <code>true</code>.</p> \n  <p>Notice that the state <code>todo</code> depends only on the state <code>used</code>, so when memoizing our search, we only need to make lookups by <code>used</code>.</p> \n  <p>In the solutions below, we present both a top-down dynamic programming solution, and a bottom-up one. The bottom-up solution uses a different notion of state.</p> \n  <p><strong>Python</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">canPartitionKSubsets</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">nums</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">):</span>\n        <span class=\"n\">target</span><span class=\"p\">,</span> <span class=\"n\">rem</span> <span class=\"o\">=</span> <span class=\"nb\">divmod</span><span class=\"p\">(</span><span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">),</span> <span class=\"n\">k</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"n\">rem</span> <span class=\"ow\">or</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"n\">target</span><span class=\"p\">:</span> <span class=\"k\">return</span> <span class=\"bp\">False</span>\n\n        <span class=\"n\">memo</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"bp\">None</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">&lt;&lt;</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">))</span>\n        <span class=\"n\">memo</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"bp\">True</span>\n        <span class=\"k\">def</span> <span class=\"nf\">search</span><span class=\"p\">(</span><span class=\"n\">used</span><span class=\"p\">,</span> <span class=\"n\">todo</span><span class=\"p\">):</span>\n            <span class=\"k\">if</span> <span class=\"n\">memo</span><span class=\"p\">[</span><span class=\"n\">used</span><span class=\"p\">]</span> <span class=\"ow\">is</span> <span class=\"bp\">None</span><span class=\"p\">:</span>\n                <span class=\"n\">targ</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">todo</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">%</span> <span class=\"n\">target</span> <span class=\"o\">+</span> <span class=\"mi\">1</span>\n                <span class=\"n\">memo</span><span class=\"p\">[</span><span class=\"n\">used</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nb\">any</span><span class=\"p\">(</span><span class=\"n\">search</span><span class=\"p\">(</span><span class=\"n\">used</span> <span class=\"o\">|</span> <span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"o\">&lt;&lt;</span><span class=\"n\">i</span><span class=\"p\">),</span> <span class=\"n\">todo</span> <span class=\"o\">-</span> <span class=\"n\">num</span><span class=\"p\">)</span>\n                                 <span class=\"k\">for</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">num</span> <span class=\"ow\">in</span> <span class=\"nb\">enumerate</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">)</span>\n                                 <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">used</span> <span class=\"o\">&gt;&gt;</span> <span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"o\">&amp;</span> <span class=\"mi\">1</span> <span class=\"o\">==</span> <span class=\"mi\">0</span> <span class=\"ow\">and</span> <span class=\"n\">num</span> <span class=\"o\">&lt;=</span> <span class=\"n\">targ</span><span class=\"p\">)</span>\n            <span class=\"k\">return</span> <span class=\"n\">memo</span><span class=\"p\">[</span><span class=\"n\">used</span><span class=\"p\">]</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">search</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">target</span> <span class=\"o\">*</span> <span class=\"n\">k</span><span class=\"p\">)</span>\n</pre>\n  </div> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">enum</span> <span class=\"n\">Result</span> <span class=\"o\">{</span> <span class=\"n\">TRUE</span><span class=\"o\">,</span> <span class=\"n\">FALSE</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"kt\">boolean</span> <span class=\"nf\">search</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">used</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">todo</span><span class=\"o\">,</span> <span class=\"n\">Result</span><span class=\"o\">[]</span> <span class=\"n\">memo</span><span class=\"o\">,</span> <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">target</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">memo</span><span class=\"o\">[</span><span class=\"n\">used</span><span class=\"o\">]</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">memo</span><span class=\"o\">[</span><span class=\"n\">used</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">Result</span><span class=\"o\">.</span><span class=\"na\">FALSE</span><span class=\"o\">;</span>\n            <span class=\"kt\">int</span> <span class=\"n\">targ</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">todo</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">%</span> <span class=\"n\">target</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">;</span>\n            <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n                <span class=\"k\">if</span> <span class=\"o\">((((</span><span class=\"n\">used</span> <span class=\"o\">&gt;&gt;</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">&amp;</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">&lt;=</span> <span class=\"n\">targ</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">search</span><span class=\"o\">(</span><span class=\"n\">used</span> <span class=\"o\">|</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">&lt;&lt;</span><span class=\"n\">i</span><span class=\"o\">),</span> <span class=\"n\">todo</span> <span class=\"o\">-</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">],</span> <span class=\"n\">memo</span><span class=\"o\">,</span> <span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"n\">target</span><span class=\"o\">))</span> <span class=\"o\">{</span>\n                        <span class=\"n\">memo</span><span class=\"o\">[</span><span class=\"n\">used</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">Result</span><span class=\"o\">.</span><span class=\"na\">TRUE</span><span class=\"o\">;</span>\n                        <span class=\"k\">break</span><span class=\"o\">;</span>\n                    <span class=\"o\">}</span>\n                <span class=\"o\">}</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">memo</span><span class=\"o\">[</span><span class=\"n\">used</span><span class=\"o\">]</span> <span class=\"o\">==</span> <span class=\"n\">Result</span><span class=\"o\">.</span><span class=\"na\">TRUE</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">canPartitionKSubsets</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"n\">Arrays</span><span class=\"o\">.</span><span class=\"na\">stream</span><span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">).</span><span class=\"na\">sum</span><span class=\"o\">();</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">sum</span> <span class=\"o\">%</span> <span class=\"n\">k</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n\n        <span class=\"n\">Result</span><span class=\"o\">[]</span> <span class=\"n\">memo</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Result</span><span class=\"o\">[</span><span class=\"mi\">1</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">];</span>\n        <span class=\"n\">memo</span><span class=\"o\">[(</span><span class=\"mi\">1</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">Result</span><span class=\"o\">.</span><span class=\"na\">TRUE</span><span class=\"o\">;</span>\n        <span class=\"k\">return</span> <span class=\"n\">search</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">sum</span><span class=\"o\">,</span> <span class=\"n\">memo</span><span class=\"o\">,</span> <span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"n\">sum</span> <span class=\"o\">/</span> <span class=\"n\">k</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><em>Bottom-Up Variation</em></p> \n  <p><strong>Python</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">canPartitionKSubsets</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">nums</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">):</span>\n        <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"n\">sort</span><span class=\"p\">()</span>\n        <span class=\"n\">target</span><span class=\"p\">,</span> <span class=\"n\">rem</span> <span class=\"o\">=</span> <span class=\"nb\">divmod</span><span class=\"p\">(</span><span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">),</span> <span class=\"n\">k</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"n\">rem</span> <span class=\"ow\">or</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">&gt;</span> <span class=\"n\">target</span><span class=\"p\">:</span> <span class=\"k\">return</span> <span class=\"bp\">False</span>\n\n        <span class=\"n\">dp</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"bp\">False</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">&lt;&lt;</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">))</span>\n        <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"bp\">True</span>\n        <span class=\"n\">total</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">&lt;&lt;</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">))</span>\n\n        <span class=\"k\">for</span> <span class=\"n\">state</span> <span class=\"ow\">in</span> <span class=\"nb\">xrange</span><span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">&lt;&lt;</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">)):</span>\n            <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">state</span><span class=\"p\">]:</span> <span class=\"k\">continue</span>\n            <span class=\"k\">for</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">num</span> <span class=\"ow\">in</span> <span class=\"nb\">enumerate</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">):</span>\n                <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">state</span> <span class=\"o\">|</span> <span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">i</span><span class=\"p\">)</span>\n                <span class=\"k\">if</span> <span class=\"n\">state</span> <span class=\"o\">!=</span> <span class=\"n\">future</span> <span class=\"ow\">and</span> <span class=\"ow\">not</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">future</span><span class=\"p\">]:</span>\n                    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">num</span> <span class=\"o\">&lt;=</span> <span class=\"n\">target</span> <span class=\"o\">-</span> <span class=\"p\">(</span><span class=\"n\">total</span><span class=\"p\">[</span><span class=\"n\">state</span><span class=\"p\">]</span> <span class=\"o\">%</span> <span class=\"n\">target</span><span class=\"p\">)):</span>\n                        <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">future</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"bp\">True</span>\n                        <span class=\"n\">total</span><span class=\"p\">[</span><span class=\"n\">future</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">total</span><span class=\"p\">[</span><span class=\"n\">state</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">num</span>\n                    <span class=\"k\">else</span><span class=\"p\">:</span>\n                        <span class=\"k\">break</span>\n        <span class=\"k\">return</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n</pre>\n  </div> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">canPartitionKSubsets</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">N</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span>\n        <span class=\"n\">Arrays</span><span class=\"o\">.</span><span class=\"na\">sort</span><span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">);</span>\n        <span class=\"kt\">int</span> <span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"n\">Arrays</span><span class=\"o\">.</span><span class=\"na\">stream</span><span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">).</span><span class=\"na\">sum</span><span class=\"o\">();</span>\n        <span class=\"kt\">int</span> <span class=\"n\">target</span> <span class=\"o\">=</span> <span class=\"n\">sum</span> <span class=\"o\">/</span> <span class=\"n\">k</span><span class=\"o\">;</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">sum</span> <span class=\"o\">%</span> <span class=\"n\">k</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span> <span class=\"o\">||</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">N</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"o\">&gt;</span> <span class=\"n\">target</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n\n        <span class=\"kt\">boolean</span><span class=\"o\">[]</span> <span class=\"n\">dp</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">boolean</span><span class=\"o\">[</span><span class=\"mi\">1</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">N</span><span class=\"o\">];</span>\n        <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n        <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">total</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"mi\">1</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">N</span><span class=\"o\">];</span>\n\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">state</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">state</span> <span class=\"o\">&lt;</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">N</span><span class=\"o\">);</span> <span class=\"n\">state</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"k\">if</span> <span class=\"o\">(!</span><span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">state</span><span class=\"o\">])</span> <span class=\"k\">continue</span><span class=\"o\">;</span>\n            <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">N</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n                <span class=\"kt\">int</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">state</span> <span class=\"o\">|</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">i</span><span class=\"o\">);</span>\n                <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">state</span> <span class=\"o\">!=</span> <span class=\"n\">future</span> <span class=\"o\">&amp;&amp;</span> <span class=\"o\">!</span><span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">future</span><span class=\"o\">])</span> <span class=\"o\">{</span>\n                    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">&lt;=</span> <span class=\"n\">target</span> <span class=\"o\">-</span> <span class=\"o\">(</span><span class=\"n\">total</span><span class=\"o\">[</span><span class=\"n\">state</span><span class=\"o\">]</span> <span class=\"o\">%</span> <span class=\"n\">target</span><span class=\"o\">))</span> <span class=\"o\">{</span>\n                        <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">future</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n                        <span class=\"n\">total</span><span class=\"o\">[</span><span class=\"n\">future</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">total</span><span class=\"o\">[</span><span class=\"n\">state</span><span class=\"o\">]</span> <span class=\"o\">+</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">];</span>\n                    <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>\n                        <span class=\"k\">break</span><span class=\"o\">;</span>\n                    <span class=\"o\">}</span>\n                <span class=\"o\">}</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">dp</span><span class=\"o\">[(</span><span class=\"mi\">1</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">];</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N * 2^N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>nums</code>. There are <script type=\"math/tex; mode=display\">2^N</script> states of <code>used</code> (or <code>state</code> in our bottom-up variant), and each state performs <code>O(N)</code> work searching through <code>nums</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(2^N)</script>, the space used by <code>memo</code> (or <code>dp</code>, <code>total</code> in our bottom-up variant).</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 697,
    "article_live": true,
    "article_slug": "degree-of-an-array",
    "title": "Degree of an Array",
    "title_slug": "degree-of-an-array",
    "content": "<p>Given a non-empty array of non-negative integers <code>nums</code>, the <b>degree</b> of this array is defined as the maximum frequency of any one of its elements.</p>\r\n<p>Your task is to find the smallest possible length of a (contiguous) subarray of <code>nums</code>, that has the same degree as <code>nums</code>.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [1, 2, 2, 3, 1]\r\n<b>Output:</b> 2\r\n<b>Explanation:</b> \r\nThe input array has a degree of 2 because both elements 1 and 2 appear twice.\r\nOf the subarrays that have the same degree:\r\n[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]\r\nThe shortest length is 2. So return 2.\r\n</pre>\r\n</p>\r\n\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> [1,2,2,3,1,4,2]\r\n<b>Output:</b> 6\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\n<li><code>nums.length</code> will be between 1 and 50,000.</li>\r\n<li><code>nums[i]</code> will be an integer between 0 and 49,999.</li>\r\n</p>",
    "tags": "Array",
    "difficulty": 1,
    "frontend_article_id": 697,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-left-and-right-index-accepted\">Approach #1: Left and Right Index [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-left-and-right-index-accepted\">Approach #1: Left and Right Index [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>An array that has degree <code>d</code>, must have some element <code>x</code> occur <code>d</code> times. If some subarray has the same degree, then some element <code>x</code> (that occured <code>d</code> times), still occurs <code>d</code> times. The shortest such subarray would be from the first occurrence of <code>x</code> until the last occurrence.</p> \n  <p>For each element in the given array, let's know <code>left</code>, the index of its first occurrence; and <code>right</code>, the index of its last occurrence. For example, with <code>nums = [1,2,3,2,5]</code> we have <code>left[2] = 1</code> and <code>right[2] = 3</code>.</p> \n  <p>Then, for each element <code>x</code> that occurs the maximum number of times, <code>right[x] - left[x] + 1</code> will be our candidate answer, and we'll take the minimum of those candidates.</p> \n  <p><strong>Python</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">findShortestSubArray</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">nums</span><span class=\"p\">):</span>\n        <span class=\"n\">left</span><span class=\"p\">,</span> <span class=\"n\">right</span><span class=\"p\">,</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"p\">{},</span> <span class=\"p\">{},</span> <span class=\"p\">{}</span>\n        <span class=\"k\">for</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">x</span> <span class=\"ow\">in</span> <span class=\"nb\">enumerate</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">):</span>\n            <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"n\">left</span><span class=\"p\">:</span> <span class=\"n\">left</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">i</span>\n            <span class=\"n\">right</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">i</span>\n            <span class=\"n\">count</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">count</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"mi\">1</span>\n\n        <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">)</span>\n        <span class=\"n\">degree</span> <span class=\"o\">=</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">count</span><span class=\"o\">.</span><span class=\"n\">values</span><span class=\"p\">())</span>\n        <span class=\"k\">for</span> <span class=\"n\">x</span> <span class=\"ow\">in</span> <span class=\"n\">count</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"n\">count</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"n\">degree</span><span class=\"p\">:</span>\n                <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"nb\">min</span><span class=\"p\">(</span><span class=\"n\">ans</span><span class=\"p\">,</span> <span class=\"n\">right</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"n\">left</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">ans</span>\n</pre>\n  </div> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">findShortestSubArray</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">Map</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">,</span> <span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">left</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HashMap</span><span class=\"o\">(),</span>\n            <span class=\"n\">right</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HashMap</span><span class=\"o\">(),</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HashMap</span><span class=\"o\">();</span>\n\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"kt\">int</span> <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">];</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">left</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"n\">left</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">);</span>\n            <span class=\"n\">right</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">);</span>\n            <span class=\"n\">count</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">count</span><span class=\"o\">.</span><span class=\"na\">getOrDefault</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"kt\">int</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span>\n        <span class=\"kt\">int</span> <span class=\"n\">degree</span> <span class=\"o\">=</span> <span class=\"n\">Collections</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">count</span><span class=\"o\">.</span><span class=\"na\">values</span><span class=\"o\">());</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">count</span><span class=\"o\">.</span><span class=\"na\">keySet</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">count</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">==</span> <span class=\"n\">degree</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">min</span><span class=\"o\">(</span><span class=\"n\">ans</span><span class=\"o\">,</span> <span class=\"n\">right</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">-</span> <span class=\"n\">left</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">ans</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>nums</code>. Every loop is through <script type=\"math/tex; mode=display\">O(N)</script> items with <script type=\"math/tex; mode=display\">O(1)</script> work inside the for-block.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the space used by <code>left</code>, <code>right</code>, and <code>count</code>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 696,
    "article_live": true,
    "article_slug": "count-binary-substrings",
    "title": "Count Binary Substrings",
    "title_slug": "count-binary-substrings",
    "content": "<p>Give a string <code>s</code>, count the number of non-empty (contiguous) substrings that have the same number of 0's and 1's, and all the 0's and all the 1's in these substrings are grouped consecutively. \r\n</p>\r\n<p>Substrings that occur multiple times are counted the number of times they occur.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \"00110011\"\r\n<b>Output:</b> 6\r\n<b>Explanation:</b> There are 6 substrings that have equal number of consecutive 1's and 0's: \"0011\", \"01\", \"1100\", \"10\", \"0011\", and \"01\".\r\n<br>Notice that some of these substrings repeat and are counted the number of times they occur.\r\n<br>Also, \"00110011\" is not a valid substring because <b>all</b> the 0's (and 1's) are not grouped together.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> \"10101\"\r\n<b>Output:</b> 4\r\n<b>Explanation:</b> There are 4 substrings: \"10\", \"01\", \"10\", \"01\" that have equal number of consecutive 1's and 0's.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\n<li><code>s.length</code> will be between 1 and 50,000.</li>\r\n<li><code>s</code> will only consist of \"0\" or \"1\" characters.</li>\r\n</p>",
    "tags": "String",
    "difficulty": 1,
    "frontend_article_id": 696,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-group-by-character-accepted\">Approach #1: Group By Character [Accepted]</a></li> \n    <li><a href=\"#approach-2-linear-scan-accepted\">Approach #2: Linear Scan [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-group-by-character-accepted\">Approach #1: Group By Character [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>We can convert the string <code>s</code> into an array <code>groups</code> that represents the length of same-character contiguous blocks within the string. For example, if <code>s = \"110001111000000\"</code>, then <code>groups = [2, 3, 4, 6]</code>.</p> \n  <p>For every binary string of the form <code>'0' * k + '1' * k</code> or <code>'1' * k + '0' * k</code>, the middle of this string must occur between two groups. </p> \n  <p>Let's try to count the number of valid binary strings between <code>groups[i]</code> and <code>groups[i+1]</code>. If we have <code>groups[i] = 2, groups[i+1] = 3</code>, then it represents either <code>\"00111\"</code> or <code>\"11000\"</code>. We clearly can make <code>min(groups[i], groups[i+1])</code> valid binary strings within this string. Because the binary digits to the left or right of this string must change at the boundary, our answer can never be larger.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Let's create <code>groups</code> as defined above. The first element of <code>s</code> belongs in it's own group. From then on, each element either doesn't match the previous element, so that it starts a new group of size 1; or it does match, so that the size of the most recent group increases by 1.</p> \n  <p>Afterwards, we will take the sum of <code>min(groups[i-1], groups[i])</code>.</p> \n  <p><strong>Python</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">countBinarySubstrings</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">s</span><span class=\"p\">):</span>\n        <span class=\"n\">groups</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n        <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">xrange</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">)):</span>\n            <span class=\"k\">if</span> <span class=\"n\">s</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">!=</span> <span class=\"n\">s</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]:</span>\n                <span class=\"n\">groups</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n            <span class=\"k\">else</span><span class=\"p\">:</span>\n                <span class=\"n\">groups</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n\n        <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n        <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">xrange</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">groups</span><span class=\"p\">)):</span>\n            <span class=\"n\">ans</span> <span class=\"o\">+=</span> <span class=\"nb\">min</span><span class=\"p\">(</span><span class=\"n\">groups</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">groups</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">])</span>\n        <span class=\"k\">return</span> <span class=\"n\">ans</span>\n</pre>\n  </div> \n  <p><em>Alternate Implentation</em></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">countBinarySubstrings</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">s</span><span class=\"p\">):</span>\n        <span class=\"n\">groups</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">))</span> <span class=\"k\">for</span> <span class=\"n\">_</span><span class=\"p\">,</span> <span class=\"n\">v</span> <span class=\"ow\">in</span> <span class=\"n\">itertools</span><span class=\"o\">.</span><span class=\"n\">groupby</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">)]</span>\n        <span class=\"k\">return</span> <span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"nb\">min</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span> <span class=\"ow\">in</span> <span class=\"nb\">zip</span><span class=\"p\">(</span><span class=\"n\">groups</span><span class=\"p\">,</span> <span class=\"n\">groups</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">:]))</span>\n</pre>\n  </div> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">countBinarySubstrings</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">groups</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">s</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()];</span>\n        <span class=\"kt\">int</span> <span class=\"n\">t</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n        <span class=\"n\">groups</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"o\">;</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">s</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">();</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">.</span><span class=\"na\">charAt</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">!=</span> <span class=\"n\">s</span><span class=\"o\">.</span><span class=\"na\">charAt</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">{</span>\n                <span class=\"n\">groups</span><span class=\"o\">[++</span><span class=\"n\">t</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>\n                <span class=\"n\">groups</span><span class=\"o\">[</span><span class=\"n\">t</span><span class=\"o\">]++;</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"kt\">int</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;=</span> <span class=\"n\">t</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"n\">ans</span> <span class=\"o\">+=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">min</span><span class=\"o\">(</span><span class=\"n\">groups</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"o\">],</span> <span class=\"n\">groups</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]);</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">ans</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>s</code>. Every loop is through <script type=\"math/tex; mode=display\">O(N)</script> items with <script type=\"math/tex; mode=display\">O(1)</script> work inside the for-block.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the space used by <code>groups</code>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-linear-scan-accepted\">Approach #2: Linear Scan [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>We can amend our <em>Approach #1</em> to calculate the answer on the fly. Instead of storing <code>groups</code>, we will remember only <code>prev = groups[-2]</code> and <code>cur = groups[-1]</code>. Then, the answer is the sum of <code>min(prev, cur)</code> over each different final <code>(prev, cur)</code> we see.</p> \n  <p><strong>Python</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">countBinarySubstrings</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">s</span><span class=\"p\">):</span>\n        <span class=\"n\">ans</span><span class=\"p\">,</span> <span class=\"n\">prev</span><span class=\"p\">,</span> <span class=\"n\">cur</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span>\n        <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">xrange</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">)):</span>\n            <span class=\"k\">if</span> <span class=\"n\">s</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">!=</span> <span class=\"n\">s</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]:</span>\n                <span class=\"n\">ans</span> <span class=\"o\">+=</span> <span class=\"nb\">min</span><span class=\"p\">(</span><span class=\"n\">prev</span><span class=\"p\">,</span> <span class=\"n\">cur</span><span class=\"p\">)</span>\n                <span class=\"n\">prev</span><span class=\"p\">,</span> <span class=\"n\">cur</span> <span class=\"o\">=</span> <span class=\"n\">cur</span><span class=\"p\">,</span> <span class=\"mi\">1</span>\n            <span class=\"k\">else</span><span class=\"p\">:</span>\n                <span class=\"n\">cur</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">ans</span> <span class=\"o\">+</span> <span class=\"nb\">min</span><span class=\"p\">(</span><span class=\"n\">prev</span><span class=\"p\">,</span> <span class=\"n\">cur</span><span class=\"p\">)</span>\n</pre>\n  </div> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">countBinarySubstrings</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">prev</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">cur</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"o\">;</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">s</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">();</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">.</span><span class=\"na\">charAt</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">!=</span> <span class=\"n\">s</span><span class=\"o\">.</span><span class=\"na\">charAt</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">{</span>\n                <span class=\"n\">ans</span> <span class=\"o\">+=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">min</span><span class=\"o\">(</span><span class=\"n\">prev</span><span class=\"o\">,</span> <span class=\"n\">cur</span><span class=\"o\">);</span>\n                <span class=\"n\">prev</span> <span class=\"o\">=</span> <span class=\"n\">cur</span><span class=\"o\">;</span>\n                <span class=\"n\">cur</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>\n                <span class=\"n\">cur</span><span class=\"o\">++;</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">ans</span> <span class=\"o\">+</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">min</span><span class=\"o\">(</span><span class=\"n\">prev</span><span class=\"o\">,</span> <span class=\"n\">cur</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>s</code>. Every loop is through <script type=\"math/tex; mode=display\">O(N)</script> items with <script type=\"math/tex; mode=display\">O(1)</script> work inside the for-block.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>, the space used by <code>prev</code>, <code>cur</code>, and <code>ans</code>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 695,
    "article_live": true,
    "article_slug": "max-area-of-island",
    "title": "Max Area of Island",
    "title_slug": "max-area-of-island",
    "content": "<p>Given a non-empty 2D array <code>grid</code> of 0&#39;s and 1&#39;s, an <b>island</b> is a group of <code>1</code>&#39;s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.</p>\r\n\r\n<p>Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)</p>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\n[[0,0,1,0,0,0,0,1,0,0,0,0,0],\r\n [0,0,0,0,0,0,0,1,1,1,0,0,0],\r\n [0,1,1,0,1,0,0,0,0,0,0,0,0],\r\n [0,1,0,0,1,1,0,0,<b>1</b>,0,<b>1</b>,0,0],\r\n [0,1,0,0,1,1,0,0,<b>1</b>,<b>1</b>,<b>1</b>,0,0],\r\n [0,0,0,0,0,0,0,0,0,0,<b>1</b>,0,0],\r\n [0,0,0,0,0,0,0,1,1,1,0,0,0],\r\n [0,0,0,0,0,0,0,1,1,0,0,0,0]]\r\n</pre>\r\nGiven the above grid, return <code>6</code>. Note the answer is not 11, because the island must be connected 4-directionally.\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\n[[0,0,0,0,0,0,0,0]]</pre>\r\nGiven the above grid, return <code>0</code>.\r\n\r\n<p><b>Note:</b> The length of each dimension in the given <code>grid</code> does not exceed 50.</p>\r\n",
    "tags": "Array, Depth-first Search",
    "difficulty": 2,
    "frontend_article_id": 695,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-depth-first-search-recursive-accepted\">Approach #1: Depth-First Search (Recursive) [Accepted]</a></li> \n    <li><a href=\"#approach-2-depth-first-search-iterative-accepted\">Approach #2: Depth-First Search (Iterative) [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-depth-first-search-recursive-accepted\">Approach #1: Depth-First Search (Recursive) [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>We want to know the area of each connected shape in the grid, then take the maximum of these.</p> \n  <p>If we are on a land square and explore every square connected to it 4-directionally (and recursively squares connected to those squares, and so on), then the total number of squares explored will be the area of that connected shape.</p> \n  <p>To ensure we don't count squares in a shape more than once, let's use <code>seen</code> to keep track of squares we haven't visited before. It will also prevent us from counting the same shape more than once.</p> \n  <iframe src=\"https://leetcode.com/playground/CQGNqDhr/shared\" frameborder=\"0\" name=\"CQGNqDhr\" width=\"100%\" height=\"479\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(R*C)</script>, where <script type=\"math/tex; mode=display\">R</script> is the number of rows in the given <code>grid</code>, and <script type=\"math/tex; mode=display\">C</script> is the number of columns. We visit every square once.</p> </li> \n   <li> <p>Space complexity: <script type=\"math/tex; mode=display\">O(R*C)</script>, the space used by <code>seen</code> to keep track of visited squares, and the space used by the call stack during our recursion.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-depth-first-search-iterative-accepted\">Approach #2: Depth-First Search (Iterative) [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>We can try the same approach using a stack based, (or \"iterative\") depth-first search.</p> \n  <p>Here, <code>seen</code> will represent squares that have either been visited or are added to our list of squares to visit (<code>stack</code>). For every starting land square that hasn't been visited, we will explore 4-directionally around it, adding land squares that haven't been added to <code>seen</code> to our <code>stack</code>.</p> \n  <p>On the side, we'll keep a count <code>shape</code> of the total number of squares seen during the exploration of this shape. We'll want the running max of these counts.</p> \n  <iframe src=\"https://leetcode.com/playground/khZHhSir/shared\" frameborder=\"0\" name=\"khZHhSir\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(R*C)</script>, where <script type=\"math/tex; mode=display\">R</script> is the number of rows in the given <code>grid</code>, and <script type=\"math/tex; mode=display\">C</script> is the number of columns. We visit every square once.</p> </li> \n   <li> <p>Space complexity: <script type=\"math/tex; mode=display\">O(R*C)</script>, the space used by <code>seen</code> to keep track of visited squares, and the space used by <code>stack</code>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 694,
    "article_live": true,
    "article_slug": "number-of-distinct-islands",
    "title": "Number of Distinct Islands",
    "title_slug": "number-of-distinct-islands",
    "tags": "Hash Table, Depth-first Search",
    "difficulty": 2,
    "frontend_article_id": 694,
    "article_content": ""
},
{
    "frontend_question_id": 693,
    "article_live": true,
    "article_slug": "binary-number-with-alternating-bits",
    "title": "Binary Number with Alternating Bits",
    "title_slug": "binary-number-with-alternating-bits",
    "content": "<p>Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> 5\r\n<b>Output:</b> True\r\n<b>Explanation:</b>\r\nThe binary representation of 5 is: 101\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> 7\r\n<b>Output:</b> False\r\n<b>Explanation:</b>\r\nThe binary representation of 7 is: 111.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 3:</b><br />\r\n<pre>\r\n<b>Input:</b> 11\r\n<b>Output:</b> False\r\n<b>Explanation:</b>\r\nThe binary representation of 11 is: 1011.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 4:</b><br />\r\n<pre>\r\n<b>Input:</b> 10\r\n<b>Output:</b> True\r\n<b>Explanation:</b>\r\nThe binary representation of 10 is: 1010.\r\n</pre>\r\n</p>",
    "tags": "Bit Manipulation",
    "difficulty": 1,
    "frontend_article_id": 693,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-convert-to-string-accepted\">Approach #1: Convert to String [Accepted]</a></li> \n    <li><a href=\"#approach-2-divide-by-two-accepted\">Approach #2: Divide By Two [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-convert-to-string-accepted\">Approach #1: Convert to String [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Let's convert the given number into a string of binary digits. Then, we should simply check that no two adjacent digits are the same.</p> \n  <iframe src=\"https://leetcode.com/playground/79o5Wvyy/shared\" frameborder=\"0\" name=\"79o5Wvyy\" width=\"100%\" height=\"241\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(1)</script>. For arbitrary inputs, we do <script type=\"math/tex; mode=display\">O(w)</script> work, where <script type=\"math/tex; mode=display\">w</script> is the number of bits in <code>n</code>. However, <script type=\"math/tex; mode=display\">w \\leq 32</script>.</p> </li> \n   <li> <p>Space complexity: <script type=\"math/tex; mode=display\">O(1)</script>, or alternatively <script type=\"math/tex; mode=display\">O(w)</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-divide-by-two-accepted\">Approach #2: Divide By Two [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>We can get the last bit and the rest of the bits via <code>n % 2</code> and <code>n // 2</code> operations. Let's remember <code>cur</code>, the last bit of <code>n</code>. If the last bit ever equals the last bit of the remaining, then two adjacent bits have the same value, and the answer is <code>False</code>. Otherwise, the answer is <code>True</code>.</p> \n  <p>Also note that instead of <code>n % 2</code> and <code>n // 2</code>, we could have used operators <code>n &amp; 1</code> and <code>n &gt;&gt;= 1</code> instead.</p> \n  <iframe src=\"https://leetcode.com/playground/oFAELrSA/shared\" frameborder=\"0\" name=\"oFAELrSA\" width=\"100%\" height=\"258\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(1)</script>. For arbitrary inputs, we do <script type=\"math/tex; mode=display\">O(w)</script> work, where <script type=\"math/tex; mode=display\">w</script> is the number of bits in <code>n</code>. However, <script type=\"math/tex; mode=display\">w \\leq 32</script>.</p> </li> \n   <li> <p>Space complexity: <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 692,
    "article_live": true,
    "article_slug": "top-k-frequent-words",
    "title": "Top K Frequent Words",
    "title_slug": "top-k-frequent-words",
    "content": "<p>Given a non-empty list of words, return the <i>k</i> most frequent elements.</p>\r\n<p>Your answer should be sorted by frequency from highest to lowest. If two words have the same frequency, then the word with the lower alphabetical order comes first.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [\"i\", \"love\", \"leetcode\", \"i\", \"love\", \"coding\"], k = 2\r\n<b>Output:</b> [\"i\", \"love\"]\r\n<b>Explanation:</b> \"i\" and \"love\" are the two most frequent words.\r\n    Note that \"i\" comes before \"love\" due to a lower alphabetical order.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> [\"the\", \"day\", \"is\", \"sunny\", \"the\", \"the\", \"the\", \"sunny\", \"is\", \"is\"], k = 4\r\n<b>Output:</b> [\"the\", \"is\", \"sunny\", \"day\"]\r\n<b>Explanation:</b> \"the\", \"is\", \"sunny\" and \"day\" are the four most frequent words,\r\n    with the number of occurrence being 4, 3, 2 and 1 respectively.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>You may assume <i>k</i> is always valid, 1 &le; <i>k</i> &le; number of unique elements.</li>\r\n<li>Input words contain only lowercase letters.</li>\r\n</ol>\r\n</p>\r\n\r\n<p><b>Follow up:</b><br />\r\n<ol>\r\n<li>Try to solve it in <i>O</i>(<i>n</i> log <i>k</i>) time and <i>O</i>(<i>n</i>) extra space.</li>\r\n</ol>\r\n</p>",
    "tags": "Hash Table, Heap, Trie",
    "difficulty": 2,
    "frontend_article_id": 692,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-sorting-accepted\">Approach #1: Sorting [Accepted]</a></li> \n    <li><a href=\"#approach-2-heap-accepted\">Approach #2: Heap [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-sorting-accepted\">Approach #1: Sorting [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Count the frequency of each word, and sort the words with a custom ordering relation that uses these frequencies. Then take the best <code>k</code> of them.</p> \n  <p><strong>Python</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">topKFrequent</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">words</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">):</span>\n        <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">Counter</span><span class=\"p\">(</span><span class=\"n\">words</span><span class=\"p\">)</span>\n        <span class=\"n\">candidates</span> <span class=\"o\">=</span> <span class=\"n\">count</span><span class=\"o\">.</span><span class=\"n\">keys</span><span class=\"p\">()</span>\n        <span class=\"n\">candidates</span><span class=\"o\">.</span><span class=\"n\">sort</span><span class=\"p\">(</span><span class=\"n\">key</span> <span class=\"o\">=</span> <span class=\"k\">lambda</span> <span class=\"n\">w</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"o\">-</span><span class=\"n\">count</span><span class=\"p\">[</span><span class=\"n\">w</span><span class=\"p\">],</span> <span class=\"n\">w</span><span class=\"p\">))</span>\n        <span class=\"k\">return</span> <span class=\"n\">candidates</span><span class=\"p\">[:</span><span class=\"n\">k</span><span class=\"p\">]</span>\n</pre>\n  </div> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;</span> <span class=\"nf\">topKFrequent</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">words</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">Map</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">,</span> <span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HashMap</span><span class=\"o\">();</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">word</span><span class=\"o\">:</span> <span class=\"n\">words</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">count</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"n\">word</span><span class=\"o\">,</span> <span class=\"n\">count</span><span class=\"o\">.</span><span class=\"na\">getOrDefault</span><span class=\"o\">(</span><span class=\"n\">word</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n        <span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">candidates</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">(</span><span class=\"n\">count</span><span class=\"o\">.</span><span class=\"na\">keySet</span><span class=\"o\">());</span>\n        <span class=\"n\">Collections</span><span class=\"o\">.</span><span class=\"na\">sort</span><span class=\"o\">(</span><span class=\"n\">candidates</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">w1</span><span class=\"o\">,</span> <span class=\"n\">w2</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">count</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">w1</span><span class=\"o\">).</span><span class=\"na\">equals</span><span class=\"o\">(</span><span class=\"n\">count</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">w2</span><span class=\"o\">))</span> <span class=\"o\">?</span>\n                <span class=\"n\">w1</span><span class=\"o\">.</span><span class=\"na\">compareTo</span><span class=\"o\">(</span><span class=\"n\">w2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">count</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">w2</span><span class=\"o\">)</span> <span class=\"o\">-</span> <span class=\"n\">count</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">w1</span><span class=\"o\">));</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">candidates</span><span class=\"o\">.</span><span class=\"na\">subList</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">k</span><span class=\"o\">);</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N \\log{N})</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>words</code>. We count the frequency of each word in <script type=\"math/tex; mode=display\">O(N)</script> time, then we sort the given words in <script type=\"math/tex; mode=display\">O(N \\log{N})</script> time.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the space used to store our <code>candidates</code>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-heap-accepted\">Approach #2: Heap [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Count the frequency of each word, then add it to heap that stores the best <code>k</code> candidates. Here, \"best\" is defined with our custom ordering relation, which puts the worst candidates at the top of the heap. At the end, we pop off the heap up to <code>k</code> times and reverse the result so that the best candidates are first.</p> \n  <p>In Python, we instead use <code>heapq.heapify</code>, which can turn a list into a heap in linear time, simplifying our work.</p> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;</span> <span class=\"nf\">topKFrequent</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">words</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">Map</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">,</span> <span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HashMap</span><span class=\"o\">();</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">word</span><span class=\"o\">:</span> <span class=\"n\">words</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">count</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"n\">word</span><span class=\"o\">,</span> <span class=\"n\">count</span><span class=\"o\">.</span><span class=\"na\">getOrDefault</span><span class=\"o\">(</span><span class=\"n\">word</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n        <span class=\"n\">PriorityQueue</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">heap</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">PriorityQueue</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;(</span>\n                <span class=\"o\">(</span><span class=\"n\">w1</span><span class=\"o\">,</span> <span class=\"n\">w2</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">count</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">w1</span><span class=\"o\">).</span><span class=\"na\">equals</span><span class=\"o\">(</span><span class=\"n\">count</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">w2</span><span class=\"o\">))</span> <span class=\"o\">?</span>\n                <span class=\"n\">w2</span><span class=\"o\">.</span><span class=\"na\">compareTo</span><span class=\"o\">(</span><span class=\"n\">w1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">count</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">w1</span><span class=\"o\">)</span> <span class=\"o\">-</span> <span class=\"n\">count</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">w2</span><span class=\"o\">)</span> <span class=\"o\">);</span>\n\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">word</span><span class=\"o\">:</span> <span class=\"n\">count</span><span class=\"o\">.</span><span class=\"na\">keySet</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n            <span class=\"n\">heap</span><span class=\"o\">.</span><span class=\"na\">offer</span><span class=\"o\">(</span><span class=\"n\">word</span><span class=\"o\">);</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">heap</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">()</span> <span class=\"o\">&gt;</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"n\">heap</span><span class=\"o\">.</span><span class=\"na\">poll</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">();</span>\n        <span class=\"k\">while</span> <span class=\"o\">(!</span><span class=\"n\">heap</span><span class=\"o\">.</span><span class=\"na\">isEmpty</span><span class=\"o\">())</span> <span class=\"n\">ans</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">heap</span><span class=\"o\">.</span><span class=\"na\">poll</span><span class=\"o\">());</span>\n        <span class=\"n\">Collections</span><span class=\"o\">.</span><span class=\"na\">reverse</span><span class=\"o\">(</span><span class=\"n\">ans</span><span class=\"o\">);</span>\n        <span class=\"k\">return</span> <span class=\"n\">ans</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">topKFrequent</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">words</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">):</span>\n        <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">Counter</span><span class=\"p\">(</span><span class=\"n\">words</span><span class=\"p\">)</span>\n        <span class=\"n\">heap</span> <span class=\"o\">=</span> <span class=\"p\">[(</span><span class=\"o\">-</span><span class=\"n\">freq</span><span class=\"p\">,</span> <span class=\"n\">word</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">word</span><span class=\"p\">,</span> <span class=\"n\">freq</span> <span class=\"ow\">in</span> <span class=\"n\">count</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">()]</span>\n        <span class=\"n\">heapq</span><span class=\"o\">.</span><span class=\"n\">heapify</span><span class=\"p\">(</span><span class=\"n\">heap</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"p\">[</span><span class=\"n\">heapq</span><span class=\"o\">.</span><span class=\"n\">heappop</span><span class=\"p\">(</span><span class=\"n\">heap</span><span class=\"p\">)[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"k\">for</span> <span class=\"n\">_</span> <span class=\"ow\">in</span> <span class=\"nb\">xrange</span><span class=\"p\">(</span><span class=\"n\">k</span><span class=\"p\">)]</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time Complexity: <script type=\"math/tex; mode=display\">O(N \\log{k})</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>words</code>. We count the frequency of each word in <script type=\"math/tex; mode=display\">O(N)</script> time, then we add <script type=\"math/tex; mode=display\">N</script> words to the heap, each in <script type=\"math/tex; mode=display\">O(\\log {k})</script> time. Finally, we pop from the heap up to <script type=\"math/tex; mode=display\">k</script> times. As <script type=\"math/tex; mode=display\">k \\leq N</script>, this is <script type=\"math/tex; mode=display\">O(N \\log{k})</script> in total.</li> \n  </ul> \n  <p>In Python, we improve this to <script type=\"math/tex; mode=display\">O(N + k \\log {N})</script>: our <code>heapq.heapify</code> operation and counting operations are <script type=\"math/tex; mode=display\">O(N)</script>, and each of <script type=\"math/tex; mode=display\">k</script> <code>heapq.heappop</code> operations are <script type=\"math/tex; mode=display\">O(\\log {N})</script>.</p> \n  <ul> \n   <li>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the space used to store our <code>count</code>.</li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 691,
    "article_live": true,
    "article_slug": "stickers-to-spell-word",
    "title": "Stickers to Spell Word",
    "title_slug": "stickers-to-spell-word",
    "content": "<p>\r\nWe are given N different types of stickers.  Each sticker has a lowercase English word on it.\r\n</p><p>\r\nYou would like to spell out the given <code>target</code> string by cutting individual letters from your collection of stickers and rearranging them.\r\n</p><p>\r\nYou can use each sticker more than once if you want, and you have infinite quantities of each sticker.\r\n</p><p>\r\nWhat is the minimum number of stickers that you need to spell out the <code>target</code>?  If the task is impossible, return -1.\r\n</p>\r\n\r\n<p><b>Example 1:</b></p>\r\n<p>Input:<pre>\r\n[\"with\", \"example\", \"science\"], \"thehat\"\r\n</pre></p>\r\n\r\n<p>Output:<pre>\r\n3\r\n</pre></p>\r\n\r\n<p>Explanation:<pre>\r\nWe can use 2 \"with\" stickers, and 1 \"example\" sticker.\r\nAfter cutting and rearrange the letters of those stickers, we can form the target \"thehat\".\r\nAlso, this is the minimum number of stickers necessary to form the target string.\r\n</pre></p>\r\n\r\n<p><b>Example 2:</b></p>\r\n<p>Input:<pre>\r\n[\"notice\", \"possible\"], \"basicbasic\"\r\n</pre></p>\r\n\r\n<p>Output:<pre>\r\n-1\r\n</pre></p>\r\n\r\n<p>Explanation:<pre>\r\nWe can't form the target \"basicbasic\" from cutting letters from the given stickers.\r\n</pre></p>\r\n\r\n<p><b>Note:</b>\r\n<li><code>stickers</code> has length in the range <code>[1, 50]</code>.</li>\r\n<li><code>stickers</code> consists of lowercase English words (without apostrophes).</li>\r\n<li><code>target</code> has length in the range <code>[1, 15]</code>, and consists of lowercase English letters.</li>\r\n<li>In all test cases, all words were chosen <u>randomly</u> from the 1000 most common US English words, and the target was chosen as a concatenation of two random words.</li>\r\n<li>The time limit may be more challenging than usual.  It is expected that a 50 sticker test case can be solved within 35ms on average.</li>\r\n</p>",
    "tags": "Dynamic Programming, Backtracking",
    "difficulty": 3,
    "frontend_article_id": 691,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-optimized-exhaustive-search\">Approach 1: Optimized Exhaustive Search</a></li> \n    <li><a href=\"#approach-2-dynamic-programming\">Approach 2: Dynamic Programming</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-optimized-exhaustive-search\">Approach 1: Optimized Exhaustive Search</h4> \n  <p><br></p> \n  <p><strong>Intuition</strong></p> \n  <p>A natural answer is to exhaustively search combinations of stickers. Because the data is randomized, there are many heuristics available to us that will make this faster.</p> \n  <ul> \n   <li> <p>For all stickers, we can ignore any letters that are not in the target word.</p> </li> \n   <li> <p>When our candidate answer won't be smaller than an answer we have already found, we can stop searching this path.</p> </li> \n   <li> <p>We should try to have our exhaustive search bound the answer as soon as possible, so the effect described in the above point happens more often.</p> </li> \n   <li> <p>When a sticker dominates another, we shouldn't include the dominated sticker in our sticker collection. [Here, we say a sticker <code>A</code> dominates <code>B</code> if <code>A.count(letter) &gt;= B.count(letter)</code> for all letters.]</p> </li> \n  </ul> \n  <p><br></p> \n  <p><strong>Algorithm</strong></p> \n  <p>Firstly, for each sticker, let's create a count of that sticker (a mapping <code>letter -&gt; sticker.count(letter)</code>) that does not consider letters not in the target word. Let <code>A</code> be an array of these counts. Also, let's create <code>t_count</code>, a count of our <code>target</code> word.</p> \n  <p>Secondly, let's remove dominated stickers. Because dominance is a transitive relation, we only need to check if a sticker is not dominated by any other sticker once - the ones that aren't dominated are included in our collection.</p> \n  <p>We are now ready to begin our exhaustive search. A call to <code>search(ans)</code> denotes that we want to decide the minimum number of stickers we can used in <code>A</code> to satisfy the target count <code>t_count</code>. <code>ans</code> will store the currently formed answer, and <code>best</code> will store the current best answer.</p> \n  <p>If our current answer can't beat our current best answer, we should stop searching. Also, if there are no stickers left and our target is satisfied, we should update our answer.</p> \n  <p>Otherwise, we want to know the maximum number of this sticker we can use. For example, if this sticker is <code>'abb'</code> and our target is <code>'aaabbbbccccc'</code>, then we could use a maximum of 3 stickers. This is the maximum of <code>math.ceil(target.count(letter) / sticker.count(letter))</code>, taken over all <code>letter</code>s in <code>sticker</code>. Let's call this quantity <code>used</code>.</p> \n  <p>After, for the sticker we are currently considering, we try to use <code>used</code> of them, then <code>used - 1</code>, <code>used - 2</code> and so on. The reason we do it in this order is so that we can arrive at a value for <code>best</code> more quickly, which will stop other branches of our exhaustive search from continuing.</p> \n  <p>The Python version of this solution showcases using <code>collections.Counter</code> as a way to simplify some code sections, whereas the Java solution sticks to arrays.</p> \n  <iframe src=\"https://leetcode.com/playground/KP3fS7G3/shared\" frameborder=\"0\" name=\"KP3fS7G3\" width=\"100%\" height=\"515\"></iframe> \n  <p><br></p> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: Let <script type=\"math/tex; mode=display\">N</script> be the number of stickers, and <script type=\"math/tex; mode=display\">T</script> be the number of letters in the target word. A bound for time complexity is <script type=\"math/tex; mode=display\">O(N^{T+1} T^2)</script>: for each sticker, we'll have to try using it up to <script type=\"math/tex; mode=display\">T+1</script> times, and updating our target count costs <script type=\"math/tex; mode=display\">O(T)</script>, which we do up to <script type=\"math/tex; mode=display\">T</script> times. Alternatively, since the answer is bounded at <script type=\"math/tex; mode=display\">T</script>, we can prove that we can only search up to <script type=\"math/tex; mode=display\">\\binom{N+T-1}{T-1}</script> times. This would be <script type=\"math/tex; mode=display\">O(\\binom{N+T-1}{T-1} T^2)</script>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N+T)</script>, to store <code>stickersCount</code>, <code>targetCount</code>, and handle the recursive callstack when calling <code>search</code>.</p> </li> \n  </ul> \n  <p><br></p> \n  <hr> \n  <h4 id=\"approach-2-dynamic-programming\">Approach 2: Dynamic Programming</h4> \n  <p><br></p> \n  <p><strong>Intuition</strong></p> \n  <p>Suppose we need <code>dp[state]</code> stickers to satisfy all <code>target[i]</code>'s for which the <code>i</code>-th bit of <code>state</code> is set. We would like to know <code>dp[(1 &lt;&lt; len(target)) - 1]</code>.</p> \n  <p><br></p> \n  <p><strong>Algorithm</strong></p> \n  <p>For each <code>state</code>, let's work with it as <code>now</code> and look at what happens to it after applying a sticker. For each letter in the sticker that can satisfy an unset bit of <code>state</code>, we set the bit (<code>now |= 1 &lt;&lt; i</code>). At the end, we know <code>now</code> is the result of applying that sticker to <code>state</code>, and we update our <code>dp</code> appropriately.</p> \n  <p>When using Python, we will need some extra techniques from <em>Approach #1</em> to pass in time.</p> \n  <iframe src=\"https://leetcode.com/playground/JTZ2SYco/shared\" frameborder=\"0\" name=\"JTZ2SYco\" width=\"100%\" height=\"515\"></iframe> \n  <p><br></p> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(2^T * S * T)</script> where <script type=\"math/tex; mode=display\">S</script> be the total number of letters in all stickers, and <script type=\"math/tex; mode=display\">T</script> be the number of letters in the target word. We can examine each loop carefully to arrive at this conclusion.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(2^T)</script>, the space used by <code>dp</code>.</p> </li> \n  </ul> \n  <p><br></p> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>. <a href=\"https://leetcode.com/contest/leetcode-weekly-contest-53/ranking\">Approach #2</a> inspired by <a href=\"https://leetcode.com/dreamoon\">@dreamoon</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 690,
    "article_live": true,
    "article_slug": "employee-importance",
    "title": "Employee Importance",
    "title_slug": "employee-importance",
    "content": "<p>You are given a data structure of employee information, which includes the employee's <b>unique id</b>, his <b>importance value</b> and his <b>direct</b> subordinates' id. </p>\r\n\r\n<p>For example, employee 1 is the leader of employee 2, and employee 2 is the leader of employee 3. They have importance value 15, 10 and 5, respectively. Then employee 1 has a data structure like [1, 15, [2]], and employee 2 has [2, 10, [3]], and employee 3 has [3, 5, []]. Note that although employee 3 is also a subordinate of employee 1, the relationship is <b>not direct</b>.</p>\r\n\r\n<p>Now given the employee information of a company, and an employee id, you need to return the total importance value of this employee and all his subordinates.</p>\r\n\r\n<p><b>Example 1:</b><br/>\r\n<pre>\r\n<b>Input:</b> [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1\r\n<b>Output:</b> 11\r\n<b>Explanation:</b>\r\nEmployee 1 has importance value 5, and he has two direct subordinates: employee 2 and employee 3. They both have importance value 3. So the total importance value of employee 1 is 5 + 3 + 3 = 11.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>One employee has at most one <b>direct</b> leader and may have several subordinates.</li>\r\n<li>The maximum number of employees won't exceed 2000.</li>\r\n</ol>\r\n</p>",
    "tags": "Hash Table, Depth-first Search, Breadth-first Search",
    "difficulty": 1,
    "frontend_article_id": 690,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-depth-first-search-accepted\">Approach #1: Depth-First Search [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-depth-first-search-accepted\">Approach #1: Depth-First Search [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Let's use a hashmap <code>emap = {employee.id -&gt; employee}</code> to query employees quickly.</p> \n  <p>Now to find the total importance of an employee, it will be the importance of that employee, plus the total importance of each of that employee's subordinates. This is a straightforward depth-first search.</p> \n  <iframe src=\"https://leetcode.com/playground/NX7sm9qW/shared\" frameborder=\"0\" width=\"100%\" height=\"310\" name=\"NX7sm9qW\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of employees. We might query each employee in <code>dfs</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the size of the implicit call stack when evaluating <code>dfs</code>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 689,
    "article_live": true,
    "article_slug": "maximum-sum-of-3-non-overlapping-intervals",
    "title": "Maximum Sum of 3 Non-Overlapping Subarrays",
    "title_slug": "maximum-sum-of-3-non-overlapping-subarrays",
    "content": "<p>\r\nIn a given array <code>nums</code> of positive integers, find three non-overlapping subarrays with maximum sum.\r\n</p>\r\n<p>\r\nEach subarray will be of size <code>k</code>, and we want to maximize the sum of all <code>3*k</code> entries.\r\n</p>\r\n<p>\r\nReturn the result as a list of indices representing the starting position of each interval (0-indexed).  If there are multiple answers, return the lexicographically smallest one.\r\n</p>\r\n<p><b>Example:</b><br />\r\n<pre>\r\n<b>Input:</b> [1,2,1,2,6,7,5,1], 2\r\n<b>Output:</b> [0, 3, 5]\r\n<b>Explanation:</b> Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting indices [0, 3, 5].\r\nWe could have also taken [2, 1], but an answer of [1, 3, 5] would be lexicographically larger.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br />\r\n<li><code>nums.length</code> will be between 1 and 20000.</li>\r\n<li><code>nums[i]</code> will be between 1 and 65535.</li>\r\n<li><code>k</code> will be between 1 and floor(nums.length / 3).</li>\r\n</p>",
    "tags": "Array, Dynamic Programming",
    "difficulty": 3,
    "frontend_article_id": 689,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-ad-hoc-accepted\">Approach #1: Ad-Hoc [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-ad-hoc-accepted\">Approach #1: Ad-Hoc [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>It is natural to consider an array <code>W</code> of each interval's sum, where each interval is the given length <code>K</code>. To create <code>W</code>, we can either use prefix sums, or manage the sum of the interval as a window slides along the array.</p> \n  <p>From there, we approach the reduced problem: Given some array <code>W</code> and an integer <code>K</code>, what is the lexicographically smallest tuple of indices <code>(i, j, k)</code> with <code>i + K &lt;= j</code> and <code>j + K &lt;= k</code> that maximizes <code>W[i] + W[j] + W[k]</code>?</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Suppose we fixed <code>j</code>. We would like to know on the intervals <script type=\"math/tex; mode=display\">i \\in [0, j-K]</script> and <script type=\"math/tex; mode=display\">k \\in [j+K, \\text{len}(W)-1]</script>, where the largest value of <script type=\"math/tex; mode=display\">W[i]</script> (and respectively <script type=\"math/tex; mode=display\">W[k]</script>) occurs first. (Here, first means the smaller index.)</p> \n  <p>We can solve these problems with dynamic programming. For example, if we know that <script type=\"math/tex; mode=display\">i</script> is where the largest value of <script type=\"math/tex; mode=display\">W[i]</script> occurs first on <script type=\"math/tex; mode=display\">[0, 5]</script>, then on <script type=\"math/tex; mode=display\">[0, 6]</script> the first occurrence of the largest <script type=\"math/tex; mode=display\">W[i]</script> must be either <script type=\"math/tex; mode=display\">i</script> or <script type=\"math/tex; mode=display\">6</script>. If say, <script type=\"math/tex; mode=display\">6</script> is better, then we set <code>best = 6</code>.</p> \n  <p>At the end, <code>left[z]</code> will be the first occurrence of the largest value of <code>W[i]</code> on the interval <script type=\"math/tex; mode=display\">i \\in [0, z]</script>, and <code>right[z]</code> will be the same but on the interval <script type=\"math/tex; mode=display\">i \\in [z, \\text{len}(W) - 1]</script>. This means that for some choice <code>j</code>, the candidate answer must be <code>(left[j-K], j, right[j+K])</code>. We take the candidate that produces the maximum <code>W[i] + W[j] + W[k]</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/rcX96JEv/shared\" frameborder=\"0\" name=\"rcX96JEv\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of the array. Every loop is bounded in the number of steps by <script type=\"math/tex; mode=display\">N</script>, and does <script type=\"math/tex; mode=display\">O(1)</script> work.</p> </li> \n   <li> <p>Space complexity: <script type=\"math/tex; mode=display\">O(N)</script>. <code>W</code>, <code>left</code>, and <code>right</code> all take <script type=\"math/tex; mode=display\">O(N)</script> memory.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 688,
    "article_live": true,
    "article_slug": "knight-probability-in-chessboard",
    "title": "Knight Probability in Chessboard",
    "title_slug": "knight-probability-in-chessboard",
    "content": "<p>On an <code>N</code>x<code>N</code> chessboard, a knight starts at the <code>r</code>-th row and <code>c</code>-th column and attempts to make exactly <code>K</code> moves. The rows and columns are 0 indexed, so the top-left square is <code>(0, 0)</code>, and the bottom-right square is <code>(N-1, N-1)</code>.</p>\r\n\r\n<p>A chess knight has 8 possible moves it can make, as illustrated below. Each move is two squares in a cardinal direction, then one square in an orthogonal direction.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/12/knight.png\" style=\"width: 200px; height: 200px;\" /></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Each time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.</p>\r\n\r\n<p>The knight continues moving until it has made exactly <code>K</code> moves or has moved off the chessboard. Return the probability that the knight remains on the board after it has stopped moving.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Example:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> 3, 2, 0, 0\r\n<b>Output:</b> 0.0625\r\n<b>Explanation:</b> There are two moves (to (1,2), (2,1)) that will keep the knight on the board.\r\nFrom each of those positions, there are also two moves that will keep the knight on the board.\r\nThe total probability the knight stays on the board is 0.0625.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Note:</b></p>\r\n\r\n<ul>\r\n\t<li><code>N</code> will be between 1 and 25.</li>\r\n\t<li><code>K</code> will be between 0 and 100.</li>\r\n\t<li>The knight always initially starts on the board.</li>\r\n</ul>\r\n",
    "tags": "Dynamic Programming",
    "difficulty": 2,
    "frontend_article_id": 688,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-dynamic-programming-accepted\">Approach #1: Dynamic Programming [Accepted]</a></li> \n    <li><a href=\"#approach-2-matrix-exponentiation-accepted\">Approach #2: Matrix Exponentiation [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-dynamic-programming-accepted\">Approach #1: Dynamic Programming [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Let <code>f[r][c][steps]</code> be the probability of being on square <code>(r, c)</code> after <code>steps</code> steps. Based on how a knight moves, we have the following recursion:</p> \n  <p> <script type=\"math/tex; mode=display\">f[r][c][steps] = \\sum_{dr, dc} f[r+dr][c+dc][steps-1] / 8.0</script> </p> \n  <p>where the sum is taken over the eight <script type=\"math/tex; mode=display\">(dr, dc)</script> pairs <script type=\"math/tex; mode=display\">(2, 1),</script> <script type=\"math/tex; mode=display\">(2, -1),</script> <script type=\"math/tex; mode=display\">(-2, 1),</script> <script type=\"math/tex; mode=display\">(-2, -1),</script> <script type=\"math/tex; mode=display\">(1, 2),</script> <script type=\"math/tex; mode=display\">(1, -2),</script> <script type=\"math/tex; mode=display\">(-1, 2),</script> <script type=\"math/tex; mode=display\">(-1, -2)</script>.</p> \n  <p>Instead of using a three-dimensional array <code>f</code>, we will use two two-dimensional ones <code>dp</code> and <code>dp2</code>, storing the result of the two most recent layers we are working on. <code>dp2</code> will represent <code>f[][][steps]</code>, and <code>dp</code> will represent <code>f[][][steps-1]</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/VTNPLt6H/shared\" frameborder=\"0\" name=\"VTNPLt6H\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2 K)</script> where <script type=\"math/tex; mode=display\">N, K</script> are defined as in the problem. We do <script type=\"math/tex; mode=display\">O(1)</script> work on each layer <code>dp</code> of <script type=\"math/tex; mode=display\">N^2</script> elements, and there are <script type=\"math/tex; mode=display\">K</script> layers considered.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, the size of <code>dp</code> and <code>dp2</code>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-matrix-exponentiation-accepted\">Approach #2: Matrix Exponentiation [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>The recurrence expressed in <em>Approach #1</em> expressed states that transitioned to a linear combination of other states. Any time this happens, we can represent the entire transition as a matrix of those linear combinations. Then, the <script type=\"math/tex; mode=display\">n</script>-th power of this matrix represents the transition of <script type=\"math/tex; mode=display\">n</script> moves, and thus we can reduce the problem to a problem of matrix exponentiation.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>First, there is a lot of symmetry on the board that we can exploit. Naively, there are <script type=\"math/tex; mode=display\">N^2</script> possible states the knight can be in (assuming it is on the board). Because of symmetry through the horizontal, vertical, and diagonal axes, we can assume that the knight is in the top-left quadrant of the board, and that the column number is equal to or larger than the row number. For any square, the square that is found by reflecting about these axes to satisfy these conditions will be the <em>canonical index</em> of that square.</p> \n  <p>This will reduce the number of states from <script type=\"math/tex; mode=display\">N^2</script> to approximately <script type=\"math/tex; mode=display\">\\frac{N^2}{8}</script>, which makes the following (cubic) matrix exponentiation on this <script type=\"math/tex; mode=display\">O(\\frac{N^2}{8}) \\times O(\\frac{N^2}{8})</script> matrix approximately <script type=\"math/tex; mode=display\">8^3</script> times faster.</p> \n  <p>Now, if we know that every state becomes some linear combination of states after one move, then let's write a transition matrix <script type=\"math/tex; mode=display\">\\mathcal{T}</script> of them, where the <script type=\"math/tex; mode=display\">i</script>-th row of <script type=\"math/tex; mode=display\">\\mathcal{T}</script> represents the linear combination of states that the <script type=\"math/tex; mode=display\">i</script>-th state goes to. Then, <script type=\"math/tex; mode=display\">\\mathcal{T}^n</script> represents a transition of <script type=\"math/tex; mode=display\">n</script> moves, for which we want the sum of the <script type=\"math/tex; mode=display\">i</script>-th row, where <script type=\"math/tex; mode=display\">i</script> is the index of the starting square.</p> \n  <iframe src=\"https://leetcode.com/playground/ARu5yUUd/shared\" frameborder=\"0\" name=\"ARu5yUUd\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^6 \\log(K))</script> where <script type=\"math/tex; mode=display\">N, K</script> are defined as in the problem. There are approximately <script type=\"math/tex; mode=display\">\\frac{N^2}{8}</script> canonical states, which makes our matrix multiplication <script type=\"math/tex; mode=display\">O(N^6)</script>. To find the <script type=\"math/tex; mode=display\">K</script>-th power of this matrix, we make <script type=\"math/tex; mode=display\">O(\\log(K))</script> matrix multiplications.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N^4)</script>. The matrix has approximately <script type=\"math/tex; mode=display\">\\frac{N^4}{64}</script> elements.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 687,
    "article_live": true,
    "article_slug": "longest-univalue-path",
    "title": "Longest Univalue Path",
    "title_slug": "longest-univalue-path",
    "content": "<p>Given a binary tree, find the length of the longest path where each node in the path has the same value. This path may or may not pass through the root.</p>\r\n\r\n<p><b>Note:</b> The length of path between two nodes is represented by the number of edges between them.</p>\r\n\r\n<p>\r\n<b>Example 1:</b>\r\n</p>\r\n\r\n\r\n<p>\r\nInput:\r\n<pre>\r\n              5\r\n             / \\\r\n            4   5\r\n           / \\   \\\r\n          1   1   5\r\n</pre>\r\n</p>\r\n\r\n<p>\r\nOutput:\r\n<pre>\r\n2\r\n</pre>\r\n</p>\r\n\r\n<p>\r\n<b>Example 2:</b>\r\n</p>\r\n\r\n\r\n<p>\r\nInput:\r\n<pre>\r\n              1\r\n             / \\\r\n            4   5\r\n           / \\   \\\r\n          4   4   5\r\n</pre>\r\n</p>\r\n\r\n<p>\r\nOutput:\r\n<pre>\r\n2\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\nThe given binary tree has not more than 10000 nodes.  The height of the tree is not more than 1000.\r\n</p>",
    "tags": "Tree, Recursion",
    "difficulty": 1,
    "frontend_article_id": 687,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-recursion-accepted\">Approach #1: Recursion [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-recursion-accepted\">Approach #1: Recursion [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>We can think of any path (of nodes with the same values) as up to two arrows extending from it's root.</p> \n  <p>Specifically, the <em>root</em> of a path will be the unique node such that the parent of that node does not appear in the path, and an <em>arrow</em> will be a path where the root only has one child node in the path.</p> \n  <p>Then, for each node, we want to know what is the longest possible arrow extending left, and the longest possible arrow extending right? We can solve this using recursion.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Let <code>arrow_length(node)</code> be the length of the longest arrow that extends from the <code>node</code>. That will be <code>1 + arrow_length(node.left)</code> if <code>node.left</code> exists and has the same value as <code>node</code>. Similarly for the <code>node.right</code> case.</p> \n  <p>While we are computing arrow lengths, each candidate answer will be the sum of the arrows in both directions from that node. We record these candidate answers and return the best one.</p> \n  <iframe src=\"https://leetcode.com/playground/DjHbgZUi/shared\" frameborder=\"0\" name=\"DjHbgZUi\" width=\"100%\" height=\"428\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of nodes in the tree. We process every node once.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(H)</script>, where <script type=\"math/tex; mode=display\">H</script> is the height of the tree. Our recursive call stack could be up to <script type=\"math/tex; mode=display\">H</script> layers deep.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 686,
    "article_live": true,
    "article_slug": "repeated-string-match",
    "title": "Repeated String Match",
    "title_slug": "repeated-string-match",
    "content": "<p>Given two strings A and B, find the minimum number of times A has to be repeated such that B is a substring of it. If no such solution, return -1.</p>\r\n\r\n<p>For example, with A = &quot;abcd&quot; and B = &quot;cdabcdab&quot;.</p>\r\n\r\n<p>Return 3, because by repeating A three times (&ldquo;abcdabcdabcd&rdquo;), B is a substring of it; and B is not a substring of A repeated two times (&quot;abcdabcd&quot;).</p>\r\n\r\n<p><b>Note:</b><br />\r\nThe length of <code>A</code> and <code>B</code> will be between 1 and 10000.</p>\r\n",
    "tags": "String",
    "difficulty": 1,
    "frontend_article_id": 686,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-ad-hoc-accepted\">Approach #1: Ad-Hoc [Accepted]</a></li> \n    <li><a href=\"#approach-2-rabin-karp-rolling-hash-accepted\">Approach #2: Rabin-Karp (Rolling Hash) [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-ad-hoc-accepted\">Approach #1: Ad-Hoc [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>The question can be summarized as \"What is the smallest <code>k</code> for which <code>B</code> is a substring of <code>A * k</code>?\" We can just try every <code>k</code>.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Imagine we wrote <code>S = A+A+A+...</code>. If <code>B</code> is to be a substring of <code>S</code>, we only need to check whether some <code>S[0:], S[1:], ..., S[len(A) - 1:]</code> starts with <code>B</code>, as <code>S</code> is long enough to contain <code>B</code>, and <code>S</code> has period at most <code>len(A)</code>.</p> \n  <p>Now, suppose <code>q</code> is the least number for which <code>len(B) &lt;= len(A * q)</code>. We only need to check whether <code>B</code> is a substring of <code>A * q</code> or <code>A * (q+1)</code>. If we try <code>k &lt; q</code>, then <code>B</code> has larger length than <code>A * q</code> and therefore can't be a substring. When <code>k = q+1</code>, <code>A * k</code> is already big enough to try all positions for <code>B</code>; namely, <code>A[i:i+len(B)] == B</code> for <code>i = 0, 1, ..., len(A) - 1</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/gTtmgvev/shared\" frameborder=\"0\" name=\"gTtmgvev\" width=\"100%\" height=\"224\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N*(N+M))</script>, where <script type=\"math/tex; mode=display\">M, N</script> are the lengths of strings <code>A, B</code>. We create two strings <code>A * q</code>, <code>A * (q+1)</code> which have length at most <code>O(M+N)</code>. When checking whether <code>B</code> is a substring of <code>A</code>, this check takes naively the product of their lengths.</p> </li> \n   <li> <p>Space complexity: As justified above, we created strings that used <script type=\"math/tex; mode=display\">O(M+N)</script> space.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-rabin-karp-rolling-hash-accepted\">Approach #2: Rabin-Karp (Rolling Hash) [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>As in <em>Approach #1</em>, we've reduced the problem to deciding whether B is a substring of some <code>A * k</code>. Using the following technique, we can decide whether <code>B</code> is a substring in <script type=\"math/tex; mode=display\">O(len(A) * k)</script> time.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>For strings <script type=\"math/tex; mode=display\">S</script>, consider each <script type=\"math/tex; mode=display\">S[i]</script> as some integer ASCII code. Then for some prime <script type=\"math/tex; mode=display\">p</script>, consider the following function modulo some prime modulus <script type=\"math/tex; mode=display\">\\mathcal{M}</script>:</p> \n  <p> <script type=\"math/tex; mode=display\">\\text{hash}(S) = \\sum_{0 \\leq i < len(S)} p^i * S[i]</script> </p> \n  <p>Notably, <script type=\"math/tex; mode=display\">\\text{hash}(S[1:] + x) = \\frac{(\\text{hash}(S) - S[0])}{p} + p^{n-1} x</script>. This shows we can get the hash of every substring of <code>A * q</code> in time complexity linear to it's size. (We will also use the fact that <script type=\"math/tex; mode=display\">p^{-1} = p^{\\mathcal{M}-2} \\mod \\mathcal{M}</script>.)</p> \n  <p>However, hashes may collide haphazardly. To be absolutely sure in theory, we should check the answer in the usual way. The expected number of checks we make is in the order of <script type=\"math/tex; mode=display\">1 + \\frac{s}{\\mathcal{M}}</script> where <script type=\"math/tex; mode=display\">s</script> is the number of substrings we computed hashes for (assuming the hashes are equally distributed), which is effectively 1.</p> \n  <iframe src=\"https://leetcode.com/playground/DKSFgXSr/shared\" frameborder=\"0\" name=\"DKSFgXSr\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(M+N)</script> (at these sizes), where <script type=\"math/tex; mode=display\">M, N</script> are the lengths of strings <code>A, B</code>. As in <em>Approach #1</em>, we justify that <code>A * (q+1)</code> will be of length <script type=\"math/tex; mode=display\">O(M + N)</script>, and computing the rolling hashes was linear work. We will also do a linear <script type=\"math/tex; mode=display\">O(N)</script> final check of our answer <script type=\"math/tex; mode=display\">1 + O(M) / \\mathcal{M}</script> times. In total, this is <script type=\"math/tex; mode=display\">O(M+N + N(1 + \\frac{M}{\\mathcal{M}}))</script> work. Since <script type=\"math/tex; mode=display\">M \\leq 10000 < \\mathcal{M} = 10^9 + 7</script>, we can consider this to be linear behavior.</p> </li> \n   <li> <p>Space complexity: <script type=\"math/tex; mode=display\">O(1)</script>. Only integers were stored with additional memory.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 685,
    "article_live": true,
    "article_slug": "redundant-connection-ii",
    "title": "Redundant Connection II",
    "title_slug": "redundant-connection-ii",
    "content": "<p>\r\nIn this problem, a rooted tree is a <b>directed</b> graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.\r\n</p><p>\r\nThe given input is a directed graph that started as a rooted tree with N nodes (with distinct values 1, 2, ..., N), with one additional directed edge added.  The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.\r\n</p><p>\r\nThe resulting graph is given as a 2D-array of <code>edges</code>.  Each element of <code>edges</code> is a pair <code>[u, v]</code> that represents a <b>directed</b> edge connecting nodes <code>u</code> and <code>v</code>, where <code>u</code> is a parent of child <code>v</code>.\r\n</p><p>\r\nReturn an edge that can be removed so that the resulting graph is a rooted tree of N nodes.  If there are multiple answers, return the answer that occurs last in the given 2D-array.\r\n</p><p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [[1,2], [1,3], [2,3]]\r\n<b>Output:</b> [2,3]\r\n<b>Explanation:</b> The given directed graph will be like this:\r\n  1\r\n / \\\r\nv   v\r\n2-->3\r\n</pre>\r\n</p>\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> [[1,2], [2,3], [3,4], [4,1], [1,5]]\r\n<b>Output:</b> [4,1]\r\n<b>Explanation:</b> The given directed graph will be like this:\r\n5 <- 1 -> 2\r\n     ^    |\r\n     |    v\r\n     4 <- 3\r\n</pre>\r\n</p>\r\n<p><b>Note:</b><br />\r\n<li>The size of the input 2D-array will be between 3 and 1000.</li>\r\n<li>Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array.</li>\r\n</p>",
    "tags": "Tree, Depth-first Search, Union Find, Graph",
    "difficulty": 3,
    "frontend_article_id": 685,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-depth-first-search-accepted\">Approach #1: Depth-First Search [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-depth-first-search-accepted\">Approach #1: Depth-First Search [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Starting from a rooted tree with <code>N-1</code> edges and <code>N</code> vertices, let's enumerate the possibilities for the added \"redundant\" edge. If there is no loop, then either one vertex must have two parents (or no edge is redundant.) If there is a loop, then either one vertex has two parents, or every vertex has one parent.</p> \n  <p>In the first two cases, there are only two candidates for deleting an edge, and we can try removing the last one and seeing if that works. In the last case, the last edge of the cycle can be removed: for example, when <code>1-&gt;2-&gt;3-&gt;4-&gt;1-&gt;5</code>, we want the last edge (by order of occurrence) in the cycle <code>1-&gt;2-&gt;3-&gt;4-&gt;1</code> (but not necessarily <code>1-&gt;5</code>).</p> \n  <p><strong>Algorithm</strong></p> \n  <p>We'll first construct the underlying graph, keeping track of edges coming from nodes with multiple parents. After, we either have 2 or 0 <code>candidates</code>.</p> \n  <p>If there are no candidates, then every vertex has one parent, such as in the case <code>1-&gt;2-&gt;3-&gt;4-&gt;1-&gt;5</code>. From any node, we walk towards it's parent until we revisit a node - then we must be inside the cycle, and any future seen nodes are part of that cycle. Now we take the last edge that occurs in the cycle.</p> \n  <p>Otherwise, we'll see if the graph induced by <code>parent</code> is a rooted tree. We again take the <code>root</code> by walking from any node towards the parent until we can't, then we perform a depth-first search on this <code>root</code>. If we visit every node, then removing the last of the two edge candidates is acceptable, and we should. Otherwise, we should remove the first of the two edge candidates.</p> \n  <p>In our solution, we use <code>orbit</code> to find the result upon walking from a node <code>x</code> towards it's parent repeatedly until you revisit a node or can't walk anymore. <code>orbit(x).node</code> (or <code>orbit(x)[0]</code> in Python) will be the resulting node, while <code>orbit(x).seen</code> (or <code>orbit(x)[1]</code>) will be all the nodes visited.</p> \n  <iframe src=\"https://leetcode.com/playground/sHSf6pyj/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"sHSf6pyj\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script> where <script type=\"math/tex; mode=display\">N</script> is the number of vertices (and also the number of edges) in the graph. We perform a depth-first search.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the size of the graph.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 684,
    "article_live": true,
    "article_slug": "redundant-connection",
    "title": "Redundant Connection",
    "title_slug": "redundant-connection",
    "content": "<p>\r\nIn this problem, a tree is an <b>undirected</b> graph that is connected and has no cycles.\r\n</p><p>\r\nThe given input is a graph that started as a tree with N nodes (with distinct values 1, 2, ..., N), with one additional edge added.  The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.\r\n</p><p>\r\nThe resulting graph is given as a 2D-array of <code>edges</code>.  Each element of <code>edges</code> is a pair <code>[u, v]</code> with <code>u < v</code>, that represents an <b>undirected</b> edge connecting nodes <code>u</code> and <code>v</code>.\r\n</p><p>\r\nReturn an edge that can be removed so that the resulting graph is a tree of N nodes.  If there are multiple answers, return the answer that occurs last in the given 2D-array.  The answer edge <code>[u, v]</code> should be in the same format, with <code>u < v</code>.\r\n</p><p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [[1,2], [1,3], [2,3]]\r\n<b>Output:</b> [2,3]\r\n<b>Explanation:</b> The given undirected graph will be like this:\r\n  1\r\n / \\\r\n2 - 3\r\n</pre>\r\n</p>\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> [[1,2], [2,3], [3,4], [1,4], [1,5]]\r\n<b>Output:</b> [1,4]\r\n<b>Explanation:</b> The given undirected graph will be like this:\r\n5 - 1 - 2\r\n    |   |\r\n    4 - 3\r\n</pre>\r\n</p>\r\n<p><b>Note:</b><br />\r\n<li>The size of the input 2D-array will be between 3 and 1000.</li>\r\n<li>Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array.</li>\r\n</p>\r\n\r\n<br />\r\n\r\n<p>\r\n<b><font color=\"red\">Update (2017-09-26):</font></b><br>\r\nWe have overhauled the problem description + test cases and specified clearly the graph is an <b><i>undirected</i></b> graph. For the <b><i>directed</i></b> graph follow up please see <b><a href=\"https://leetcode.com/problems/redundant-connection-ii/description/\">Redundant Connection II</a></b>). We apologize for any inconvenience caused.\r\n</p>",
    "tags": "Tree, Union Find, Graph",
    "difficulty": 2,
    "frontend_article_id": 684,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-dfs-accepted\">Approach #1: DFS [Accepted]</a></li> \n    <li><a href=\"#approach-2-union-find-accepted\">Approach #2: Union-Find [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-dfs-accepted\">Approach #1: DFS [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>For each edge <code>(u, v)</code>, traverse the graph with a depth-first search to see if we can connect <code>u</code> to <code>v</code>. If we can, then it must be the duplicate edge.</p> \n  <iframe src=\"https://leetcode.com/playground/W7EXu5ND/shared\" frameborder=\"0\" name=\"W7EXu5ND\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script> where <script type=\"math/tex; mode=display\">N</script> is the number of vertices (and also the number of edges) in the graph. In the worst case, for every edge we include, we have to search every previously-occurring edge of the graph.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. The current construction of the graph has at most <script type=\"math/tex; mode=display\">N</script> nodes.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-union-find-accepted\">Approach #2: Union-Find [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>If we are familiar with a Disjoint Set Union (DSU) data structure, we can use this in a straightforward manner to solve the problem: we simply find the first edge occurring in the graph that is already connected. The rest of this explanation will focus on the details of implementing DSU.</p> \n  <p>A DSU data structure can be used to maintain knowledge of the connected components of a graph, and query for them quickly. In particular, we would like to support two operations:</p> \n  <ul> \n   <li> <p><code>dsu.find(node x)</code>, which outputs a unique id so that two nodes have the same id if and only if they are in the same connected component, and:</p> </li> \n   <li> <p><code>dsu.union(node x, node y)</code>, which draws an edge <code>(x, y)</code> in the graph, connecting the components with id <code>find(x)</code> and <code>find(y)</code> together.</p> </li> \n  </ul> \n  <p>To achieve this, we keep track of <code>parent</code>, which remembers the <code>id</code> of a smaller node in the same connected component. If the node is it's own parent, we call this the <em>leader</em> of that connected component.</p> \n  <p>A naive implementation of a DSU structure would look something like this:</p> \n  <p><em>Psuedocode</em></p> \n  <iframe src=\"https://leetcode.com/playground/sCjT3wyq/shared\" frameborder=\"0\" name=\"sCjT3wyq\" width=\"100%\" height=\"190\"></iframe> \n  <p>We use two techniques to improve the run-time complexity: <em>path compression</em>, and <em>union-by-rank</em>.</p> \n  <ul> \n   <li> <p>Path compression involves changing the <code>x = parent[x]</code> in the <code>find</code> function to <code>parent[x] = find(parent[x])</code>. Basically, as we compute the correct leader for x, we should remember our calculation.</p> </li> \n   <li> <p>Union-by-rank involves distributing the workload of <code>find</code> across leaders evenly. Whenever we <code>dsu.union(x, y)</code>, we have two leaders <code>xr, yr</code> and we have to choose whether we want <code>parent[x] = yr</code> or <code>parent[y] = xr</code>. We choose the leader that has a higher following to pick up a new follower.<br> Specifically, the meaning of <code>rank</code> is that there are less than <code>2 ^ rank[x]</code> followers of <code>x</code>. This strategy can be shown to give us better bounds for how long the recursive loop in <code>dsu.find</code> could run for.</p> </li> \n  </ul> \n  <iframe src=\"https://leetcode.com/playground/tFfjEuXo/shared\" frameborder=\"0\" name=\"tFfjEuXo\" width=\"100%\" height=\"515\"></iframe> \n  <p><em>Alternate Implementation of DSU without Union-By-Rank</em> <iframe src=\"https://leetcode.com/playground/DzMVxYRc/shared\" frameborder=\"0\" name=\"DzMVxYRc\" width=\"100%\" height=\"207\"></iframe></p> \n  <iframe src=\"https://leetcode.com/playground/YgdvM9bJ/shared\" frameborder=\"0\" name=\"YgdvM9bJ\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N\\alpha(N)) \\approx O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of vertices (and also the number of edges) in the graph, and <script type=\"math/tex; mode=display\">\\alpha</script> is the <em>Inverse-Ackermann</em> function. We make up to <script type=\"math/tex; mode=display\">N</script> queries of <code>dsu.union</code>, which takes (amortized) <script type=\"math/tex; mode=display\">O(\\alpha(N))</script> time. Outside the scope of this article, it can be shown why <code>dsu.union</code> has <script type=\"math/tex; mode=display\">O(\\alpha(N))</script> complexity, what the Inverse-Ackermann function is, and why <script type=\"math/tex; mode=display\">O(\\alpha(N))</script> is approximately <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. The current construction of the graph (embedded in our <code>dsu</code> structure) has at most <script type=\"math/tex; mode=display\">N</script> nodes.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 683,
    "article_live": true,
    "article_slug": "k-empty-slots",
    "title": "K Empty Slots",
    "title_slug": "k-empty-slots",
    "tags": "Array, Binary Search Tree",
    "difficulty": 3,
    "frontend_article_id": 683,
    "article_content": ""
},
{
    "frontend_question_id": 682,
    "article_live": true,
    "article_slug": "baseball-game",
    "title": "Baseball Game",
    "title_slug": "baseball-game",
    "content": "<p>\r\nYou're now a baseball game point recorder.\r\n</p>\r\n\r\n<p>\r\nGiven a list of strings, each string can be one of the 4 following types:\r\n<ol>\r\n<li><code>Integer</code> (one round's score): Directly represents the number of points you get in this round.</li>\r\n<li><code>\"+\"</code> (one round's score): Represents that the points you get in this round are the sum of the last two <code>valid</code> round's points.</li>\r\n<li><code>\"D\"</code> (one round's score): Represents that the points you get in this round are the doubled data of the last <code>valid</code> round's points.</li>\r\n<li><code>\"C\"</code> (an operation, which isn't a round's score): Represents the last <code>valid</code> round's points you get were invalid and should be removed.</li>\r\n</ol>\r\n</p>\r\n\r\n<p>\r\nEach round's operation is permanent and could have an impact on the round before and the round after.\r\n</p>\r\n\r\n<p>\r\nYou need to return the sum of the points you could get in all the rounds.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [\"5\",\"2\",\"C\",\"D\",\"+\"]\r\n<b>Output:</b> 30\r\n<b>Explanation:</b> \r\nRound 1: You could get 5 points. The sum is: 5.\r\nRound 2: You could get 2 points. The sum is: 7.\r\nOperation 1: The round 2's data was invalid. The sum is: 5.  \r\nRound 3: You could get 10 points (the round 2's data has been removed). The sum is: 15.\r\nRound 4: You could get 5 + 10 = 15 points. The sum is: 30.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> [\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]\r\n<b>Output:</b> 27\r\n<b>Explanation:</b> \r\nRound 1: You could get 5 points. The sum is: 5.\r\nRound 2: You could get -2 points. The sum is: 3.\r\nRound 3: You could get 4 points. The sum is: 7.\r\nOperation 1: The round 3's data is invalid. The sum is: 3.  \r\nRound 4: You could get -4 points (the round 3's data has been removed). The sum is: -1.\r\nRound 5: You could get 9 points. The sum is: 8.\r\nRound 6: You could get -4 + 9 = 5 points. The sum is 13.\r\nRound 7: You could get 9 + 5 = 14 points. The sum is 27.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br />\r\n<li>The size of the input list will be between 1 and 1000.</li>\r\n<li>Every integer represented in the list will be between -30000 and 30000.</li>\r\n</p>",
    "tags": "Stack",
    "difficulty": 1,
    "frontend_article_id": 682,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <h4 id=\"approach-1-stack-accepted\">Approach #1: Stack [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Let's maintain the value of each valid round on a stack as we process the data. A stack is ideal since we only deal with operations involving the last or second-last valid round.</p> \n  <iframe src=\"https://leetcode.com/playground/FRAbgcgJ/shared\" frameborder=\"0\" name=\"FRAbgcgJ\" width=\"100%\" height=\"462\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>ops</code>. We parse through every element in the given array once, and do <script type=\"math/tex; mode=display\">O(1)</script> work for each element.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the space used to store our <code>stack</code>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 681,
    "article_live": true,
    "article_slug": "next-closest-time",
    "title": "Next Closest Time",
    "title_slug": "next-closest-time",
    "tags": "String",
    "difficulty": 2,
    "frontend_article_id": 681,
    "article_content": ""
},
{
    "frontend_question_id": 680,
    "article_live": true,
    "article_slug": "valid-palindrome-ii",
    "title": "Valid Palindrome II",
    "title_slug": "valid-palindrome-ii",
    "content": "<p>\r\nGiven a non-empty string <code>s</code>, you may delete <b>at most</b> one character.  Judge whether you can make it a palindrome.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \"aba\"\r\n<b>Output:</b> True\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> \"abca\"\r\n<b>Output:</b> True\r\n<b>Explanation:</b> You could delete the character 'c'.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The string will only contain lowercase characters a-z.\r\nThe maximum length of the string is 50000.</li>\r\n</ol>\r\n</p>",
    "tags": "String",
    "difficulty": 1,
    "frontend_article_id": 680,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-brute-force-time-limit-exceeded\">Approach #1: Brute Force [Time Limit Exceeded]</a></li> \n    <li><a href=\"#approach-2-greedy-accepted\">Approach #2: Greedy [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-brute-force-time-limit-exceeded\">Approach #1: Brute Force [Time Limit Exceeded]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>For each index <code>i</code> in the given string, let's remove that character, then check if the resulting string is a palindrome. If it is, (or if the original string was a palindrome), then we'll return <code>true</code></p> \n  <iframe src=\"https://leetcode.com/playground/F8rXiMNb/shared\" frameborder=\"0\" name=\"F8rXiMNb\" width=\"100%\" height=\"394\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script> where <script type=\"math/tex; mode=display\">N</script> is the length of the string. We do the following <script type=\"math/tex; mode=display\">N</script> times: create a string of length <script type=\"math/tex; mode=display\">N</script> and iterate over it.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the space used by our candidate answer.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-greedy-accepted\">Approach #2: Greedy [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>If the beginning and end characters of a string are the same (ie. <code>s[0] == s[s.length - 1]</code>), then whether the inner characters are a palindrome (<code>s[1], s[2], ..., s[s.length - 2]</code>) uniquely determines whether the entire string is a palindrome.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Suppose we want to know whether <code>s[i], s[i+1], ..., s[j]</code> form a palindrome. If <code>i &gt;= j</code> then we are done. If <code>s[i] == s[j]</code> then we may take <code>i++; j--</code>. Otherwise, the palindrome must be either <code>s[i+1], s[i+2], ..., s[j]</code> or <code>s[i], s[i+1], ..., s[j-1]</code>, and we should check both cases.</p> \n  <iframe src=\"https://leetcode.com/playground/46SiEhrv/shared\" frameborder=\"0\" name=\"46SiEhrv\" width=\"100%\" height=\"360\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script> where <script type=\"math/tex; mode=display\">N</script> is the length of the string. Each of two checks of whether some substring is a palindrome is <script type=\"math/tex; mode=display\">O(N)</script>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script> additional complexity. Only pointers were stored in memory.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 679,
    "article_live": true,
    "article_slug": "24-game",
    "title": "24 Game",
    "title_slug": "24-game",
    "content": "<p>\r\nYou have 4 cards each containing a number from 1 to 9.  You need to judge whether they could operated through <code>*</code>, <code>/</code>, <code>+</code>, <code>-</code>, <code>(</code>, <code>)</code> to get the value of 24.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [4, 1, 8, 7]\r\n<b>Output:</b> True\r\n<b>Explanation:</b> (8-4) * (7-1) = 24\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> [1, 2, 1, 2]\r\n<b>Output:</b> False\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The division operator <code>/</code> represents real division, not integer division.  For example, 4 / (1 - 2/3) = 12.</li>\r\n<li>Every operation done is between two numbers.  In particular, we cannot use <code>-</code> as a unary operator.  For example, with <code>[1, 1, 1, 1]</code> as input, the expression <code>-1 - 1 - 1 - 1</code> is not allowed.</li>\r\n<li>You cannot concatenate numbers together.  For example, if the input is <code>[1, 2, 1, 2]</code>, we cannot write this as 12 + 12.</li>\r\n</ol>\r\n</p>\r\n</p>",
    "tags": "Depth-first Search",
    "difficulty": 3,
    "frontend_article_id": 679,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-backtracking-accepted\">Approach #1: Backtracking [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-backtracking-accepted\">Approach #1: Backtracking [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>There are only 4 cards and only 4 operations that can be performed. Even when all operations do not commute, that gives us an upper bound of <script type=\"math/tex; mode=display\">12 * 6 * 2 * 4 * 4 * 4 = 9216</script> possibilities, which makes it feasible to just try them all. Specifically, we choose two numbers (with order) in 12 ways and perform one of 4 operations (12 * 4). Then, with 3 remaining numbers, we choose 2 of them and perform one of 4 operations (6 * 4). Finally we have two numbers left and make a final choice of 2 * 4 possibilities.</p> \n  <p>We will perform 3 binary operations (<code>+, -, *, /</code> are the operations) on either our numbers or resulting numbers. Because <code>-</code> and <code>/</code> do not commute, we must be careful to consider both <code>a / b</code> and <code>b / a</code>.</p> \n  <p>For every way to remove two numbers <code>a, b</code> in our list, and for each possible result they can make, like <code>a+b</code>, <code>a/b</code>, etc., we will recursively solve the problem on this smaller list of numbers.</p> \n  <iframe src=\"https://leetcode.com/playground/vSR6aMjS/shared\" frameborder=\"0\" name=\"vSR6aMjS\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(1)</script>. There is a hard limit of 9216 possibilities, and we do <script type=\"math/tex; mode=display\">O(1)</script> work for each of them.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>. Our intermediate arrays are at most 4 elements, and the number made is bounded by an <script type=\"math/tex; mode=display\">O(1)</script> factor.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 678,
    "article_live": true,
    "article_slug": "valid-parenthesis-string",
    "title": "Valid Parenthesis String",
    "title_slug": "valid-parenthesis-string",
    "content": "<p>\r\nGiven a string containing only three types of characters: '(', ')' and '*', write a function to check whether this string is valid. We define the validity of a string by these rules:\r\n<ol>\r\n<li>Any left parenthesis <code>'('</code> must have a corresponding right parenthesis <code>')'</code>.</li>\r\n<li>Any right parenthesis <code>')'</code> must have a corresponding left parenthesis <code>'('</code>.</li>\r\n<li>Left parenthesis <code>'('</code> must go before the corresponding right parenthesis <code>')'</code>.</li>\r\n<li><code>'*'</code> could be treated as a single right parenthesis <code>')'</code> or a single left parenthesis <code>'('</code> or an empty string.</li>\r\n<li>An empty string is also valid.</li>\r\n</ol>\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \"()\"\r\n<b>Output:</b> True\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> \"(*)\"\r\n<b>Output:</b> True\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 3:</b><br />\r\n<pre>\r\n<b>Input:</b> \"(*))\"\r\n<b>Output:</b> True\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The string size will be in the range [1, 100].</li>\r\n</ol>\r\n</p>",
    "tags": "String",
    "difficulty": 2,
    "frontend_article_id": 678,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-brute-force-time-limit-exceeded\">Approach #1: Brute Force [Time Limit Exceeded]</a></li> \n    <li><a href=\"#approach-2-dynamic-programming-accepted\">Approach #2: Dynamic Programming [Accepted]</a></li> \n    <li><a href=\"#approach-3-greedy-accepted\">Approach #3: Greedy [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-brute-force-time-limit-exceeded\">Approach #1: Brute Force [Time Limit Exceeded]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>For each asterisk, let's try both possibilities.</p> \n  <iframe src=\"https://leetcode.com/playground/HHVFGh2C/shared\" frameborder=\"0\" name=\"HHVFGh2C\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N * 3^{N})</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of the string. For each asterisk we try 3 different values. Thus, we could be checking the validity of up to <script type=\"math/tex; mode=display\">3^N</script> strings. Then, each check of validity is <script type=\"math/tex; mode=display\">O(N)</script>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the space used by our character array.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-dynamic-programming-accepted\">Approach #2: Dynamic Programming [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Let <code>dp[i][j]</code> be <code>true</code> if and only if the interval <code>s[i], s[i+1], ..., s[j]</code> can be made valid. Then <code>dp[i][j]</code> is true only if:</p> \n  <ul> \n   <li> <p><code>s[i]</code> is <code>'*'</code>, and the interval <code>s[i+1], s[i+2], ..., s[j]</code> can be made valid;</p> </li> \n   <li> <p>or, <code>s[i]</code> can be made to be <code>'('</code>, and there is some <code>k</code> in <code>[i+1, j]</code> such that <code>s[k]</code> can be made to be <code>')'</code>, plus the two intervals cut by <code>s[k]</code> (<code>s[i+1: k]</code> and <code>s[k+1: j+1]</code>) can be made valid;</p> </li> \n  </ul> \n  <iframe src=\"https://leetcode.com/playground/c2qhBzko/shared\" frameborder=\"0\" name=\"c2qhBzko\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^3)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of the string. There are <script type=\"math/tex; mode=display\">O(N^2)</script> states corresponding to entries of <code>dp</code>, and we do an average of <script type=\"math/tex; mode=display\">O(N)</script> work on each state.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, the space used to store intermediate results in <code>dp</code>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-greedy-accepted\">Approach #3: Greedy [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>When checking whether the string is valid, we only cared about the \"<code>balance</code>\": the number of extra, open left brackets as we parsed through the string. For example, when checking whether '(()())' is valid, we had a balance of <code>1, 2, 1, 2, 1, 0</code> as we parse through the string: <code>'('</code> has 1 left bracket, <code>'(('</code> has 2, <code>'(()'</code> has 1, and so on. This means that after parsing the first <code>i</code> symbols, (which may include asterisks,) we only need to keep track of what the <code>balance</code> could be.</p> \n  <p>For example, if we have string <code>'(***)'</code>, then as we parse each symbol, the set of possible values for the <code>balance</code> is <code>[1]</code> for <code>'('</code>; <code>[0, 1, 2]</code> for <code>'(*'</code>; <code>[0, 1, 2, 3]</code> for <code>'(**'</code>; <code>[0, 1, 2, 3, 4]</code> for <code>'(***'</code>, and <code>[0, 1, 2, 3]</code> for <code>'(***)'</code>.</p> \n  <p>Furthermore, we can prove these states always form a contiguous interval. Thus, we only need to know the left and right bounds of this interval. That is, we would keep those intermediate states described above as <code>[lo, hi] = [1, 1], [0, 2], [0, 3], [0, 4], [0, 3]</code>.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Let <code>lo, hi</code> respectively be the smallest and largest possible number of open left brackets after processing the current character in the string.</p> \n  <p>If we encounter a left bracket (<code>c == '('</code>), then <code>lo++</code>, otherwise we could write a right bracket, so <code>lo--</code>. If we encounter what can be a left bracket (<code>c != ')'</code>), then <code>hi++</code>, otherwise we must write a right bracket, so <code>hi--</code>. If <code>hi &lt; 0</code>, then the current prefix can't be made valid no matter what our choices are. Also, we can never have less than <code>0</code> open left brackets. At the end, we should check that we can have exactly 0 open left brackets.</p> \n  <iframe src=\"https://leetcode.com/playground/AP7MmhXJ/shared\" frameborder=\"0\" name=\"AP7MmhXJ\" width=\"100%\" height=\"258\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of the string. We iterate through the string once.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>, the space used by our <code>lo</code> and <code>hi</code> pointers. However, creating a new character array will take <script type=\"math/tex; mode=display\">O(N)</script> space.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 677,
    "article_live": true,
    "article_slug": "map-sum-pairs",
    "title": "Map Sum Pairs",
    "title_slug": "map-sum-pairs",
    "content": "<p>\r\nImplement a MapSum class with <code>insert</code>, and <code>sum</code> methods.\r\n</p>\r\n\r\n<p>\r\nFor the method <code>insert</code>, you'll be given a pair of (string, integer). The string represents the key and the integer represents the value. If the key already existed, then the original key-value pair will be overridden to the new one.\r\n</p>\r\n\r\n<p>\r\nFor the method <code>sum</code>, you'll be given a string representing the prefix, and you need to return the sum of all the pairs' value whose key starts with the prefix.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\nInput: insert(\"apple\", 3), Output: Null\r\nInput: sum(\"ap\"), Output: 3\r\nInput: insert(\"app\", 2), Output: Null\r\nInput: sum(\"ap\"), Output: 5\r\n</pre>\r\n</p>\r\n",
    "tags": "Trie",
    "difficulty": 2,
    "frontend_article_id": 677,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-brute-force-accepted\">Approach #1: Brute Force [Accepted]</a></li> \n    <li><a href=\"#approach-2-prefix-hashmap-accepted\">Approach #2: Prefix Hashmap [Accepted]</a></li> \n    <li><a href=\"#approach-3-trie-accepted\">Approach #3: Trie [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-brute-force-accepted\">Approach #1: Brute Force [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>For each key in the map, if that key starts with the given prefix, then add it to the answer.</p> \n  <iframe src=\"https://leetcode.com/playground/jNhyy639/shared\" frameborder=\"0\" name=\"jNhyy639\" width=\"100%\" height=\"360\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: Every insert operation is <script type=\"math/tex; mode=display\">O(1)</script>. Every sum operation is <script type=\"math/tex; mode=display\">O(N * P)</script> where <script type=\"math/tex; mode=display\">N</script> is the number of items in the map, and <script type=\"math/tex; mode=display\">P</script> is the length of the input prefix.</p> </li> \n   <li> <p>Space Complexity: The space used by <code>map</code> is linear in the size of all input <code>key</code> and <code>val</code> values combined.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-prefix-hashmap-accepted\">Approach #2: Prefix Hashmap [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>We can remember the answer for all possible prefixes in a HashMap <code>score</code>. When we get a new <code>(key, val)</code> pair, we update every prefix of <code>key</code> appropriately: each prefix will be changed by <code>delta = val - map[key]</code>, where <code>map</code> is the previous associated value of <code>key</code> (zero if undefined.)</p> \n  <iframe src=\"https://leetcode.com/playground/QYzALHGM/shared\" frameborder=\"0\" name=\"QYzALHGM\" width=\"100%\" height=\"394\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: Every insert operation is <script type=\"math/tex; mode=display\">O(K^2)</script>, where <script type=\"math/tex; mode=display\">K</script> is the length of the key, as <script type=\"math/tex; mode=display\">K</script> strings are made of an average length of <script type=\"math/tex; mode=display\">K</script>. Every sum operation is <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n   <li> <p>Space Complexity: The space used by <code>map</code> and <code>score</code> is linear in the size of all input <code>key</code> and <code>val</code> values combined.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-trie-accepted\">Approach #3: Trie [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Since we are dealing with prefixes, a Trie (prefix tree) is a natural data structure to approach this problem. For every node of the trie corresponding to some prefix, we will remember the desired answer (score) and store it at this node. As in <em>Approach #2</em>, this involves modifying each node by <code>delta = val - map[key]</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/FbmbbgFJ/shared\" frameborder=\"0\" name=\"FbmbbgFJ\" width=\"100%\" height=\"513\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: Every insert operation is <script type=\"math/tex; mode=display\">O(K)</script>, where <script type=\"math/tex; mode=display\">K</script> is the length of the key. Every sum operation is <script type=\"math/tex; mode=display\">O(K)</script>.</p> </li> \n   <li> <p>Space Complexity: The space used is linear in the size of the total input.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 676,
    "article_live": true,
    "article_slug": "implement-magic-dictionary",
    "title": "Implement Magic Dictionary",
    "title_slug": "implement-magic-dictionary",
    "content": "<p>\r\nImplement a magic directory with <code>buildDict</code>, and <code>search</code> methods.\r\n</p>\r\n\r\n<p>\r\nFor the method <code>buildDict</code>, you'll be given a list of non-repetitive words to build a dictionary.\r\n</p>\r\n\r\n<p>\r\nFor the method <code>search</code>, you'll be given a word, and judge whether if you modify <b>exactly</b> one character into <b>another</b> character in this word, the modified word is in the dictionary you just built.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\nInput: buildDict([\"hello\", \"leetcode\"]), Output: Null\r\nInput: search(\"hello\"), Output: False\r\nInput: search(\"hhllo\"), Output: True\r\nInput: search(\"hell\"), Output: False\r\nInput: search(\"leetcoded\"), Output: False\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>You may assume that all the inputs are consist of lowercase letters <code>a-z</code>.</li>\r\n<li>For contest purpose, the test data is rather small by now. You could think about highly efficient algorithm after the contest.</li>\r\n<li>Please remember to <b>RESET</b> your class variables declared in class MagicDictionary, as static/class variables are <b>persisted across multiple test cases</b>. Please see <a href=\"https://leetcode.com/faq/#different-output\">here</a> for more details.</li>\r\n</ol>\r\n</p>",
    "tags": "Hash Table, Trie",
    "difficulty": 2,
    "frontend_article_id": 676,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-brute-force-with-bucket-by-length-accepted\">Approach #1: Brute Force with Bucket-By-Length [Accepted]</a></li> \n    <li><a href=\"#approach-2-generalized-neighbors-accepted\">Approach #2: Generalized Neighbors [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-brute-force-with-bucket-by-length-accepted\">Approach #1: Brute Force with Bucket-By-Length [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Call two strings neighbors if exactly one character can be changed in one to make the strings equal (ie. their hamming distance is 1.)</p> \n  <p>Strings can only be neighbors if their lengths are equal. When <code>search</code>ing a new word, let's check only the words that are the same length.</p> \n  <p><strong>Python</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"k\">class</span> <span class=\"nc\">MagicDictionary</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">buckets</span> <span class=\"o\">=</span> <span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">defaultdict</span><span class=\"p\">(</span><span class=\"nb\">list</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">buildDict</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">words</span><span class=\"p\">):</span>\n        <span class=\"k\">for</span> <span class=\"n\">word</span> <span class=\"ow\">in</span> <span class=\"n\">words</span><span class=\"p\">:</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">buckets</span><span class=\"p\">[</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">word</span><span class=\"p\">)]</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">word</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">search</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">word</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"nb\">any</span><span class=\"p\">(</span><span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">!=</span><span class=\"n\">b</span> <span class=\"k\">for</span> <span class=\"n\">a</span><span class=\"p\">,</span><span class=\"n\">b</span> <span class=\"ow\">in</span> <span class=\"nb\">zip</span><span class=\"p\">(</span><span class=\"n\">word</span><span class=\"p\">,</span> <span class=\"n\">candidate</span><span class=\"p\">))</span> <span class=\"o\">==</span> <span class=\"mi\">1</span>\n                   <span class=\"k\">for</span> <span class=\"n\">candidate</span> <span class=\"ow\">in</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">buckets</span><span class=\"p\">[</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">word</span><span class=\"p\">)])</span>\n</pre>\n  </div> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">class</span> <span class=\"nc\">MagicDictionary</span> <span class=\"o\">{</span>\n    <span class=\"n\">Map</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">,</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">buckets</span><span class=\"o\">;</span>\n    <span class=\"kd\">public</span> <span class=\"nf\">MagicDictionary</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">buckets</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HashMap</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">buildDict</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">words</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">word</span><span class=\"o\">:</span> <span class=\"n\">words</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">buckets</span><span class=\"o\">.</span><span class=\"na\">computeIfAbsent</span><span class=\"o\">(</span><span class=\"n\">word</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">(),</span> <span class=\"n\">x</span> <span class=\"o\">-&gt;</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">()).</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">word</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">search</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">word</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(!</span><span class=\"n\">buckets</span><span class=\"o\">.</span><span class=\"na\">containsKey</span><span class=\"o\">(</span><span class=\"n\">word</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()))</span> <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">candidate</span><span class=\"o\">:</span> <span class=\"n\">buckets</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">word</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()))</span> <span class=\"o\">{</span>\n            <span class=\"kt\">int</span> <span class=\"n\">mismatch</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n            <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">word</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">();</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">word</span><span class=\"o\">.</span><span class=\"na\">charAt</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">!=</span> <span class=\"n\">candidate</span><span class=\"o\">.</span><span class=\"na\">charAt</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">{</span>\n                    <span class=\"k\">if</span> <span class=\"o\">(++</span><span class=\"n\">mismatch</span> <span class=\"o\">&gt;</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"k\">break</span><span class=\"o\">;</span>\n                <span class=\"o\">}</span>\n            <span class=\"o\">}</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">mismatch</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(S)</script> to build and <script type=\"math/tex; mode=display\">O(NK)</script> to search, where <script type=\"math/tex; mode=display\">N</script> is the number of <code>words</code> in our magic dictionary, <script type=\"math/tex; mode=display\">S</script> is the total number of letters in it, and <script type=\"math/tex; mode=display\">K</script> is the length of the search word.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(S)</script>, the space used by <code>buckets</code>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-generalized-neighbors-accepted\">Approach #2: Generalized Neighbors [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Recall in <em>Approach #1</em> that two words are <em>neighbors</em> if exactly one character can be changed in one word to make the strings equal.</p> \n  <p>Let's say a word 'apple' has <em>generalized neighbors</em> '*pple', 'a*ple', 'ap*le', 'app*e', and 'appl*'. When searching for whether a word like 'apply' has a neighbor like 'apple', we only need to know whether they have a common <em>generalized neighbor</em>.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Continuing the above thinking, one issue is that 'apply' is not a neighbor with itself, yet it has the same generalized neighbor '*pply'. To remedy this, we'll count how many sources generated '*pply'. If there are 2 or more, then one of them won't be 'apply'. If there is exactly one, we should check that it wasn't 'apply'. In either case, we can be sure that there was some magic word generating '*pply' that <em>wasn't</em> 'apply'.</p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"k\">class</span> <span class=\"nc\">MagicDictionary</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">_genneighbors</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">word</span><span class=\"p\">):</span>\n        <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">xrange</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">word</span><span class=\"p\">)):</span>\n            <span class=\"k\">yield</span> <span class=\"n\">word</span><span class=\"p\">[:</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"s1\">'*'</span> <span class=\"o\">+</span> <span class=\"n\">word</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">:]</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">buildDict</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">words</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">words</span> <span class=\"o\">=</span> <span class=\"nb\">set</span><span class=\"p\">(</span><span class=\"n\">words</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">Counter</span><span class=\"p\">(</span><span class=\"n\">nei</span> <span class=\"k\">for</span> <span class=\"n\">word</span> <span class=\"ow\">in</span> <span class=\"n\">words</span>\n                                        <span class=\"k\">for</span> <span class=\"n\">nei</span> <span class=\"ow\">in</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_genneighbors</span><span class=\"p\">(</span><span class=\"n\">word</span><span class=\"p\">))</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">search</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">word</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"nb\">any</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">count</span><span class=\"p\">[</span><span class=\"n\">nei</span><span class=\"p\">]</span> <span class=\"o\">&gt;</span> <span class=\"mi\">1</span> <span class=\"ow\">or</span>\n                   <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">count</span><span class=\"p\">[</span><span class=\"n\">nei</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"mi\">1</span> <span class=\"ow\">and</span> <span class=\"n\">word</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">words</span>\n                   <span class=\"k\">for</span> <span class=\"n\">nei</span> <span class=\"ow\">in</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_genneighbors</span><span class=\"p\">(</span><span class=\"n\">word</span><span class=\"p\">))</span>\n</pre>\n  </div> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">MagicDictionary</span> <span class=\"o\">{</span>\n    <span class=\"n\">Set</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">words</span><span class=\"o\">;</span>\n    <span class=\"n\">Map</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">,</span> <span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">count</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"nf\">MagicDictionary</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">words</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HashSet</span><span class=\"o\">();</span>\n        <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HashMap</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">private</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;</span> <span class=\"nf\">generalizedNeighbors</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">word</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">();</span>\n        <span class=\"kt\">char</span><span class=\"o\">[]</span> <span class=\"n\">ca</span> <span class=\"o\">=</span> <span class=\"n\">word</span><span class=\"o\">.</span><span class=\"na\">toCharArray</span><span class=\"o\">();</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">word</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">();</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kt\">char</span> <span class=\"n\">letter</span> <span class=\"o\">=</span> <span class=\"n\">ca</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">];</span>\n            <span class=\"n\">ca</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"sc\">'*'</span><span class=\"o\">;</span>\n            <span class=\"n\">String</span> <span class=\"n\">magic</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">String</span><span class=\"o\">(</span><span class=\"n\">ca</span><span class=\"o\">);</span>\n            <span class=\"n\">ans</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">magic</span><span class=\"o\">);</span>\n            <span class=\"n\">ca</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">letter</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">ans</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">buildDict</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">words</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">word</span><span class=\"o\">:</span> <span class=\"n\">words</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">words</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">word</span><span class=\"o\">);</span>\n            <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">nei</span><span class=\"o\">:</span> <span class=\"n\">generalizedNeighbors</span><span class=\"o\">(</span><span class=\"n\">word</span><span class=\"o\">))</span> <span class=\"o\">{</span>\n                <span class=\"n\">count</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"n\">nei</span><span class=\"o\">,</span> <span class=\"n\">count</span><span class=\"o\">.</span><span class=\"na\">getOrDefault</span><span class=\"o\">(</span><span class=\"n\">nei</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">search</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">word</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">nei</span><span class=\"o\">:</span> <span class=\"n\">generalizedNeighbors</span><span class=\"o\">(</span><span class=\"n\">word</span><span class=\"o\">))</span> <span class=\"o\">{</span>\n            <span class=\"kt\">int</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">count</span><span class=\"o\">.</span><span class=\"na\">getOrDefault</span><span class=\"o\">(</span><span class=\"n\">nei</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">);</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">&gt;</span> <span class=\"mi\">1</span> <span class=\"o\">||</span> <span class=\"n\">c</span> <span class=\"o\">==</span> <span class=\"mi\">1</span> <span class=\"o\">&amp;&amp;</span> <span class=\"o\">!</span><span class=\"n\">words</span><span class=\"o\">.</span><span class=\"na\">contains</span><span class=\"o\">(</span><span class=\"n\">word</span><span class=\"o\">))</span> <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(\\sum w_i^2)</script> to build and <script type=\"math/tex; mode=display\">O(K^2)</script> to search, where <script type=\"math/tex; mode=display\">w_i</script> is the length of <code>words[i]</code>, and <script type=\"math/tex; mode=display\">K</script> is the length of our search word.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(\\sum w_i^2)</script>, the space used by <code>count</code>. We also use <script type=\"math/tex; mode=display\">O(K^2)</script> space when generating neighbors to search.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 675,
    "article_live": true,
    "article_slug": "cutoff-trees-for-golf-event",
    "title": "Cut Off Trees for Golf Event",
    "title_slug": "cut-off-trees-for-golf-event",
    "content": "<p>\r\nYou are asked to cut off trees in a forest for a golf event. The forest is represented as a non-negative 2D map, in this map:\r\n<ol>\r\n<li><code>0</code> represents the <code>obstacle</code> can't be reached.</li>\r\n<li><code>1</code> represents the <code>ground</code> can be walked through.</li>\r\n<li><code>The place with number bigger than 1</code> represents a <code>tree</code> can be walked through, and this positive number represents the tree's height.</li>\r\n</ol>\r\n</p>\r\n\r\n<p>\r\nYou are asked to cut off <b>all</b> the trees in this forest in the order of tree's height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1). \r\n</p>\r\n\r\n<p>\r\nYou will start from the point (0, 0) and you should output the minimum steps <b>you need to walk</b> to cut off all the trees. If you can't cut off all the trees, output -1 in that situation.\r\n</p>\r\n\r\n<p>\r\nYou are guaranteed that no two <code>trees</code> have the same height and there is at least one tree needs to be cut off.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\n[\r\n [1,2,3],\r\n [0,0,4],\r\n [7,6,5]\r\n]\r\n<b>Output:</b> 6\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\n[\r\n [1,2,3],\r\n [0,0,0],\r\n [7,6,5]\r\n]\r\n<b>Output:</b> -1\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 3:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\n[\r\n [2,3,4],\r\n [0,0,5],\r\n [8,7,6]\r\n]\r\n<b>Output:</b> 6\r\n<b>Explanation:</b> You started from the point (0,0) and you can cut off the tree in (0,0) directly without walking.\r\n</pre>\r\n</p>\r\n\r\n<p>\r\n<b>Hint</b>: size of the given matrix will not exceed 50x50.\r\n</p>",
    "tags": "Breadth-first Search",
    "difficulty": 3,
    "frontend_article_id": 675,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-framework\">Approach Framework</a></li> \n    <li><a href=\"#approach-1-bfs-accepted\">Approach #1: BFS [Accepted]</a></li> \n    <li><a href=\"#approach-2-a-search-accepted\">Approach #2: A* Search [Accepted]</a></li> \n    <li><a href=\"#approach-3-hadlocks-algorithm-accepted\">Approach #3: Hadlock's Algorithm [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-framework\">Approach Framework</h4> \n  <p><strong>Explanation</strong></p> \n  <p>Starting from <code>(0, 0)</code>, for each tree in height order, we will calculate the distance from where we are to the next tree (and move there), adding that distance to the answer.</p> \n  <p>We frame the problem as providing some distance function <code>dist(forest, sr, sc, tr, tc)</code> that calculates the path distance from source <code>(sr, sc)</code> to target <code>(tr, tc)</code> through obstacles <code>dist[i][j] == 0</code>. (This distance function will return <code>-1</code> if the path is impossible.)</p> \n  <p>What follows is code and complexity analysis that is common to all three approaches. After, the algorithms presented in our approaches will focus on only providing our <code>dist</code> function.</p> \n  <p><strong>Python</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">cutOffTree</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">forest</span><span class=\"p\">):</span>\n        <span class=\"n\">trees</span> <span class=\"o\">=</span> <span class=\"nb\">sorted</span><span class=\"p\">((</span><span class=\"n\">v</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"n\">row</span> <span class=\"ow\">in</span> <span class=\"nb\">enumerate</span><span class=\"p\">(</span><span class=\"n\">forest</span><span class=\"p\">)</span>\n                       <span class=\"k\">for</span> <span class=\"n\">c</span><span class=\"p\">,</span> <span class=\"n\">v</span> <span class=\"ow\">in</span> <span class=\"nb\">enumerate</span><span class=\"p\">(</span><span class=\"n\">row</span><span class=\"p\">)</span> <span class=\"k\">if</span> <span class=\"n\">v</span> <span class=\"o\">&gt;</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n        <span class=\"n\">sr</span> <span class=\"o\">=</span> <span class=\"n\">sc</span> <span class=\"o\">=</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n        <span class=\"k\">for</span> <span class=\"n\">_</span><span class=\"p\">,</span> <span class=\"n\">tr</span><span class=\"p\">,</span> <span class=\"n\">tc</span> <span class=\"ow\">in</span> <span class=\"n\">trees</span><span class=\"p\">:</span>\n            <span class=\"n\">d</span> <span class=\"o\">=</span> <span class=\"n\">dist</span><span class=\"p\">(</span><span class=\"n\">forest</span><span class=\"p\">,</span> <span class=\"n\">sr</span><span class=\"p\">,</span> <span class=\"n\">sc</span><span class=\"p\">,</span> <span class=\"n\">tr</span><span class=\"p\">,</span> <span class=\"n\">tc</span><span class=\"p\">)</span>\n            <span class=\"k\">if</span> <span class=\"n\">d</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span><span class=\"p\">:</span> <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"mi\">1</span>\n            <span class=\"n\">ans</span> <span class=\"o\">+=</span> <span class=\"n\">d</span>\n            <span class=\"n\">sr</span><span class=\"p\">,</span> <span class=\"n\">sc</span> <span class=\"o\">=</span> <span class=\"n\">tr</span><span class=\"p\">,</span> <span class=\"n\">tc</span>\n        <span class=\"k\">return</span> <span class=\"n\">ans</span>\n</pre>\n  </div> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">dr</span> <span class=\"o\">=</span> <span class=\"o\">{-</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">};</span>\n    <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">dc</span> <span class=\"o\">=</span> <span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">};</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">cutOffTree</span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">forest</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">[]&gt;</span> <span class=\"n\">trees</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">();</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">r</span> <span class=\"o\">&lt;</span> <span class=\"n\">forest</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">();</span> <span class=\"o\">++</span><span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">c</span> <span class=\"o\">&lt;</span> <span class=\"n\">forest</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">).</span><span class=\"na\">size</span><span class=\"o\">();</span> <span class=\"o\">++</span><span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"kt\">int</span> <span class=\"n\">v</span> <span class=\"o\">=</span> <span class=\"n\">forest</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"o\">).</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">);</span>\n                <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">&gt;</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">trees</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[]{</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">});</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"n\">Collections</span><span class=\"o\">.</span><span class=\"na\">sort</span><span class=\"o\">(</span><span class=\"n\">trees</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">Integer</span><span class=\"o\">.</span><span class=\"na\">compare</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">],</span> <span class=\"n\">b</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]));</span>\n\n        <span class=\"kt\">int</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">sr</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">sc</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">tree</span><span class=\"o\">:</span> <span class=\"n\">trees</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kt\">int</span> <span class=\"n\">d</span> <span class=\"o\">=</span> <span class=\"n\">dist</span><span class=\"o\">(</span><span class=\"n\">forest</span><span class=\"o\">,</span> <span class=\"n\">sr</span><span class=\"o\">,</span> <span class=\"n\">sc</span><span class=\"o\">,</span> <span class=\"n\">tree</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">],</span> <span class=\"n\">tree</span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">]);</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"o\">;</span>\n            <span class=\"n\">ans</span> <span class=\"o\">+=</span> <span class=\"n\">d</span><span class=\"o\">;</span>\n            <span class=\"n\">sr</span> <span class=\"o\">=</span> <span class=\"n\">tree</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">];</span> <span class=\"n\">sc</span> <span class=\"o\">=</span> <span class=\"n\">tree</span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">];</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">ans</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <p>All three algorithms have similar worst case complexities, but in practice each successive algorithm presented performs faster on random data.</p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O((RC)^2)</script> where there are <script type=\"math/tex; mode=display\">R</script> rows and <script type=\"math/tex; mode=display\">C</script> columns in the given <code>forest</code>. We walk to <script type=\"math/tex; mode=display\">R*C</script> trees, and each walk could spend <script type=\"math/tex; mode=display\">O(R*C)</script> time searching for the tree.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(R*C)</script>, the maximum size of the data structures used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-1-bfs-accepted\">Approach #1: BFS [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>We perform a breadth-first-search, processing nodes (grid positions) in a queue. <code>seen</code> keeps track of nodes that have already been added to the queue at some point - those nodes will be already processed or are in the queue awaiting processing.</p> \n  <p>For each node that is next to be processed, we look at it's neighbors. If they are in the forest (grid), they haven't been enqueued, and they aren't an obstacle, we will enqueue that neighbor.</p> \n  <p>We also keep a side count of the distance travelled for each node. If the node we are processing is our destination 'target' <code>(tr, tc)</code>, we'll return the answer.</p> \n  <p><strong>Python</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"k\">def</span> <span class=\"nf\">bfs</span><span class=\"p\">(</span><span class=\"n\">forest</span><span class=\"p\">,</span> <span class=\"n\">sr</span><span class=\"p\">,</span> <span class=\"n\">sc</span><span class=\"p\">,</span> <span class=\"n\">tr</span><span class=\"p\">,</span> <span class=\"n\">tc</span><span class=\"p\">):</span>\n    <span class=\"n\">R</span><span class=\"p\">,</span> <span class=\"n\">C</span> <span class=\"o\">=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">forest</span><span class=\"p\">),</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">forest</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span>\n    <span class=\"n\">queue</span> <span class=\"o\">=</span> <span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">deque</span><span class=\"p\">([(</span><span class=\"n\">sr</span><span class=\"p\">,</span> <span class=\"n\">sc</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)])</span>\n    <span class=\"n\">seen</span> <span class=\"o\">=</span> <span class=\"p\">{(</span><span class=\"n\">sr</span><span class=\"p\">,</span> <span class=\"n\">sc</span><span class=\"p\">)}</span>\n    <span class=\"k\">while</span> <span class=\"n\">queue</span><span class=\"p\">:</span>\n        <span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">,</span> <span class=\"n\">d</span> <span class=\"o\">=</span> <span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"n\">popleft</span><span class=\"p\">()</span>\n        <span class=\"k\">if</span> <span class=\"n\">r</span> <span class=\"o\">==</span> <span class=\"n\">tr</span> <span class=\"ow\">and</span> <span class=\"n\">c</span> <span class=\"o\">==</span> <span class=\"n\">tc</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"n\">d</span>\n        <span class=\"k\">for</span> <span class=\"n\">nr</span><span class=\"p\">,</span> <span class=\"n\">nc</span> <span class=\"ow\">in</span> <span class=\"p\">((</span><span class=\"n\">r</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"n\">r</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">)):</span>\n            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"mi\">0</span> <span class=\"o\">&lt;=</span> <span class=\"n\">nr</span> <span class=\"o\">&lt;</span> <span class=\"n\">R</span> <span class=\"ow\">and</span> <span class=\"mi\">0</span> <span class=\"o\">&lt;=</span> <span class=\"n\">nc</span> <span class=\"o\">&lt;</span> <span class=\"n\">C</span> <span class=\"ow\">and</span>\n                    <span class=\"p\">(</span><span class=\"n\">nr</span><span class=\"p\">,</span> <span class=\"n\">nc</span><span class=\"p\">)</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"n\">seen</span> <span class=\"ow\">and</span> <span class=\"n\">forest</span><span class=\"p\">[</span><span class=\"n\">nr</span><span class=\"p\">][</span><span class=\"n\">nc</span><span class=\"p\">]):</span>\n                <span class=\"n\">seen</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">((</span><span class=\"n\">nr</span><span class=\"p\">,</span> <span class=\"n\">nc</span><span class=\"p\">))</span>\n                <span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">((</span><span class=\"n\">nr</span><span class=\"p\">,</span> <span class=\"n\">nc</span><span class=\"p\">,</span> <span class=\"n\">d</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">))</span>\n    <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"mi\">1</span>\n</pre>\n  </div> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">bfs</span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">forest</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">sr</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">sc</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">tr</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">tc</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">R</span> <span class=\"o\">=</span> <span class=\"n\">forest</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">(),</span> <span class=\"n\">C</span> <span class=\"o\">=</span> <span class=\"n\">forest</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">).</span><span class=\"na\">size</span><span class=\"o\">();</span>\n    <span class=\"n\">Queue</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">[]&gt;</span> <span class=\"n\">queue</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">LinkedList</span><span class=\"o\">();</span>\n    <span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[]{</span><span class=\"n\">sr</span><span class=\"o\">,</span> <span class=\"n\">sc</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">});</span>\n    <span class=\"kt\">boolean</span><span class=\"o\">[][]</span> <span class=\"n\">seen</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">boolean</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">][</span><span class=\"n\">C</span><span class=\"o\">];</span>\n    <span class=\"n\">seen</span><span class=\"o\">[</span><span class=\"n\">sr</span><span class=\"o\">][</span><span class=\"n\">sc</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">(!</span><span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"na\">isEmpty</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">cur</span> <span class=\"o\">=</span> <span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"na\">poll</span><span class=\"o\">();</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">cur</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"o\">==</span> <span class=\"n\">tr</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">cur</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"o\">==</span> <span class=\"n\">tc</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"n\">cur</span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">];</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">di</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">di</span> <span class=\"o\">&lt;</span> <span class=\"mi\">4</span><span class=\"o\">;</span> <span class=\"o\">++</span><span class=\"n\">di</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kt\">int</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">cur</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"o\">+</span> <span class=\"n\">dr</span><span class=\"o\">[</span><span class=\"n\">di</span><span class=\"o\">];</span>\n            <span class=\"kt\">int</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">cur</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"o\">+</span> <span class=\"n\">dc</span><span class=\"o\">[</span><span class=\"n\">di</span><span class=\"o\">];</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">&lt;=</span> <span class=\"n\">r</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">r</span> <span class=\"o\">&lt;</span> <span class=\"n\">R</span> <span class=\"o\">&amp;&amp;</span> <span class=\"mi\">0</span> <span class=\"o\">&lt;=</span> <span class=\"n\">c</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">c</span> <span class=\"o\">&lt;</span> <span class=\"n\">C</span> <span class=\"o\">&amp;&amp;</span>\n                    <span class=\"o\">!</span><span class=\"n\">seen</span><span class=\"o\">[</span><span class=\"n\">r</span><span class=\"o\">][</span><span class=\"n\">c</span><span class=\"o\">]</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">forest</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"o\">).</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"n\">seen</span><span class=\"o\">[</span><span class=\"n\">r</span><span class=\"o\">][</span><span class=\"n\">c</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n                <span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[]{</span><span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">cur</span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">]+</span><span class=\"mi\">1</span><span class=\"o\">});</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <hr> \n  <h4 id=\"approach-2-a-search-accepted\">Approach #2: A* Search [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>The A<em> star algorithm is another path-finding algorithm. For every node at position <code>(r, c)</code>, we have some estimated cost <code>node.f = node.g + node.h</code>, where <code>node.g</code> is the actual distance from <code>(sr, sc)</code> to <code>(r, c)</code>, and <code>node.h</code> is our </em>heuristic* (guess) of the distance from <code>(r, c)</code> to <code>(tr, tc)</code>. In this case, our guess will be the taxicab distance, <code>node.h = abs(r-tr) + abs(c-tc)</code>.</p> \n  <p>We keep a priority queue to decide what node to search in (<em>expand</em>) next. We can prove that if we find the target node, we must have travelled the lowest possible distance <code>node.g</code>. By considering the last time where two backwards paths are the same, without loss of generality we could suppose the penultimate square of the two paths are different, and then in this case <code>node.f = node.g + 1</code>, showing the path with less actual distance travelled is expanded first as desired.</p> \n  <p>It might be useful for solvers familiar with <em>Dijkstra's Algorithm</em> to know that <em>A* Search</em> is a special case of <em>Dijkstra's</em> with <code>node.h = 0</code> always.</p> \n  <p><strong>Python</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"k\">def</span> <span class=\"nf\">astar</span><span class=\"p\">(</span><span class=\"n\">forest</span><span class=\"p\">,</span> <span class=\"n\">sr</span><span class=\"p\">,</span> <span class=\"n\">sc</span><span class=\"p\">,</span> <span class=\"n\">tr</span><span class=\"p\">,</span> <span class=\"n\">tc</span><span class=\"p\">):</span>\n    <span class=\"n\">R</span><span class=\"p\">,</span> <span class=\"n\">C</span> <span class=\"o\">=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">forest</span><span class=\"p\">),</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">forest</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span>\n    <span class=\"n\">heap</span> <span class=\"o\">=</span> <span class=\"p\">[(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">sr</span><span class=\"p\">,</span> <span class=\"n\">sc</span><span class=\"p\">)]</span>\n    <span class=\"n\">cost</span> <span class=\"o\">=</span> <span class=\"p\">{(</span><span class=\"n\">sr</span><span class=\"p\">,</span> <span class=\"n\">sc</span><span class=\"p\">):</span> <span class=\"mi\">0</span><span class=\"p\">}</span>\n    <span class=\"k\">while</span> <span class=\"n\">heap</span><span class=\"p\">:</span>\n        <span class=\"n\">f</span><span class=\"p\">,</span> <span class=\"n\">g</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">heapq</span><span class=\"o\">.</span><span class=\"n\">heappop</span><span class=\"p\">(</span><span class=\"n\">heap</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"n\">r</span> <span class=\"o\">==</span> <span class=\"n\">tr</span> <span class=\"ow\">and</span> <span class=\"n\">c</span> <span class=\"o\">==</span> <span class=\"n\">tc</span><span class=\"p\">:</span> <span class=\"k\">return</span> <span class=\"n\">g</span>\n        <span class=\"k\">for</span> <span class=\"n\">nr</span><span class=\"p\">,</span> <span class=\"n\">nc</span> <span class=\"ow\">in</span> <span class=\"p\">((</span><span class=\"n\">r</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"n\">c</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"n\">r</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"n\">c</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"n\">r</span><span class=\"p\">,</span><span class=\"n\">c</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"n\">r</span><span class=\"p\">,</span><span class=\"n\">c</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">)):</span>\n            <span class=\"k\">if</span> <span class=\"mi\">0</span> <span class=\"o\">&lt;=</span> <span class=\"n\">nr</span> <span class=\"o\">&lt;</span> <span class=\"n\">R</span> <span class=\"ow\">and</span> <span class=\"mi\">0</span> <span class=\"o\">&lt;=</span> <span class=\"n\">nc</span> <span class=\"o\">&lt;</span> <span class=\"n\">C</span> <span class=\"ow\">and</span> <span class=\"n\">forest</span><span class=\"p\">[</span><span class=\"n\">nr</span><span class=\"p\">][</span><span class=\"n\">nc</span><span class=\"p\">]:</span>\n                <span class=\"n\">ncost</span> <span class=\"o\">=</span> <span class=\"n\">g</span> <span class=\"o\">+</span> <span class=\"mi\">1</span> <span class=\"o\">+</span> <span class=\"nb\">abs</span><span class=\"p\">(</span><span class=\"n\">nr</span> <span class=\"o\">-</span> <span class=\"n\">tr</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"nb\">abs</span><span class=\"p\">(</span><span class=\"n\">nc</span> <span class=\"o\">-</span> <span class=\"n\">tc</span><span class=\"p\">)</span>\n                <span class=\"k\">if</span> <span class=\"n\">ncost</span> <span class=\"o\">&lt;</span> <span class=\"n\">cost</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">((</span><span class=\"n\">nr</span><span class=\"p\">,</span> <span class=\"n\">nc</span><span class=\"p\">),</span> <span class=\"mi\">9999</span><span class=\"p\">):</span>\n                    <span class=\"n\">cost</span><span class=\"p\">[</span><span class=\"n\">nr</span><span class=\"p\">,</span> <span class=\"n\">nc</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">ncost</span>\n                    <span class=\"n\">heapq</span><span class=\"o\">.</span><span class=\"n\">heappush</span><span class=\"p\">(</span><span class=\"n\">heap</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">ncost</span><span class=\"p\">,</span> <span class=\"n\">g</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">nr</span><span class=\"p\">,</span> <span class=\"n\">nc</span><span class=\"p\">))</span>\n    <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"mi\">1</span>\n</pre>\n  </div> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">cutOffTree</span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">forest</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">sr</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">sc</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">tr</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">tc</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">R</span> <span class=\"o\">=</span> <span class=\"n\">forest</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">(),</span> <span class=\"n\">C</span> <span class=\"o\">=</span> <span class=\"n\">forest</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">).</span><span class=\"na\">size</span><span class=\"o\">();</span>\n    <span class=\"n\">PriorityQueue</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">[]&gt;</span> <span class=\"n\">heap</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">PriorityQueue</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">[]&gt;(</span>\n        <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">Integer</span><span class=\"o\">.</span><span class=\"na\">compare</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">],</span> <span class=\"n\">b</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]));</span>\n    <span class=\"n\">heap</span><span class=\"o\">.</span><span class=\"na\">offer</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[]{</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">sr</span><span class=\"o\">,</span> <span class=\"n\">sc</span><span class=\"o\">});</span>\n\n    <span class=\"n\">HashMap</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">,</span> <span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">cost</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HashMap</span><span class=\"o\">();</span>\n    <span class=\"n\">cost</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"n\">sr</span> <span class=\"o\">*</span> <span class=\"n\">C</span> <span class=\"o\">+</span> <span class=\"n\">sc</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">);</span>\n\n    <span class=\"k\">while</span> <span class=\"o\">(!</span><span class=\"n\">heap</span><span class=\"o\">.</span><span class=\"na\">isEmpty</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">cur</span> <span class=\"o\">=</span> <span class=\"n\">heap</span><span class=\"o\">.</span><span class=\"na\">poll</span><span class=\"o\">();</span>\n        <span class=\"kt\">int</span> <span class=\"n\">g</span> <span class=\"o\">=</span> <span class=\"n\">cur</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">],</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">cur</span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">],</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">cur</span><span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">];</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">==</span> <span class=\"n\">tr</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">c</span> <span class=\"o\">==</span> <span class=\"n\">tc</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"n\">g</span><span class=\"o\">;</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">di</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">di</span> <span class=\"o\">&lt;</span> <span class=\"mi\">4</span><span class=\"o\">;</span> <span class=\"o\">++</span><span class=\"n\">di</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kt\">int</span> <span class=\"n\">nr</span> <span class=\"o\">=</span> <span class=\"n\">r</span> <span class=\"o\">+</span> <span class=\"n\">dr</span><span class=\"o\">[</span><span class=\"n\">di</span><span class=\"o\">],</span> <span class=\"n\">nc</span> <span class=\"o\">=</span> <span class=\"n\">c</span> <span class=\"o\">+</span> <span class=\"n\">dc</span><span class=\"o\">[</span><span class=\"n\">di</span><span class=\"o\">];</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">&lt;=</span> <span class=\"n\">nr</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">nr</span> <span class=\"o\">&lt;</span> <span class=\"n\">R</span> <span class=\"o\">&amp;&amp;</span> <span class=\"mi\">0</span> <span class=\"o\">&lt;=</span> <span class=\"n\">nc</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">nc</span> <span class=\"o\">&lt;</span> <span class=\"n\">C</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">forest</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">nr</span><span class=\"o\">).</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">nc</span><span class=\"o\">)</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"kt\">int</span> <span class=\"n\">ncost</span> <span class=\"o\">=</span> <span class=\"n\">g</span> <span class=\"o\">+</span> <span class=\"mi\">1</span> <span class=\"o\">+</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">abs</span><span class=\"o\">(</span><span class=\"n\">nr</span><span class=\"o\">-</span><span class=\"n\">tr</span><span class=\"o\">)</span> <span class=\"o\">+</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">abs</span><span class=\"o\">(</span><span class=\"n\">nc</span><span class=\"o\">-</span><span class=\"n\">tr</span><span class=\"o\">);</span>\n                <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">ncost</span> <span class=\"o\">&lt;</span> <span class=\"n\">cost</span><span class=\"o\">.</span><span class=\"na\">getOrDefault</span><span class=\"o\">(</span><span class=\"n\">nr</span> <span class=\"o\">*</span> <span class=\"n\">C</span> <span class=\"o\">+</span> <span class=\"n\">nc</span><span class=\"o\">,</span> <span class=\"mi\">9999</span><span class=\"o\">))</span> <span class=\"o\">{</span>\n                    <span class=\"n\">cost</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"n\">nr</span> <span class=\"o\">*</span> <span class=\"n\">C</span> <span class=\"o\">+</span> <span class=\"n\">nc</span><span class=\"o\">,</span> <span class=\"n\">ncost</span><span class=\"o\">);</span>\n                    <span class=\"n\">heap</span><span class=\"o\">.</span><span class=\"na\">offer</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[]{</span><span class=\"n\">ncost</span><span class=\"o\">,</span> <span class=\"n\">g</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">nr</span><span class=\"o\">,</span> <span class=\"n\">nc</span><span class=\"o\">});</span>\n                <span class=\"o\">}</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <hr> \n  <h4 id=\"approach-3-hadlocks-algorithm-accepted\">Approach #3: Hadlock's Algorithm [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Without any obstacles, the distance from <code>source = (sr, sc)</code> to <code>target = (tr, tc)</code> is simply <code>taxi(source, target) = abs(sr-tr) + abs(sc-tc)</code>. This represents a sort of minimum distance that must be travelled. Whenever we walk \"away\" from the target, we increase this minimum by 2, as we stepped 1 move, plus the taxicab distance from our new location has increased by one.</p> \n  <p>Let's call such a move that walks away from the target a <em>detour</em>. It can be proven that the distance from source to target is simply <code>taxi(source, target) + 2 * detours</code>, where <code>detours</code> is the smallest number of detours in any path from <code>source</code> to <code>target</code>.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>With respect to a <code>source</code> and <code>target</code>, call the <em>detour number</em> of a square to be the lowest number of detours possible in any path from <code>source</code> to that square. (Here, detours are defined with respect to <code>target</code> - the number of away steps from that target.)</p> \n  <p>We will perform a priority-first-search in order of detour number. If the target is found, it was found with the lowest detour number and therefore the lowest corresponding distance. This motivates using <code>processed</code>, keeping track of when nodes are expanded, not visited - nodes could potentially be visited twice.</p> \n  <p>As each neighboring node can only have the same detour number or a detour number one higher, we will only consider at most 2 priority classes at a time. Thus, we can use a deque (double ended queue) to perform this implementation. We will place nodes with the same detour number to be expanded first, and nodes with a detour number one higher to be expanded after all nodes with the current number are done.</p> \n  <p><strong>Python</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"k\">def</span> <span class=\"nf\">hadlocks</span><span class=\"p\">(</span><span class=\"n\">forest</span><span class=\"p\">,</span> <span class=\"n\">sr</span><span class=\"p\">,</span> <span class=\"n\">sc</span><span class=\"p\">,</span> <span class=\"n\">tr</span><span class=\"p\">,</span> <span class=\"n\">tc</span><span class=\"p\">):</span>\n    <span class=\"n\">R</span><span class=\"p\">,</span> <span class=\"n\">C</span> <span class=\"o\">=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">forest</span><span class=\"p\">),</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">forest</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span>\n    <span class=\"n\">processed</span> <span class=\"o\">=</span> <span class=\"nb\">set</span><span class=\"p\">()</span>\n    <span class=\"n\">deque</span> <span class=\"o\">=</span> <span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">deque</span><span class=\"p\">([(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">sr</span><span class=\"p\">,</span> <span class=\"n\">sc</span><span class=\"p\">)])</span>\n    <span class=\"k\">while</span> <span class=\"n\">deque</span><span class=\"p\">:</span>\n        <span class=\"n\">detours</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">deque</span><span class=\"o\">.</span><span class=\"n\">popleft</span><span class=\"p\">()</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">)</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"n\">processed</span><span class=\"p\">:</span>\n            <span class=\"n\">processed</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">((</span><span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">))</span>\n            <span class=\"k\">if</span> <span class=\"n\">r</span> <span class=\"o\">==</span> <span class=\"n\">tr</span> <span class=\"ow\">and</span> <span class=\"n\">c</span> <span class=\"o\">==</span> <span class=\"n\">tc</span><span class=\"p\">:</span>\n                <span class=\"k\">return</span> <span class=\"nb\">abs</span><span class=\"p\">(</span><span class=\"n\">sr</span><span class=\"o\">-</span><span class=\"n\">tr</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"nb\">abs</span><span class=\"p\">(</span><span class=\"n\">sc</span><span class=\"o\">-</span><span class=\"n\">tc</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">detours</span>\n            <span class=\"k\">for</span> <span class=\"n\">nr</span><span class=\"p\">,</span> <span class=\"n\">nc</span><span class=\"p\">,</span> <span class=\"n\">closer</span> <span class=\"ow\">in</span> <span class=\"p\">((</span><span class=\"n\">r</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">,</span> <span class=\"n\">r</span> <span class=\"o\">&gt;</span> <span class=\"n\">tr</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"n\">r</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">,</span> <span class=\"n\">r</span> <span class=\"o\">&lt;</span> <span class=\"n\">tr</span><span class=\"p\">),</span>\n                                   <span class=\"p\">(</span><span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">c</span> <span class=\"o\">&gt;</span> <span class=\"n\">tc</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">c</span> <span class=\"o\">&lt;</span> <span class=\"n\">tc</span><span class=\"p\">)):</span>\n                <span class=\"k\">if</span> <span class=\"mi\">0</span> <span class=\"o\">&lt;=</span> <span class=\"n\">nr</span> <span class=\"o\">&lt;</span> <span class=\"n\">R</span> <span class=\"ow\">and</span> <span class=\"mi\">0</span> <span class=\"o\">&lt;=</span> <span class=\"n\">nc</span> <span class=\"o\">&lt;</span> <span class=\"n\">C</span> <span class=\"ow\">and</span> <span class=\"n\">forest</span><span class=\"p\">[</span><span class=\"n\">nr</span><span class=\"p\">][</span><span class=\"n\">nc</span><span class=\"p\">]:</span>\n                    <span class=\"k\">if</span> <span class=\"n\">closer</span><span class=\"p\">:</span>\n                        <span class=\"n\">deque</span><span class=\"o\">.</span><span class=\"n\">appendleft</span><span class=\"p\">((</span><span class=\"n\">detours</span><span class=\"p\">,</span> <span class=\"n\">nr</span><span class=\"p\">,</span> <span class=\"n\">nc</span><span class=\"p\">))</span>\n                    <span class=\"k\">else</span><span class=\"p\">:</span>\n                        <span class=\"n\">deque</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">((</span><span class=\"n\">detours</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">nr</span><span class=\"p\">,</span> <span class=\"n\">nc</span><span class=\"p\">))</span>\n    <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"mi\">1</span>\n</pre>\n  </div> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">hadlocks</span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">forest</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">sr</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">sc</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">tr</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">tc</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">R</span> <span class=\"o\">=</span> <span class=\"n\">forest</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">(),</span> <span class=\"n\">C</span> <span class=\"o\">=</span> <span class=\"n\">forest</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">).</span><span class=\"na\">size</span><span class=\"o\">();</span>\n    <span class=\"n\">Set</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">processed</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HashSet</span><span class=\"o\">();</span>\n    <span class=\"n\">Deque</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">[]&gt;</span> <span class=\"n\">deque</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayDeque</span><span class=\"o\">();</span>\n    <span class=\"n\">deque</span><span class=\"o\">.</span><span class=\"na\">offerFirst</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[]{</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">sr</span><span class=\"o\">,</span> <span class=\"n\">sc</span><span class=\"o\">});</span>\n    <span class=\"k\">while</span> <span class=\"o\">(!</span><span class=\"n\">deque</span><span class=\"o\">.</span><span class=\"na\">isEmpty</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">cur</span> <span class=\"o\">=</span> <span class=\"n\">deque</span><span class=\"o\">.</span><span class=\"na\">pollFirst</span><span class=\"o\">();</span>\n        <span class=\"kt\">int</span> <span class=\"n\">detours</span> <span class=\"o\">=</span> <span class=\"n\">cur</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">],</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">cur</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">],</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">cur</span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">];</span>\n        <span class=\"k\">if</span> <span class=\"o\">(!</span><span class=\"n\">processed</span><span class=\"o\">.</span><span class=\"na\">contains</span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"o\">*</span><span class=\"n\">C</span> <span class=\"o\">+</span> <span class=\"n\">c</span><span class=\"o\">))</span> <span class=\"o\">{</span>\n            <span class=\"n\">processed</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"o\">*</span><span class=\"n\">C</span> <span class=\"o\">+</span> <span class=\"n\">c</span><span class=\"o\">);</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">==</span> <span class=\"n\">tr</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">c</span> <span class=\"o\">==</span> <span class=\"n\">tc</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"k\">return</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">abs</span><span class=\"o\">(</span><span class=\"n\">sr</span><span class=\"o\">-</span><span class=\"n\">tr</span><span class=\"o\">)</span> <span class=\"o\">+</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">abs</span><span class=\"o\">(</span><span class=\"n\">sc</span><span class=\"o\">-</span><span class=\"n\">tc</span><span class=\"o\">)</span> <span class=\"o\">+</span> <span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">detours</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span>\n            <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">di</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">di</span> <span class=\"o\">&lt;</span> <span class=\"mi\">4</span><span class=\"o\">;</span> <span class=\"o\">++</span><span class=\"n\">di</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"kt\">int</span> <span class=\"n\">nr</span> <span class=\"o\">=</span> <span class=\"n\">r</span> <span class=\"o\">+</span> <span class=\"n\">dr</span><span class=\"o\">[</span><span class=\"n\">di</span><span class=\"o\">];</span>\n                <span class=\"kt\">int</span> <span class=\"n\">nc</span> <span class=\"o\">=</span> <span class=\"n\">c</span> <span class=\"o\">+</span> <span class=\"n\">dc</span><span class=\"o\">[</span><span class=\"n\">di</span><span class=\"o\">];</span>\n                <span class=\"kt\">boolean</span> <span class=\"n\">closer</span><span class=\"o\">;</span>\n                <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">di</span> <span class=\"o\">&lt;=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">closer</span> <span class=\"o\">=</span> <span class=\"n\">di</span> <span class=\"o\">==</span> <span class=\"mi\">0</span> <span class=\"o\">?</span> <span class=\"n\">r</span> <span class=\"o\">&gt;</span> <span class=\"n\">tr</span> <span class=\"o\">:</span> <span class=\"n\">r</span> <span class=\"o\">&lt;</span> <span class=\"n\">tr</span><span class=\"o\">;</span>\n                <span class=\"k\">else</span> <span class=\"n\">closer</span> <span class=\"o\">=</span> <span class=\"n\">di</span> <span class=\"o\">==</span> <span class=\"mi\">2</span> <span class=\"o\">?</span> <span class=\"n\">c</span> <span class=\"o\">&gt;</span> <span class=\"n\">tc</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"o\">&lt;</span> <span class=\"n\">tc</span><span class=\"o\">;</span>\n                <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">&lt;=</span> <span class=\"n\">nr</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">nr</span> <span class=\"o\">&lt;</span> <span class=\"n\">R</span> <span class=\"o\">&amp;&amp;</span> <span class=\"mi\">0</span> <span class=\"o\">&lt;=</span> <span class=\"n\">nc</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">nc</span> <span class=\"o\">&lt;</span> <span class=\"n\">C</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">forest</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">nr</span><span class=\"o\">).</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">nc</span><span class=\"o\">)</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">closer</span><span class=\"o\">)</span> <span class=\"n\">deque</span><span class=\"o\">.</span><span class=\"na\">offerFirst</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[]{</span><span class=\"n\">detours</span><span class=\"o\">,</span> <span class=\"n\">nr</span><span class=\"o\">,</span> <span class=\"n\">nc</span><span class=\"o\">});</span>\n                    <span class=\"k\">else</span> <span class=\"n\">deque</span><span class=\"o\">.</span><span class=\"na\">offerLast</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[]{</span><span class=\"n\">detours</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">nr</span><span class=\"o\">,</span> <span class=\"n\">nc</span><span class=\"o\">});</span>\n                <span class=\"o\">}</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 674,
    "article_live": true,
    "article_slug": "longest-continuous-increasing-subsequence",
    "title": "Longest Continuous Increasing Subsequence",
    "title_slug": "longest-continuous-increasing-subsequence",
    "content": "<p>\r\nGiven an unsorted array of integers, find the length of longest <code>continuous</code> increasing subsequence (subarray).\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [1,3,5,4,7]\r\n<b>Output:</b> 3\r\n<b>Explanation:</b> The longest continuous increasing subsequence is [1,3,5], its length is 3. \r\nEven though [1,3,5,7] is also an increasing subsequence, it's not a continuous one where 5 and 7 are separated by 4. \r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> [2,2,2,2,2]\r\n<b>Output:</b> 1\r\n<b>Explanation:</b> The longest continuous increasing subsequence is [2], its length is 1. \r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\nLength of the array will not exceed 10,000.\r\n</p>",
    "tags": "Array",
    "difficulty": 1,
    "frontend_article_id": 674,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-sliding-window-accepted\">Approach #1: Sliding Window [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-sliding-window-accepted\">Approach #1: Sliding Window [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Every (continuous) increasing subsequence is disjoint, and the boundary of each such subsequence occurs whenever <code>nums[i-1] &gt;= nums[i]</code>. When it does, it marks the start of a new increasing subsequence at <code>nums[i]</code>, and we store such <code>i</code> in the variable <code>anchor</code>.</p> \n  <p>For example, if <code>nums = [7, 8, 9, 1, 2, 3]</code>, then <code>anchor</code> starts at <code>0</code> (<code>nums[anchor] = 7</code>) and gets set again to <code>anchor = 3</code> (<code>nums[anchor] = 1</code>). Regardless of the value of <code>anchor</code>, we record a candidate answer of <code>i - anchor + 1</code>, the length of the subarray <code>nums[anchor], nums[anchor+1], ..., nums[i]</code>; and our answer gets updated appropriately.</p> \n  <iframe src=\"https://leetcode.com/playground/AvR7oHwg/shared\" frameborder=\"0\" width=\"100%\" height=\"225\" name=\"AvR7oHwg\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>nums</code>. We perform one loop through <code>nums</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>, the space used by <code>anchor</code> and <code>ans</code>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 673,
    "article_live": true,
    "article_slug": "number-of-longest-increasing-subsequence",
    "title": "Number of Longest Increasing Subsequence",
    "title_slug": "number-of-longest-increasing-subsequence",
    "content": "<p>\r\nGiven an unsorted array of integers, find the number of longest increasing subsequence.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [1,3,5,4,7]\r\n<b>Output:</b> 2\r\n<b>Explanation:</b> The two longest increasing subsequence are [1, 3, 4, 7] and [1, 3, 5, 7].\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> [2,2,2,2,2]\r\n<b>Output:</b> 5\r\n<b>Explanation:</b> The length of longest continuous increasing subsequence is 1, and there are 5 subsequences' length is 1, so output 5.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\nLength of the given array will be not exceed 2000 and the answer is guaranteed to be fit in 32-bit signed int.\r\n</p>",
    "tags": "Dynamic Programming",
    "difficulty": 2,
    "frontend_article_id": 673,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-dynamic-programming-accepted\">Approach #1: Dynamic Programming [Accepted]</a></li> \n    <li><a href=\"#approach-2-segment-tree-accepted\">Approach #2: Segment Tree [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-dynamic-programming-accepted\">Approach #1: Dynamic Programming [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Suppose for sequences ending at <code>nums[i]</code>, we knew the length <code>length[i]</code> of the longest sequence, and the number <code>count[i]</code> of such sequences with that length.</p> \n  <p>For every <code>i &lt; j</code> with <code>A[i] &lt; A[j]</code>, we might append <code>A[j]</code> to a longest subsequence ending at <code>A[i]</code>. It means that we have demonstrated <code>count[i]</code> subsequences of length <code>length[i] + 1</code>. </p> \n  <p>Now, if those sequences are longer than <code>length[j]</code>, then we know we have <code>count[i]</code> sequences of this length. If these sequences are equal in length to <code>length[j]</code>, then we know that there are now <code>count[i]</code> additional sequences to be counted of that length (ie. <code>count[j] += count[i]</code>).</p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">findNumberOfLIS</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">nums</span><span class=\"p\">):</span>\n        <span class=\"n\">N</span> <span class=\"o\">=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"n\">N</span> <span class=\"o\">&lt;=</span> <span class=\"mi\">1</span><span class=\"p\">:</span> <span class=\"k\">return</span> <span class=\"n\">N</span>\n        <span class=\"n\">lengths</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"n\">N</span> <span class=\"c1\">#lengths[i] = longest ending in nums[i]</span>\n        <span class=\"n\">counts</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"n\">N</span> <span class=\"c1\">#count[i] = number of longest ending in nums[i]</span>\n\n        <span class=\"k\">for</span> <span class=\"n\">j</span><span class=\"p\">,</span> <span class=\"n\">num</span> <span class=\"ow\">in</span> <span class=\"nb\">enumerate</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">):</span>\n            <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">xrange</span><span class=\"p\">(</span><span class=\"n\">j</span><span class=\"p\">):</span>\n                <span class=\"k\">if</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">&lt;</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">]:</span>\n                    <span class=\"k\">if</span> <span class=\"n\">lengths</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">&gt;=</span> <span class=\"n\">lengths</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">]:</span>\n                        <span class=\"n\">lengths</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span> <span class=\"o\">+</span> <span class=\"n\">lengths</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span>\n                        <span class=\"n\">counts</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">counts</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span>\n                    <span class=\"k\">elif</span> <span class=\"n\">lengths</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"mi\">1</span> <span class=\"o\">==</span> <span class=\"n\">lengths</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">]:</span>\n                        <span class=\"n\">counts</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">]</span> <span class=\"o\">+=</span> <span class=\"n\">counts</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span>\n\n        <span class=\"n\">longest</span> <span class=\"o\">=</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">lengths</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"n\">c</span> <span class=\"k\">for</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">c</span> <span class=\"ow\">in</span> <span class=\"nb\">enumerate</span><span class=\"p\">(</span><span class=\"n\">counts</span><span class=\"p\">)</span> <span class=\"k\">if</span> <span class=\"n\">lengths</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"n\">longest</span><span class=\"p\">)</span>\n</pre>\n  </div> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">findNumberOfLIS</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">N</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">&lt;=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"n\">N</span><span class=\"o\">;</span>\n        <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">lengths</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">N</span><span class=\"o\">];</span> <span class=\"c1\">//lengths[i] = length of longest ending in nums[i]</span>\n        <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">counts</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">N</span><span class=\"o\">];</span> <span class=\"c1\">//count[i] = number of longest ending in nums[i]</span>\n        <span class=\"n\">Arrays</span><span class=\"o\">.</span><span class=\"na\">fill</span><span class=\"o\">(</span><span class=\"n\">counts</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;</span> <span class=\"n\">N</span><span class=\"o\">;</span> <span class=\"o\">++</span><span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">j</span><span class=\"o\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">&lt;</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">])</span> <span class=\"o\">{</span>\n                <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">lengths</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">&gt;=</span> <span class=\"n\">lengths</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">])</span> <span class=\"o\">{</span>\n                    <span class=\"n\">lengths</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">lengths</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">;</span>\n                    <span class=\"n\">counts</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">counts</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">];</span>\n                <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">lengths</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">+</span> <span class=\"mi\">1</span> <span class=\"o\">==</span> <span class=\"n\">lengths</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">])</span> <span class=\"o\">{</span>\n                    <span class=\"n\">counts</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">]</span> <span class=\"o\">+=</span> <span class=\"n\">counts</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">];</span>\n                <span class=\"o\">}</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"kt\">int</span> <span class=\"n\">longest</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">length</span><span class=\"o\">:</span> <span class=\"n\">lengths</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">longest</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">longest</span><span class=\"o\">,</span> <span class=\"n\">length</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">N</span><span class=\"o\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">lengths</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">==</span> <span class=\"n\">longest</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"n\">ans</span> <span class=\"o\">+=</span> <span class=\"n\">counts</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">];</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">ans</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script> where <script type=\"math/tex; mode=display\">N</script> is the length of <code>nums</code>. There are two for-loops and the work inside is <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the space used by <code>lengths</code> and <code>counts</code>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-segment-tree-accepted\">Approach #2: Segment Tree [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Suppose we knew for each length <code>L</code>, the number of sequences with length <code>L</code> ending in <code>x</code>. Then when considering the next element of <code>nums</code>, updating our knowledge hinges on knowing the number of sequences with length <code>L-1</code> ending in <code>y &lt; x</code>. This type of query over an interval is a natural fit for using some sort of tree.</p> \n  <p>We could try using Fenwick trees, but we would have to store <script type=\"math/tex; mode=display\">N</script> of them, which naively might be <script type=\"math/tex; mode=display\">O(N^2)</script> space. Here, we focus on an implementation of a Segment Tree.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Implementing Segment Trees is discussed in more detail <a href=\"https://leetcode.com/articles/recursive-approach-segment-trees-range-sum-queries-lazy-propagation/\">here</a>. In this approach, we will attempt a variant of segment tree that doesn't use lazy propagation.</p> \n  <p>First, let us call the \"value\" of an interval, the longest length of an increasing subsequence, and the number of such subsequences in that interval.</p> \n  <p>Each node knows about the interval of <code>nums</code> values it is considering <code>[node.range_left, node.range_right]</code>, and it knows about <code>node.val</code>, which contains information on the value of interval. Nodes also have <code>node.left</code> and <code>node.right</code> children that represents the left and right half of the interval <code>node</code> considers. These child nodes are created on demand as appropriate.</p> \n  <p>Now, <code>query(node, key)</code> will tell us the value of the interval specified by <code>node</code>, except we'll exclude anything above <code>key</code>. When key is outside the interval specified by <code>node</code>, we return the answer. Otherwise, we'll divide the interval into two and query both intervals, then <code>merge</code> the result.</p> \n  <p>What does <code>merge(v1, v2)</code> do? Suppose two nodes specify adjacent intervals, and have corresponding values <code>v1 = node1.val, v2 = node2.val</code>. What should the aggregate value, <code>v = merge(v1, v2)</code> be? If there are longer subsequences in one node, then <code>v</code> will just be that. If both nodes have longest subsequences of equal length, then we should count subsequences in both nodes. Note that we did not have to consider cases where larger subsequences were made, since these were handled by <code>insert</code>.</p> \n  <p>What does <code>insert(node, key, val)</code> do? We repeatedly insert the <code>key</code> into the correct half of the interval that <code>node</code> specifies (possibly a point), and after such insertion this node's value could change, so we merge the values together again.</p> \n  <p>Finally, in our main algorithm, for each <code>num in nums</code> we <code>query</code> for the value <code>length, count</code> of the interval below <code>num</code>, and we know it will lead to <code>count</code> additional sequences of length <code>length + 1</code>. We then update our tree with that knowledge.</p> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"n\">Value</span> <span class=\"nf\">merge</span><span class=\"o\">(</span><span class=\"n\">Value</span> <span class=\"n\">v1</span><span class=\"o\">,</span> <span class=\"n\">Value</span> <span class=\"n\">v2</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">v1</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">==</span> <span class=\"n\">v2</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">v1</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"n\">Value</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n            <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"n\">Value</span><span class=\"o\">(</span><span class=\"n\">v1</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">,</span> <span class=\"n\">v1</span><span class=\"o\">.</span><span class=\"na\">count</span> <span class=\"o\">+</span> <span class=\"n\">v2</span><span class=\"o\">.</span><span class=\"na\">count</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">v1</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">&gt;</span> <span class=\"n\">v2</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">?</span> <span class=\"n\">v1</span> <span class=\"o\">:</span> <span class=\"n\">v2</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">insert</span><span class=\"o\">(</span><span class=\"n\">Node</span> <span class=\"n\">node</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">Value</span> <span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">range_left</span> <span class=\"o\">==</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">range_right</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">val</span> <span class=\"o\">=</span> <span class=\"n\">merge</span><span class=\"o\">(</span><span class=\"n\">val</span><span class=\"o\">,</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">val</span><span class=\"o\">);</span>\n            <span class=\"k\">return</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">key</span> <span class=\"o\">&lt;=</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">getRangeMid</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n            <span class=\"n\">insert</span><span class=\"o\">(</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">getLeft</span><span class=\"o\">(),</span> <span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">val</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>\n            <span class=\"n\">insert</span><span class=\"o\">(</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">getRight</span><span class=\"o\">(),</span> <span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">val</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n        <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">val</span> <span class=\"o\">=</span> <span class=\"n\">merge</span><span class=\"o\">(</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">getLeft</span><span class=\"o\">().</span><span class=\"na\">val</span><span class=\"o\">,</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">getRight</span><span class=\"o\">().</span><span class=\"na\">val</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"n\">Value</span> <span class=\"nf\">query</span><span class=\"o\">(</span><span class=\"n\">Node</span> <span class=\"n\">node</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">key</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">range_right</span> <span class=\"o\">&lt;=</span> <span class=\"n\">key</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">val</span><span class=\"o\">;</span>\n        <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">range_left</span> <span class=\"o\">&gt;</span> <span class=\"n\">key</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"n\">Value</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n        <span class=\"k\">else</span> <span class=\"k\">return</span> <span class=\"n\">merge</span><span class=\"o\">(</span><span class=\"n\">query</span><span class=\"o\">(</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">getLeft</span><span class=\"o\">(),</span> <span class=\"n\">key</span><span class=\"o\">),</span> <span class=\"n\">query</span><span class=\"o\">(</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">getRight</span><span class=\"o\">(),</span> <span class=\"n\">key</span><span class=\"o\">));</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">findNumberOfLIS</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n        <span class=\"kt\">int</span> <span class=\"n\">min</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">],</span> <span class=\"n\">max</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">];</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">num</span><span class=\"o\">:</span> <span class=\"n\">nums</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">min</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">min</span><span class=\"o\">(</span><span class=\"n\">min</span><span class=\"o\">,</span> <span class=\"n\">num</span><span class=\"o\">);</span>\n            <span class=\"n\">max</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"o\">,</span> <span class=\"n\">num</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n        <span class=\"n\">Node</span> <span class=\"n\">root</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Node</span><span class=\"o\">(</span><span class=\"n\">min</span><span class=\"o\">,</span> <span class=\"n\">max</span><span class=\"o\">);</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">num</span><span class=\"o\">:</span> <span class=\"n\">nums</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">Value</span> <span class=\"n\">v</span> <span class=\"o\">=</span> <span class=\"n\">query</span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"o\">,</span> <span class=\"n\">num</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"o\">);</span>\n            <span class=\"n\">insert</span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"o\">,</span> <span class=\"n\">num</span><span class=\"o\">,</span> <span class=\"k\">new</span> <span class=\"n\">Value</span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">.</span><span class=\"na\">count</span><span class=\"o\">));</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">root</span><span class=\"o\">.</span><span class=\"na\">val</span><span class=\"o\">.</span><span class=\"na\">count</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"nc\">Node</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">range_left</span><span class=\"o\">,</span> <span class=\"n\">range_right</span><span class=\"o\">;</span>\n    <span class=\"n\">Node</span> <span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">right</span><span class=\"o\">;</span>\n    <span class=\"n\">Value</span> <span class=\"n\">val</span><span class=\"o\">;</span>\n    <span class=\"kd\">public</span> <span class=\"nf\">Node</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">start</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">end</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">range_left</span> <span class=\"o\">=</span> <span class=\"n\">start</span><span class=\"o\">;</span>\n        <span class=\"n\">range_right</span> <span class=\"o\">=</span> <span class=\"n\">end</span><span class=\"o\">;</span>\n        <span class=\"n\">left</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n        <span class=\"n\">right</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n        <span class=\"n\">val</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Value</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">getRangeMid</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">range_left</span> <span class=\"o\">+</span> <span class=\"o\">(</span><span class=\"n\">range_right</span> <span class=\"o\">-</span> <span class=\"n\">range_left</span><span class=\"o\">)</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"kd\">public</span> <span class=\"n\">Node</span> <span class=\"nf\">getLeft</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">left</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"n\">left</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Node</span><span class=\"o\">(</span><span class=\"n\">range_left</span><span class=\"o\">,</span> <span class=\"n\">getRangeMid</span><span class=\"o\">());</span>\n        <span class=\"k\">return</span> <span class=\"n\">left</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"kd\">public</span> <span class=\"n\">Node</span> <span class=\"nf\">getRight</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">right</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"n\">right</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Node</span><span class=\"o\">(</span><span class=\"n\">getRangeMid</span><span class=\"o\">()</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">range_right</span><span class=\"o\">);</span>\n        <span class=\"k\">return</span> <span class=\"n\">right</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"nc\">Value</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">length</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">count</span><span class=\"o\">;</span>\n    <span class=\"kd\">public</span> <span class=\"nf\">Value</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">len</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">ct</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">length</span> <span class=\"o\">=</span> <span class=\"n\">len</span><span class=\"o\">;</span>\n        <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"n\">ct</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Python</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"k\">class</span> <span class=\"nc\">Node</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">start</span><span class=\"p\">,</span> <span class=\"n\">end</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">range_left</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">range_right</span> <span class=\"o\">=</span> <span class=\"n\">start</span><span class=\"p\">,</span> <span class=\"n\">end</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_left</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_right</span> <span class=\"o\">=</span> <span class=\"bp\">None</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">val</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span> <span class=\"c1\">#length, count</span>\n    <span class=\"nd\">@property</span>\n    <span class=\"k\">def</span> <span class=\"nf\">range_mid</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">range_left</span> <span class=\"o\">+</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">range_right</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"mi\">2</span>\n    <span class=\"nd\">@property</span>\n    <span class=\"k\">def</span> <span class=\"nf\">left</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_left</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_left</span> <span class=\"ow\">or</span> <span class=\"n\">Node</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">range_left</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">range_mid</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_left</span>\n    <span class=\"nd\">@property</span>\n    <span class=\"k\">def</span> <span class=\"nf\">right</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_right</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_right</span> <span class=\"ow\">or</span> <span class=\"n\">Node</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">range_mid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">range_right</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_right</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">merge</span><span class=\"p\">(</span><span class=\"n\">v1</span><span class=\"p\">,</span> <span class=\"n\">v2</span><span class=\"p\">):</span>\n    <span class=\"k\">if</span> <span class=\"n\">v1</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"n\">v2</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]:</span>\n        <span class=\"k\">if</span> <span class=\"n\">v1</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">:</span> <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">v1</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">v1</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">v2</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n    <span class=\"k\">return</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">v1</span><span class=\"p\">,</span> <span class=\"n\">v2</span><span class=\"p\">)</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">insert</span><span class=\"p\">(</span><span class=\"n\">node</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"n\">val</span><span class=\"p\">):</span>\n    <span class=\"k\">if</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">range_left</span> <span class=\"o\">==</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">range_right</span><span class=\"p\">:</span>\n        <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">val</span> <span class=\"o\">=</span> <span class=\"n\">merge</span><span class=\"p\">(</span><span class=\"n\">val</span><span class=\"p\">,</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">val</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span>\n    <span class=\"k\">if</span> <span class=\"n\">key</span> <span class=\"o\">&lt;=</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">range_mid</span><span class=\"p\">:</span>\n        <span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">left</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"n\">val</span><span class=\"p\">)</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">right</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"n\">val</span><span class=\"p\">)</span>\n    <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">val</span> <span class=\"o\">=</span> <span class=\"n\">merge</span><span class=\"p\">(</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">left</span><span class=\"o\">.</span><span class=\"n\">val</span><span class=\"p\">,</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">right</span><span class=\"o\">.</span><span class=\"n\">val</span><span class=\"p\">)</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">query</span><span class=\"p\">(</span><span class=\"n\">node</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"p\">):</span>\n    <span class=\"k\">if</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">range_right</span> <span class=\"o\">&lt;=</span> <span class=\"n\">key</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">val</span>\n    <span class=\"k\">elif</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">range_left</span> <span class=\"o\">&gt;</span> <span class=\"n\">key</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"n\">merge</span><span class=\"p\">(</span><span class=\"n\">query</span><span class=\"p\">(</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">left</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"p\">),</span> <span class=\"n\">query</span><span class=\"p\">(</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">right</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"p\">))</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">findNumberOfLIS</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">nums</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">nums</span><span class=\"p\">:</span> <span class=\"k\">return</span> <span class=\"mi\">0</span>\n        <span class=\"n\">root</span> <span class=\"o\">=</span> <span class=\"n\">Node</span><span class=\"p\">(</span><span class=\"nb\">min</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">),</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">))</span>\n        <span class=\"k\">for</span> <span class=\"n\">num</span> <span class=\"ow\">in</span> <span class=\"n\">nums</span><span class=\"p\">:</span>\n            <span class=\"n\">length</span><span class=\"p\">,</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"n\">query</span><span class=\"p\">(</span><span class=\"n\">root</span><span class=\"p\">,</span> <span class=\"n\">num</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n            <span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"n\">root</span><span class=\"p\">,</span> <span class=\"n\">num</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">length</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">count</span><span class=\"p\">))</span>\n        <span class=\"k\">return</span> <span class=\"n\">root</span><span class=\"o\">.</span><span class=\"n\">val</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N\\log {N})</script> where <script type=\"math/tex; mode=display\">N</script> is the length of <code>nums</code>. In our main for loop, we do <code>$$O(\\log{N})$$</code> work to <code>query</code> and <code>insert</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the space used by the segment tree.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>. Approach #2 inspired by <a href=\"https://discuss.leetcode.com/topic/103992/python-dp-segment_tree-o-nlogn\">@dut200901102</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 672,
    "article_live": true,
    "article_slug": "bulb-switcher-ii",
    "title": "Bulb Switcher II",
    "title_slug": "bulb-switcher-ii",
    "content": "<p>\r\nThere is a room with <code>n</code> lights which are turned on initially and 4 buttons on the wall. After performing exactly <code>m</code> unknown operations towards buttons, you need to return how many different kinds of status of the <code>n</code> lights could be.\r\n</p>\r\n\r\n<p>\r\nSuppose <code>n</code> lights are labeled as number [1, 2, 3 ..., n], function of these 4 buttons are given below:\r\n\r\n<ol>\r\n<li>Flip all the lights.</li>\r\n<li>Flip lights with even numbers.</li>\r\n<li>Flip lights with odd numbers.</li>\r\n<li>Flip lights with (3k + 1) numbers, k = 0, 1, 2, ...</li>\r\n</ol>\r\n</p>\r\n\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> n = 1, m = 1.\r\n<b>Output:</b> 2\r\n<b>Explanation:</b> Status can be: [on], [off]\r\n</pre>\r\n</p>\r\n\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> n = 2, m = 1.\r\n<b>Output:</b> 3\r\n<b>Explanation:</b> Status can be: [on, off], [off, on], [off, off]\r\n</pre>\r\n</p>\r\n\r\n\r\n<p><b>Example 3:</b><br />\r\n<pre>\r\n<b>Input:</b> n = 3, m = 1.\r\n<b>Output:</b> 4\r\n<b>Explanation:</b> Status can be: [off, on, off], [on, off, on], [off, off, off], [off, on, on].\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\n<code>n</code> and <code>m</code> both fit in range [0, 1000].\r\n</p>\r\n",
    "tags": "Math",
    "difficulty": 2,
    "frontend_article_id": 672,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-reduce-search-space-accepted\">Approach #1: Reduce Search Space [Accepted]</a></li> \n    <li><a href=\"#approach-2-mathematical-accepted\">Approach #2: Mathematical [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-reduce-search-space-accepted\">Approach #1: Reduce Search Space [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>As the search space is very large (<script type=\"math/tex; mode=display\">2^N</script> states of lights, naively <script type=\"math/tex; mode=display\">4^M</script> operation sequences), let us try to reduce it.</p> \n  <p>The first 6 lights uniquely determine the rest of the lights. This is because every operation that modifies the <script type=\"math/tex; mode=display\">x</script>-th light also modifies the <script type=\"math/tex; mode=display\">(x+6)</script>-th light.</p> \n  <p>Also, operations commute: doing operation A followed by B is the same as doing operation B followed by A. So we can assume we do all the operations in order.</p> \n  <p>Finally, doing the same operation twice in a row is the same as doing nothing. So we only need to consider whether each operation was done 0 or 1 times.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Say we do the <script type=\"math/tex; mode=display\">i</script>-th operation <script type=\"math/tex; mode=display\">f_i</script> times. Let's first figure out what sets of residues are possible: that is, what sets <script type=\"math/tex; mode=display\">c_i = f_i</script> (<script type=\"math/tex; mode=display\">\\mod 2</script> ) are possible.</p> \n  <p>Because <script type=\"math/tex; mode=display\">c_i \\equiv f_i</script> and <script type=\"math/tex; mode=display\">c_i \\leq f_i</script>, if <script type=\"math/tex; mode=display\">\\sum f_i \\not\\equiv \\sum c_i</script>, or if <script type=\"math/tex; mode=display\">\\sum f_i < \\sum c_i</script>, it isn't possible. Otherwise, it is possible by a simple construction: do the operations specified by <script type=\"math/tex; mode=display\">c_i</script>, then do operation number 1 with the even number of operations you have left.</p> \n  <p>For each possible set of residues, let's simulate and remember what the first 6 lights will look like, storing it in a <em>Set</em> structure <code>seen</code>. At the end, we'll return the size of this set.</p> \n  <p>In Java, we make use of bit manipulations to manage the state of lights, where in Python we simulate it directly.</p> \n  <iframe src=\"https://leetcode.com/playground/pHeNoQ3Q/shared\" frameborder=\"0\" width=\"100%\" height=\"378\" name=\"pHeNoQ3Q\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(1)</script>. Our checks are bounded by a constant.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>, the size of the data structures used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-mathematical-accepted\">Approach #2: Mathematical [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>As before, the first 6 lights uniquely determine the rest of the lights. This is because every operation that modifies the <script type=\"math/tex; mode=display\">x</script>-th light also modifies the <script type=\"math/tex; mode=display\">(x+6)</script>-th light, so the <script type=\"math/tex; mode=display\">x</script>-th light is always equal to the <script type=\"math/tex; mode=display\">(x+6)</script>-th light.</p> \n  <p>Actually, the first 3 lights uniquely determine the rest of the sequence, as shown by the table below for performing the operations a, b, c, d:</p> \n  <ul> \n   <li>Light 1 = 1 + a + c + d</li> \n   <li>Light 2 = 1 + a + b</li> \n   <li>Light 3 = 1 + a + c</li> \n   <li>Light 4 = 1 + a + b + d</li> \n   <li>Light 5 = 1 + a + c</li> \n   <li>Light 6 = 1 + a + b</li> \n  </ul> \n  <p>So that (modulo 2):</p> \n  <ul> \n   <li>Light 4 = (Light 1) + (Light 2) + (Light 3)</li> \n   <li>Light 5 = Light 3</li> \n   <li>Light 6 = Light 2</li> \n  </ul> \n  <p>The above justifies taking <script type=\"math/tex; mode=display\">n = min(n, 3)</script> without loss of generality. The rest is now casework.</p> \n  <p>Let's denote the state of lights by the tuple <script type=\"math/tex; mode=display\">(a, b, c)</script>. The transitions are to XOR by <script type=\"math/tex; mode=display\">(1, 1, 1), (0, 1, 0), (1, 0, 1),</script> or <script type=\"math/tex; mode=display\">(1, 0, 0)</script>.</p> \n  <p>When <script type=\"math/tex; mode=display\">m = 0</script>, all the lights are on, and there is only one state <script type=\"math/tex; mode=display\">(1, 1, 1)</script>. The answer in this case is always 1.</p> \n  <p>When <script type=\"math/tex; mode=display\">m = 1</script>, we could get states <script type=\"math/tex; mode=display\">(0, 0, 0)</script>, <script type=\"math/tex; mode=display\">(1, 0, 1)</script>, <script type=\"math/tex; mode=display\">(0, 1, 0)</script>, or <script type=\"math/tex; mode=display\">(0, 1, 1)</script>. The answer in this case is either <script type=\"math/tex; mode=display\">2, 3, 4</script> for <script type=\"math/tex; mode=display\">n = 1, 2, 3</script> respectively.</p> \n  <p>When <script type=\"math/tex; mode=display\">m = 2</script>, we can manually check that we can get 7 states: all of them except for <script type=\"math/tex; mode=display\">(0, 1, 1)</script>. The answer in this case is either <script type=\"math/tex; mode=display\">2, 4, 7</script> for <script type=\"math/tex; mode=display\">n = 1, 2, 3</script> respectively.</p> \n  <p>When <script type=\"math/tex; mode=display\">m = 3</script>, we can get all 8 states. The answer in this case is either <script type=\"math/tex; mode=display\">2, 4, 8</script> for <script type=\"math/tex; mode=display\">n = 1, 2, 3</script> respectively.</p> \n  <iframe src=\"https://leetcode.com/playground/yn2rvFzw/shared\" frameborder=\"0\" width=\"100%\" height=\"208\" name=\"yn2rvFzw\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time and Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>. The entire program uses constants.</li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 671,
    "article_live": true,
    "article_slug": "second-minimum-node-in-a-binary-tree",
    "title": "Second Minimum Node In a Binary Tree",
    "title_slug": "second-minimum-node-in-a-binary-tree",
    "content": "<p>\r\nGiven a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly <code>two</code> or <code>zero</code> sub-node. If the node has two sub-nodes, then this node's value is the smaller value among its two sub-nodes. \r\n</p>\r\n\r\n<p>\r\nGiven such a binary tree, you need to output the <b>second minimum</b> value in the set made of all the nodes' value in the whole tree. \r\n</p>\r\n\r\n<p>\r\nIf no such second minimum value exists, output -1 instead.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\n    2\r\n   / \\\r\n  2   5\r\n     / \\\r\n    5   7\r\n\r\n<b>Output:</b> 5\r\n<b>Explanation:</b> The smallest value is 2, the second smallest value is 5.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\n    2\r\n   / \\\r\n  2   2\r\n\r\n<b>Output:</b> -1\r\n<b>Explanation:</b> The smallest value is 2, but there isn't any second smallest value.\r\n</pre>\r\n</p>",
    "tags": "Tree",
    "difficulty": 1,
    "frontend_article_id": 671,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-accepted\">Approach #1: Brute Force [Accepted]</a></li> \n      <li><a href=\"#approach-2-ad-hoc-accepted\">Approach #2: Ad-Hoc [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-accepted\">Approach #1: Brute Force [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Traverse the tree with a depth-first search, and record every unique value in the tree using a Set structure <code>uniques</code>.</p> \n  <p>Then, we'll look through the recorded values for the second minimum. The first minimum must be <script type=\"math/tex; mode=display\">\\text{root.val}</script>.</p> \n  <iframe src=\"https://leetcode.com/playground/rVYM4qCQ/shared\" frameborder=\"0\" name=\"rVYM4qCQ\" width=\"100%\" height=\"394\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the total number of nodes in the given tree. We visit each node exactly once, and scan through the <script type=\"math/tex; mode=display\">O(N)</script> values in <code>unique</code> once.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the information stored in <code>uniques</code>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-ad-hoc-accepted\">Approach #2: Ad-Hoc [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Let <script type=\"math/tex; mode=display\">\\text{min1 = root.val}</script>. When traversing the tree at some node, <script type=\"math/tex; mode=display\">\\text{node}</script>, if <script type=\"math/tex; mode=display\">\\text{node.val > min1}</script>, we know all values in the subtree at <script type=\"math/tex; mode=display\">\\text{node}</script> are at least <script type=\"math/tex; mode=display\">\\text{node.val}</script>, so there cannot be a better candidate for the second minimum in this subtree. Thus, we do not need to search this subtree.</p> \n  <p>Also, as we only care about the second minimum <script type=\"math/tex; mode=display\">\\text{ans}</script>, we do not need to record any values that are larger than our current candidate for the second minimum, so unlike Approach #1 we can skip maintaining a Set of values(<code>uniques</code>) entirely.</p> \n  <iframe src=\"https://leetcode.com/playground/btTLPkjK/shared\" frameborder=\"0\" name=\"btTLPkjK\" width=\"100%\" height=\"394\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the total number of nodes in the given tree. We visit each node at most once.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. The information stored in <script type=\"math/tex; mode=display\">\\text{ans}</script> and <script type=\"math/tex; mode=display\">\\text{min1}</script> is <script type=\"math/tex; mode=display\">O(1)</script>, but our depth-first search may store up to <script type=\"math/tex; mode=display\">O(h) = O(N)</script> information in the call stack, where <script type=\"math/tex; mode=display\">h</script> is the height of the tree.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 670,
    "article_live": true,
    "article_slug": "maximum-swap",
    "title": "Maximum Swap",
    "title_slug": "maximum-swap",
    "content": "<p>\r\nGiven a non-negative integer, you could swap two digits <b>at most</b> once to get the maximum valued number. Return the maximum valued number you could get.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> 2736\r\n<b>Output:</b> 7236\r\n<b>Explanation:</b> Swap the number 2 and the number 7.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> 9973\r\n<b>Output:</b> 9973\r\n<b>Explanation:</b> No swap.\r\n</pre>\r\n</p>\r\n\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The given number is in the range [0, 10<sup>8</sup>]</li>\r\n</ol>\r\n</p>",
    "tags": "Array, Math",
    "difficulty": 2,
    "frontend_article_id": 670,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-accepted\">Approach #1: Brute Force [Accepted]</a></li> \n      <li><a href=\"#approach-2-greedy-accepted\">Approach #2: Greedy [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-accepted\">Approach #1: Brute Force [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>The number only has at most 8 digits, so there are only <script type=\"math/tex; mode=display\">{}^{8}\\text{C}_{2}</script> = 28 available swaps. We can easily brute force them all.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>We will store the candidates as lists of length <script type=\"math/tex; mode=display\">\\text{len(num)}</script>. For each candidate swap with positions <script type=\"math/tex; mode=display\">\\text{(i, j)}</script>, we swap the number and record if the candidate is larger than the current answer, then swap back to restore the original number.</p> \n  <p>The only detail is possibly to check that we didn't introduce a leading zero. We don't actually need to check it, because our original number doesn't have one.</p> \n  <iframe src=\"https://leetcode.com/playground/9BbnzEUC/shared\" frameborder=\"0\" name=\"9BbnzEUC\" width=\"100%\" height=\"462\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^3)</script>, where <script type=\"math/tex; mode=display\">N</script> is the total number of digits in the input number. For each pair of digits, we spend up to <script type=\"math/tex; mode=display\">O(N)</script> time to compare the final sequences.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the information stored in <script type=\"math/tex; mode=display\">\\text{A}</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-greedy-accepted\">Approach #2: Greedy [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>At each digit of the input number in order, if there is a larger digit that occurs later, we know that the best swap must occur with the digit we are currently considering.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>We will compute <script type=\"math/tex; mode=display\">\\text{last[d] = i}</script>, the index <script type=\"math/tex; mode=display\">\\text{i}</script> of the last occurrence of digit <script type=\"math/tex; mode=display\">\\text{d}</script> (if it exists).</p> \n  <p>Afterwards, when scanning the number from left to right, if there is a larger digit in the future, we will swap it with the largest such digit; if there are multiple such digits, we will swap it with the one that occurs the latest.</p> \n  <iframe src=\"https://leetcode.com/playground/c2u3L78L/shared\" frameborder=\"0\" name=\"c2u3L78L\" width=\"100%\" height=\"411\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the total number of digits in the input number. Every digit is considered at most once.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>. The additional space used by <script type=\"math/tex; mode=display\">\\text{last}</script> only has up to 10 values.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 669,
    "article_live": true,
    "article_slug": "trim-a-binary-search-tree",
    "title": "Trim a Binary Search Tree",
    "title_slug": "trim-a-binary-search-tree",
    "content": "<p>\r\nGiven a binary search tree and the lowest and highest boundaries as <code>L</code> and <code>R</code>, trim the tree so that all its elements lies in <code>[L, R]</code> (R >= L). You might need to change the root of the tree, so the result should return the new root of the trimmed binary search tree.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\n    1\r\n   / \\\r\n  0   2\r\n\r\n  L = 1\r\n  R = 2\r\n\r\n<b>Output:</b> \r\n    1\r\n      \\\r\n       2\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\n    3\r\n   / \\\r\n  0   4\r\n   \\\r\n    2\r\n   /\r\n  1\r\n\r\n  L = 1\r\n  R = 3\r\n\r\n<b>Output:</b> \r\n      3\r\n     / \r\n   2   \r\n  /\r\n 1\r\n</pre>\r\n</p>",
    "tags": "Tree",
    "difficulty": 1,
    "frontend_article_id": 669,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-recursion-accepted\">Approach #1: Recursion [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-recursion-accepted\">Approach #1: Recursion [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Let <code>trim(node)</code> be the desired answer for the subtree at that node. We can construct the answer recursively.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>When <script type=\"math/tex; mode=display\">\\text{node.val > R}</script>, we know that the trimmed binary tree must occur to the left of the node. Similarly, when <script type=\"math/tex; mode=display\">\\text{node.val < L}</script>, the trimmed binary tree occurs to the right of the node. Otherwise, we will trim both sides of the tree.</p> \n  <iframe src=\"https://leetcode.com/playground/8eWsgDRM/shared\" frameborder=\"0\" name=\"8eWsgDRM\" width=\"100%\" height=\"309\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the total number of nodes in the given tree. We visit each node at most once.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. Even though we don't explicitly use any additional memory, the call stack of our recursion could be as large as the number of nodes in the worst case.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 668,
    "article_live": true,
    "article_slug": "kth-smallest-number-in-multiplication-table",
    "title": "Kth Smallest Number in Multiplication Table",
    "title_slug": "kth-smallest-number-in-multiplication-table",
    "content": "<p>\r\nNearly every one have used the <a href=\"https://en.wikipedia.org/wiki/Multiplication_table\">Multiplication Table</a>. But could you find out the <code>k-th</code> smallest number quickly from the multiplication table?\r\n</p>\r\n\r\n<p>\r\nGiven the height <code>m</code> and the length <code>n</code> of a <code>m * n</code> Multiplication Table, and a positive integer <code>k</code>, you need to return the <code>k-th</code> smallest number in this table.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> m = 3, n = 3, k = 5\r\n<b>Output:</b> \r\n<b>Explanation:</b> \r\nThe Multiplication Table:\r\n1\t2\t3\r\n2\t4\t6\r\n3\t6\t9\r\n\r\nThe 5-th smallest number is 3 (1, 2, 2, 3, 3).\r\n</pre>\r\n</p>\r\n\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> m = 2, n = 3, k = 6\r\n<b>Output:</b> \r\n<b>Explanation:</b> \r\nThe Multiplication Table:\r\n1\t2\t3\r\n2\t4\t6\r\n\r\nThe 6-th smallest number is 6 (1, 2, 2, 3, 4, 6).\r\n</pre>\r\n</p>\r\n\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The <code>m</code> and <code>n</code> will be in the range [1, 30000].</li>\r\n<li>The <code>k</code> will be in the range [1, m * n]</li>\r\n</ol>\r\n</p>",
    "tags": "Binary Search",
    "difficulty": 3,
    "frontend_article_id": 668,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-memory-limit-exceeded\">Approach #1: Brute Force [Memory Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-next-heap-time-limit-exceeded\">Approach #2: Next Heap [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-3-binary-search-accepted\">Approach #3: Binary Search [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-memory-limit-exceeded\">Approach #1: Brute Force [Memory Limit Exceeded]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Create the multiplication table and sort it, then take the <script type=\"math/tex; mode=display\">k^{th}</script> element.</p> \n  <iframe src=\"https://leetcode.com/playground/JNTnTCLa/shared\" frameborder=\"0\" name=\"JNTnTCLa\" width=\"100%\" height=\"258\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(m*n)</script> to create the table, and <script type=\"math/tex; mode=display\">O(m*n\\log(m*n))</script> to sort it.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(m*n)</script> to store the table.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-next-heap-time-limit-exceeded\">Approach #2: Next Heap [Time Limit Exceeded]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Maintain a heap of the smallest unused element of each row. Then, finding the next element is a pop operation on the heap.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Our <code>heap</code> is going to consist of elements <script type=\"math/tex; mode=display\">\\text{(val, root)}</script>, where <script type=\"math/tex; mode=display\">\\text{val}</script> is the next unused value of that row, and <script type=\"math/tex; mode=display\">\\text{root}</script> was the starting value of that row.</p> \n  <p>We will repeatedly find the next lowest element in the table. To do this, we pop from the heap. Then, if there's a next lowest element in that row, we'll put that element back on the heap.</p> \n  <iframe src=\"https://leetcode.com/playground/Evrh9ssK/shared\" frameborder=\"0\" name=\"Evrh9ssK\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(k * m \\log m) = O(m^2 n \\log m)</script>. Our initial heapify operation is <script type=\"math/tex; mode=display\">O(m)</script>. Afterwards, each pop and push is <script type=\"math/tex; mode=display\">O(m \\log m)</script>, and our outer loop is <script type=\"math/tex; mode=display\">O(k) = O(m*n)</script> </p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(m)</script>. Our heap is implemented as an array with <script type=\"math/tex; mode=display\">m</script> elements.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-binary-search-accepted\">Approach #3: Binary Search [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>As <script type=\"math/tex; mode=display\">\\text{k}</script> and <script type=\"math/tex; mode=display\">\\text{m*n}</script> are up to <script type=\"math/tex; mode=display\">9 * 10^8</script>, linear solutions will not work. This motivates solutions with <script type=\"math/tex; mode=display\">\\log</script> complexity, such as binary search.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Let's do the binary search for the answer <script type=\"math/tex; mode=display\">\\text{A}</script>.</p> \n  <p>Say <code>enough(x)</code> is true if and only if there are <script type=\"math/tex; mode=display\">\\text{k}</script> or more values in the multiplication table that are less than or equal to <script type=\"math/tex; mode=display\">\\text{x}</script>. Colloquially, <code>enough</code> describes whether <script type=\"math/tex; mode=display\">\\text{x}</script> is large enough to be the <script type=\"math/tex; mode=display\">k^{th}</script> value in the multiplication table.</p> \n  <p>Then (for our answer <script type=\"math/tex; mode=display\">\\text{A}</script>), whenever <script type=\"math/tex; mode=display\">\\text{x &geq; A}</script>, <code>enough(x)</code> is <code>True</code>; and whenever <script type=\"math/tex; mode=display\">\\text{x < A}</script>, <code>enough(x)</code> is <code>False</code>.</p> \n  <p>In our binary search, our loop invariant is <code>enough(hi) = True</code>. At the beginning, <code>enough(m*n) = True</code>, and whenever <code>hi</code> is set, it is set to a value that is \"enough\" (<code>enough(mi) = True</code>). That means <code>hi</code> will be the lowest such value at the end of our binary search.</p> \n  <p>This leaves us with the task of counting how many values are less than or equal to <script type=\"math/tex; mode=display\">\\text{x}</script>. For each of <script type=\"math/tex; mode=display\">\\text{m}</script> rows, the <script type=\"math/tex; mode=display\">i^{th}</script> row looks like <script type=\"math/tex; mode=display\">\\text{[i, 2*i, 3*i, ..., n*i]}</script>. The largest possible <script type=\"math/tex; mode=display\">\\text{k*i &leq; x}</script> that could appear is <script type=\"math/tex; mode=display\">\\text{k = x // i}</script>. However, if <script type=\"math/tex; mode=display\">\\text{x}</script> is really big, then perhaps <script type=\"math/tex; mode=display\">\\text{k > n}</script>, so in total there are <script type=\"math/tex; mode=display\">\\text{min(k, n) = min(x // i, n)}</script> values in that row that are less than or equal to <script type=\"math/tex; mode=display\">\\text{x}</script>.</p> \n  <p>After we have the count of how many values in the table are less than or equal to <script type=\"math/tex; mode=display\">\\text{x}</script>, by the definition of <code>enough(x)</code>, we want to know if that count is greater than or equal to <script type=\"math/tex; mode=display\">\\text{k}</script>.</p> \n  <iframe src=\"https://leetcode.com/playground/4ankdsg9/shared\" frameborder=\"0\" name=\"4ankdsg9\" width=\"100%\" height=\"377\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(m * \\log (m*n))</script>. Our binary search divides the interval <script type=\"math/tex; mode=display\">\\text{[lo, hi]}</script> into half at each step. At each step, we call <code>enough</code> which requires <script type=\"math/tex; mode=display\">O(m)</script> time.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>. We only keep integers in memory during our intermediate calculations.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 667,
    "article_live": true,
    "article_slug": "beautiful-arrangement-ii",
    "title": "Beautiful Arrangement II",
    "title_slug": "beautiful-arrangement-ii",
    "content": "<p>\r\nGiven two integers <code>n</code> and <code>k</code>, you need to construct a list which contains <code>n</code> different positive integers ranging from <code>1</code> to <code>n</code> and obeys the following requirement: <br/>\r\n\r\nSuppose this list is [a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>, ... , a<sub>n</sub>], then the list [|a<sub>1</sub> - a<sub>2</sub>|, |a<sub>2</sub> - a<sub>3</sub>|, |a<sub>3</sub> - a<sub>4</sub>|, ... , |a<sub>n-1</sub> - a<sub>n</sub>|] has exactly <code>k</code> distinct integers.\r\n</p>\r\n\r\n<p>\r\nIf there are multiple answers, print any of them.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br/>\r\n<pre>\r\n<b>Input:</b> n = 3, k = 1\r\n<b>Output:</b> [1, 2, 3]\r\n<b>Explanation:</b> The [1, 2, 3] has three different positive integers ranging from 1 to 3, and the [1, 1] has exactly 1 distinct integer: 1.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> n = 3, k = 2\r\n<b>Output:</b> [1, 3, 2]\r\n<b>Explanation:</b> The [1, 3, 2] has three different positive integers ranging from 1 to 3, and the [2, 1] has exactly 2 distinct integers: 1 and 2.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The <code>n</code> and <code>k</code> are in the range 1 <= k < n <= 10<sup>4</sup>.</li>\r\n</ol>\r\n</p>",
    "tags": "Array",
    "difficulty": 2,
    "frontend_article_id": 667,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-time-limit-exceeded\">Approach #1: Brute Force [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-construction-accepted\">Approach #2: Construction [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-time-limit-exceeded\">Approach #1: Brute Force [Time Limit Exceeded]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>For each permutation of <script type=\"math/tex; mode=display\">\\text{[1, 2, ..., n]}</script>, let's look at the set of differences of the adjacent elements.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>For each permutation, we find the number of unique differences of adjacent elements. If it is the desired number, we'll return that permutation.</p> \n  <p>To enumerate each permutation without using library functions, we use a recursive algorithm, where <code>permute</code> is responsible for permuting the indexes of <script type=\"math/tex; mode=display\">\\text{nums}</script> in the interval <script type=\"math/tex; mode=display\">\\text{[start, nums.length)}</script>.</p> \n  <iframe src=\"https://leetcode.com/playground/JvKeuMXb/shared\" frameborder=\"0\" name=\"JvKeuMXb\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(n!)</script> to generate every permutation in the outer loop, then <script type=\"math/tex; mode=display\">O(n)</script> work to check differences. In total taking <script type=\"math/tex; mode=display\">O(n* n!)</script> time.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(n)</script>. We use <script type=\"math/tex; mode=display\">\\text{seen}</script> to store whether we've seen the differences, and each generated permutation has a length equal to <script type=\"math/tex; mode=display\">\\text{n}</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-construction-accepted\">Approach #2: Construction [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>When <script type=\"math/tex; mode=display\">\\text{k = n-1}</script>, a valid construction is <script type=\"math/tex; mode=display\">\\text{[1, n, 2, n-1, 3, n-2, ....]}</script>. One way to see this is, we need to have a difference of <script type=\"math/tex; mode=display\">\\text{n-1}</script>, which means we need <script type=\"math/tex; mode=display\">\\text{1}</script> and <script type=\"math/tex; mode=display\">\\text{n}</script> adjacent; then, we need a difference of <script type=\"math/tex; mode=display\">\\text{n-2}</script>, etc.</p> \n  <p>Also, when <script type=\"math/tex; mode=display\">\\text{k = 1}</script>, a valid construction is <script type=\"math/tex; mode=display\">\\text{[1, 2, 3, ..., n]}</script>. So we have a construction when <script type=\"math/tex; mode=display\">\\text{n-k}</script> is tiny, and when it is large. This leads to the idea that we can stitch together these two constructions: we can put <script type=\"math/tex; mode=display\">\\text{[1, 2, ..., n-k-1]}</script> first so that <script type=\"math/tex; mode=display\">\\text{n}</script> is effectively <script type=\"math/tex; mode=display\">\\text{k+1}</script>, and then finish the construction with the first <script type=\"math/tex; mode=display\">\\text{\"k = n-1\"}</script> method.</p> \n  <p>For example, when <script type=\"math/tex; mode=display\">\\text{n = 6}</script> and <script type=\"math/tex; mode=display\">\\text{k = 3}</script>, we will construct the array as <script type=\"math/tex; mode=display\">\\text{[1, 2, 3, 6, 4, 5]}</script>. This consists of two parts: a construction of <script type=\"math/tex; mode=display\">\\text{[1, 2]}</script> and a construction of <script type=\"math/tex; mode=display\">\\text{[1, 4, 2, 3]}</script> where every element had <script type=\"math/tex; mode=display\">\\text{2}</script> added to it (i.e. <script type=\"math/tex; mode=display\">\\text{[3, 6, 4, 5]}</script>).</p> \n  <p><strong>Algorithm</strong></p> \n  <p>As before, write <script type=\"math/tex; mode=display\">\\text{[1, 2, ..., n-k-1]}</script> first. The remaining <script type=\"math/tex; mode=display\">\\text{k+1}</script> elements to be written are <script type=\"math/tex; mode=display\">\\text{[n-k, n-k+1, ..., n]}</script>, and we'll write them in alternating head and tail order.</p> \n  <p>When we are writing the <script type=\"math/tex; mode=display\">i^{th}</script> element from the remaining <script type=\"math/tex; mode=display\">\\text{k+1}</script>, every even <script type=\"math/tex; mode=display\">i</script> is going to be chosen from the head, and will have value <script type=\"math/tex; mode=display\">\\text{n-k + i//2}</script>. Every odd <script type=\"math/tex; mode=display\">i</script> is going to be chosen from the tail, and will have value <script type=\"math/tex; mode=display\">\\text{n - i//2}</script>.</p> \n  <iframe src=\"https://leetcode.com/playground/knXdznYV/shared\" frameborder=\"0\" name=\"knXdznYV\" width=\"100%\" height=\"275\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(n)</script>. We are making a list of size <script type=\"math/tex; mode=display\">\\text{n}</script>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(n)</script>. Our answer has a length equal to <script type=\"math/tex; mode=display\">\\text{n}</script>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 666,
    "article_live": true,
    "article_slug": "path-sum-iv",
    "title": "Path Sum IV",
    "title_slug": "path-sum-iv",
    "tags": "Tree",
    "difficulty": 2,
    "frontend_article_id": 666,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-convert-to-tree-accepted\">Approach #1: Convert to Tree [Accepted]</a></li> \n    <li><a href=\"#approach-2-direct-traversal-accepted\">Approach #2: Direct Traversal [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-convert-to-tree-accepted\">Approach #1: Convert to Tree [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Convert the given array into a tree using Node objects. Afterwards, for each path from root to leaf, we can add the sum of that path to our answer.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>There are two steps, the tree construction, and the traversal.</p> \n  <p>In the tree construction, we have some depth, position, and value, and we want to know where the new node goes. With some effort, we can see the relevant condition for whether a node should be left or right is <code>pos - 1 &lt; 2**(depth - 2)</code>. For example, when <code>depth = 4</code>, the positions are <code>1, 2, 3, 4, 5, 6, 7, 8</code>, and it's left when <code>pos &lt;= 4</code>.</p> \n  <p>In the traversal, we perform a depth-first search from root to leaf, keeping track of the current sum along the path we have travelled. Every time we reach a leaf <code>(node.left == null &amp;&amp; node.right == null)</code>, we have to add that running sum to our answer.</p> \n  <iframe src=\"https://leetcode.com/playground/9DugWkyp/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"9DugWkyp\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script> where <script type=\"math/tex; mode=display\">N</script> is the length of <code>nums</code>. We construct the graph and traverse it in this time.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the size of the implicit call stack in our depth-first search.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-direct-traversal-accepted\">Approach #2: Direct Traversal [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>As in <em>Approach #1</em>, we will depth-first search on the tree. One time-saving idea is that we can use <code>num / 10 = 10 * depth + pos</code> as a unique identifier for that node. The left child of such a node would have identifier <code>10 * (depth + 1) + 2 * pos - 1</code>, and the right child would be one greater.</p> \n  <iframe src=\"https://leetcode.com/playground/JG3jC7pT/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"JG3jC7pT\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time and Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. The analysis is the same as in <em>Approach #1</em>.</li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 665,
    "article_live": true,
    "article_slug": "non-decreasing-array",
    "title": "Non-decreasing Array",
    "title_slug": "non-decreasing-array",
    "content": "<p>\r\nGiven an array with <code>n</code> integers, your task is to check if it could become non-decreasing by modifying <b>at most</b> <code>1</code> element.\r\n</p>\r\n\r\n<p>\r\nWe define an array is non-decreasing if <code>array[i] <= array[i + 1]</code> holds for every <code>i</code> (1 <= i < n).\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [4,2,3]\r\n<b>Output:</b> True\r\n<b>Explanation:</b> You could modify the first <code>4</code> to <code>1</code> to get a non-decreasing array.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> [4,2,1]\r\n<b>Output:</b> False\r\n<b>Explanation:</b> You can't get a non-decreasing array by modify at most one element.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\nThe <code>n</code> belongs to [1, 10,000].\r\n</p>",
    "tags": "Array",
    "difficulty": 1,
    "frontend_article_id": 665,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-time-limit-exceeded\">Approach #1: Brute Force [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-reduce-to-smaller-problem-accepted\">Approach #2: Reduce to Smaller Problem [Accepted]</a></li> \n      <li><a href=\"#approach-3-locate-and-analyze-problem-index-accepted\">Approach #3: Locate and Analyze Problem Index [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-time-limit-exceeded\">Approach #1: Brute Force [Time Limit Exceeded]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>For the given array <script type=\"math/tex; mode=display\">\\text{A}</script>, if we are changing at most one element <script type=\"math/tex; mode=display\">\\text{A[i]}</script>, we should change <script type=\"math/tex; mode=display\">\\text{A[i]}</script> to <script type=\"math/tex; mode=display\">\\text{A[i-1]}</script>, as it would be guaranteed that <script type=\"math/tex; mode=display\">\\text{A[i-1]} &leq; \\text{A[i]}</script>, and <script type=\"math/tex; mode=display\">\\text{A[i]}</script> would be the smallest possible to try and achieve <script type=\"math/tex; mode=display\">\\text{A[i]} &leq; \\text{A[i+1]}</script>.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>For each possible change <script type=\"math/tex; mode=display\">\\text{A[i]}</script>, check if the sequence is monotone increasing. We'll modify <script type=\"math/tex; mode=display\">\\text{new}</script>, a copy of the array <script type=\"math/tex; mode=display\">\\text{A}</script>.</p> \n  <iframe src=\"https://leetcode.com/playground/FK7JPfxR/shared\" frameborder=\"0\" name=\"FK7JPfxR\" width=\"100%\" height=\"343\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: Let <script type=\"math/tex; mode=display\">N</script> be the length of the given array. For each element <script type=\"math/tex; mode=display\">\\text{A[i]}</script>, we check if some sequence is monotone increasing, which takes <script type=\"math/tex; mode=display\">O(N)</script> steps. In total, this is a complexity of <script type=\"math/tex; mode=display\">O(N^2)</script>.</p> </li> \n   <li> <p>Space Complexity: To hold our array <script type=\"math/tex; mode=display\">\\text{new}</script>, we need <script type=\"math/tex; mode=display\">O(N)</script> space.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-reduce-to-smaller-problem-accepted\">Approach #2: Reduce to Smaller Problem [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>If <script type=\"math/tex; mode=display\">\\text{A[0]} &leq; \\text{A[1]} &leq; \\text{A[2]}</script>, then we may remove <script type=\"math/tex; mode=display\">\\text{A[0]}</script> without changing the answer. Similarly, if <script type=\"math/tex; mode=display\">\\text{A}\\big[\\text{len(A)-3}\\big] &leq; \\text{A}\\big[\\text{len(A)-2}\\big] &leq; \\text{A}\\big[\\text{len(A)-1}\\big]</script>, we may remove <script type=\"math/tex; mode=display\">\\text{A[len(A)-1]}</script> without changing the answer.</p> \n  <p>If the problem is solvable, then after these removals, very few numbers will remain.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Consider the interval <script type=\"math/tex; mode=display\">\\text{[i, j]}</script> corresponding to the subarray <script type=\"math/tex; mode=display\">\\big[\\text{A[i], A[i+1], ..., A[j]}\\big]</script>. When <script type=\"math/tex; mode=display\">\\text{A[i]} &leq; \\text{A[i+1]} &leq; \\text{A[i+2]}</script>, we know we do not need to modify <script type=\"math/tex; mode=display\">\\text{A[i]}</script>, and we can consider solving the problem on the interval <script type=\"math/tex; mode=display\">\\text{[i+1, j]}</script> instead. We use a similar approach for <script type=\"math/tex; mode=display\">j</script>.</p> \n  <p>Afterwards, with the length of the interval under consideration being <script type=\"math/tex; mode=display\">\\text{j - i + 1}</script>, if the interval has size 2 or less, then we did not find any problem. </p> \n  <p>If our interval under consideration has 5 or more elements, then there are two disjoint problems that cannot be fixed with one replacement. </p> \n  <p>Otherwise, our problem size is now at most 4 elements, which we can easily brute force.</p> \n  <iframe src=\"https://leetcode.com/playground/4ypTHUiy/shared\" frameborder=\"0\" name=\"4ypTHUiy\" width=\"100%\" height=\"343\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: Let <script type=\"math/tex; mode=display\">N</script> be the length of the given array. Our pointers <script type=\"math/tex; mode=display\">i</script> and <script type=\"math/tex; mode=display\">j</script> move at most <script type=\"math/tex; mode=display\">O(N)</script> times. Our brute force is constant time as there are at most 4 elements in the array. Hence, the complexity is <script type=\"math/tex; mode=display\">O(N)</script>.</p> </li> \n   <li> <p>Space Complexity: The extra array <script type=\"math/tex; mode=display\">\\text{A[i: j+1]}</script> only has at most 4 elements, so it is constant space, and so is the space used by our auxillary brute force algorithm. In total, the space complexity is <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-locate-and-analyze-problem-index-accepted\">Approach #3: Locate and Analyze Problem Index [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Consider all indices <script type=\"math/tex; mode=display\">p</script> for which <script type=\"math/tex; mode=display\">\\text{A[p]} > \\text{A[p+1]}</script>. If there are zero, the answer is <code>True</code>. If there are 2 or more, the answer is <code>False</code>, as more than one element of the array must be changed for <script type=\"math/tex; mode=display\">\\text{A}</script> to be monotone increasing.</p> \n  <p>At the problem index <script type=\"math/tex; mode=display\">p</script>, we only care about the surrounding elements. Thus, immediately the problem is reduced to a very small size that can be analyzed by casework.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>As before, let <script type=\"math/tex; mode=display\">p</script> be the unique problem index for which <script type=\"math/tex; mode=display\">\\text{A[p]} > \\text{A[p+1]}</script>. If this is not unique or doesn't exist, the answer is <code>False</code> or <code>True</code> respectively. We analyze the following cases:</p> \n  <ul> \n   <li>If <script type=\"math/tex; mode=display\">\\text{p = 0}</script>, then we could make the array good by setting <script type=\"math/tex; mode=display\">\\text{A[p] = A[p+1]}</script>.</li> \n   <li>If <script type=\"math/tex; mode=display\">\\text{p = len(A) - 2}</script>, then we could make the array good by setting <script type=\"math/tex; mode=display\">\\text{A[p+1] = A[p]}</script>.</li> \n   <li>Otherwise, <script type=\"math/tex; mode=display\">\\text{A[p-1], A[p], A[p+1], A[p+2]}</script> all exist, and:\n    <ul> \n     <li>We could change <script type=\"math/tex; mode=display\">\\text{A[p]}</script> to be between <script type=\"math/tex; mode=display\">\\text{A[p-1]}</script> and <script type=\"math/tex; mode=display\">\\text{A[p+1]}</script> if possible, or;</li> \n     <li>We could change <script type=\"math/tex; mode=display\">\\text{A[p+1]}</script> to be between <script type=\"math/tex; mode=display\">\\text{A[p]}</script> and <script type=\"math/tex; mode=display\">\\text{A[p+2]}</script> if possible.</li> \n    </ul> </li> \n  </ul> \n  <iframe src=\"https://leetcode.com/playground/NGHYqESJ/shared\" frameborder=\"0\" name=\"NGHYqESJ\" width=\"100%\" height=\"241\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: Let <script type=\"math/tex; mode=display\">N</script> be the length of the given array. We loop through the array once, so our time complexity is <script type=\"math/tex; mode=display\">O(N)</script>.</p> </li> \n   <li> <p>Space Complexity: We only use <script type=\"math/tex; mode=display\">p</script> and <script type=\"math/tex; mode=display\">i</script>, and the answer itself as the additional space. The additional space complexity is <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 664,
    "article_live": true,
    "article_slug": "strange-printer",
    "title": "Strange Printer",
    "title_slug": "strange-printer",
    "content": "<p>\r\nThere is a strange printer with the following two special requirements:\r\n\r\n<ol>\r\n<li>The printer can only print a sequence of the same character each time.</li>\r\n<li>At each turn, the printer can print new characters starting from and ending at any places, and will cover the original existing characters.</li>\r\n</ol>\r\n\r\n</p>\r\n\r\n<p>\r\nGiven a string consists of lower English letters only, your job is to count the minimum number of turns the printer needed in order to print it.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \"aaabbb\"\r\n<b>Output:</b> 2\r\n<b>Explanation:</b> Print \"aaa\" first and then print \"bbb\".\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> \"aba\"\r\n<b>Output:</b> 2\r\n<b>Explanation:</b> Print \"aaa\" first and then print \"b\" from the second place of the string, which will cover the existing character 'a'.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Hint</b>: Length of the given string will not exceed 100.</p>",
    "tags": "Dynamic Programming, Depth-first Search",
    "difficulty": 3,
    "frontend_article_id": 664,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-dynamic-programming-accepted\">Approach #1: Dynamic Programming [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-dynamic-programming-accepted\">Approach #1: Dynamic Programming [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>It is natural to consider letting <code>dp(i, j)</code> be the answer for printing <code>S[i], S[i+1], ..., S[j]</code>, but proceeding from here is difficult. We need the following sequence of deductions:</p> \n  <ul> \n   <li> <p>Whatever turn creates the final print of <code>S[i]</code> might as well be the first turn, and also there might as well only be one print, since any later prints on interval <code>[i, k]</code> could just be on <code>[i+1, k]</code>.</p> </li> \n   <li> <p>Say the first print is on <code>[i, k]</code>. We can assume <code>S[i] == S[k]</code>, because if it wasn't, we could print up to the last occurrence of <code>S[i]</code> in <code>[i, k]</code> for the same result.</p> </li> \n   <li> <p>When correctly printing everything in <code>[i, k]</code> (with <code>S[i] == S[k]</code>), it will take the same amount of steps as correctly printing everything in <code>[i, k-1]</code>. This is because if <code>S[i]</code> and <code>S[k]</code> get completed in separate steps, we might as well print them first in one step instead.</p> </li> \n  </ul> \n  <p><strong>Algorithm</strong></p> \n  <p>With the above deductions, the algorithm is straightforward.</p> \n  <p>To compute a recursion for <code>dp(i, j)</code>, for every <code>i &lt;= k &lt;= j</code> with <code>S[i] == S[k]</code>, we have some candidate answer <code>dp(i, k-1) + dp(k+1, j)</code>, and we take the minimum of these candidates. Of course, when <code>k = i</code>, the candidate is just <code>1 + dp(i+1, j)</code>.</p> \n  <p>To avoid repeating work, we memoize our intermediate answers <code>dp(i, j)</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/L3mAUr9w/shared\" frameborder=\"0\" width=\"100%\" height=\"378\" name=\"L3mAUr9w\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^3)</script> where <script type=\"math/tex; mode=display\">N</script> is the length of <code>s</code>. For each of <script type=\"math/tex; mode=display\">O(N^2)</script> possible states representing a subarray of <code>s</code>, we perform <script type=\"math/tex; mode=display\">O(N)</script> work iterating through <code>k</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, the size of our <code>memo</code>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 663,
    "article_live": true,
    "article_slug": "equal-tree-partition",
    "title": "Equal Tree Partition",
    "title_slug": "equal-tree-partition",
    "tags": "Tree",
    "difficulty": 2,
    "frontend_article_id": 663,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-depth-first-search-accepted\">Approach #1: Depth-First Search [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-depth-first-search-accepted\">Approach #1: Depth-First Search [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>After removing some edge from <code>parent</code> to <code>child</code>, (where the <code>child</code> cannot be the original <code>root</code>) the subtree rooted at <code>child</code> must be half the sum of the entire tree.</p> \n  <p>Let's record the sum of every subtree. We can do this recursively using depth-first search. After, we should check that half the sum of the entire tree occurs somewhere in our recording (and not from the total of the entire tree.)</p> \n  <p>Our careful treatment and analysis above prevented errors in the case of these trees:</p> \n  <div class=\"codehilite\">\n   <pre><span></span>  <span class=\"mi\">0</span>\n <span class=\"o\">/</span> \\\n<span class=\"o\">-</span><span class=\"mi\">1</span>  <span class=\"mi\">1</span>\n\n <span class=\"mi\">0</span>\n  \\\n   <span class=\"mi\">0</span>\n</pre>\n  </div> \n  <iframe src=\"https://leetcode.com/playground/PfHZumnG/shared\" frameborder=\"0\" width=\"100%\" height=\"378\" name=\"PfHZumnG\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script> where <script type=\"math/tex; mode=display\">N</script> is the number of nodes in the input tree. We traverse every node.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the size of <code>seen</code> and the implicit call stack in our DFS.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 662,
    "article_live": true,
    "article_slug": "maximum-width-of-binary-tree",
    "title": "Maximum Width of Binary Tree",
    "title_slug": "maximum-width-of-binary-tree",
    "content": "<p>Given a binary tree, write a function to get the maximum width of the given tree. The width of a tree is the maximum width among all levels. The binary tree has the same structure as a <b>full binary tree</b>, but some nodes are null. </p>\r\n\r\n<p>The width of one level is defined as the length between the end-nodes (the leftmost and right most non-null nodes in the level, where the <code>null</code> nodes between the end-nodes are also counted into the length calculation.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\n\r\n           1\r\n         /   \\\r\n        3     2\r\n       / \\     \\  \r\n      5   3     9 \r\n\r\n<b>Output:</b> 4\r\n<b>Explanation:</b> The maximum width existing in the third level with the length 4 (5,3,null,9).\r\n</pre>\r\n\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\n\r\n          1\r\n         /  \r\n        3    \r\n       / \\       \r\n      5   3     \r\n\r\n<b>Output:</b> 2\r\n<b>Explanation:</b> The maximum width existing in the third level with the length 2 (5,3).\r\n</pre>\r\n\r\n\r\n<p><b>Example 3:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\n\r\n          1\r\n         / \\\r\n        3   2 \r\n       /        \r\n      5      \r\n\r\n<b>Output:</b> 2\r\n<b>Explanation:</b> The maximum width existing in the second level with the length 2 (3,2).\r\n</pre>\r\n\r\n<p><b>Example 4:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\n\r\n          1\r\n         / \\\r\n        3   2\r\n       /     \\  \r\n      5       9 \r\n     /         \\\r\n    6           7\r\n<b>Output:</b> 8\r\n<b>Explanation:</b>The maximum width existing in the fourth level with the length 8 (6,null,null,null,null,null,null,7).\r\n\r\n\r\n</pre>\r\n\r\n<p><b>Note:</b>\r\nAnswer will in the range of 32-bit signed integer.\r\n</p>",
    "tags": "Tree",
    "difficulty": 2,
    "frontend_article_id": 662,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-framework\">Approach Framework</a></li> \n    <li><a href=\"#approach-1-breadth-first-search-accepted\">Approach #1: Breadth-First Search [Accepted]</a></li> \n    <li><a href=\"#approach-2-depth-first-search-accepted\">Approach #2: Depth-First Search [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-framework\">Approach Framework</h4> \n  <p><strong>Explanation</strong></p> \n  <p>As we need to reach every node in the given tree, we will have to traverse the tree, either with a depth-first search, or with a breadth-first search.</p> \n  <p>The main idea in this question is to give each node a <code>position</code> value. If we go down the left neighbor, then <code>position -&gt; position * 2</code>; and if we go down the right neighbor, then <code>position -&gt; position * 2 + 1</code>. This makes it so that when we look at the position values <code>L</code> and <code>R</code> of two nodes with the same depth, the width will be <code>R - L + 1</code>.</p> \n  <hr> \n  <h4 id=\"approach-1-breadth-first-search-accepted\">Approach #1: Breadth-First Search [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Traverse each node in breadth-first order, keeping track of that node's position. For each depth, the first node reached is the left-most, while the last node reached is the right-most.</p> \n  <iframe src=\"https://leetcode.com/playground/GsZid6zn/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"GsZid6zn\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script> where <script type=\"math/tex; mode=display\">N</script> is the number of nodes in the input tree. We traverse every node.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the size of our <code>queue</code>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-depth-first-search-accepted\">Approach #2: Depth-First Search [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Traverse each node in depth-first order, keeping track of that node's position. For each depth, the position of the first node reached of that depth will be kept in <code>left[depth]</code>.</p> \n  <p>Then, for each node, a candidate width is <code>pos - left[depth] + 1</code>. We take the maximum of the candidate answers.</p> \n  <iframe src=\"https://leetcode.com/playground/A9iKAcsQ/shared\" frameborder=\"0\" width=\"100%\" height=\"344\" name=\"A9iKAcsQ\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script> where <script type=\"math/tex; mode=display\">N</script> is the number of nodes in the input tree. We traverse every node.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the size of the implicit call stack in our DFS.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 661,
    "article_live": true,
    "article_slug": "image-smoother",
    "title": "Image Smoother",
    "title_slug": "image-smoother",
    "content": "<p>Given a 2D integer matrix M representing the gray scale of an image, you need to design a smoother to make the gray scale of each cell becomes the average gray scale (rounding down) of all the 8 surrounding cells and itself.  If a cell has less than 8 surrounding cells, then use as many as you can.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b>\r\n[[1,1,1],\r\n [1,0,1],\r\n [1,1,1]]\r\n<b>Output:</b>\r\n[[0, 0, 0],\r\n [0, 0, 0],\r\n [0, 0, 0]]\r\n<b>Explanation:</b>\r\nFor the point (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0\r\nFor the point (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0\r\nFor the point (1,1): floor(8/9) = floor(0.88888889) = 0\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The value in the given matrix is in the range of [0, 255].</li>\r\n<li>The length and width of the given matrix are in the range of [1, 150].</li>\r\n</ol>\r\n</p>",
    "tags": "Array",
    "difficulty": 1,
    "frontend_article_id": 661,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-iterate-through-grid\">Approach #1: Iterate Through Grid</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-iterate-through-grid\">Approach #1: Iterate Through Grid</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>For each cell in the grid, look at the immediate neighbors - up to 9 of them, including the original cell.</p> \n  <p>Then, we will add the sum of the neighbors into <code>ans[r][c]</code> while recording <code>count</code>, the number of such neighbors. The final answer is the sum divided by the count.</p> \n  <iframe src=\"https://leetcode.com/playground/i8A5ppzu/shared\" frameborder=\"0\" width=\"100%\" height=\"395\" name=\"i8A5ppzu\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of pixels in our image. We iterate over every pixel.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the size of our answer.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 660,
    "article_live": true,
    "article_slug": "remove-9",
    "title": "Remove 9",
    "title_slug": "remove-9",
    "tags": "Math",
    "difficulty": 3,
    "frontend_article_id": 660,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-mathematical\">Approach #1: Mathematical</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-mathematical\">Approach #1: Mathematical</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Let's write the first numbers and try to notice a pattern. Those numbers are:</p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">6</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"mi\">8</span><span class=\"p\">,</span>\n<span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">11</span><span class=\"p\">,</span> <span class=\"mi\">12</span><span class=\"p\">,</span> <span class=\"mi\">13</span><span class=\"p\">,</span> <span class=\"mi\">14</span><span class=\"p\">,</span> <span class=\"mi\">15</span><span class=\"p\">,</span> <span class=\"mi\">16</span><span class=\"p\">,</span> <span class=\"mi\">17</span><span class=\"p\">,</span> <span class=\"mi\">18</span><span class=\"p\">,</span>\n<span class=\"mi\">20</span><span class=\"p\">,</span> <span class=\"mi\">21</span><span class=\"p\">,</span> <span class=\"mi\">22</span><span class=\"p\">,</span> <span class=\"mi\">23</span><span class=\"p\">,</span> <span class=\"mi\">24</span><span class=\"p\">,</span> <span class=\"mi\">25</span><span class=\"p\">,</span> <span class=\"mi\">26</span><span class=\"p\">,</span> <span class=\"mi\">27</span><span class=\"p\">,</span> <span class=\"mi\">28</span><span class=\"p\">,</span>\n<span class=\"o\">...</span>\n<span class=\"mi\">80</span><span class=\"p\">,</span> <span class=\"mi\">81</span><span class=\"p\">,</span> <span class=\"mi\">82</span><span class=\"p\">,</span> <span class=\"mi\">83</span><span class=\"p\">,</span> <span class=\"mi\">84</span><span class=\"p\">,</span> <span class=\"mi\">85</span><span class=\"p\">,</span> <span class=\"mi\">86</span><span class=\"p\">,</span> <span class=\"mi\">87</span><span class=\"p\">,</span> <span class=\"mi\">88</span><span class=\"p\">,</span>\n<span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"mi\">101</span><span class=\"p\">,</span> <span class=\"mi\">102</span><span class=\"p\">,</span> <span class=\"o\">...</span>\n</pre>\n  </div> \n  <p>These numbers look exactly like all base-9 numbers!</p> \n  <p>Indeed, every base-9 number is a number in this sequence, and every number in this sequence is a base-9 number. Both this sequence and the sequence of all base-9 numbers are in increasing order. The answer is therefore just the n-th base-9 number.</p> \n  <iframe src=\"https://leetcode.com/playground/tGRiLEQb/shared\" frameborder=\"0\" width=\"100%\" height=\"174\" name=\"tGRiLEQb\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(1)</script>, since <script type=\"math/tex; mode=display\">N</script> has at most 9 digits.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 659,
    "article_live": true,
    "article_slug": "split-array-into-consecutive-subsequences",
    "title": "Split Array into Consecutive Subsequences",
    "title_slug": "split-array-into-consecutive-subsequences",
    "content": "<p>You are given an integer array sorted in ascending order (may contain duplicates), you need to split them into several subsequences, where each subsequences consist of at least 3 consecutive integers. Return whether you can make such a split.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [1,2,3,3,4,5]\r\n<b>Output:</b> True\r\n<b>Explanation:</b>\r\nYou can split them into two consecutive subsequences : \r\n1, 2, 3\r\n3, 4, 5\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> [1,2,3,3,4,4,5,5]\r\n<b>Output:</b> True\r\n<b>Explanation:</b>\r\nYou can split them into two consecutive subsequences : \r\n1, 2, 3, 4, 5\r\n3, 4, 5\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 3:</b><br />\r\n<pre>\r\n<b>Input:</b> [1,2,3,4,4,5]\r\n<b>Output:</b> False\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The length of the input is in range of [1, 10000]</li>\r\n</ol>\r\n</p>",
    "tags": "Heap, Greedy",
    "difficulty": 2,
    "frontend_article_id": 659,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-opening-and-closing-events-accepted\">Approach #1: Opening and Closing Events [Accepted]</a></li> \n    <li><a href=\"#approach-2-greedy-accepted\">Approach #2: Greedy [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-opening-and-closing-events-accepted\">Approach #1: Opening and Closing Events [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>We can think of the problem as drawing intervals on a number line. This gives us the idea of opening and closing events.</p> \n  <p>To illustrate this concept, say we have <code>nums = [10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 13]</code>, with no <code>9</code>s and no <code>14</code>s. We must have two sequences start at 10, two sequences start at 11, and 3 sequences end at 12.</p> \n  <p>In general, when considering a chain of consecutive integers <code>x</code>, we must have <code>C = count[x+1] - count[x]</code> sequences start at <code>x+1</code> when <code>C &gt; 0</code>, and <code>-C</code> sequences end at <code>x</code> if <code>C &lt; 0</code>. Even if there are more endpoints on the intervals we draw, there must be at least this many endpoints.</p> \n  <p>With the above example, <code>count[11] - count[10] = 2</code> and <code>count[13] - count[12] = -3</code> show that two sequences start at <code>11</code>, and three sequences end at <code>12</code>.</p> \n  <p>Also, if for example we know some sequences must start at time <code>1</code> and <code>4</code> and some sequences end at <code>5</code> and <code>7</code>, to maximize the smallest length sequence, we should pair the events together in the order they occur: ie., <code>1</code> with <code>5</code> and <code>4</code> with <code>7</code>.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>For each group of numbers, say the number is <code>x</code> and there are <code>count</code> of them. Furthermore, say <code>prev, prev_count</code> is the previous integer encountered and it's count.</p> \n  <p>Then, in general there are <code>abs(count - prev_count)</code> events that will happen: if <code>count &gt; prev_count</code> then we will add this many <code>t</code>'s to <code>starts</code>; and if <code>count &lt; prev_count</code> then we will attempt to pair <code>starts.popleft()</code> with <code>t-1</code>.</p> \n  <p>More specifically, when we have finished a consecutive group, we will have <code>prev_count</code> endings; and when we are in a consecutive group, we may have <code>count - prev_count</code> starts or <code>prev_count - count</code> endings.</p> \n  <p>For example, when <code>nums = [1,2,3,3,4,5]</code>, then the starts are at <code>[1, 3]</code> and the endings are at <code>[3, 5]</code>. As our algorithm progresses:</p> \n  <ul> \n   <li>When <code>t = 1, count = 1</code>: <code>starts = [1]</code></li> \n   <li>When <code>t = 2, count = 1</code>: <code>starts = [1]</code></li> \n   <li>When <code>t = 3, count = 2</code>: <code>starts = [1, 3]</code></li> \n   <li>When <code>t = 4, count = 1</code>: <code>starts = [3]</code>, since <code>prev_count - count = 1</code> we process one closing event, which is accepted as <code>t-1 &gt;= starts.popleft() + 2</code>.</li> \n   <li>When <code>t = 5, count = 1</code>: <code>starts = [3]</code></li> \n  </ul> \n  <p>And at the end, we process <code>prev_count</code> more closing events <code>nums[-1]</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/aPKnzzAo/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"aPKnzzAo\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>nums</code>. We iterate over the array and every event is added or popped to <code>starts</code> at most once.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the size of <code>starts</code>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-greedy-accepted\">Approach #2: Greedy [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Call a <em>chain</em> a sequence of 3 or more consecutive numbers.</p> \n  <p>Considering numbers <code>x</code> from left to right, if <code>x</code> can be added to a current chain, it's at least as good to add <code>x</code> to that chain first, rather than to start a new chain.</p> \n  <p>Why? If we started with numbers <code>x</code> and greater from the beginning, the shorter chains starting from <code>x</code> could be concatenated with the chains ending before <code>x</code>, possibly helping us if there was a \"chain\" from <code>x</code> that was only length 1 or 2.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Say we have a count of each number, and let <code>tails[x]</code> be the number of chains ending right before <code>x</code>.</p> \n  <p>Now let's process each number. If there's a chain ending before <code>x</code>, then add it to that chain. Otherwise, if we can start a new chain, do so.</p> \n  <p>It's worth noting that our solution can be amended to take only <script type=\"math/tex; mode=display\">O(1)</script> additional space, since we could do our counts similar to <em>Approach #1</em>, and we only need to know the last 3 counts at a time.</p> \n  <iframe src=\"https://leetcode.com/playground/RErfKTGx/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"RErfKTGx\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>nums</code>. We iterate over the array.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the size of <code>count</code> and <code>tails</code>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>. Approach #2 inspired by <a href=\"https://discuss.leetcode.com/topic/99187/java-o-n-time-o-n-space\">@compton_scatter</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 658,
    "article_live": true,
    "article_slug": "find-k-closest-elements",
    "title": "Find K Closest Elements",
    "title_slug": "find-k-closest-elements",
    "content": "<p>\r\nGiven a sorted array, two integers <code>k</code> and <code>x</code>, find the <code>k</code> closest elements to <code>x</code> in the array.  The result should also be sorted in ascending order.\r\nIf there is a tie,  the smaller elements are always preferred.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [1,2,3,4,5], k=4, x=3\r\n<b>Output:</b> [1,2,3,4]\r\n</pre>\r\n</p>\r\n\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> [1,2,3,4,5], k=4, x=-1\r\n<b>Output:</b> [1,2,3,4]\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The value k is positive and will always be smaller than the length of the sorted array.</li>\r\n<li> Length of the given array is positive and will not exceed 10<sup>4</sup></li>\r\n<li> Absolute value of elements in the array and x will not exceed 10<sup>4</sup></li>\r\n</ol>\r\n</p>\r\n\r\n<hr />\r\n\r\n<p>\r\n<b><font color=\"red\">UPDATE (2017/9/19):</font></b><br />\r\nThe <i>arr</i> parameter had been changed to an <b>array of integers</b> (instead of a list of integers). <b><i>Please reload the code definition to get the latest changes</i></b>.\r\n</p>",
    "tags": "Binary Search",
    "difficulty": 2,
    "frontend_article_id": 658,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-using-collectionsort-accepted\">Approach #1 Using Collection.sort( ) [Accepted]</a></li> \n      <li><a href=\"#approach-2-using-binary-search-and-two-pointers-accepted\">Approach #2 Using Binary Search and Two Pointers [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-using-collectionsort-accepted\">Approach #1 Using Collection.sort( ) [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Intuitively, we can sort the elements in list <code>arr</code> by their absolute difference values to the target <code>x</code>. Then the sublist of the first k elements is the result after sorting the elements by the natural order.</p> \n  <iframe src=\"https://leetcode.com/playground/5B68PpKj/shared\" frameborder=\"0\" name=\"5B68PpKj\" width=\"100%\" height=\"156\"></iframe> \n  <p>Note: This solution is inspired by <a href=\"https://discuss.leetcode.com/user/compton_scatter\">@compton_scatter</a>.</p> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n*log(n))</script>. Collections.sort() uses binary sort so it has a <script type=\"math/tex; mode=display\">O(n*log(n))</script> complexity.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(k)</script>. The in-place sorting does not consume any extra space. However, generating a k length sublist will take some space.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-using-binary-search-and-two-pointers-accepted\">Approach #2 Using Binary Search and Two Pointers [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>The original array has been sorted so we can take this advantage by the following steps. 1. If the target <code>x</code> is less or equal than the first element in the sorted array, the first <code>k</code> elements are the result. 2. Similarly, if the target <code>x</code> is more or equal than the last element in the sorted array, the last <code>k</code> elements are the result. 3. Otherwise, we can use binary search to find the <code>index</code> of the element, which is equal (when this list has <code>x</code>) or a little bit larger than <code>x</code> (when this list does not have it). Then set <code>low</code> to its left <code>k-1</code> position, and <code>high</code> to the right <code>k-1</code> position of this <code>index</code> as a start. The desired k numbers must in this rang [index-k-1, index+k-1]. So we can shrink this range to get the result using the following rules. * If <code>low</code> reaches the lowest index <code>0</code> or the <code>low</code> element is closer to <code>x</code> than the <code>high</code> element, decrease the <code>high</code> index. * If <code>high</code> reaches to the highest index <code>arr.size()-1</code> or it is nearer to <code>x</code> than the <code>low</code> element, increase the <code>low</code> index. * The looping ends when there are exactly k elements in [low, high], the subList of which is the result.</p> \n  <iframe src=\"https://leetcode.com/playground/sqToH7AR/shared\" frameborder=\"0\" name=\"sqToH7AR\" width=\"100%\" height=\"479\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(log(n)+k)</script>. <script type=\"math/tex; mode=display\">O(log(n))</script> is for the time of binary search, while <script type=\"math/tex; mode=display\">O(k)</script> is for shrinking the index range to k elements.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(k)</script>. It is to generate the required sublist.</p> </li> \n  </ul> \n  <p>Analysis written by: <a href=\"https://discuss.leetcode.com/user/mr-bin\">@Mr.Bin</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 657,
    "article_live": true,
    "article_slug": "judge-route-circle",
    "title": "Robot Return to Origin",
    "title_slug": "robot-return-to-origin",
    "content": "<p>There is a robot starting at position (0, 0), the origin, on a 2D plane. Given a sequence of its moves, judge if this robot <strong>ends up at (0, 0)</strong> after it completes its moves.</p>\r\n\r\n<p>The move sequence is represented by a string, and the character moves[i] represents its ith move. Valid moves are R (right), L (left), U (up), and D (down). If the robot returns to the origin after it finishes all of its moves, return true. Otherwise, return false.</p>\r\n\r\n<p><strong>Note</strong>: The way that the robot is &quot;facing&quot; is irrelevant. &quot;R&quot; will always make the robot move to the right once, &quot;L&quot; will always make it move left, etc. Also, assume that the magnitude of the robot&#39;s movement is the same for each move.</p>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> &quot;UD&quot;\r\n<b>Output:</b> true \r\n<strong>Explanation</strong>: The robot moves up once, and then down once. All moves have the same magnitude, so it ended up at the origin where it started. Therefore, we return true.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> &quot;LL&quot;\r\n<b>Output:</b> false\r\n<strong>Explanation</strong>: The robot moves left twice. It ends up two &quot;moves&quot; to the left of the origin. We return false because it is not at the origin at the end of its moves.\r\n</pre>\r\n",
    "tags": "String",
    "difficulty": 1,
    "frontend_article_id": 657,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-simulation-accepted\">Approach #1: Simulation [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-simulation-accepted\">Approach #1: Simulation [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>We can simulate the position of the robot after each command.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Initially, the robot is at <code>(x, y) = (0, 0)</code>. If the move is <code>'U'</code>, the robot goes to <code>(x, y-1)</code>; if the move is <code>'R'</code>, the robot goes to <code>(x, y) = (x+1, y)</code>, and so on.</p> \n  <iframe src=\"https://leetcode.com/playground/9w36FnNS/shared\" frameborder=\"0\" width=\"100%\" height=\"259\" name=\"9w36FnNS\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>moves</code>. We iterate through the string.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>. In Java, our character array is <script type=\"math/tex; mode=display\">O(N)</script>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 656,
    "article_live": true,
    "article_slug": "coin-path",
    "title": "Coin Path",
    "title_slug": "coin-path",
    "tags": "Dynamic Programming",
    "difficulty": 3,
    "frontend_article_id": 656,
    "article_content": ""
},
{
    "frontend_question_id": 655,
    "article_live": true,
    "article_slug": "print-binary-tree",
    "title": "Print Binary Tree",
    "title_slug": "print-binary-tree",
    "content": "<p>Print a binary tree in an m*n 2D string array following these rules: </p>\r\n\r\n<ol>\r\n<li>The row number <code>m</code> should be equal to the height of the given binary tree.</li>\r\n<li>The column number <code>n</code> should always be an odd number.</li>\r\n<li>The root node's value (in string format) should be put in the exactly middle of the first row it can be put. The column and the row where the root node belongs will separate the rest space into two parts (<b>left-bottom part and right-bottom part</b>). You should print the left subtree in the left-bottom part and print the right subtree in the right-bottom part. The left-bottom part and the right-bottom part should have the same size. Even if one subtree is none while the other is not, you don't need to print anything for the none subtree but still need to leave the space as large as that for the other subtree. However, if two subtrees are none, then you don't need to leave space for both of them. </li>\r\n<li>Each unused space should contain an empty string <code>\"\"</code>.</li>\r\n<li>Print the subtrees following the same rules.</li>\r\n</ol>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b>\r\n     1\r\n    /\r\n   2\r\n<b>Output:</b>\r\n[[\"\", \"1\", \"\"],\r\n [\"2\", \"\", \"\"]]\r\n</pre>\r\n</p>\r\n\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b>\r\n     1\r\n    / \\\r\n   2   3\r\n    \\\r\n     4\r\n<b>Output:</b>\r\n[[\"\", \"\", \"\", \"1\", \"\", \"\", \"\"],\r\n [\"\", \"2\", \"\", \"\", \"\", \"3\", \"\"],\r\n [\"\", \"\", \"4\", \"\", \"\", \"\", \"\"]]\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 3:</b><br />\r\n<pre>\r\n<b>Input:</b>\r\n      1\r\n     / \\\r\n    2   5\r\n   / \r\n  3 \r\n / \r\n4 \r\n<b>Output:</b>\r\n\r\n[[\"\",  \"\",  \"\", \"\",  \"\", \"\", \"\", \"1\", \"\",  \"\",  \"\",  \"\",  \"\", \"\", \"\"]\r\n [\"\",  \"\",  \"\", \"2\", \"\", \"\", \"\", \"\",  \"\",  \"\",  \"\",  \"5\", \"\", \"\", \"\"]\r\n [\"\",  \"3\", \"\", \"\",  \"\", \"\", \"\", \"\",  \"\",  \"\",  \"\",  \"\",  \"\", \"\", \"\"]\r\n [\"4\", \"\",  \"\", \"\",  \"\", \"\", \"\", \"\",  \"\",  \"\",  \"\",  \"\",  \"\", \"\", \"\"]]\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\nThe height of binary tree is in the range of [1, 10].\r\n</p>",
    "tags": "Tree",
    "difficulty": 2,
    "frontend_article_id": 655,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-recursive-solutionaccepted\">Approach #1 Recursive Solution[Accepted]</a></li> \n      <li><a href=\"#approach-2-using-queuebfsaccepted\">Approach #2 Using queue(BFS)[Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-recursive-solutionaccepted\">Approach #1 Recursive Solution[Accepted]</h4> \n  <p>We start by initializing a <script type=\"math/tex; mode=display\">res</script> array with the dimensions being <script type=\"math/tex; mode=display\">height</script>x<script type=\"math/tex; mode=display\">2^{height}-1</script>. Here, <script type=\"math/tex; mode=display\">height</script> refers to the number of levels in the given tree. In order to fill this <script type=\"math/tex; mode=display\">res</script> array with the required elements, initially, we fill the complete array with <code>\"\"</code> . After this we make use of a recursive function <code>fill(res, root, i, l, r)</code> which fills the <script type=\"math/tex; mode=display\">res</script> array such that the current element has to be filled in <script type=\"math/tex; mode=display\">i^{th}</script> row, and the column being the middle of the indices <script type=\"math/tex; mode=display\">l</script> and <script type=\"math/tex; mode=display\">r</script>, where <script type=\"math/tex; mode=display\">l</script> and <script type=\"math/tex; mode=display\">r</script> refer to the left and the right boundaries of the columns in which the current element can be filled.</p> \n  <p>In every recursive call, we do as follows:</p> \n  <ol> \n   <li> <p>If we've reached the end of the tree, i.e. if root==null, return.</p> </li> \n   <li> <p>Determine the column in which the current element(<script type=\"math/tex; mode=display\">root</script>) needs to be filled, which is the middle of <script type=\"math/tex; mode=display\">l</script> and <script type=\"math/tex; mode=display\">r</script>, given by say, <script type=\"math/tex; mode=display\">j</script>. The row number is same as <script type=\"math/tex; mode=display\">i</script>. Put the current element at <script type=\"math/tex; mode=display\">res[i][j]</script>.</p> </li> \n   <li> <p>Make the recursive call for the left child of the <script type=\"math/tex; mode=display\">root</script> using <code>fill(res, root.left, i + 1, l, (l + r) / 2)</code>.</p> </li> \n   <li> <p>Make the recursive call for the right child of the <script type=\"math/tex; mode=display\">root</script> using <code>fill(res, root.right, i + 1, (l + r + 1) / 2, r)</code>.</p> </li> \n  </ol> \n  <p>Note, that in the last two recursive calls, we update the row number(level of the tree). This ensures that the child nodes fit into the correct row. We also update the column boundaries appropriately based on the <script type=\"math/tex; mode=display\">l</script> and <script type=\"math/tex; mode=display\">r</script> values.</p> \n  <p>Further, to determine the <script type=\"math/tex; mode=display\">height</script> also, we make use of recursive funtion <code>getHeight(root)</code>, which returns the height of the tree starting from the <script type=\"math/tex; mode=display\">root</script> node. We traverse into all the branches possible in the tree recursively and find the depth of the longest branch.</p> \n  <p>At the end, we convert the <script type=\"math/tex; mode=display\">res</script> array into the required list format, before returning the results.</p> \n  <iframe src=\"https://leetcode.com/playground/ncTFx4nd/shared\" frameborder=\"0\" name=\"ncTFx4nd\" width=\"100%\" height=\"479\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(h*2^h)</script>. We need to fill the <script type=\"math/tex; mode=display\">res</script> array of size <script type=\"math/tex; mode=display\">h</script>x<script type=\"math/tex; mode=display\">2^h - 1</script>. Here, <script type=\"math/tex; mode=display\">h</script> refers to the height of the given tree.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(h*2^h)</script>. <script type=\"math/tex; mode=display\">res</script> array of size <script type=\"math/tex; mode=display\">h</script>x<script type=\"math/tex; mode=display\">2^h - 1</script> is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-using-queuebfsaccepted\">Approach #2 Using queue(BFS)[Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>We can also solve the problem by making use of Breadth First Search's idea. For this, we make use of a class <script type=\"math/tex; mode=display\">Params</script> which stores the parameters of a <script type=\"math/tex; mode=display\">node</script> of the tree, including its value, its level in the tree(<script type=\"math/tex; mode=display\">i</script>), and the left(<script type=\"math/tex; mode=display\">l</script>) and right(<script type=\"math/tex; mode=display\">r</script>) boundaries of the columns in which this element can be filled in the result to be returned.</p> \n  <p>We start by initializing a <script type=\"math/tex; mode=display\">res</script> array as in the previous approach. After this, we add the parametrized <script type=\"math/tex; mode=display\">root</script> of the tree into a <script type=\"math/tex; mode=display\">queue</script>. After this, we do the following at every step.</p> \n  <ol> \n   <li> <p>Remove an element, $$p$, from the front of the <script type=\"math/tex; mode=display\">queue</script>. </p> </li> \n   <li> <p>Add this element at its correct position in the <script type=\"math/tex; mode=display\">res</script> array given by <script type=\"math/tex; mode=display\">res[p.i][(p.l + p.r) / 2]</script>. Here, the values <script type=\"math/tex; mode=display\">i</script>, <script type=\"math/tex; mode=display\">l</script> and <script type=\"math/tex; mode=display\">r</script> refer to the column/level number, and the left and right boundaries permissible for putting the current node into <script type=\"math/tex; mode=display\">res</script>. These are obtained from the node's parameters, which have been associated with it before putting it into the <script type=\"math/tex; mode=display\">queue</script>.</p> </li> \n   <li> <p>If the left child of <script type=\"math/tex; mode=display\">p</script> exists, put it at the back of the <script type=\"math/tex; mode=display\">queue</script>, in a parametized form, by appropriately updating the level as the next level and the boundaries permissible as well.</p> </li> \n   <li> <p>If the right child of <script type=\"math/tex; mode=display\">p</script> exists, put it at the back of the <script type=\"math/tex; mode=display\">queue</script>, in a parametized form, by appropriately updating the level as the next level and the boundaries permissible as well.</p> </li> \n   <li> <p>Continue steps 1. to 4. till the <script type=\"math/tex; mode=display\">queue</script> becomes empty. </p> </li> \n  </ol> \n  <p>At the end, we again convert the <script type=\"math/tex; mode=display\">res</script> array into the required list format, before returning the results.</p> \n  <iframe src=\"https://leetcode.com/playground/jb3EALV4/shared\" frameborder=\"0\" name=\"jb3EALV4\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(h*2^h)</script>. We need to fill the <script type=\"math/tex; mode=display\">res</script> array of size <script type=\"math/tex; mode=display\">h</script>x<script type=\"math/tex; mode=display\">2^h - 1</script>. Here, <script type=\"math/tex; mode=display\">h</script> refers to the height of the given tree.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(h*2^h)</script>. <script type=\"math/tex; mode=display\">res</script> array of size <script type=\"math/tex; mode=display\">h</script>x<script type=\"math/tex; mode=display\">2^h - 1</script> is used.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 654,
    "article_live": true,
    "article_slug": "maximum-binary-tree",
    "title": "Maximum Binary Tree",
    "title_slug": "maximum-binary-tree",
    "content": "<p>\r\nGiven an integer array with no duplicates. A maximum tree building on this array is defined as follow:\r\n<ol>\r\n<li>The root is the maximum number in the array. </li>\r\n<li>The left subtree is the maximum tree constructed from left part subarray divided by the maximum number.</li>\r\n<li>The right subtree is the maximum tree constructed from right part subarray divided by the maximum number.</li> \r\n</ol>\r\n</p>\r\n\r\n<p>\r\nConstruct the maximum tree by the given array and output the root node of this tree.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [3,2,1,6,0,5]\r\n<b>Output:</b> return the tree root node representing the following tree:\r\n\r\n      6\r\n    /   \\\r\n   3     5\r\n    \\    / \r\n     2  0   \r\n       \\\r\n        1\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The size of the given array will be in the range [1,1000].</li>\r\n</ol>\r\n</p>",
    "tags": "Tree",
    "difficulty": 2,
    "frontend_article_id": 654,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-recursive-solutionaccepted\">Approach #1 Recursive Solution[Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-recursive-solutionaccepted\">Approach #1 Recursive Solution[Accepted]</h4> \n  <p>The current solution is very simple. We make use of a function <code>construct(nums, l, r)</code>, which returns the maximum binary tree consisting of numbers within the indices <script type=\"math/tex; mode=display\">l</script> and <script type=\"math/tex; mode=display\">r</script> in the given <script type=\"math/tex; mode=display\">nums</script> array(excluding the <script type=\"math/tex; mode=display\">r^{th}</script> element).</p> \n  <p>The algorithm consists of the following steps:</p> \n  <ol> \n   <li> <p>Start with the function call <code>construct(nums, 0, n)</code>. Here, <script type=\"math/tex; mode=display\">n</script> refers to the number of elements in the given <script type=\"math/tex; mode=display\">nums</script> array.</p> </li> \n   <li> <p>Find the index, <script type=\"math/tex; mode=display\">max_i</script>, of the largest element in the current range of indices <script type=\"math/tex; mode=display\">(l:r-1)</script>. Make this largest element, $<script type=\"math/tex; mode=display\">nums[max_i]</script> as the local root node.</p> </li> \n   <li> <p>Determine the left child using <code>construct(nums, l, max_i)</code>. Doing this recursively finds the largest element in the subarray left to the current largest element.</p> </li> \n   <li> <p>Similarly, determine the right child using <code>construct(nums, max_i + 1, r)</code>.</p> </li> \n   <li> <p>Return the root node to the calling function.</p> </li> \n  </ol> \n  <iframe src=\"https://leetcode.com/playground/j4QpdWko/shared\" frameborder=\"0\" name=\"j4QpdWko\" width=\"100%\" height=\"428\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^2)</script>. The function <code>construct</code> is called <script type=\"math/tex; mode=display\">n</script> times. At each level of the recursive tree, we traverse over all the <script type=\"math/tex; mode=display\">n</script> elements to find the maximum element. In the average case, there will be a <script type=\"math/tex; mode=display\">log(n)</script> levels leading to a complexity of <script type=\"math/tex; mode=display\">O\\big(nlog(n)\\big)</script>. In the worst case, the depth of the recursive tree can grow upto <script type=\"math/tex; mode=display\">n</script>, which happens in the case of a sorted <script type=\"math/tex; mode=display\">nums</script> array, giving a complexity of <script type=\"math/tex; mode=display\">O(n^2)</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The size of the <script type=\"math/tex; mode=display\">set</script> can grow upto <script type=\"math/tex; mode=display\">n</script> in the worst case. In the average case, the size will be <script type=\"math/tex; mode=display\">log(n)</script> for <script type=\"math/tex; mode=display\">n</script> elements in <script type=\"math/tex; mode=display\">nums</script>, giving an average case complexity of <script type=\"math/tex; mode=display\">O(log(n))</script> </p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 653,
    "article_live": true,
    "article_slug": "two-sum-iv",
    "title": "Two Sum IV - Input is a BST",
    "title_slug": "two-sum-iv-input-is-a-bst",
    "content": "<p>Given a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\n    5\r\n   / \\\r\n  3   6\r\n / \\   \\\r\n2   4   7\r\n\r\nTarget = 9\r\n\r\n<b>Output:</b> True\r\n</pre>\r\n</p>\r\n\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\n    5\r\n   / \\\r\n  3   6\r\n / \\   \\\r\n2   4   7\r\n\r\nTarget = 28\r\n\r\n<b>Output:</b> False\r\n</pre>\r\n</p>\r\n\r\n",
    "tags": "Tree",
    "difficulty": 1,
    "frontend_article_id": 653,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-using-hashsetaccepted\">Approach #1 Using HashSet[Accepted]</a></li> \n      <li><a href=\"#approach-2-using-bfs-and-hashset-accepted\">Approach #2 Using BFS and HashSet [Accepted]</a></li> \n      <li><a href=\"#approach-3-using-bst-accepted\">Approach #3 Using BST [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-using-hashsetaccepted\">Approach #1 Using HashSet[Accepted]</h4> \n  <p>The simplest solution will be to traverse over the whole tree and consider every possible pair of nodes to determine if they can form the required sum <script type=\"math/tex; mode=display\">k</script>. But, we can improve the process if we look at a little catch here.</p> \n  <p>If the sum of two elements <script type=\"math/tex; mode=display\">x + y</script> equals <script type=\"math/tex; mode=display\">k</script>, and we already know that <script type=\"math/tex; mode=display\">x</script> exists in the given tree, we only need to check if an element <script type=\"math/tex; mode=display\">y</script> exists in the given tree, such that <script type=\"math/tex; mode=display\">y = k - x</script>. Based on this simple catch, we can traverse the tree in both the directions(left child and right child) at every step. We keep a track of the elements which have been found so far during the tree traversal, by putting them into a <script type=\"math/tex; mode=display\">set</script>. </p> \n  <p>For every current node with a value of <script type=\"math/tex; mode=display\">p</script>, we check if <script type=\"math/tex; mode=display\">k-p</script> already exists in the array. If so, we can conclude that the sum <script type=\"math/tex; mode=display\">k</script> can be formed by using the two elements from the given tree. Otherwise, we put this value <script type=\"math/tex; mode=display\">p</script> into the <script type=\"math/tex; mode=display\">set</script>.</p> \n  <p>If even after the whole tree's traversal, no such element <script type=\"math/tex; mode=display\">p</script> can be found, the sum <script type=\"math/tex; mode=display\">k</script> can't be formed by using any two elements.</p> \n  <iframe src=\"https://leetcode.com/playground/NwhifNbv/shared\" frameborder=\"0\" name=\"NwhifNbv\" width=\"100%\" height=\"309\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The entire tree is traversed only once in the worst case. Here, <script type=\"math/tex; mode=display\">n</script> refers to the number of nodes in the given tree.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The size of the <script type=\"math/tex; mode=display\">set</script> can grow upto <script type=\"math/tex; mode=display\">n</script> in the worst case.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-using-bfs-and-hashset-accepted\">Approach #2 Using BFS and HashSet [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In this approach, the idea of using the <script type=\"math/tex; mode=display\">set</script> is the same as in the last approach. But, we can carry on the traversal in a Breadth First Search manner, which is a very common traversal method used in Trees. The way BFS is used can be summarized as given below. We start by putting the root node into a <script type=\"math/tex; mode=display\">queue</script>. We also maintain a <script type=\"math/tex; mode=display\">set</script> similar to the last approach. Then, at every step, we do as follows:</p> \n  <ol> \n   <li> <p>Remove an element, <script type=\"math/tex; mode=display\">p</script>, from the front of the <script type=\"math/tex; mode=display\">queue</script>. </p> </li> \n   <li> <p>Check if the element <script type=\"math/tex; mode=display\">k-p</script> already exists in the <script type=\"math/tex; mode=display\">set</script>. If so, return True.</p> </li> \n   <li> <p>Otherwise, add this element, <script type=\"math/tex; mode=display\">p</script> to the <script type=\"math/tex; mode=display\">set</script>. Further, add the right and the left child nodes of the current node to the back of the <script type=\"math/tex; mode=display\">queue</script>.</p> </li> \n   <li> <p>Continue steps 1. to 3. till the <script type=\"math/tex; mode=display\">queue</script> becomes empty. </p> </li> \n   <li> <p>Return false if the <script type=\"math/tex; mode=display\">queue</script> becomes empty.</p> </li> \n  </ol> \n  <p>By following this process, we traverse the tree on a level by level basis. </p> \n  <iframe src=\"https://leetcode.com/playground/7SgfKz2F/shared\" frameborder=\"0\" name=\"7SgfKz2F\" width=\"100%\" height=\"377\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. We need to traverse over the whole tree once in the worst case. Here, <script type=\"math/tex; mode=display\">n</script> refers to the number of nodes in the given tree.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The size of the <script type=\"math/tex; mode=display\">set</script> can grow atmost upto <script type=\"math/tex; mode=display\">n</script>. </p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-using-bst-accepted\">Approach #3 Using BST [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In this approach, we make use of the fact that the given tree is a Binary Search Tree. Now, we know that the inorder traversal of a BST gives the nodes in ascending order. Thus, we do the inorder traversal of the given tree and put the results in a <script type=\"math/tex; mode=display\">list</script> which contains the nodes sorted in ascending order.</p> \n  <p>Once this is done, we make use of two pointers <script type=\"math/tex; mode=display\">l</script> and <script type=\"math/tex; mode=display\">r</script> pointing to the beginning and the end of the sorted <script type=\"math/tex; mode=display\">list</script>. Then, we do as follows:</p> \n  <ol> \n   <li> <p>Check if the sum of the elements pointed by <script type=\"math/tex; mode=display\">l</script> and <script type=\"math/tex; mode=display\">r</script> is equal to the required sum <script type=\"math/tex; mode=display\">k</script>. If so, return a True immediately.</p> </li> \n   <li> <p>Otherwise, if the sum of the current two elements is lesser than the required sum <script type=\"math/tex; mode=display\">k</script>, update <script type=\"math/tex; mode=display\">l</script> to point to the next element. This is done, because, we need to increase the sum of the current elements, which can only be done by increasing the smaller number.</p> </li> \n   <li> <p>Otherwise, if the sum of the current two elements is larger than the required sum <script type=\"math/tex; mode=display\">k</script>, update <script type=\"math/tex; mode=display\">r</script> to point to the previous element. This is done, because, we need to decrease the sum of the current elements, which can only be done by reducing the larger number. </p> </li> \n   <li> <p>Continue steps 1. to 3. till the left pointer <script type=\"math/tex; mode=display\">l</script> crosses the right pointer <script type=\"math/tex; mode=display\">r</script>.</p> </li> \n   <li> <p>If the two pointers cross each other, return a False value.</p> </li> \n  </ol> \n  <p>Note that we need not increase the larger number or reduce the smaller number in any case. This happens because, in case, a number larger than the current <script type=\"math/tex; mode=display\">list[r]</script> is needed to form the required sum <script type=\"math/tex; mode=display\">k</script>, the right pointer could not have been reduced in the first place. The similar argument holds true for not reducing the smaller number as well.</p> \n  <iframe src=\"https://leetcode.com/playground/chZDDTAy/shared\" frameborder=\"0\" name=\"chZDDTAy\" width=\"100%\" height=\"462\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. We need to traverse over the whole tree once to do the inorder traversal. Here, <script type=\"math/tex; mode=display\">n</script> refers to the number of nodes in the given tree.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The sorted <script type=\"math/tex; mode=display\">list</script> will contain <script type=\"math/tex; mode=display\">n</script> elements.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 652,
    "article_live": true,
    "article_slug": "find-duplicate-subtrees",
    "title": "Find Duplicate Subtrees",
    "title_slug": "find-duplicate-subtrees",
    "content": "<p>Given a binary tree, return all duplicate subtrees. For each kind of duplicate subtrees, you only need to return the root node of any <b>one</b> of them.</p>\r\n\r\n<p>Two trees are duplicate if they have the same structure with same node values.</p>\r\n\r\n<p><b>Example 1: </b></p>\r\n\r\n<pre>\r\n        1\r\n       / \\\r\n      2   3\r\n     /   / \\\r\n    4   2   4\r\n       /\r\n      4\r\n</pre>\r\n\r\n<p>The following are two duplicate subtrees:</p>\r\n\r\n<pre>\r\n      2\r\n     /\r\n    4\r\n</pre>\r\n\r\n<p>and</p>\r\n\r\n<pre>\r\n    4\r\n</pre>\r\nTherefore, you need to return above trees&#39; root in the form of a list.",
    "tags": "Tree",
    "difficulty": 2,
    "frontend_article_id": 652,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-depth-first-search-accepted\">Approach #1: Depth-First Search [Accepted]</a></li> \n    <li><a href=\"#approach-2-unique-identifier-accepted\">Approach #2: Unique Identifier [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-depth-first-search-accepted\">Approach #1: Depth-First Search [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>We can serialize each subtree. For example, the tree</p> \n  <div class=\"codehilite\">\n   <pre><span></span>   <span class=\"mi\">1</span>\n  <span class=\"o\">/</span> \\\n <span class=\"mi\">2</span>   <span class=\"mi\">3</span>\n    <span class=\"o\">/</span> \\\n   <span class=\"mi\">4</span>   <span class=\"mi\">5</span>\n</pre>\n  </div> \n  <p>can be represented as the serialization <code>1,2,#,#,3,4,#,#,5,#,#</code>, which is a unique representation of the tree.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Perform a depth-first search, where the recursive function returns the serialization of the tree. At each node, record the result in a map, and analyze the map after to determine duplicate subtrees.</p> \n  <iframe src=\"https://leetcode.com/playground/4UyWd7Zu/shared\" frameborder=\"0\" width=\"100%\" height=\"378\" name=\"4UyWd7Zu\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of nodes in the tree. We visit each node once, but each creation of <code>serial</code> may take <script type=\"math/tex; mode=display\">O(N)</script> work.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>, the size of <code>count</code>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-unique-identifier-accepted\">Approach #2: Unique Identifier [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Suppose we have a unique identifier for subtrees: two subtrees are the same if and only if they have the same id.</p> \n  <p>Then, for a node with left child id of <code>x</code> and right child id of <code>y</code>, <code>(node.val, x, y)</code> uniquely determines the tree.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>If we have seen the triple <code>(node.val, x, y)</code> before, we can use the identifier we've remembered. Otherwise, we'll create a new one.</p> \n  <iframe src=\"https://leetcode.com/playground/sgdon7Zu/shared\" frameborder=\"0\" width=\"100%\" height=\"480\" name=\"sgdon7Zu\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of nodes in the tree. We visit each node once.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. Every structure we use is using <script type=\"math/tex; mode=display\">O(1)</script> storage per node.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>. Approach #2 inspired by <a href=\"https://discuss.leetcode.com/topic/97625/o-n-time-and-space-lots-of-analysis\">@StefanPochmann</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 651,
    "article_live": true,
    "article_slug": "4-keys-keyboard",
    "title": "4 Keys Keyboard",
    "title_slug": "4-keys-keyboard",
    "tags": "Math, Dynamic Programming, Greedy",
    "difficulty": 2,
    "frontend_article_id": 651,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-framework\">Approach Framework</a></li> \n    <li><a href=\"#approach-1-dynamic-programming-accepted\">Approach #1: Dynamic Programming [Accepted]</a></li> \n    <li><a href=\"#approach-2-optimized-dynamic-programming-accepted\">Approach #2: Optimized Dynamic Programming [Accepted]</a></li> \n    <li><a href=\"#approach-3-mathematical-accepted\">Approach #3: Mathematical [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-framework\">Approach Framework</h4> \n  <p><strong>Explanation</strong></p> \n  <p>We either press 'A', or press 'CTRL+A', 'CTRL+C', and some number of 'CTRL+V's. Thus, in the context of making <code>N</code> keypresses to write the letter 'A' <code>M</code> times, there are only two types of moves:</p> \n  <ul> \n   <li>Add (<code>1</code> keypress): Add <code>1</code> to <code>M</code>.</li> \n   <li>Multiply (<code>k+1</code> keypresses): Multiply <code>M</code> by <code>k</code>, where <code>k &gt;= 2</code>.</li> \n  </ul> \n  <p>In the following explanations, we will reference these as moves.</p> \n  <hr> \n  <h4 id=\"approach-1-dynamic-programming-accepted\">Approach #1: Dynamic Programming [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Say <code>best[k]</code> is the largest number of written 'A's possible after <code>k</code> keypresses.</p> \n  <p>If the last move in some optimal solution of <code>k</code> keypresses was adding, then <code>best[k] = best[k-1] + 1</code>.</p> \n  <p>Otherwise, if the last move was multiplying, then we multiplied by <code>x</code>, and <code>best[k-(x+1)] = best[k-(x+1)] * x</code> for some <code>x &lt; k-1</code>.</p> \n  <p>Taking the best of these candidates lets us find <code>best[k]</code> in terms of previous <code>best[j]</code>, when <code>j &lt; k</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/SGFr27fh/shared\" frameborder=\"0\" width=\"100%\" height=\"242\" name=\"SGFr27fh\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script>. We have two nested for-loops, each of which do <script type=\"math/tex; mode=display\">O(N)</script> work.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the size of <code>best</code>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-optimized-dynamic-programming-accepted\">Approach #2: Optimized Dynamic Programming [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>If we multiply by <code>2N</code>, paying a cost of <code>2N+1</code>, we could instead multiply by <code>N</code> then <code>2</code>, paying <code>N+4</code>. When <code>N &gt;= 3</code>, we don't pay more by doing it the second way.</p> \n  <p>Similarly, if we are to multiply by <code>2N+1</code> paying <code>2N+2</code>, we could instead multiply by <code>N+1</code> then <code>2</code>, paying <code>N+5</code>. Again, when <code>N &gt;= 3</code>, we don't pay more doing it the second way.</p> \n  <p>Thus, we never multiply by more than <code>5</code>.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Our approach is the same as <em>Approach #1</em>, except we do not consider multiplying by more than 5 in our inner loop. For brevity, we have omitted this solution.</p> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. We have two nested for-loops, but the inner loop does <script type=\"math/tex; mode=display\">O(1)</script> work.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the size of <code>best</code>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-mathematical-accepted\">Approach #3: Mathematical [Accepted]</h4> \n  <p><strong>Explanation</strong></p> \n  <p>As in <em>Approach #2</em>, we never multiply by more than 5.</p> \n  <p>When <code>N</code> is arbitrarily large, the long run behavior of multiplying by <code>k</code> repeatedly is to get to the value <script type=\"math/tex; mode=display\">k^{\\frac{N}{k+1}}</script>. Analyzing the function <script type=\"math/tex; mode=display\">k^{\\frac{1}{k+1}}</script> at values <script type=\"math/tex; mode=display\">k = 2, 3, 4, 5</script>, it attains a peak at <script type=\"math/tex; mode=display\">k = 4</script>. Thus, we should expect that <em>eventually</em>, <code>best[K] = best[K-5] * 4</code>.</p> \n  <p>Now, we need to make a few more deductions.</p> \n  <ul> \n   <li> <p>We never add after multiplying: if we add <code>c</code> after multiplying by <code>k</code>, we should instead multiply by <code>k+c</code>.</p> </li> \n   <li> <p>We never add after 5: If we add <code>1</code> then multiply by <code>k</code> to get to <code>(x+1) * k = xk + k</code>, we could instead multiply by <code>k+1</code> to get to <code>xk + x</code>. Since <code>k &lt;= 5</code>, we must have <code>x &lt;= 5</code> for our additions to not be dominated.</p> </li> \n   <li> <p>The number of multiplications by 2, 3, or 5 is bounded.</p> </li> \n   <li> <p>Every time we've multiplied by 2 two times, we prefer to multiply by 4 once for less cost. (4^1 for a cost of 5, vs 2^2 for a cost of 6.)</p> </li> \n   <li>Every time we've multiplied by 3 five times, we prefer to multiply by 4 four times for the same cost but a larger result. (4^4 &gt; 3^5, and cost is 20.)</li> \n   <li>Every time we've multiplied by 5 five times, we prefer to multiply by 4 six times for the same cost but a larger result. (4^6 &gt; 5^5, and cost is 30.)</li> \n  </ul> \n  <p>Together, this shows there are at most 5 additions and 9 multiplications by a number that isn't 4.</p> \n  <p>We can find the first 14 operations on 1 by hand: <code>1, 2, 3, 4, 5, 6, 9, 12, 16, 20, 27, 36, 48, 64, 81</code>. After that, every subsequent number is achieved by multiplying by 4: ie., <code>best[K] = best[K-5] * 4</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/Pe7Dpj2G/shared\" frameborder=\"0\" width=\"100%\" height=\"191\" name=\"Pe7Dpj2G\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time and Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>.</li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 650,
    "article_live": true,
    "article_slug": "2-keys-keyboard",
    "title": "2 Keys Keyboard",
    "title_slug": "2-keys-keyboard",
    "content": "<p>\r\nInitially on a notepad only one character 'A' is present. You can perform two operations on this notepad for each step: \r\n<ol>\r\n<li><code>Copy All</code>: You can copy all the characters present on the notepad (partial copy is not allowed).</li>\r\n<li><code>Paste</code>: You can paste the characters which are copied <b>last time</b>.</li>\r\n</ol>\r\n</p>\r\n\r\n<p>\r\nGiven a number <code>n</code>. You have to get <b>exactly</b> <code>n</code> 'A' on the notepad by performing the minimum number of steps permitted. Output the minimum number of steps to get <code>n</code> 'A'. \r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> 3\r\n<b>Output:</b> 3\r\n<b>Explanation:</b>\r\nIntitally, we have one character 'A'.\r\nIn step 1, we use <b>Copy All</b> operation.\r\nIn step 2, we use <b>Paste</b> operation to get 'AA'.\r\nIn step 3, we use <b>Paste</b> operation to get 'AAA'.\r\n</pre>\r\n</p>\r\n\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The <code>n</code> will be in the range [1, 1000].</li>\r\n</ol>\r\n</p>",
    "tags": "Dynamic Programming",
    "difficulty": 2,
    "frontend_article_id": 650,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-prime-factorization-accepted\">Approach #1: Prime Factorization [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-prime-factorization-accepted\">Approach #1: Prime Factorization [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>We can break our moves into groups of <code>(copy, paste, ..., paste)</code>. Let <code>C</code> denote copying and <code>P</code> denote pasting. Then for example, in the sequence of moves <code>CPPCPPPPCP</code>, the groups would be <code>[CPP][CPPPP][CP]</code>.</p> \n  <p>Say these groups have lengths <code>g_1, g_2, ...</code>. After parsing the first group, there are <code>g_1</code> <code>'A'</code>s. After parsing the second group, there are <code>g_1 * g_2</code> <code>'A'</code>s, and so on. At the end, there are <code>g_1 * g_2 * ... * g_n</code> <code>'A'</code>s.</p> \n  <p>We want exactly <code>N = g_1 * g_2 * ... * g_n</code>. If any of the <code>g_i</code> are composite, say <code>g_i = p * q</code>, then we can split this group into two groups (the first of which has one copy followed by <code>p-1</code> pastes, while the second group having one copy and <code>q-1</code> pastes).</p> \n  <p>Such a split never uses more moves: we use <code>p+q</code> moves when splitting, and <code>pq</code> moves previously. As <code>p+q &lt;= pq</code> is equivalent to <code>1 &lt;= (p-1)(q-1)</code>, which is true as long as <code>p &gt;= 2</code> and <code>q &gt;= 2</code>.</p> \n  <p><strong>Algorithm</strong> By the above argument, we can suppose <code>g_1, g_2, ...</code> is the prime factorization of <code>N</code>, and the answer is therefore the sum of these prime factors.</p> \n  <iframe src=\"https://leetcode.com/playground/U88jzmPG/shared\" frameborder=\"0\" width=\"100%\" height=\"276\" name=\"U88jzmPG\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(\\sqrt{N})</script>. When <code>N</code> is the square of a prime, our loop does <script type=\"math/tex; mode=display\">O(\\sqrt{N})</script> steps.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>, the space used by <code>ans</code> and <code>d</code>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 649,
    "article_live": true,
    "article_slug": "dota2-senate",
    "title": "Dota2 Senate",
    "title_slug": "dota2-senate",
    "content": "<p>\r\nIn the world of Dota2, there are two parties: the <code>Radiant</code> and the <code>Dire</code>.\r\n</p>\r\n\r\n<p>\r\nThe Dota2 senate consists of senators coming from two parties. Now the senate wants to make a decision about a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise <code>one</code> of the two rights:\r\n<ol>\r\n<li><code>Ban one senator's right</code>: <br/>A senator can make another senator lose <b>all his rights</b> in this and all the following rounds.</li>\r\n<li><code>Announce the victory</code>: <br/>If this senator found the senators who still have rights to vote are all from <b>the same party</b>, he can announce the victory and make the decision about the change in the game.</li>\r\n</ol>\r\n</p>\r\n\r\n<p>\r\nGiven a string representing each senator's party belonging. The character 'R' and 'D' represent the <code>Radiant</code> party and the <code>Dire</code> party respectively. Then if there are <code>n</code> senators, the size of the given string will be <code>n</code>.\r\n</p>\r\n\r\n<p>\r\nThe round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure.\r\n</p>\r\n\r\n<p>\r\nSuppose every senator is smart enough and will play the best strategy for his own party, you need to predict which party will finally announce the victory and make the change in the Dota2 game. The output should be <code>Radiant</code> or <code>Dire</code>.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \"RD\"\r\n<b>Output:</b> \"Radiant\"\r\n<b>Explanation:</b> The first senator comes from Radiant and he can just ban the next senator's right in the round 1. <br/>And the second senator can't exercise any rights any more since his right has been banned. <br/>And in the round 2, the first senator can just announce the victory since he is the only guy in the senate who can vote.\r\n</pre>\r\n</p>\r\n\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> \"RDD\"\r\n<b>Output:</b> \"Dire\"\r\n<b>Explanation:</b> \r\nThe first senator comes from Radiant and he can just ban the next senator's right in the round 1. <br/>And the second senator can't exercise any rights anymore since his right has been banned. <br/>And the third senator comes from Dire and he can ban the first senator's right in the round 1. <br/>And in the round 2, the third senator can just announce the victory since he is the only guy in the senate who can vote.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The length of the given string will in the range [1, 10,000].</li>\r\n</ol>\r\n</p>",
    "tags": "Greedy",
    "difficulty": 2,
    "frontend_article_id": 649,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-simulation-accepted\">Approach #1: Simulation [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-simulation-accepted\">Approach #1: Simulation [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>A senator performing a ban doesn't need to use it on another senator immediately. We can wait to see when another team's senator will vote, then use that ban retroactively.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Put the senators in an integer queue: <code>1</code> for <code>'Radiant'</code> and <code>0</code> for <code>'Dire'</code>.</p> \n  <p>Now process the queue: if there is a floating ban for that senator, exercise it and continue. Otherwise, add a floating ban against the other team, and enqueue this senator again.</p> \n  <iframe src=\"https://leetcode.com/playground/zdvGbwLN/shared\" frameborder=\"0\" width=\"100%\" height=\"497\" name=\"zdvGbwLN\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script> where <script type=\"math/tex; mode=display\">N</script> is the size of the senate. Every vote removes one senator from the other team.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the space used by our queue.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 648,
    "article_live": true,
    "article_slug": "replace-words",
    "title": "Replace Words",
    "title_slug": "replace-words",
    "content": "<p>\r\nIn English, we have a concept called <code>root</code>, which can be followed by some other words to form another longer word - let's call this word <code>successor</code>. For example, the root <code>an</code>, followed by <code>other</code>, which can form another word <code>another</code>.\r\n</p>\r\n\r\n\r\n<p>\r\nNow, given a dictionary consisting of many roots and a sentence. You need to replace all the <code>successor</code> in the sentence with the <code>root</code> forming it. If a <code>successor</code> has many <code>roots</code> can form it, replace it with the root with the shortest length.\r\n</p>\r\n\r\n<p>\r\nYou need to output the sentence after the replacement.\r\n</p>\r\n\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> dict = [\"cat\", \"bat\", \"rat\"]\r\nsentence = \"the cattle was rattled by the battery\"\r\n<b>Output:</b> \"the cat was rat by the bat\"\r\n</pre>\r\n</p>\r\n\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The input will only have lower-case letters.</li>\r\n<li> 1 <= dict words number <= 1000 </li>\r\n<li> 1 <= sentence words number <= 1000  </li>\r\n<li> 1 <= root length <= 100 </li>\r\n<li> 1 <= sentence words length <= 1000 </li>\r\n</ol>\r\n</p>",
    "tags": "Hash Table, Trie",
    "difficulty": 2,
    "frontend_article_id": 648,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-prefix-hash-accepted\">Approach #1: Prefix Hash [Accepted]</a></li> \n    <li><a href=\"#approach-2-trie-accepted\">Approach #2: Trie [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-prefix-hash-accepted\">Approach #1: Prefix Hash [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>For each word in the sentence, we'll look at successive prefixes and see if we saw them before.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Store all the <code>roots</code> in a <em>Set</em> structure. Then for each word, look at successive prefixes of that word. If you find a prefix that is a root, replace the word with that prefix. Otherwise, the prefix will just be the word itself, and we should add that to the final sentence answer.</p> \n  <iframe src=\"https://leetcode.com/playground/tvjGGLzd/shared\" frameborder=\"0\" width=\"100%\" height=\"361\" name=\"tvjGGLzd\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(\\sum w_i^2)</script> where <script type=\"math/tex; mode=display\">w_i</script> is the length of the <script type=\"math/tex; mode=display\">i</script>-th word. We might check every prefix, the <script type=\"math/tex; mode=display\">i</script>-th of which is <script type=\"math/tex; mode=display\">O(w_i^2)</script> work.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script> where <script type=\"math/tex; mode=display\">N</script> is the length of our sentence; the space used by <code>rootset</code>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-trie-accepted\">Approach #2: Trie [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Put all the roots in a trie (prefix tree). Then for any query word, we can find the smallest root that was a prefix in linear time.</p> \n  <iframe src=\"https://leetcode.com/playground/5Dt2dcFU/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"5Dt2dcFU\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script> where <script type=\"math/tex; mode=display\">N</script> is the length of the <code>sentence</code>. Every query of a word is in linear time.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the size of our trie.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 647,
    "article_live": true,
    "article_slug": "palindromic-substrings",
    "title": "Palindromic Substrings",
    "title_slug": "palindromic-substrings",
    "content": "<p>\r\nGiven a string, your task is to count how many palindromic substrings in this string.\r\n</p>\r\n\r\n<p>\r\nThe substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters. \r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \"abc\"\r\n<b>Output:</b> 3\r\n<b>Explanation:</b> Three palindromic strings: \"a\", \"b\", \"c\".\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> \"aaa\"\r\n<b>Output:</b> 6\r\n<b>Explanation:</b> Six palindromic strings: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\".\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The input string length won't exceed 1000.</li>\r\n</ol>\r\n</p>",
    "tags": "String, Dynamic Programming",
    "difficulty": 2,
    "frontend_article_id": 647,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-expand-around-center-accepted\">Approach #1: Expand Around Center [Accepted]</a></li> \n    <li><a href=\"#approach-2-manachers-algorithm-accepted\">Approach #2: Manacher's Algorithm [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-expand-around-center-accepted\">Approach #1: Expand Around Center [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Let <code>N</code> be the length of the string. The middle of the palindrome could be in one of <code>2N - 1</code> positions: either at letter or between two letters.</p> \n  <p>For each center, let's count all the palindromes that have this center. Notice that if <code>[a, b]</code> is a palindromic interval (meaning <code>S[a], S[a+1], ..., S[b]</code> is a palindrome), then <code>[a+1, b-1]</code> is one too.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>For each possible palindrome center, let's expand our candidate palindrome on the interval <code>[left, right]</code> as long as we can. The condition for expanding is <code>left &gt;= 0 and right &lt; N and S[left] == S[right]</code>. That means we want to count a new palindrome <code>S[left], S[left+1], ..., S[right]</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/EEGE8AYR/shared\" frameborder=\"0\" width=\"100%\" height=\"310\" name=\"EEGE8AYR\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script> where <script type=\"math/tex; mode=display\">N</script> is the length of <code>S</code>. Each expansion might do <script type=\"math/tex; mode=display\">O(N)</script> work.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-manachers-algorithm-accepted\">Approach #2: Manacher's Algorithm [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Manacher's algorithm is a textbook algorithm that finds in linear time, the maximum size palindrome for any possible palindrome center. If we had such an algorithm, finding the answer is straightforward.</p> \n  <p>What follows is a discussion of why this algorithm works.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Our loop invariants will be that <code>center, right</code> is our knowledge of the palindrome with the largest right-most boundary with <code>center &lt; i</code>, centered at <code>center</code> with right-boundary <code>right</code>. Also, <code>i &gt; center</code>, and we've already computed all <code>Z[j]</code>'s for <code>j &lt; i</code>.</p> \n  <p>When <code>i &lt; right</code>, we reflect <code>i</code> about <code>center</code> to be at some coordinate <code>j = 2 * center - i</code>. Then, limited to the interval with radius <code>right - i</code> and center <code>i</code>, the situation for <code>Z[i]</code> is the same as for <code>Z[j]</code>.</p> \n  <p>For example, if at some time <code>center = 7, right = 13, i = 10</code>, then for a string like <code>A = '@#A#B#A#A#B#A#$'</code>, the <code>center</code> is at the <code>'#'</code> between the two middle <code>'A'</code>'s, the right boundary is at the last <code>'#'</code>, <code>i</code> is at the last <code>'B'</code>, and <code>j</code> is at the first <code>'B'</code>.</p> \n  <p>Notice that limited to the interval <code>[center - (right - center), right]</code> (the interval with center <code>center</code> and right-boundary <code>right</code>), the situation for <code>i</code> and <code>j</code> is a reflection of something we have already computed. Since we already know <code>Z[j] = 3</code>, we can quickly find <code>Z[i] = min(right - i, Z[j]) = 3</code>.</p> \n  <p>Now, why is this algorithm linear? The while loop only checks the condition more than once when <code>Z[i] = right - i</code>. In that case, for each time <code>Z[i] += 1</code>, it increments <code>right</code>, and <code>right</code> can only be incremented up to <code>2*N+2</code> times.</p> \n  <p>Finally, we sum up <code>(v+1) / 2</code> for each <code>v in Z</code>. Say the longest palindrome with some given center C has radius R. Then, the substring with center C and radius R-1, R-2, R-3, ..., 0 are also palindromes. Example: <code>abcdedcba</code> is a palindrome with center <code>e</code>, radius 4: but <code>e</code>, <code>ded</code>, <code>cdedc</code>, <code>bcdedcb</code>, and <code>abcdedcba</code> are all palindromes.</p> \n  <p>We are dividing by 2 because we were using half-lengths instead of lengths. For example we actually had the palindrome <code>a#b#c#d#e#d#c#b#a</code>, so our length is twice as big.</p> \n  <iframe src=\"https://leetcode.com/playground/ttFoRCjg/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"ttFoRCjg\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script> where <script type=\"math/tex; mode=display\">N</script> is the length of <code>S</code>. As discussed above, the complexity is linear.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the size of <code>A</code> and <code>Z</code>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 646,
    "article_live": true,
    "article_slug": "maximum-length-of-pair-chain",
    "title": "Maximum Length of Pair Chain",
    "title_slug": "maximum-length-of-pair-chain",
    "content": "<p>\r\nYou are given <code>n</code> pairs of numbers. In every pair, the first number is always smaller than the second number.\r\n</p>\r\n\r\n<p>\r\nNow, we define a pair <code>(c, d)</code> can follow another pair <code>(a, b)</code> if and only if <code>b < c</code>. Chain of pairs can be formed in this fashion. \r\n</p>\r\n\r\n<p>\r\nGiven a set of pairs, find the length longest chain which can be formed. You needn't use up all the given pairs. You can select pairs in any order.\r\n</p>\r\n\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [[1,2], [2,3], [3,4]]\r\n<b>Output:</b> 2\r\n<b>Explanation:</b> The longest chain is [1,2] -> [3,4]\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The number of given pairs will be in the range [1, 1000].</li>\r\n</ol>\r\n</p>",
    "tags": "Dynamic Programming",
    "difficulty": 2,
    "frontend_article_id": 646,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-dynamic-programming-accepted\">Approach #1: Dynamic Programming [Accepted]</a></li> \n    <li><a href=\"#approach-2-greedy-accepted\">Approach #2: Greedy [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-dynamic-programming-accepted\">Approach #1: Dynamic Programming [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>If a chain of length <code>k</code> ends at some <code>pairs[i]</code>, and <code>pairs[i][1] &lt; pairs[j][0]</code>, we can extend this chain to a chain of length <code>k+1</code>.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Sort the pairs by first coordinate, and let <code>dp[i]</code> be the length of the longest chain ending at <code>pairs[i]</code>. When <code>i &lt; j</code> and <code>pairs[i][1] &lt; pairs[j][0]</code>, we can extend the chain, and so we have the candidate answer <code>dp[j] = max(dp[j], dp[i] + 1)</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/5RAj49MD/shared\" frameborder=\"0\" width=\"100%\" height=\"378\" name=\"5RAj49MD\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N^2)</script> where <script type=\"math/tex; mode=display\">N</script> is the length of <code>pairs</code>. There are two for loops, and <script type=\"math/tex; mode=display\">N^2</script> dominates the sorting step.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script> for sorting and to store <code>dp</code>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-greedy-accepted\">Approach #2: Greedy [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>We can greedily add to our chain. Choosing the next addition to be the one with the lowest second coordinate is at least better than a choice with a larger second coordinate.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Consider the pairs in increasing order of their <em>second</em> coordinate. We'll try to add them to our chain. If we can, by the above argument we know that it is correct to do so.</p> \n  <iframe src=\"https://leetcode.com/playground/imd3oEYD/shared\" frameborder=\"0\" width=\"100%\" height=\"242\" name=\"imd3oEYD\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N \\log N)</script> where <script type=\"math/tex; mode=display\">N</script> is the length of <code>S</code>. The complexity comes from the sorting step, but the rest of the solution does linear work.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. The additional space complexity of storing <code>cur</code> and <code>ans</code>, but sorting uses <script type=\"math/tex; mode=display\">O(N)</script> space. Depending on the implementation of the language used, sorting can sometimes use less space.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 645,
    "article_live": true,
    "article_slug": "set-mismatch",
    "title": "Set Mismatch",
    "title_slug": "set-mismatch",
    "content": "<p>\r\nThe set <code>S</code> originally contains numbers from 1 to <code>n</code>. But unfortunately, due to the data error, one of the numbers in the set got duplicated to <b>another</b> number in the set, which results in repetition of one number and loss of another number. \r\n</p>\r\n\r\n<p>\r\nGiven an array <code>nums</code> representing the data status of this set after the error. Your task is to firstly find the number occurs twice and then find the number that is missing. Return them in the form of an array.\r\n</p>\r\n\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> nums = [1,2,2,4]\r\n<b>Output:</b> [2,3]\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The given array size will in the range [2, 10000].</li>\r\n<li>The given array's numbers won't have any order.</li>\r\n</ol>\r\n</p>",
    "tags": "Hash Table, Math",
    "difficulty": 1,
    "frontend_article_id": 645,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-better-brute-force-time-limit-exceeded\">Approach #2 Better Brute Force [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-3-using-sorting-accepted\">Approach #3 Using Sorting [Accepted]</a></li> \n      <li><a href=\"#approach-4-using-map-accepted\">Approach #4 Using map [Accepted]</a></li> \n      <li><a href=\"#approach-5-using-extra-arrayaccepted\">Approach #5 Using Extra Array[Accepted]:</a></li> \n      <li><a href=\"#approach-6-using-constant-spaceaccepted\">Approach #6 Using Constant Space[Accepted]:</a></li> \n      <li><a href=\"#approach-7-using-xor-accepted\">Approach #7 Using XOR [Accepted]:</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <h4 id=\"approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</h4> \n  <p>The most naive solution is to consider each number from <script type=\"math/tex; mode=display\">1</script> to <script type=\"math/tex; mode=display\">n</script>, and traverse over the whole <script type=\"math/tex; mode=display\">nums</script> array to check if the current number occurs twice in <script type=\"math/tex; mode=display\">nums</script> or doesn't occur at all. We need to set the duplicate number, <script type=\"math/tex; mode=display\">dup</script> and the missing number, <script type=\"math/tex; mode=display\">missing</script>, appropriately in such cases respectively.</p> \n  <iframe src=\"https://leetcode.com/playground/XmJ9Tdi2/shared\" frameborder=\"0\" name=\"XmJ9Tdi2\" width=\"100%\" height=\"343\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^2)</script>. We traverse over the <script type=\"math/tex; mode=display\">nums</script> array of size <script type=\"math/tex; mode=display\">n</script> for each of the numbers from <script type=\"math/tex; mode=display\">1</script> to <script type=\"math/tex; mode=display\">n</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant extra space is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-better-brute-force-time-limit-exceeded\">Approach #2 Better Brute Force [Time Limit Exceeded]</h4> \n  <p>In the last approach, we continued the search process, even when we've already found the duplicate and the missing number. But, as per the problem statement, we know that only one number will be repeated and only one number will be missing. Thus, we can optimize the last approach to some extent, by stopping the search process as soon as we find these two required numbers.</p> \n  <iframe src=\"https://leetcode.com/playground/XQ5or7QV/shared\" frameborder=\"0\" name=\"XQ5or7QV\" width=\"100%\" height=\"394\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^2)</script>. We traverse over the <script type=\"math/tex; mode=display\">nums</script> array of size <script type=\"math/tex; mode=display\">n</script> for each of the numbers from <script type=\"math/tex; mode=display\">1</script> to <script type=\"math/tex; mode=display\">n</script>, in the worst case.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant extra space is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-using-sorting-accepted\">Approach #3 Using Sorting [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>One way to further optimize the last approach is to sort the given <script type=\"math/tex; mode=display\">nums</script> array. This way, the numbers which are equal will always lie together. Further, we can easily identify the missing number by checking if every two consecutive elements in the sorted <script type=\"math/tex; mode=display\">nums</script> array are just one count apart or not.</p> \n  <iframe src=\"https://leetcode.com/playground/5WFPjrzW/shared\" frameborder=\"0\" name=\"5WFPjrzW\" width=\"100%\" height=\"292\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(nlogn)</script>. Sorting takes <script type=\"math/tex; mode=display\">O(nlogn)</script> time.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(logn)</script>. Sorting takes <script type=\"math/tex; mode=display\">O(logn)</script> space. </p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-4-using-map-accepted\">Approach #4 Using map [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>The given problem can also be solved easily if we can somehow keep a track of the number of times each element of the <script type=\"math/tex; mode=display\">nums</script> array occurs. One way to do so is to make an entry for each element of <script type=\"math/tex; mode=display\">nums</script> in a HashMap <script type=\"math/tex; mode=display\">map</script>. This <script type=\"math/tex; mode=display\">map</script> stores the entries in the form <script type=\"math/tex; mode=display\">(num_i, count_i)</script>. Here, <script type=\"math/tex; mode=display\">num</script> refers to the <script type=\"math/tex; mode=display\">i^{th}</script> element in <script type=\"math/tex; mode=display\">nums</script> and <script type=\"math/tex; mode=display\">count_i</script> refers to the number of times this element occurs in <script type=\"math/tex; mode=display\">nums</script>. Whenever, the same element occurs again, we can increment the count corresponding to the same. </p> \n  <p>After this, we can consider every number from <script type=\"math/tex; mode=display\">1</script> to <script type=\"math/tex; mode=display\">n</script>, and check for its presence in <script type=\"math/tex; mode=display\">map</script>. If it isn't present, we can update the <script type=\"math/tex; mode=display\">missing</script> variable appropriately. But, if the <script type=\"math/tex; mode=display\">count</script> corresponding to the current number is <script type=\"math/tex; mode=display\">2</script>, we can update the <script type=\"math/tex; mode=display\">dup</script> variable with the current number.</p> \n  <iframe src=\"https://leetcode.com/playground/NdSWUKGM/shared\" frameborder=\"0\" name=\"NdSWUKGM\" width=\"100%\" height=\"343\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Traversing over <script type=\"math/tex; mode=display\">nums</script> of size <script type=\"math/tex; mode=display\">n</script> takes <script type=\"math/tex; mode=display\">O(n)</script> time. Considering each number from <script type=\"math/tex; mode=display\">1</script> to <script type=\"math/tex; mode=display\">n</script> also takes <script type=\"math/tex; mode=display\">O(n)</script> time.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. <script type=\"math/tex; mode=display\">map</script> can contain atmost <script type=\"math/tex; mode=display\">n</script> entries for each of the numbers from <script type=\"math/tex; mode=display\">1</script> to <script type=\"math/tex; mode=display\">n</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-5-using-extra-arrayaccepted\">Approach #5 Using Extra Array[Accepted]:</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In the last approach, we make use of a <script type=\"math/tex; mode=display\">map</script> to store the elements of <script type=\"math/tex; mode=display\">nums</script> along with their corresponding counts. But, we can note, that each entry in <script type=\"math/tex; mode=display\">map</script> requires two entries. Thus, putting up <script type=\"math/tex; mode=display\">n</script> entries requires <script type=\"math/tex; mode=display\">2n</script> space actually. We can reduce this space required to <script type=\"math/tex; mode=display\">n</script> by making use of an array, <script type=\"math/tex; mode=display\">arr</script> instead. Now, the indices of <script type=\"math/tex; mode=display\">arr</script> can be used instead of storing the elements again. Thus, we make use of <script type=\"math/tex; mode=display\">arr</script> in such a way that, <script type=\"math/tex; mode=display\">arr[i]</script> is used to store the number of occurences of the element <script type=\"math/tex; mode=display\">i+1</script>. The rest of the process remains the same as in the last approach.</p> \n  <iframe src=\"https://leetcode.com/playground/362FM5TH/shared\" frameborder=\"0\" name=\"362FM5TH\" width=\"100%\" height=\"326\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Traversing over <script type=\"math/tex; mode=display\">nums</script> of size <script type=\"math/tex; mode=display\">n</script> takes <script type=\"math/tex; mode=display\">O(n)</script> time. Considering each number from <script type=\"math/tex; mode=display\">1</script> to <script type=\"math/tex; mode=display\">n</script> also takes <script type=\"math/tex; mode=display\">O(n)</script> time.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. <script type=\"math/tex; mode=display\">arr</script> can contain atmost <script type=\"math/tex; mode=display\">n</script> elements for each of the numbers from <script type=\"math/tex; mode=display\">1</script> to <script type=\"math/tex; mode=display\">n</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-6-using-constant-spaceaccepted\">Approach #6 Using Constant Space[Accepted]:</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>We can save the space used in the last approach, if we can somehow, include the information regarding the duplicacy of an element or absence of an element in the <script type=\"math/tex; mode=display\">nums</script> array. Let's see how this can be done.</p> \n  <p>We know that all the elements in the given <script type=\"math/tex; mode=display\">nums</script> array are positive, and lie in the range <script type=\"math/tex; mode=display\">1</script> to <script type=\"math/tex; mode=display\">n</script> only. Thus, we can pick up each element <script type=\"math/tex; mode=display\">i</script> from <script type=\"math/tex; mode=display\">nums</script>. For every number <script type=\"math/tex; mode=display\">i</script> picked up, we can invert the element at the index <script type=\"math/tex; mode=display\">\\left|i\\right|</script>. By doing so, if one of the elements <script type=\"math/tex; mode=display\">j</script> occurs twice, when this number is encountered the second time, the element <script type=\"math/tex; mode=display\">nums[\\left|i\\right|]</script> will be found to be negative. Thus, while doing the inversions, we can check if a number found is already negative, to find the duplicate number.</p> \n  <p>After the inversions have been done, if all the elements in <script type=\"math/tex; mode=display\">nums</script> are present correctly, the resultant <script type=\"math/tex; mode=display\">nums</script> array will have all the elements as negative now. But, if one of the numbers, <script type=\"math/tex; mode=display\">j</script> is missing, the element at the <script type=\"math/tex; mode=display\">j^{th}</script> index will be positive. This can be used to determine the missing number.</p> \n  <iframe src=\"https://leetcode.com/playground/jNt2byCg/shared\" frameborder=\"0\" name=\"jNt2byCg\" width=\"100%\" height=\"326\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Two traversals over the <script type=\"math/tex; mode=display\">nums</script> array of size <script type=\"math/tex; mode=display\">n</script> are done.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant extra space is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-7-using-xor-accepted\">Approach #7 Using XOR [Accepted]:</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Before we dive into the solution to this problem, let's consider a simple problem. Consider an array with <script type=\"math/tex; mode=display\">n-1</script> elements containing numbers from <script type=\"math/tex; mode=display\">1</script> to <script type=\"math/tex; mode=display\">n</script> with one number missing out of them. Now, how to we find out this missing element. One of the solutions is to take the XOR of all the elements of this array with all the numbers from <script type=\"math/tex; mode=display\">1</script> to <script type=\"math/tex; mode=display\">n</script>. By doing so, we get the required missing number. This works because XORing a number with itself results in a 0 result. Thus, only the number which is missing can't get cancelled with this XORing.</p> \n  <p>Now, using this idea as the base, let's take it a step forward and use it for the current problem. By taking the XOR of all the elements of the given <script type=\"math/tex; mode=display\">nums</script> array with all the numbers from <script type=\"math/tex; mode=display\">1</script> to <script type=\"math/tex; mode=display\">n</script>, we will get a result, <script type=\"math/tex; mode=display\">xor</script>, as <script type=\"math/tex; mode=display\">x^y</script>. Here, <script type=\"math/tex; mode=display\">x</script> and <script type=\"math/tex; mode=display\">y</script> refer to the repeated and the missing term in the given <script type=\"math/tex; mode=display\">nums</script> array. This happens on the same grounds as in the first problem discussed above.</p> \n  <p>Now, in the resultant <script type=\"math/tex; mode=display\">xor</script>, we'll get a 1 in the binary representation only at those bit positions which have a 1 in one out of the numbers <script type=\"math/tex; mode=display\">x</script> and <script type=\"math/tex; mode=display\">y</script>, and a 0 at the same bit position in the other one. In the current solution, we consider the rightmost bit which is 1 in the <script type=\"math/tex; mode=display\">xor</script>, although any bit would work. Let's say, this position is called the <script type=\"math/tex; mode=display\">rightmostbit</script>. </p> \n  <p>If we divide the elements of the given <script type=\"math/tex; mode=display\">nums</script> array into two parts such that the first set contains the elements which have a 1 at the <script type=\"math/tex; mode=display\">rightmostbit</script> position and the second set contains the elements having a 0 at the same position, we'll get one out of <script type=\"math/tex; mode=display\">x</script> or <script type=\"math/tex; mode=display\">y</script> in one set and the other one in the second set. Now, our problem has reduced somewhat to the simple problem discussed above.</p> \n  <p>To solve this reduced problem, we can find out the elements from <script type=\"math/tex; mode=display\">1</script> to <script type=\"math/tex; mode=display\">n</script> and consider them as a part of the previous sets only, with the allocation of the set depending on a 1 or 0 at the <script type=\"math/tex; mode=display\">righmostbit</script> position. </p> \n  <p>Now, if we do the XOR of all the elements of the first set, all the elements will result in an XOR of 0, due to cancellation of the similar terms in both <script type=\"math/tex; mode=display\">nums</script> and the numbers <script type=\"math/tex; mode=display\">(1:n)</script>, except one term, which is either <script type=\"math/tex; mode=display\">x</script> or <script type=\"math/tex; mode=display\">y</script>. </p> \n  <p>For the other term, we can do the XOR of all the elements in the second set as well.</p> \n  <p>Consider the example <code>[1 2 4 4 5 6]</code></p> \n  <p><img alt=\"XOR\" src=\"../Figures/645_Set_Mismatch.PNG\"></p> \n  <p>One more traversal over the <script type=\"math/tex; mode=display\">nums</script> can be used to identify the missing and the repeated number out of the two numbers found.</p> \n  <iframe src=\"https://leetcode.com/playground/WhhZovFh/shared\" frameborder=\"0\" name=\"WhhZovFh\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. We iterate over <script type=\"math/tex; mode=display\">n</script> elements five times.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant extra space is used.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 644,
    "article_live": true,
    "article_slug": "maximum-average-subarray-ii",
    "title": "Maximum Average Subarray II",
    "title_slug": "maximum-average-subarray-ii",
    "tags": "Array, Binary Search",
    "difficulty": 3,
    "frontend_article_id": 644,
    "article_content": ""
},
{
    "frontend_question_id": 643,
    "article_live": true,
    "article_slug": "maximum-average-subarray",
    "title": "Maximum Average Subarray I",
    "title_slug": "maximum-average-subarray-i",
    "content": "<p>\r\nGiven an array consisting of <code>n</code> integers, find the contiguous subarray of given length <code>k</code> that has the maximum average value. And you need to output the maximum average value.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [1,12,-5,-6,50,3], k = 4\r\n<b>Output:</b> 12.75\r\n<b>Explanation:</b> Maximum average is (12-5-6+50)/4 = 51/4 = 12.75\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>1 <= <code>k</code> <= <code>n</code> <= 30,000.</li>\r\n<li>Elements of the given array will be in the range [-10,000, 10,000].</li>\r\n</ol>\r\n</p>",
    "tags": "Array",
    "difficulty": 1,
    "frontend_article_id": 643,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-cumulative-sum-accepted\">Approach #1 Cumulative Sum [Accepted]</a></li> \n      <li><a href=\"#approach-2-sliding-window-accepted\">Approach #2 Sliding Window [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-cumulative-sum-accepted\">Approach #1 Cumulative Sum [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>We know that in order to obtain the averages of subarrays with length <script type=\"math/tex; mode=display\">k</script>, we need to obtain the sum of these <script type=\"math/tex; mode=display\">k</script> length subarrays. One of the methods of obtaining this sum is to make use of a cumulative sum array, <script type=\"math/tex; mode=display\">sum</script>, which is populated only once. Here, <script type=\"math/tex; mode=display\">sum[i]</script> is used to store the sum of the elements of the given <script type=\"math/tex; mode=display\">nums</script> array from the first element upto the element at the <script type=\"math/tex; mode=display\">i^{th}</script> index.</p> \n  <p>Once the <script type=\"math/tex; mode=display\">sum</script> array has been filled up, in order to find the sum of elements from the index <script type=\"math/tex; mode=display\">i</script> to <script type=\"math/tex; mode=display\">i+k</script>, all we need to do is to use: <script type=\"math/tex; mode=display\">sum[i] - sum[i-k]</script>. Thus, now, by doing one more iteration over the <script type=\"math/tex; mode=display\">sum</script> array, we can determine the maximum average possible from the subarrays of length <script type=\"math/tex; mode=display\">k</script>.</p> \n  <p>The following animation illustrates the process for a simple example.</p> \n  <p>!?!../Documents/643_Maximum_Average.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/dJyoFWQo/shared\" frameborder=\"0\" name=\"dJyoFWQo\" width=\"100%\" height=\"275\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. We iterate over the <script type=\"math/tex; mode=display\">nums</script> array of length <script type=\"math/tex; mode=display\">n</script> once to fill the <script type=\"math/tex; mode=display\">sum</script> array. Then, we iterate over <script type=\"math/tex; mode=display\">n-k</script> elements of <script type=\"math/tex; mode=display\">sum</script> to determine the required result.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. We make use of a <script type=\"math/tex; mode=display\">sum</script> array of length <script type=\"math/tex; mode=display\">n</script> to store the cumulative sum.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-sliding-window-accepted\">Approach #2 Sliding Window [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Instead of creating a cumulative sum array first, and then traversing over it to determine the required sum, we can simply traverse over <script type=\"math/tex; mode=display\">nums</script> just once, and on the go keep on determining the sums possible for the subarrays of length <script type=\"math/tex; mode=display\">k</script>. To understand the idea, assume that we already know the sum of elements from index <script type=\"math/tex; mode=display\">i</script> to index <script type=\"math/tex; mode=display\">i+k</script>, say it is <script type=\"math/tex; mode=display\">x</script>.</p> \n  <p>Now, to determine the sum of elements from the index <script type=\"math/tex; mode=display\">i+1</script> to the index <script type=\"math/tex; mode=display\">i+k+1</script>, all we need to do is to subtract the element <script type=\"math/tex; mode=display\">nums[i]</script> from <script type=\"math/tex; mode=display\">x</script> and to add the element <script type=\"math/tex; mode=display\">nums[i+k+1]</script> to <script type=\"math/tex; mode=display\">x</script>. We can carry out our process based on this idea and determine the maximum possible average.</p> \n  <iframe src=\"https://leetcode.com/playground/uABxt2Z8/shared\" frameborder=\"0\" name=\"uABxt2Z8\" width=\"100%\" height=\"292\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. We iterate over the given <script type=\"math/tex; mode=display\">nums</script> array of length <script type=\"math/tex; mode=display\">n</script> once only.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant extra space is used.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 642,
    "article_live": true,
    "article_slug": "design-search-autocomplete-system",
    "title": "Design Search Autocomplete System",
    "title_slug": "design-search-autocomplete-system",
    "tags": "Design, Trie",
    "difficulty": 3,
    "frontend_article_id": 642,
    "article_content": ""
},
{
    "frontend_question_id": 640,
    "article_live": true,
    "article_slug": "solve-the-equation",
    "title": "Solve the Equation",
    "title_slug": "solve-the-equation",
    "content": "<p>\r\nSolve a given equation and return the value of <code>x</code> in the form of string \"x=#value\". The equation contains only '+', '-' operation, the variable <code>x</code> and its coefficient.\r\n</p>\r\n\r\n<p>\r\nIf there is no solution for the equation, return \"No solution\".\r\n</p>\r\n<p>\r\nIf there are infinite solutions for the equation, return \"Infinite solutions\".\r\n</p>\r\n<p>\r\nIf there is exactly one solution for the equation, we ensure that the value of <code>x</code> is an integer.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br/>\r\n<pre>\r\n<b>Input:</b> \"x+5-3+x=6+x-2\"\r\n<b>Output:</b> \"x=2\"\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br/>\r\n<pre>\r\n<b>Input:</b> \"x=x\"\r\n<b>Output:</b> \"Infinite solutions\"\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 3:</b><br/>\r\n<pre>\r\n<b>Input:</b> \"2x=x\"\r\n<b>Output:</b> \"x=0\"\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 4:</b><br/>\r\n<pre>\r\n<b>Input:</b> \"2x+3x-6x=x+2\"\r\n<b>Output:</b> \"x=-1\"\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 5:</b><br/>\r\n<pre>\r\n<b>Input:</b> \"x=x+2\"\r\n<b>Output:</b> \"No solution\"\r\n</pre>\r\n</p>",
    "tags": "Math",
    "difficulty": 2,
    "frontend_article_id": 640,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-partioning-coefficients-accepted\">Approach #1 Partioning Coefficients [Accepted]</a></li> \n      <li><a href=\"#approach-2-using-regex-for-spliting-accepted\">Approach #2 Using regex for spliting [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-partioning-coefficients-accepted\">Approach #1 Partioning Coefficients [Accepted]</h4> \n  <p>In the current approach, we start by splitting the given <script type=\"math/tex; mode=display\">equation</script> based on <code>=</code> sign. This way, we've separated the left and right hand side of this equation. Once this is done, we need to extract the individual elements(i.e. <code>x</code>'s and the numbers) from both sides of the equation. To do so, we make use of <code>breakIt</code> function, in which we traverse over the given equation(either left hand side or right hand side), and put the separated parts into an array. </p> \n  <p>Now, the idea is as follows. We treat the given equation as if we're bringing all the <code>x</code>'s on the left hand side and all the rest of the numbers on the right hand side as done below for an example.</p> \n  <p><code>x+5-3+x=6+x-2</code></p> \n  <p><code>x+x-x=6-2-5+3</code></p> \n  <p>Thus, every <code>x</code> in the left hand side of the given equation is treated as positive, while that on the right hand side is treated as negative, in the current implementation. </p> \n  <p>Likewise, every number on the left hand side is treated as negative, while that on the right hand side is treated as positive. Thus, by doing so, we obtain all the <code>x</code>'s in the new <script type=\"math/tex; mode=display\">lhs</script> and all the numbers in the new <script type=\"math/tex; mode=display\">rhs</script> of the original equation. </p> \n  <p>Further, in case of an <code>x</code>, we also need to find its corresponding coefficients in order to evaluate the final effective coefficient of <code>x</code> on the left hand side. We also evaluate the final effective number on the right hand side as well.</p> \n  <p>Now, in case of a unique solution, the ratio of the effective <script type=\"math/tex; mode=display\">rhs</script> and <script type=\"math/tex; mode=display\">lhs</script> gives the required result. In case of infinite solutions, both the effective <script type=\"math/tex; mode=display\">lhs</script> and <script type=\"math/tex; mode=display\">rhs</script> turns out to be zero e.g. <code>x+1=x+1</code>. In case of no solution, the coefficient of <code>x</code>(<script type=\"math/tex; mode=display\">lhs</script>) turns out to be zero, but the effective number on the <script type=\"math/tex; mode=display\">rhs</script> is non-zero.</p> \n  <iframe src=\"https://leetcode.com/playground/5qsPscf9/shared\" frameborder=\"0\" name=\"5qsPscf9\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Generating coefficients and findinn <script type=\"math/tex; mode=display\">lhs</script> and <script type=\"math/tex; mode=display\">rhs</script> will take <script type=\"math/tex; mode=display\">O(n)</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. ArrayList <script type=\"math/tex; mode=display\">res</script> size can grow upto <script type=\"math/tex; mode=display\">n</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-using-regex-for-spliting-accepted\">Approach #2 Using regex for spliting [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In the last approach, we made use of a new function <code>breakIt</code> to obtain the individual components of either the left hand side or the right hand side. Instead of doing so, we can also make use of splitting based on <code>+</code> or <code>-</code> sign, to obtain the individual elements. The rest of the process remains the same as in the last approach. </p> \n  <p>In order to do the splitting, we make use of an expression derived from regular expressions(regex). Simply speaking, regex is a functionality used to match a target string based on some given criteria. The ?=n quantifier, in regex, matches any string that is followed by a specific string <script type=\"math/tex; mode=display\">n</script>. What it's saying is that the captured match must be followed by <script type=\"math/tex; mode=display\">n</script> but the <script type=\"math/tex; mode=display\">n</script> itself isn't captured.</p> \n  <p>By making use of this kind of expression in the <code>split</code> functionality, we make sure that the partitions are obtained such that the <code>+</code> or <code>-</code> sign remains along with the parts(numbers or coefficients) even after the splitting.</p> \n  <iframe src=\"https://leetcode.com/playground/9JbHjYgz/shared\" frameborder=\"0\" name=\"9JbHjYgz\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Generating coefficients and finding <script type=\"math/tex; mode=display\">lhs</script> and <script type=\"math/tex; mode=display\">rhs</script> will take <script type=\"math/tex; mode=display\">O(n)</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. ArrayList <script type=\"math/tex; mode=display\">res</script> size can grow upto <script type=\"math/tex; mode=display\">n</script>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 639,
    "article_live": true,
    "article_slug": "decode-ways-ii",
    "title": "Decode Ways II",
    "title_slug": "decode-ways-ii",
    "content": "<p>\r\nA message containing letters from <code>A-Z</code> is being encoded to numbers using the following mapping way:\r\n</p>\r\n\r\n<pre>\r\n'A' -> 1\r\n'B' -> 2\r\n...\r\n'Z' -> 26\r\n</pre>\r\n\r\n<p>\r\nBeyond that, now the encoded string can also contain the character '*', which can be treated as one of the numbers from 1 to 9.\r\n</p>\r\n\r\n\r\n<p>\r\nGiven the encoded message containing digits and the character '*', return the total number of ways to decode it.\r\n</p>\r\n\r\n<p>\r\nAlso, since the answer may be very large, you should return the output mod 10<sup>9</sup> + 7.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \"*\"\r\n<b>Output:</b> 9\r\n<b>Explanation:</b> The encoded message can be decoded to the string: \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\".\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> \"1*\"\r\n<b>Output:</b> 9 + 9 = 18\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The length of the input string will fit in range [1, 10<sup>5</sup>].</li>\r\n<li>The input string will only contain the character '*' and digits '0' - '9'.</li>\r\n</ol>\r\n</p>",
    "tags": "Dynamic Programming",
    "difficulty": 3,
    "frontend_article_id": 639,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-using-recursion-with-memoization-stack-overflow\">Approach #1 Using Recursion with memoization [Stack Overflow]</a></li> \n      <li><a href=\"#approach-2-dynamic-programming-accepted\">Approach #2 Dynamic Programming [Accepted]</a></li> \n      <li><a href=\"#approach-3-constant-space-dynamic-programming-accepted\">Approach #3 Constant Space Dynamic Programming [Accepted]:</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-using-recursion-with-memoization-stack-overflow\">Approach #1 Using Recursion with memoization [Stack Overflow]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In order to find the solution to the given problem, we need to consider every case possible(for the arrangement of the input digits/characters) and what value needs to be considered for each case. Let's look at each of the possibilites one by one.</p> \n  <p>Firstly, let's assume, we have a function <code>ways(s,i)</code> which returns the number of ways to decode the input string <script type=\"math/tex; mode=display\">s</script>, if only the characters upto the <script type=\"math/tex; mode=display\">i^{th}</script> index in this string are considered. We start off by calling the function <code>ways(s, s.length()-1)</code> i.e. by considering the full length of this string <script type=\"math/tex; mode=display\">s</script>.</p> \n  <p>We started by using the last index of the string <script type=\"math/tex; mode=display\">s</script>. Suppose, currently, we called the function as <code>ways(s,i)</code>. Let's look at how we proceed. At every step, we need to look at the current character at the last index (<script type=\"math/tex; mode=display\">i</script>) and we need to determine the number of ways of decoding that using this <script type=\"math/tex; mode=display\">i^{th}</script> character could add to the total value. There are the following possiblities for the <script type=\"math/tex; mode=display\">i^{th}</script> character.</p> \n  <p>The <script type=\"math/tex; mode=display\">i^{th}</script> character could be a <code>*</code>. In this case, firstly, we can see that this <code>*</code> could be decoded into any of the digits from <code>1-9</code>. Thus, for every decoding possible upto the index <script type=\"math/tex; mode=display\">i-1</script>, this <code>*</code> could be replaced by any of these digits(<code>1-9</code>). Thus, the total number of decodings is 9 times the number of decodings possible for the same string upto the index <script type=\"math/tex; mode=display\">i-1</script>. Thus, this <code>*</code> initially adds a factor of <code>9*ways(s,i-1)</code> to the total value. </p> \n  <p align=\"center\"><img alt=\"Decode_Ways\" src=\"../Figures/639/639_Decode_Ways2.png\"></p> \n  <p>Apart from this, this <code>*</code> at the <script type=\"math/tex; mode=display\">i^{th}</script> index could also contribute further to the total number of ways depending upon the character/digit at its preceding index. If the preceding character happens to be a <code>1</code>, by combining this <code>1</code> with the current <code>*</code>, we could obtain any of the digits from <code>11-19</code> which could be decoded into any of the characters from <code>K-S</code>. We need to note that these decodings are in addition to the ones already obtained above by considering only a single current <code>*</code>(<code>1-9</code> decoding to <code>A-J</code>). Thus, this <code>1*</code> pair could be replaced by any of the numbers from <code>11-19</code> irrespective of the decodings done for the previous indices(before <script type=\"math/tex; mode=display\">i-1</script>). Thus, this <code>1*</code> pair leads to 8 times the number of decodings possible with the string <script type=\"math/tex; mode=display\">s</script> upto the index <script type=\"math/tex; mode=display\">i-2</script>. Thus, this adds a factor of <code>9 * ways(s, i - 2)</code> to the total number of decodings. </p> \n  <p>Similarly, a <code>2*</code> pair obtained by a <code>2</code> at the index <script type=\"math/tex; mode=display\">i-1</script> could be considered of the numbers from <code>21-26</code>(decoding into <code>U-Z</code>), adding a total of 6 times the number of decodings possible upto the index <script type=\"math/tex; mode=display\">i-2</script>. </p> \n  <p align=\"center\"><img alt=\"Decode_Ways\" src=\"../Figures/639/639_Decode_Ways3.PNG\"></p> \n  <p>On the same basis, if the character at the index <script type=\"math/tex; mode=display\">i-1</script> happens to be another <code>*</code>, this <code>**</code> pairing could be considered as any of the numbers from <code>11-19</code>(9) and <code>21-26</code>(6). Thus, the total number of decodings will be 15(9+6) times the number of decodings possible upto the index <script type=\"math/tex; mode=display\">i-2</script>.</p> \n  <p>Now, if the <script type=\"math/tex; mode=display\">i^{th}</script> character could be a digit from <code>1-9</code> as well. In this case, the number of decodings that considering this single digit can contribute to the total number is equal to the number of decodings that can be contributed by the digits upto the index <script type=\"math/tex; mode=display\">i-1</script>. But, if the <script type=\"math/tex; mode=display\">i^{th}</script> character is<br> a <code>0</code>, this <code>0</code> alone can't contribute anything to the total number of decodings(but it can only contribute if the digit preceding it is a <code>1</code> or <code>2</code>. We'll consider this case below).</p> \n  <p>Apart from the value obtained(just above) for the digit at the <script type=\"math/tex; mode=display\">i^{th}</script> index being anyone from <code>0-9</code>, this digit could also pair with the digit at the preceding index, contributing a value dependent on the previous digit. If the previous digit happens to be a <code>1</code>, this <code>1</code> can combine with any of the current digits forming a valid number in the range <code>10-19</code>. Thus, in this case, we can consider a pair formed by the current and the preceding digit, and, the number of decodings possible by considering the decoded character to be a one formed using this pair, is equal to the total number of decodings possible by using the digits upto the index <script type=\"math/tex; mode=display\">i-2</script> only. </p> \n  <p>But, if the previous digit is a <code>2</code>, a valid number for decoding could only be a one from the range <code>20-26</code>. Thus, if the current digit is lesser than 7, again this pairing could add decodings with count equal to the ones possible by using the digits upto the <script type=\"math/tex; mode=display\">(i-2)^{th}</script> index only.</p> \n  <p>Further, if the previous digit happens to be a <code>*</code>, the additional number of decodings depend on the current digit again i.e. If the current digit is greater than <code>6</code>, this <code>*</code> could lead to pairings only in the range <code>17-19</code>(<code>*</code> can't be replaced by <code>2</code> leading to <code>27-29</code>). Thus, additional decodings with count equal to the decodings possible upto the index <script type=\"math/tex; mode=display\">i-2</script>. </p> \n  <p>On the other hand, if the current digit is lesser than 7, this <code>*</code> could be replaced by either a <code>1</code> or a <code>2</code> leading to the decodings <code>10-16</code> and <code>20-26</code> respectively. Thus, the total number of decodings possible by considering this pair is equal to twice the number of decodings possible upto the index <script type=\"math/tex; mode=display\">i-2</script>(since <code>*</code> can now be replaced by two values).</p> \n  <p>This way, by considering every possible case, we can obtain the required number of decodings by making use of the recursive function <code>ways</code> as and where necessary.</p> \n  <p>By making use of memoization, we can reduce the time complexity owing to duplicate function calls.</p> \n  <iframe src=\"https://leetcode.com/playground/nVkrWZRc/shared\" frameborder=\"0\" name=\"nVkrWZRc\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Size of recursion tree can go upto <script type=\"math/tex; mode=display\">n</script>, since <script type=\"math/tex; mode=display\">memo</script> array is filled exactly once. Here, <script type=\"math/tex; mode=display\">n</script> refers to the length of the input string.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The depth of recursion tree can go upto <script type=\"math/tex; mode=display\">n</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-dynamic-programming-accepted\">Approach #2 Dynamic Programming [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>From the solutions discussed above, we can observe that the number of decodings possible upto any index, <script type=\"math/tex; mode=display\">i</script>, is dependent only on the characters upto the index <script type=\"math/tex; mode=display\">i</script> and not on any of the characters following it. This leads us to the idea that this problem can be solved by making use of Dynamic Programming.</p> \n  <p>We can also easily observe from the recursive solution that, the number of decodings possible upto the index <script type=\"math/tex; mode=display\">i</script> can be determined easily if we know the number of decodings possible upto the index <script type=\"math/tex; mode=display\">i-1</script> and <script type=\"math/tex; mode=display\">i-2</script>. Thus, we fill in the <script type=\"math/tex; mode=display\">dp</script> array in a forward manner. <script type=\"math/tex; mode=display\">dp[i]</script> is used to store the number of decodings possible by considering the characters in the given string <script type=\"math/tex; mode=display\">s</script> upto the <script type=\"math/tex; mode=display\">(i-1)^{th}</script> index only(including it).</p> \n  <p>The equations for filling this <script type=\"math/tex; mode=display\">dp</script> at any step again depend on the current character and the just preceding character. These equations are similar to the ones used in the recursive solution.</p> \n  <p>The following animation illustrates the process of filling the <script type=\"math/tex; mode=display\">dp</script> for a simple example.</p> \n  <p>!?!../Documents/639_Decode_Ways_II.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/YDp8Hs74/shared\" frameborder=\"0\" name=\"YDp8Hs74\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. <script type=\"math/tex; mode=display\">dp</script> array of size <script type=\"math/tex; mode=display\">n+1</script> is filled once only. Here, <script type=\"math/tex; mode=display\">n</script> refers to the length of the input string.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. <script type=\"math/tex; mode=display\">dp</script> array of size <script type=\"math/tex; mode=display\">n+1</script> is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-constant-space-dynamic-programming-accepted\">Approach #3 Constant Space Dynamic Programming [Accepted]:</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In the last approach, we can observe that only the last two values <script type=\"math/tex; mode=display\">dp[i-2]</script> and <script type=\"math/tex; mode=display\">dp[i-1]</script> are used to fill the entry at <script type=\"math/tex; mode=display\">dp[i-1]</script>. We can save some space in the last approach, if instead of maintaining a whole <script type=\"math/tex; mode=display\">dp</script> array of length <script type=\"math/tex; mode=display\">n</script>, we keep a track of only the required last two values. The rest of the process remains the same as in the last approach.</p> \n  <iframe src=\"https://leetcode.com/playground/5K3aiDQd/shared\" frameborder=\"0\" name=\"5K3aiDQd\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Single loop upto <script type=\"math/tex; mode=display\">n</script> is required to find the required result. Here, <script type=\"math/tex; mode=display\">n</script> refers to the length of the input string <script type=\"math/tex; mode=display\">s</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant space is used.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 638,
    "article_live": true,
    "article_slug": "shopping-offers",
    "title": "Shopping Offers",
    "title_slug": "shopping-offers",
    "content": "<p>\r\nIn LeetCode Store, there are some kinds of items to sell. Each item has a price.\r\n</p>\r\n\r\n<p>\r\nHowever, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price.\r\n</p>\r\n\r\n<p>\r\nYou are given the each item's price, a set of special offers, and the number we need to buy for each item.\r\nThe job is to output the lowest price you have to pay for <b>exactly</b> certain items as given, where you could make optimal use of the special offers.\r\n</p>\r\n\r\n<p>\r\nEach special offer is represented in the form of an array, the last number represents the price you need to pay for this special offer, other numbers represents how many specific items you could get if you buy this offer.\r\n</p>\r\n\r\n<p>You could use any of special offers as many times as you want.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [2,5], [[3,0,5],[1,2,10]], [3,2]\r\n<b>Output:</b> 14\r\n<b>Explanation:</b> \r\nThere are two kinds of items, A and B. Their prices are $2 and $5 respectively. \r\nIn special offer 1, you can pay $5 for 3A and 0B\r\nIn special offer 2, you can pay $10 for 1A and 2B. \r\nYou need to buy 3A and 2B, so you may pay $10 for 1A and 2B (special offer #2), and $4 for 2A.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> [2,3,4], [[1,1,0,4],[2,2,1,9]], [1,2,1]\r\n<b>Output:</b> 11\r\n<b>Explanation:</b> \r\nThe price of A is $2, and $3 for B, $4 for C. \r\nYou may pay $4 for 1A and 1B, and $9 for 2A ,2B and 1C. \r\nYou need to buy 1A ,2B and 1C, so you may pay $4 for 1A and 1B (special offer #1), and $3 for 1B, $4 for 1C. \r\nYou cannot add more items, though only $9 for 2A ,2B and 1C.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br />\r\n<ol>\r\n<li>There are at most 6 kinds of items, 100 special offers.</li>\r\n<li>For each item, you need to buy at most 6 of them.</li>\r\n<li>You are <b>not</b> allowed to buy more items than you want, even if that would lower the overall price.</li>\r\n</ol>\r\n</p>",
    "tags": "Dynamic Programming, Depth-first Search",
    "difficulty": 2,
    "frontend_article_id": 638,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-using-recursion-accepted\">Approach #1 Using Recursion [Accepted]</a></li> \n      <li><a href=\"#approach-2-using-recursion-with-memoization-accepted\">Approach #2 Using Recursion with memoization [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-using-recursion-accepted\">Approach #1 Using Recursion [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Before discussing the steps involved in the process, we need to note a few points. Firstly, whenever an offer is used from amongst the ones available in the <script type=\"math/tex; mode=display\">special</script> list, we need to update the <script type=\"math/tex; mode=display\">needs</script> appropriately, such that the number of items in the current offer of each type are deducted from the ones in the corresponding entry in <script type=\"math/tex; mode=display\">needs</script>.</p> \n  <p>Further, an offer can be used only if the number of items, of each type, required for using the offer, is lesser than or equal to the ones available in the current <script type=\"math/tex; mode=display\">needs</script>. </p> \n  <p>Now, let's discuss the algorithm. We make use of a <code>shopping(price,special,needs)</code> function, which takes the <script type=\"math/tex; mode=display\">price</script> and <script type=\"math/tex; mode=display\">special</script> list along with the current(updated) <script type=\"math/tex; mode=display\">needs</script> as the input and returns the minimum cost of buying these items as required by this <script type=\"math/tex; mode=display\">needs</script> list. </p> \n  <p>In every call of the function <code>shopping(price,special,needs)</code>, we do as follows:</p> \n  <ol> \n   <li> <p>Determine the cost of buying items as per the <script type=\"math/tex; mode=display\">needs</script> array, without applying any offer. Store the result in <script type=\"math/tex; mode=display\">res</script>.</p> </li> \n   <li> <p>Iterate over every offer in the <script type=\"math/tex; mode=display\">special</script> list. For every offer chosen, repeat steps 3 to 5.</p> </li> \n   <li> <p>Create a copy of the current <script type=\"math/tex; mode=display\">needs</script> in a <script type=\"math/tex; mode=display\">clone</script> list(so that the original needs can be used again, while selecting the next offer).</p> </li> \n   <li> <p>Try to apply the current offer. If possible, update the required number of items in <script type=\"math/tex; mode=display\">clone</script>.</p> </li> \n   <li> <p>If the current offer could be applied, find the minimum cost out of <script type=\"math/tex; mode=display\">res</script> and <script type=\"math/tex; mode=display\">offer_\\current</script> + <code>shopping(price,special,clone)</code>. Here, <script type=\"math/tex; mode=display\">offer_\\current</script> refers to the price that needs to be paid for the current offer. Update the <script type=\"math/tex; mode=display\">res</script> with the minimum value.</p> </li> \n   <li> <p>Return the <script type=\"math/tex; mode=display\">res</script> corresponding to the minimum cost.</p> </li> \n  </ol> \n  <p>We need to note that the <script type=\"math/tex; mode=display\">clone</script> needs to be updated afresh from <script type=\"math/tex; mode=display\">needs</script>(coming to the current function call) when we choose a new offer. This needs to be done, because solely applying the next offer could result in a lesser cost than the one resulting by using the previous offer first.</p> \n  <iframe src=\"https://leetcode.com/playground/b6RfW7x4/shared\" frameborder=\"0\" name=\"b6RfW7x4\" width=\"100%\" height=\"515\"></iframe> \n  <hr> \n  <h4 id=\"approach-2-using-recursion-with-memoization-accepted\">Approach #2 Using Recursion with memoization [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In the last approach, we can observe that the same <script type=\"math/tex; mode=display\">needs</script> can be reached by applying the offers in various orders. e.g. We can choose the first offer followed by the second offer or vice-versa. But, both lead to the same requirement of updated <script type=\"math/tex; mode=display\">needs</script> and the cost as well. Thus, instead of repeating the whole process for the same <script type=\"math/tex; mode=display\">needs</script> state through various recursive paths, we can create an entry corresponding to the current set of <script type=\"math/tex; mode=display\">needs</script> in a HashMap, <script type=\"math/tex; mode=display\">map</script>, which stores the minimum cost corresponding to this set of <script type=\"math/tex; mode=display\">needs</script>. Thus, whenever the same call is made again in the future through a different path, we need not repeat the whole process over, and we can directly return the result stored in the <script type=\"math/tex; mode=display\">map</script>.</p> \n  <iframe src=\"https://leetcode.com/playground/aPHtk8QK/shared\" frameborder=\"0\" name=\"aPHtk8QK\" width=\"100%\" height=\"515\"></iframe> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 637,
    "article_live": true,
    "article_slug": "average-of-levels",
    "title": "Average of Levels in Binary Tree",
    "title_slug": "average-of-levels-in-binary-tree",
    "content": "Given a non-empty binary tree, return the average value of the nodes on each level in the form of an array.\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b>\r\n    3\r\n   / \\\r\n  9  20\r\n    /  \\\r\n   15   7\r\n<b>Output:</b> [3, 14.5, 11]\r\n<b>Explanation:</b>\r\nThe average value of nodes on level 0 is 3,  on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11].\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The range of node's value is in the range of 32-bit signed integer.</li>\r\n</ol>\r\n</p>",
    "tags": "Tree",
    "difficulty": 1,
    "frontend_article_id": 637,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-using-depth-first-search-accepted\">Approach #1 Using Depth First Search [Accepted]</a></li> \n      <li><a href=\"#approach-2-breadth-first-search-accepted\">Approach #2 Breadth First Search [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-using-depth-first-search-accepted\">Approach #1 Using Depth First Search [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>One of the methods to solve the given problem is to make use of Depth First Search. In DFS, we try to exhaust each branch of the given tree during the tree traversal before moving onto the next branch.</p> \n  <p>To make use of DFS to solve the given problem, we make use of two lists <script type=\"math/tex; mode=display\">count</script> and <script type=\"math/tex; mode=display\">res</script>. Here, <script type=\"math/tex; mode=display\">count[i]</script> refers to the total number of nodes found at the <script type=\"math/tex; mode=display\">i^{th}</script> level(counting from root at level 0) till now, and <script type=\"math/tex; mode=display\">res[i]</script> refers to the sum of the nodes at the <script type=\"math/tex; mode=display\">i^{th}</script> level encountered till now during the Depth First Search.</p> \n  <p>We make use of a function <code>average(t, i, res, count)</code>, which is used to fill the <script type=\"math/tex; mode=display\">res</script> and <script type=\"math/tex; mode=display\">count</script> array if we start the DFS from the node <script type=\"math/tex; mode=display\">t</script> at the <script type=\"math/tex; mode=display\">i^{th}</script> level in the given tree. We start by making the function call <code>average(root, 0, res, count)</code>. After this, we do the following at every step:</p> \n  <ol> \n   <li> <p>Add the value of the current node to the <script type=\"math/tex; mode=display\">res</script>(or <script type=\"math/tex; mode=display\">sum</script>) at the index corresponding to the current level. Also, increment the <script type=\"math/tex; mode=display\">count</script> at the index corresponding to the current level. </p> </li> \n   <li> <p>Call the same function, <code>average</code>, with the left and the right child of the current node. Also, update the current level used in making the function call.</p> </li> \n   <li> <p>Repeat the above steps till all the nodes in the given tree have been considered once.</p> </li> \n   <li> <p>Populate the averages in the resultant array to be returned.</p> </li> \n  </ol> \n  <p>The following animation illustrates the process.</p> \n  <p>!?!../Documents/637_Avg_of_Levels_DFS.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/eyx7WogA/shared\" frameborder=\"0\" name=\"eyx7WogA\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The whole tree is traversed once only. Here, <script type=\"math/tex; mode=display\">n</script> refers to the total number of nodes in the given binary tree.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(h)</script>. <script type=\"math/tex; mode=display\">res</script> and <script type=\"math/tex; mode=display\">count</script> array of size <script type=\"math/tex; mode=display\">h</script> are used. Here, <script type=\"math/tex; mode=display\">h</script> refers to the height(maximum number of levels) of the given binary tree. Further, the depth of the recursive tree could go upto <script type=\"math/tex; mode=display\">h</script> only.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-breadth-first-search-accepted\">Approach #2 Breadth First Search [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Another method to solve the given problem is to make use of a Breadth First Search. In BFS, we start by pushing the root node into a <script type=\"math/tex; mode=display\">queue</script>. Then, we remove an element(node) from the front of the <script type=\"math/tex; mode=display\">queue</script>. For every node removed from the <script type=\"math/tex; mode=display\">queue</script>, we add all its children to the back of the same <script type=\"math/tex; mode=display\">queue</script>. We keep on continuing this process till the <script type=\"math/tex; mode=display\">queue</script> becomes empty. In this way, we can traverse the given tree on a level-by-level basis.</p> \n  <p>But, in the current implementation, we need to do a slight modification, since we need to separate the nodes on one level from that of the other. </p> \n  <p>The steps to be performed are listed below:</p> \n  <ol> \n   <li> <p>Put the root node into the <script type=\"math/tex; mode=display\">queue</script>.</p> </li> \n   <li> <p>Initialize <script type=\"math/tex; mode=display\">sum</script> and <script type=\"math/tex; mode=display\">count</script> as 0 and <script type=\"math/tex; mode=display\">temp</script> as an empty queue.</p> </li> \n   <li> <p>Pop a node from the front of the <script type=\"math/tex; mode=display\">queue</script>. Add this node's value to the <script type=\"math/tex; mode=display\">sum</script> corresponding to the current level. Also, update the <script type=\"math/tex; mode=display\">count</script> corresponding to the current level.</p> </li> \n   <li> <p>Put the children nodes of the node last popped into the a <script type=\"math/tex; mode=display\">temp</script> queue(instead of <script type=\"math/tex; mode=display\">queue</script>).</p> </li> \n   <li> <p>Continue steps 3 and 4 till <script type=\"math/tex; mode=display\">queue</script> becomes empty. (An empty <script type=\"math/tex; mode=display\">queue</script> indicates that one level of the tree has been considered).</p> </li> \n   <li> <p>Reinitialize <script type=\"math/tex; mode=display\">queue</script> with its value as <script type=\"math/tex; mode=display\">temp</script>.</p> </li> \n   <li> <p>Populate the <script type=\"math/tex; mode=display\">res</script> array with the average corresponding to the current level.</p> </li> \n   <li> <p>Repeat steps 2 to 7 till the <script type=\"math/tex; mode=display\">queue</script> and <script type=\"math/tex; mode=display\">temp</script> become empty.</p> </li> \n  </ol> \n  <p>At the end, <script type=\"math/tex; mode=display\">res</script> is the required result.</p> \n  <p>The following animation illustrates the process.</p> \n  <p>!?!../Documents/637_Average_Of_Levels.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/92XSTJqk/shared\" frameborder=\"0\" name=\"92XSTJqk\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The whole tree is traversed atmost once. Here, <script type=\"math/tex; mode=display\">n</script> refers to the number of nodes in the given binary tree.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(m)</script>. The size of <script type=\"math/tex; mode=display\">queue</script> or <script type=\"math/tex; mode=display\">temp</script> can grow upto atmost the maximum number of nodes at any level in the given binary tree. Here, <script type=\"math/tex; mode=display\">m</script> refers to the maximum mumber of nodes at any level in the input tree.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 636,
    "article_live": true,
    "article_slug": "exclusive-time-of-functions",
    "title": "Exclusive Time of Functions",
    "title_slug": "exclusive-time-of-functions",
    "content": "<p>Given the running logs of <b>n</b> functions that are executed in a nonpreemptive single threaded CPU, find the exclusive time of these functions. </p>\r\n\r\n<p>Each function has a unique id, start from <b>0</b> to <b>n-1</b>. A function may be called recursively or by another function.</p>\r\n\r\n<p>A log is a string has this format : <code>function_id:start_or_end:timestamp</code>. For example, <code>\"0:start:0\"</code> means function 0 starts from the very beginning of time 0. <code>\"0:end:0\"</code> means function 0 ends to the very end of time 0. </p>\r\n\r\n<p>Exclusive time of a function is defined as the time spent within this function, the time spent by calling other functions should not be considered as this function's exclusive time. You should return the exclusive time of each function sorted by their function id.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b>\r\nn = 2\r\nlogs = \r\n[\"0:start:0\",\r\n \"1:start:2\",\r\n \"1:end:5\",\r\n \"0:end:6\"]\r\n<b>Output:</b>[3, 4]\r\n<b>Explanation:</b>\r\nFunction 0 starts at time 0, then it executes 2 units of time and reaches the end of time 1. \r\nNow function 0 <b>calls function 1</b>, function 1 starts at time 2, executes 4 units of time and end at time 5.\r\nFunction 0 is running again at time 6, and also end at the time 6, thus executes 1 unit of time. \r\nSo function 0 totally execute 2 + 1 = 3 units of time, and function 1 totally execute 4 units of time.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>Input logs will be sorted by timestamp, NOT log id.</li>\r\n<li>Your output should be sorted by function id, which means the 0th element of your output corresponds to the exclusive time of function 0.</li>\r\n<li>Two functions won't start or end at the same time.</li>\r\n<li>Functions could be called recursively, and will always end.</li>\r\n<li>1 <= n <= 100</li>\r\n</ol>\r\n</p>",
    "tags": "Stack",
    "difficulty": 2,
    "frontend_article_id": 636,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-using-stack-time-limit-exceeded\">Approach #1 Using Stack [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-better-approach-accepted\">Approach #2 Better Approach [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-using-stack-time-limit-exceeded\">Approach #1 Using Stack [Time Limit Exceeded]</h4> \n  <p>Before starting off with the solution, let's discuss a simple idea. Suppose we have three functions <script type=\"math/tex; mode=display\">func_1</script>, <script type=\"math/tex; mode=display\">func_2</script> and <script type=\"math/tex; mode=display\">func_3</script> such that <script type=\"math/tex; mode=display\">func_1</script> calls <script type=\"math/tex; mode=display\">func_2</script> and then <script type=\"math/tex; mode=display\">func_2</script> calls <script type=\"math/tex; mode=display\">func_3</script>. In this case, <script type=\"math/tex; mode=display\">func_3</script> starts at the end and ends first, <script type=\"math/tex; mode=display\">func_2</script> starts at 2nd position and ends at the 2nd last step. Similarly, <script type=\"math/tex; mode=display\">func_1</script> starts first and ends at the last position. Thus, we can conclude that the function which is entered at the end finishes first and the one which is entered first ends at the last position. </p> \n  <p>From the above discussion, we can conclude that we can make use of a <script type=\"math/tex; mode=display\">stack</script> to solve the given problem. We can start by pushing the first function's id from the given <script type=\"math/tex; mode=display\">logs</script> list onto the array. We also keep a track of the current <script type=\"math/tex; mode=display\">time</script>. We also make use of a <script type=\"math/tex; mode=display\">res</script> array, such that <script type=\"math/tex; mode=display\">res[i]</script> is to keep a track of the exclusive time spent by the Fucntion with function id <script type=\"math/tex; mode=display\">i</script> till the current time. </p> \n  <p>Now, we can move on to the next function in <script type=\"math/tex; mode=display\">logs</script>. The start/end time of the next function will obviously be larger than the start time of the function on the <script type=\"math/tex; mode=display\">stack</script>. We keep on incrementing the current <script type=\"math/tex; mode=display\">time</script> and the exclusive time for the function on the top of the <script type=\"math/tex; mode=display\">stack</script> till the current time becomes equal to the start/end time of the next function in the <script type=\"math/tex; mode=display\">logs</script> list. </p> \n  <p>Thus, now, we've reached a point, where the control shifts from the last function to a new function, due to a function call(indicated by a start label for the next function), or the last function could exit(indicated by the end label for the next function). Thus, we can no longer continue with the same old function. </p> \n  <p>If the next function includes a start label, we push this function on the top of the <script type=\"math/tex; mode=display\">stack</script>, since the last function would need to be revisited again in the future. On the other hand, if the next function includes an end label, it means the last function on the top of the <script type=\"math/tex; mode=display\">stack</script> is terminating.</p> \n  <p>We also know that an end label indicates that this function executes till the end of the given time. Thus, we need to increment the current <script type=\"math/tex; mode=display\">time</script> and the exclusive time of the last function as well to account for this fact. Now, we can remove(pop) this function from the <script type=\"math/tex; mode=display\">stack</script>. We can continue this process for every function in the <script type=\"math/tex; mode=display\">logs</script> list. </p> \n  <p>At the end, the <script type=\"math/tex; mode=display\">res</script> array gives the exclusive times for each function.</p> \n  <p>Summarizing the above process, we need to do the following:</p> \n  <ol> \n   <li> <p>Push the function id of the first function in the <script type=\"math/tex; mode=display\">logs</script> list on the <script type=\"math/tex; mode=display\">stack</script>.</p> </li> \n   <li> <p>Keep incrementing the exlusive time(along with the current time) corresponding to the function on the top of the <script type=\"math/tex; mode=display\">stack</script>(in the <script type=\"math/tex; mode=display\">res</script> array), till the current time equals the start/end time corresponding to the next function in the <script type=\"math/tex; mode=display\">logs</script> list.</p> </li> \n   <li> <p>If the next function has a 'start' label, push this function's id onto the stack. Otherwise, increment the last function's exclusive time(along with the current time), and pop the function id from the top of the stack.</p> </li> \n   <li> <p>Repeat steps 2 and 3 till all the functions in the <script type=\"math/tex; mode=display\">logs</script> list have been considered.</p> </li> \n   <li> <p>Return the resultant exlcusive time(<script type=\"math/tex; mode=display\">res</script>).</p> </li> \n  </ol> \n  <iframe src=\"https://leetcode.com/playground/RqRjdFmv/shared\" frameborder=\"0\" name=\"RqRjdFmv\" width=\"100%\" height=\"496\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(t)</script>. We increment the time till all the functions are done with the execution. Here, <script type=\"math/tex; mode=display\">t</script> refers to the end time of the last function in the <script type=\"math/tex; mode=display\">logs</script> list.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The <script type=\"math/tex; mode=display\">stack</script> can grow upto a depth of atmost <script type=\"math/tex; mode=display\">n/2</script>. Here, <script type=\"math/tex; mode=display\">n</script> refers to the number of elements in the given <script type=\"math/tex; mode=display\">logs</script> list.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-better-approach-accepted\">Approach #2 Better Approach [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In the last approach, for every function on the top of the <script type=\"math/tex; mode=display\">stack</script>, we incremented the current time and the exclusive time of this same function till the current time became equal to the start/end time of the next function. </p> \n  <p>Instead of doing this incrementing step by step, we can directly use the difference between the next function's start/stop time and the current function's start/stop time. The rest of the process remains the same as in the last approach. </p> \n  <p>The following animation illustrates the process.</p> \n  <p>!?!../Documents/636_Exclusive_Time_of_Functions.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/rZkuT7RU/shared\" frameborder=\"0\" name=\"rZkuT7RU\" width=\"100%\" height=\"462\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. We iterate over the entire <script type=\"math/tex; mode=display\">logs</script> array just once. Here, <script type=\"math/tex; mode=display\">n</script> refers to the number of elements in the <script type=\"math/tex; mode=display\">logs</script> list.</p> </li> \n   <li> <p>Space complexity : The <script type=\"math/tex; mode=display\">stack</script> can grow upto a depth of atmost <script type=\"math/tex; mode=display\">n/2</script>. Here, <script type=\"math/tex; mode=display\">n</script> refers to the number of elements in the given <script type=\"math/tex; mode=display\">logs</script> list.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 635,
    "article_live": true,
    "article_slug": "design-log-storage",
    "title": "Design Log Storage System",
    "title_slug": "design-log-storage-system",
    "tags": "String, Design",
    "difficulty": 2,
    "frontend_article_id": 635,
    "article_content": ""
},
{
    "frontend_question_id": 634,
    "article_live": true,
    "article_slug": "find-derangements",
    "title": "Find the Derangement of An Array",
    "title_slug": "find-the-derangement-of-an-array",
    "tags": "Math",
    "difficulty": 2,
    "frontend_article_id": 634,
    "article_content": ""
},
{
    "frontend_question_id": 633,
    "article_live": true,
    "article_slug": "sum-of-square-numbers",
    "title": "Sum of Square Numbers",
    "title_slug": "sum-of-square-numbers",
    "content": "<p>\r\nGiven a non-negative integer <code>c</code>, your task is to decide whether there're two integers <code>a</code> and <code>b</code> such that a<sup>2</sup> + b<sup>2</sup> = c.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> 5\r\n<b>Output:</b> True\r\n<b>Explanation:</b> 1 * 1 + 2 * 2 = 5\r\n</pre>\r\n</p>\r\n\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> 3\r\n<b>Output:</b> False\r\n</pre>\r\n</p>\r\n",
    "tags": "Math",
    "difficulty": 1,
    "frontend_article_id": 633,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-better-brute-force-time-limit-exceeded\">Approach #2 Better Brute Force [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-3-using-sqrt-function-accepted\">Approach #3 Using sqrt function [Accepted]</a></li> \n      <li><a href=\"#approach-4-using-binary-search-accepted\">Approach #4 Using Binary Search [Accepted]</a></li> \n      <li><a href=\"#approach-5-fermat-theorem-accepted\">Approach #5 Fermat Theorem [Accepted]:</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</h4> \n  <p>The simplest solution would be to consider every possible combination of integers <script type=\"math/tex; mode=display\">a</script> and <script type=\"math/tex; mode=display\">b</script> and check if the sum of their squares equals <script type=\"math/tex; mode=display\">c</script>. Now, both <script type=\"math/tex; mode=display\">a</script> and <script type=\"math/tex; mode=display\">b</script> can lie within the range <script type=\"math/tex; mode=display\">(0,\\sqrt{c})</script>. Thus, we need to check for the values of <script type=\"math/tex; mode=display\">a</script> and <script type=\"math/tex; mode=display\">b</script> in this range only.</p> \n  <iframe src=\"https://leetcode.com/playground/KJqxJTpS/shared\" frameborder=\"0\" name=\"KJqxJTpS\" width=\"100%\" height=\"241\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(c)</script>. Two loops upto <script type=\"math/tex; mode=display\">\\sqrt{c}</script>. Here, <script type=\"math/tex; mode=display\">c</script> refers to the given integer(sum of squares).</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant extra space is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-better-brute-force-time-limit-exceeded\">Approach #2 Better Brute Force [Time Limit Exceeded]</h4> \n  <p>We can improve the last solution, if we make the following observation. For any particular <script type=\"math/tex; mode=display\">a</script> chosen, the value of <script type=\"math/tex; mode=display\">b</script> required to satisfy the equation <script type=\"math/tex; mode=display\">a^2 + b^2 = c</script> will be such that <script type=\"math/tex; mode=display\">b^2 = c - a^2</script>. Thus, we need to traverse over the range <script type=\"math/tex; mode=display\">(0, \\sqrt{c})</script> only for considering the various values of <script type=\"math/tex; mode=display\">a</script>. For every current value of <script type=\"math/tex; mode=display\">a</script> chosen, we can determine the corresponding <script type=\"math/tex; mode=display\">b^2</script> value and check if it is a perfect square or not. If it happens to be a perfect square, <script type=\"math/tex; mode=display\">c</script> is a sum of squares of two integers, otherwise not.</p> \n  <p>Now, to determine, if the number <script type=\"math/tex; mode=display\">c - a^2</script> is a perfect square or not, we can make use of the following theorem: \"The square of <script type=\"math/tex; mode=display\">n^{th}</script> positive integer can be represented as a sum of first <script type=\"math/tex; mode=display\">n</script> odd positive integers.\" Or in mathematical terms:</p> \n  <p> <script type=\"math/tex; mode=display\">n^2 = 1 + 3 + 5 + ... + (2*n-1) = \\sum_{1}^{n} (2*i - 1)</script>.</p> \n  <p>To look at the proof of this statement, look at the L.H.S. of the above statement.</p> \n  <p> <script type=\"math/tex; mode=display\">1 + 3 + 5 + ... + (2*n-1)=</script> </p> \n  <p> <script type=\"math/tex; mode=display\">(2*1-1) + (2*2-1) + (2*3-1) + ... + (2*n-1)=</script> </p> \n  <p> <script type=\"math/tex; mode=display\">2*(1+2+3+....+n) - (1+1+...n times)=</script> </p> \n  <p> <script type=\"math/tex; mode=display\">2*n*(n+1)/2 - n=</script> </p> \n  <p> <script type=\"math/tex; mode=display\">n*(n+1) - n=</script> </p> \n  <p> <script type=\"math/tex; mode=display\">n^2 + n - n = n^2</script> </p> \n  <p>This completes the proof of the above statement.</p> \n  <iframe src=\"https://leetcode.com/playground/ToQxLr6g/shared\" frameborder=\"0\" name=\"ToQxLr6g\" width=\"100%\" height=\"309\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(c)</script>. The total number of times the <script type=\"math/tex; mode=display\">sum</script> is updated is: <script type=\"math/tex; mode=display\">1+2+3+...(\\sqrt{c} times) = \\sqrt{c}(\\sqrt{c}+1)/2 = O(c)</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant extra space is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-using-sqrt-function-accepted\">Approach #3 Using sqrt function [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Instead of finding if <script type=\"math/tex; mode=display\">c - a^2</script> is a perfect square using sum of odd numbers, as done in the last approach, we can make use of the inbuilt <script type=\"math/tex; mode=display\">sqrt</script> function and check if <script type=\"math/tex; mode=display\">\\sqrt{c - a^2}</script> turns out to be an integer. If it happens for any value of <script type=\"math/tex; mode=display\">a</script> in the range <script type=\"math/tex; mode=display\">[0, \\sqrt{c}]</script>, we can return a True value immediately.</p> \n  <iframe src=\"https://leetcode.com/playground/PfDSwKKi/shared\" frameborder=\"0\" name=\"PfDSwKKi\" width=\"100%\" height=\"241\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O\\big(\\sqrt{c}log(c)\\big)</script>. We iterate over <script type=\"math/tex; mode=display\">\\sqrt{c}</script> values for choosing <script type=\"math/tex; mode=display\">a</script>. For every <script type=\"math/tex; mode=display\">a</script> chosen, finding square root of <script type=\"math/tex; mode=display\">c - a^2</script> takes <script type=\"math/tex; mode=display\">O\\big(log(c)\\big)</script> time in the worst case.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant extra space is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-4-using-binary-search-accepted\">Approach #4 Using Binary Search [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Another method to check if <script type=\"math/tex; mode=display\">c - a^2</script> is a perfect square, is by making use of Binary Search. The method remains same as that of a typical Binary Search to find a number. The only difference lies in that we need to find an integer, <script type=\"math/tex; mode=display\">mid</script> in the range <script type=\"math/tex; mode=display\">[0, c - a^2]</script>, such that this number is the square root of <script type=\"math/tex; mode=display\">c - a^2</script>. Or in other words, we need to find an integer, <script type=\"math/tex; mode=display\">mid</script>, in the range <script type=\"math/tex; mode=display\">[0, c - a^2]</script>, such that <script type=\"math/tex; mode=display\">mid</script>x<script type=\"math/tex; mode=display\">mid = c - a^2</script>.</p> \n  <p>The following animation illustrates the search process for a particular value of <script type=\"math/tex; mode=display\">c - a^2 = 36</script>.</p> \n  <p>!?!../Documents/633_Sum_of_Squares.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/Eo33FrYc/shared\" frameborder=\"0\" name=\"Eo33FrYc\" width=\"100%\" height=\"394\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O\\big(\\sqrt{c}log(c)\\big)</script>. Binary search taking <script type=\"math/tex; mode=display\">O\\big(log(c)\\big)</script> in the worst case is done for <script type=\"math/tex; mode=display\">\\sqrt{c}</script> values of <script type=\"math/tex; mode=display\">a</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(log(c))</script>. Binary Search will take <script type=\"math/tex; mode=display\">O(log(c))</script> space.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-5-fermat-theorem-accepted\">Approach #5 Fermat Theorem [Accepted]:</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>This approach is based on the following statement, which is based on Fermat's Theorem:</p> \n  <p>\"Any positive number <script type=\"math/tex; mode=display\">n</script> is expressible as a sum of two squares if and only if the prime factorization of <script type=\"math/tex; mode=display\">n</script>, every prime of the form <script type=\"math/tex; mode=display\">(4k+3)</script> occurs an even number of times.\"</p> \n  <p>By making use of the above theorem, we can directly find out if the given number <script type=\"math/tex; mode=display\">c</script> can be expressed as a sum of two squares.</p> \n  <p>To do so we simply find all the prime factors of the given number <script type=\"math/tex; mode=display\">c</script>, which could range from <script type=\"math/tex; mode=display\">[2,\\sqrt{c}]</script> along with the count of those factors, by repeated division. If at any step, we find out that the number of occurences of any prime factor of the form <script type=\"math/tex; mode=display\">(4k+3)</script> occurs an odd number of times, we can return a False value.</p> \n  <p>In case, <script type=\"math/tex; mode=display\">c</script> itself is a prime number, it won't be divisible by any of the primes in the <script type=\"math/tex; mode=display\">[2,\\sqrt{c}]</script>. Thus, we need to check if <script type=\"math/tex; mode=display\">c</script> can be expressed in the form of <script type=\"math/tex; mode=display\">4k+3</script>. If so, we need to return a False value, indicating that this prime occurs an odd number(1) of times. </p> \n  <p>Otherwise, we can return a True value.</p> \n  <p>The proof of this theorem includes the knowledge of advanced mathematics and is beyond the scope of this article. However, interested reader can refer to <a href=\"http://wstein.org/edu/124/lectures/lecture21/lecture21/node2.html\">this</a> documentation.</p> \n  <iframe src=\"https://leetcode.com/playground/f9Fgne3m/shared\" frameborder=\"0\" name=\"f9Fgne3m\" width=\"100%\" height=\"326\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O\\big(\\sqrt{c}log(c)\\big)</script>. We find the factors of <script type=\"math/tex; mode=display\">c</script> and their count using repeated division. We check for the factors in the range <script type=\"math/tex; mode=display\">[0, \\sqrt{c}]</script>. The maximum number of times a factor can occur(repeated division can be done) is <script type=\"math/tex; mode=display\">log(n)</script>(considering 2 as the only factor, <script type=\"math/tex; mode=display\">c=2^x</script>. Thus, <script type=\"math/tex; mode=display\">x=log(c)</script>).</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant space is used.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 632,
    "article_live": true,
    "article_slug": "smallest-range",
    "title": "Smallest Range",
    "title_slug": "smallest-range",
    "content": "<p>You have <code>k</code> lists of sorted integers in ascending order. Find the <b>smallest</b> range that includes at least one number from each of the <code>k</code> lists. </p>\r\n\r\n<p>We define the range [a,b] is smaller than range [c,d] if <code>b-a < d-c</code> or <code>a < c</code> if <code>b-a == d-c</code>.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b>[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]\r\n<b>Output:</b> [20,24]\r\n<b>Explanation:</b> \r\nList 1: [4, 10, 15, 24,26], 24 is in range [20,24].\r\nList 2: [0, 9, 12, 20], 20 is in range [20,24].\r\nList 3: [5, 18, 22, 30], 22 is in range [20,24].\r\n</pre>\r\n</p>\r\n\r\n<p>\r\n<b>Note:</b><br/>\r\n<ol>\r\n<li>The given list may contain duplicates, so ascending order means >= here.</li>\r\n<li>1 <= <code>k</code> <= 3500</li>\r\n<li> -10<sup>5</sup> <= <code>value of elements</code> <= 10<sup>5</sup>.</li>\r\n<li><b>For Java users, please note that the input type has been changed to List&lt;List&lt;Integer&gt;&gt;. And after you reset the code template, you'll see this point.</b></li>\r\n</ol>\r\n<br/>\r\n</p>",
    "tags": "Hash Table, Two Pointers, String",
    "difficulty": 3,
    "frontend_article_id": 632,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-better-brute-force-time-limit-exceeded\">Approach #2 Better Brute Force [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-3-using-pointers-time-limit-exceeded\">Approach #3 Using Pointers [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-4-using-priority-queue-accepted\">Approach #4 Using Priority Queue [Accepted]:</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</h4> \n  <p>The naive approach is to consider every pair of elements, <script type=\"math/tex; mode=display\">nums[i][j]</script> and <script type=\"math/tex; mode=display\">nums[k][l]</script> from amongst the given lists and consider the range formed by these elements. For every range currently considered, we can traverse over all the lists to find if atleast one element from these lists can be included in the current range. If so, we store the end-points of the current range and compare it with the previous minimum range found, if any, satisfying the required criteria, to find the smaller range from among them.</p> \n  <p>Once all the element pairs have been considered as the ranges, we can obtain the required minimum range.</p> \n  <iframe src=\"https://leetcode.com/playground/SMprvqVp/shared\" frameborder=\"0\" name=\"SMprvqVp\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^3)</script>. Considering every possible range(element pair) requires <script type=\"math/tex; mode=display\">O(n^2)</script> time. For each range considered, we need to traverse over all the elements of the given lists in the worst case requiring another <script type=\"math/tex; mode=display\">O(n)</script> time. Here, <script type=\"math/tex; mode=display\">n</script> refers to the total number of elements in the given lists.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant extra space is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-better-brute-force-time-limit-exceeded\">Approach #2 Better Brute Force [Time Limit Exceeded]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In the last approach, we consider every possible range and then traverse over every list to check if atleast one of the elements from these lists lies in the required range. Instead of doing this traversal for every range, we can make use of Binary Search to find the index of the element just larger than(or equal to) the lower limit of the range currently considered. </p> \n  <p>If all the elements in the current list are lesser than this lower limit, we'll get the index as <script type=\"math/tex; mode=display\">nums[k].length</script> for the <script type=\"math/tex; mode=display\">k^{th}</script> list being currently checked. In this case, none of the elements of the current list lies in the current range.</p> \n  <p>On the other hand, if all the elements in this list are larger than this lower limit, we'll get the index of the first element(minimum) in the current list. If this element happens to be larger than the upper limit of the range currently considered, then also, none of the elements of the current list lies within the current range.</p> \n  <p>Whenever a range is found which satisfies the required criteria, we can compare it with the minimum range found so far to determine the required minimum range.</p> \n  <iframe src=\"https://leetcode.com/playground/uXxKqhkz/shared\" frameborder=\"0\" name=\"uXxKqhkz\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O\\big(n^2log(k)\\big)</script>. The time required to consider every possible range is <script type=\"math/tex; mode=display\">O(n^2)</script>. For every range currently considered, a Binary Search requiring <script type=\"math/tex; mode=display\">O\\big(log(k)\\big)</script> time is required. Here, <script type=\"math/tex; mode=display\">n</script> refers to the total number of elements in the given lists and <script type=\"math/tex; mode=display\">k</script> refers to the average length of each list.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant extra space is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-using-pointers-time-limit-exceeded\">Approach #3 Using Pointers [Time Limit Exceeded]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>We'll discuss about the implementation used in the current approach along with the idea behind it. </p> \n  <p>This approach makes use of an array of pointers, <script type=\"math/tex; mode=display\">next</script>, whose length is equal to the number of given lists. In this array, <script type=\"math/tex; mode=display\">next[i]</script> refers to the element which needs to be considered next in the <script type=\"math/tex; mode=display\">(i-1)^{th}</script> list. The meaning of this will become more clearer when we look at the process.</p> \n  <p>We start by initializing all the elements of <script type=\"math/tex; mode=display\">next</script> to 0. Thus, currently, we are considering the first(minimum) element among all the lists. Now, we find out the index of the list containing the maximum(<script type=\"math/tex; mode=display\">max_i</script>) and minimum(<script type=\"math/tex; mode=display\">min_i</script>) elements from amongst the elements currently pointed by <script type=\"math/tex; mode=display\">next</script>. The range formed by these maximum and minimum elements surely<br> contains atleast one element from each list. </p> \n  <p>But, now our objective is to minimize this range. To do so, there are two options: Either decrease the maximum value or increase the minimum value. </p> \n  <p>Now, the maximum value can't be reduced any further, since it already corresponds to the minimum value in one of the lists. Reducing it any further will lead to the exclusion of all the elements of this list(containing the last maximum value) from the new range. </p> \n  <p>Thus, the only option left in our hand is to try to increase the minimum value. To do so, we now need to consider the next element in the list containing the last minimum value. Thus, we increment the entry at the corresponding index in <script type=\"math/tex; mode=display\">next</script>, to indicate that the next element in this list now needs to be considered. </p> \n  <p>Thus, at every step, we find the maximum and minimum values being pointed currently, update the <script type=\"math/tex; mode=display\">next</script> values appropriately, and also find out the range formed by these maximum and minimum values to find out the smallest range satisfying the given criteria. </p> \n  <p>While doing this process, if any of the lists gets completely exhausted, it means that the minimum value being increased for minimizing the range being considered can't be increased any further, without causing the exclusion of all the elements in atleast one of the lists. Thus, we can stop the search process whenever any list gets completely exhausted.</p> \n  <p>We can also stop the process, when all the elements of the given lists have been exhausted.</p> \n  <p>Summarizing the statements above, the process becomes:</p> \n  <ol> \n   <li> <p>Initialize <script type=\"math/tex; mode=display\">next</script> array(pointers) with all 0's.</p> </li> \n   <li> <p>Find the indices of the lists containing the minimum(<script type=\"math/tex; mode=display\">min_i</script>) and the maximum(<script type=\"math/tex; mode=display\">max_i</script>) elements amongst the elements pointed by the <script type=\"math/tex; mode=display\">next</script> array.</p> </li> \n   <li> <p>If the range formed by the maximum and minimum elements found above is larger than the previous maximum range, update the boundary values used for the maximum range.</p> </li> \n   <li> <p>Increment the pointer <script type=\"math/tex; mode=display\">nums[min_i]</script>.</p> </li> \n   <li> <p>Repeat steps 2 to 4 till any of the lists gets exhausted.</p> </li> \n  </ol> \n  <p>The animation below illustrates the process for a visual understanding of the process.</p> \n  <p>!?!../Documents/632_Smallest_Range.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/rnPo3vGZ/shared\" frameborder=\"0\" name=\"rnPo3vGZ\" width=\"100%\" height=\"513\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n*m)</script>. In the worst case, we need to traverse over <script type=\"math/tex; mode=display\">next</script> array(of length <script type=\"math/tex; mode=display\">m</script>) for all the elements of the given lists. Here, <script type=\"math/tex; mode=display\">n</script> refers to the total number of elements in all the lists. <script type=\"math/tex; mode=display\">m</script> refers to the total number of lists.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(m)</script>. <script type=\"math/tex; mode=display\">next</script> array of size <script type=\"math/tex; mode=display\">m</script> is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-4-using-priority-queue-accepted\">Approach #4 Using Priority Queue [Accepted]:</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In the last approach, at each step, we update the pointer corresponding to the current minimum element and traverse over the whole <script type=\"math/tex; mode=display\">next</script> array to determine the new maximum and minimum values. We can do some optimization here, by making use of a simple observation.</p> \n  <p>Whenever we update a single entry of <script type=\"math/tex; mode=display\">next</script> to consider the new maximum and minimum values(if we already know the last maximum and minimum values), all the elements to be considered for finding the maximum and minimum values remain the same except the new element being pointed by a single updated entry in <script type=\"math/tex; mode=display\">next</script>. This new entry is certainly larger than the last minimum value(since that was the reasoning behind the updation). </p> \n  <p>Thus, we can't be sure whether this is the new minimum element or not. But, since it is larger than the last value being considered, it could be a potential competitor for the new maximum value. Thus, we can directly compare it with the last maximum value to determine the current maximum value.</p> \n  <p>Now, we're left with finding the minimum value iteratively at every step. To avoid this iterative process, a better idea is to make use of a Min-Heap, which stores the values being pointed currently by the <script type=\"math/tex; mode=display\">next</script> array. Thus, the minimum value always lies at the top of this heap, and we need not do the iterative search process. </p> \n  <p>At every step, we remove the minimum element from this heap and find out the range formed by the current maximum and minimum values, and compare it with the minimum range found so far to determine the required minimum range. We also update the increment the index in <script type=\"math/tex; mode=display\">next</script> corresponding to the list containing this minimum entry and add this element to the heap as well.</p> \n  <p>The rest of the process remains the same as the last approach.</p> \n  <iframe src=\"https://leetcode.com/playground/kBqfu7ju/shared\" frameborder=\"0\" name=\"kBqfu7ju\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O\\big(n*log(m)\\big)</script>. Heapification of <script type=\"math/tex; mode=display\">m</script> elements requires <script type=\"math/tex; mode=display\">O\\big(log(m)\\big)</script> time. This step could be done for all the elements of the given lists in the worst case. Here, <script type=\"math/tex; mode=display\">n</script> refers to the total number of elements in all the lists. <script type=\"math/tex; mode=display\">m</script> refers to the total number of lists.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(m)</script>. <script type=\"math/tex; mode=display\">next</script> array of size <script type=\"math/tex; mode=display\">m</script> is used. A Min-Heap with <script type=\"math/tex; mode=display\">m</script> elements is also used.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 631,
    "article_live": true,
    "article_slug": "design-excel-sum-formula",
    "title": "Design Excel Sum Formula",
    "title_slug": "design-excel-sum-formula",
    "tags": "Design",
    "difficulty": 3,
    "frontend_article_id": 631,
    "article_content": ""
},
{
    "frontend_question_id": 630,
    "article_live": true,
    "article_slug": "course-schedule-iii",
    "title": "Course Schedule III",
    "title_slug": "course-schedule-iii",
    "content": "<p>\r\nThere are <code>n</code> different online courses numbered from <code>1</code> to <code>n</code>. Each course has some duration(course length)  <code>t</code> and closed on <code>d<sub>th</sub></code> day. A course should be taken <b>continuously</b> for <code>t</code> days and must be finished before or on the <code>d<sub>th</sub></code> day. You will start at the <code>1<sub>st</sub></code> day.\r\n</p>\r\n\r\n<p>\r\nGiven <code>n</code> online courses represented by pairs <code>(t,d)</code>, your task is to find the maximal number of courses that can be taken.\r\n</p>\r\n\r\n\r\n<p><b>Example:</b><br />\r\n<pre>\r\n<b>Input:</b> [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]\r\n<b>Output:</b> 3\r\n<b>Explanation:</b> \r\nThere're totally 4 courses, but you can take 3 courses at most:\r\nFirst, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day.\r\nSecond, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day. \r\nThird, take the 2nd course, it costs 200 days so you will finish it on the 1300th day. \r\nThe 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date.\r\n</pre>\r\n</p>\r\n\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The integer 1 <= d, t, n <= 10,000. </li>\r\n<li>You can't take two courses simultaneously.</li>\r\n</ol>\r\n</p>",
    "tags": "Greedy",
    "difficulty": 3,
    "frontend_article_id": 630,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-using-recursion-with-memoizationtime-limit-exceeded\">Approach #2 Using Recursion with memoization[Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-3-iterative-solution-time-limit-exceeded\">Approach #3 Iterative Solution [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-4-optimized-iterative-accepted\">Approach #4 Optimized Iterative [Accepted]</a></li> \n      <li><a href=\"#approach-5-using-extra-list-accepted\">Approach #5 Using Extra List [Accepted]</a></li> \n      <li><a href=\"#approach-6-using-priority-queue-accepted\">Approach #6 Using Priority Queue [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>The most naive solution will be to consider every possible permutation of the given courses and to try to take as much courses as possible by taking the courses in a serial order in every permutation. We can find out the maximum number of courses that can be taken from out of values obtained from these permutations.</p> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O\\big((n+1)!\\big)</script>. A total of <script type=\"math/tex; mode=display\">n!</script> permutations are possible for the <script type=\"math/tex; mode=display\">courses</script> array of length <script type=\"math/tex; mode=display\">n</script>. For every permutation, we scan over the <script type=\"math/tex; mode=display\">n</script> elements of the permutation to find the number of courses that can be taken in each case.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Each permutation needs <script type=\"math/tex; mode=display\">n</script> space.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-using-recursion-with-memoizationtime-limit-exceeded\">Approach #2 Using Recursion with memoization[Time Limit Exceeded]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Before we move on to the better approaches, let's discuss one basic idea to solve the given problem. Suppose, we are considering only two courses <script type=\"math/tex; mode=display\">(a,x)</script> and <script type=\"math/tex; mode=display\">(b,y)</script>. Let's assume <script type=\"math/tex; mode=display\">y>x</script>. Now, we'll look at the various relative values which <script type=\"math/tex; mode=display\">a</script> and <script type=\"math/tex; mode=display\">b</script> can take, and which course should be taken first in each of these cases. In all the cases, we assume that the course's duration is always lesser than its end day i.e. <script type=\"math/tex; mode=display\">a<x</script> and <script type=\"math/tex; mode=display\">b<y</script>.</p> \n  <ol> \n   <li> <script type=\"math/tex; mode=display\">(a+b) &le; x</script>: In this case, we can take the courses in any order. Both the courses can be taken irrespective of the order in which the courses are taken.</li> \n  </ol> \n  <p align=\"center\"><img alt=\"Courses\" src=\"../Figures/630/630_Course_Schedule_III_1.PNG\"></p> \n  <ol> \n   <li> <script type=\"math/tex; mode=display\">(a+b)>x</script>, <script type=\"math/tex; mode=display\">a>b</script>, <script type=\"math/tex; mode=display\">(a+b) &leq; y</script>: In this case, as is evident from the figure, both the courses can be taken only by taking course <script type=\"math/tex; mode=display\">a</script> before <script type=\"math/tex; mode=display\">b</script>.</li> \n  </ol> \n  <p align=\"center\"><img alt=\"Courses\" src=\"../Figures/630/630_Course_Schedule_III_2.PNG\"></p> \n  <ol> \n   <li> <script type=\"math/tex; mode=display\">(a+b)>x</script>, <script type=\"math/tex; mode=display\">b>a</script>, <script type=\"math/tex; mode=display\">(a+b) &leq; y</script>: In this case also, both the courses can be taken only by taking course <script type=\"math/tex; mode=display\">a</script> before <script type=\"math/tex; mode=display\">b</script>.</li> \n  </ol> \n  <p align=\"center\"><img alt=\"Courses\" src=\"../Figures/630/630_Course_Schedule_III_3.PNG\"></p> \n  <ol> \n   <li> <script type=\"math/tex; mode=display\">(a+b)>y</script>: In this case, irrespective of the order in which we take the courses, only one course can be taken.</li> \n  </ol> \n  <p align=\"center\"><img alt=\"Courses\" src=\"../Figures/630/630_Course_Schedule_III_4.PNG\"></p> \n  <p>From the above example, we can conclude that it is always profitable to take the course with a smaller end day prior to a course with a larger end day. This is because, the course with a smaller duration, if can be taken, can surely be taken only if it is taken prior to a course with a larger end day. </p> \n  <p>Based on this idea, firstly, we sort the given <script type=\"math/tex; mode=display\">courses</script> array based on their end days. Then, we try to take the courses in a serial order from this sorted <script type=\"math/tex; mode=display\">courses</script> array. </p> \n  <p>In order to solve the given problem, we make use of a recursive function <code>schedule(courses, i, time)</code> which returns the maximum number of courses that can be taken starting from the <script type=\"math/tex; mode=display\">i^{th}</script> course(starting from 0), given the time aleady consumed by the other courses is <script type=\"math/tex; mode=display\">time</script>, i.e. the current time is <script type=\"math/tex; mode=display\">time</script>, given a <script type=\"math/tex; mode=display\">courses</script> array as the schedule.</p> \n  <p>Now, in each function call to <code>schedule(courses, i, time)</code>, we try to include the current course in the taken courses. But, this can be done only if <script type=\"math/tex; mode=display\">time + duration_i < end\\_day_i</script>. Here, <script type=\"math/tex; mode=display\">duration_i</script> refers to the duration of the <script type=\"math/tex; mode=display\">i^{th}</script> course and <script type=\"math/tex; mode=display\">end\\_day_i</script> refers to the end day of the <script type=\"math/tex; mode=display\">i^{th}</script> course. </p> \n  <p>If the course can be taken, we increment the number of courses taken and obtain the number of courses that can be taken by passing the updated time and courses' index. i.e. we make the function call <code>schedule(courses, i + 1, time + duration_i)</code>. Let's say, we store the number of courses that can be taken by taking the current course in <script type=\"math/tex; mode=display\">taken</script> variable.</p> \n  <p>Further, for every current course, we also leave the current course, and find the number of courses that can be taken thereof. Now, we need not update the time, but we need to update the courses' index. Thus, we make the function call, <code>schedule(courses, i + 1, time)</code>. Let's say, we store the count obtained in <script type=\"math/tex; mode=display\">not\\_taken</script> variable. </p> \n  <p>While returning the number of courses at the end of each function call, we return the maximum value out of <script type=\"math/tex; mode=display\">taken</script> and <script type=\"math/tex; mode=display\">not\\_taken</script>.</p> \n  <p>Thus, the function call <code>schedule(courses, 0, 0)</code> gives the required result.</p> \n  <p>In order to remove this redundancy, we make use of a memoization array <script type=\"math/tex; mode=display\">memo</script>, such that <script type=\"math/tex; mode=display\">memo[i][j]</script> is used to store the result of the function call <code>schedule(courses, i, time)</code>. Thus, whenever the same function call is made again, we can return the result directly from the <script type=\"math/tex; mode=display\">memo</script> array. This helps to prune the search space to a great extent.</p> \n  <iframe src=\"https://leetcode.com/playground/JuEBXYU7/shared\" frameborder=\"0\" name=\"JuEBXYU7\" width=\"100%\" height=\"377\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n*d)</script>. <script type=\"math/tex; mode=display\">memo</script> array of size <script type=\"math/tex; mode=display\">n</script>x<script type=\"math/tex; mode=display\">d</script> is filled once. Here, <script type=\"math/tex; mode=display\">n</script> refers to the number of courses in the given <script type=\"math/tex; mode=display\">courses</script> array and <script type=\"math/tex; mode=display\">d</script> refers to the maximum value of the end day from all the end days in the <script type=\"math/tex; mode=display\">courses</script> array.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n*d)</script>. <script type=\"math/tex; mode=display\">memo</script> array of size <script type=\"math/tex; mode=display\">n</script>x<script type=\"math/tex; mode=display\">d</script> is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-iterative-solution-time-limit-exceeded\">Approach #3 Iterative Solution [Time Limit Exceeded]</h4> \n  <p>For the current approach, the idea goes as follows. As discussed in the previous approaches, we need to sort the given <script type=\"math/tex; mode=display\">courses</script> array based on the end days. Thus, we consider the courses in the ascending order of their end days. We keep a track of the current time in a <script type=\"math/tex; mode=display\">time</script> variable. Along with this, we also keep a track of the number of courses taken till now in <script type=\"math/tex; mode=display\">count</script> variable.</p> \n  <p>For each course being considered currently(let's say <script type=\"math/tex; mode=display\">i^{th}</script> course), we try to take this course. But, to be able to do so, the current course should end before its corresponding end day i.e. <script type=\"math/tex; mode=display\">time + duration_i &leq; end\\day_i</script>. Here, <script type=\"math/tex; mode=display\">duration_i</script> refers to the duration of the <script type=\"math/tex; mode=display\">i^{th}</script> course and <script type=\"math/tex; mode=display\">end\\_day_i</script> refers to the end day of the <script type=\"math/tex; mode=display\">i^{th}</script> course. </p> \n  <p>If this course can be taken, we update the current time to <script type=\"math/tex; mode=display\">time + duration_i</script> and also increment the current <script type=\"math/tex; mode=display\">count</script> value to indicate that one more course has been taken. </p> \n  <p>But, if we aren't able to take the current course i.e. <script type=\"math/tex; mode=display\">time + duration_i > end\\_day_i</script>, we can try to take this course by removing some other course from amongst the courses that have already been taken. But, the current course can fit in by removing some other course, only if the duration of the course(<script type=\"math/tex; mode=display\">j^{th}</script>) being removed <script type=\"math/tex; mode=display\">duration_j</script> is larger than the current course's duration, <script type=\"math/tex; mode=display\">duration_i</script> i.e. <script type=\"math/tex; mode=display\">duration_j > duration_i</script>. </p> \n  <p>We are sure of the fact that by removing the <script type=\"math/tex; mode=display\">j^{th}</script> course, we can fit in the current course, because, <script type=\"math/tex; mode=display\">course_j</script> was already fitting in the duration available till now. Since, <script type=\"math/tex; mode=display\">duration_i < duration_j</script>, the current course can surely take its place. Thus, we look for a course from amongst the taken courses having a duration larger than the current course.</p> \n  <p>But why are we doing this replacement? The answer to this question is as follows. By replacing the <script type=\"math/tex; mode=display\">j^{th}</script> course, with the <script type=\"math/tex; mode=display\">i^{th}</script> course of a relatively smaller duration, we can increase the time available for upcoming courses to be taken. An extra <script type=\"math/tex; mode=display\">duration_j - duration_i</script> time can be made available by doing so. </p> \n  <p>Now, for this saving in time to be maximum, the course taken for the replacement should be the one with the maximum duration. Thus, from amongst the courses that have been taken till now, we find the course having the maximum duration which should be more than the duration of the current course(which can't be taken). </p> \n  <p>Let's say, this course be called as <script type=\"math/tex; mode=display\">max\\_i</script>. Thus, now, a saving of <script type=\"math/tex; mode=display\">duration_{max\\_i} - duration_i</script> can be achived, which could help later in fitting in more courses to be taken.</p> \n  <p>If such a course, <script type=\"math/tex; mode=display\">max\\_i</script>, is found, we remove this course from the taken courses and consider the current course as taekn. We also mark this course with <script type=\"math/tex; mode=display\">\\text{-1}</script> to indicate that this course has not been taken and should not be considered in the future again for replacement. </p> \n  <p>But, if such a course isn't found, we can't take the current course at any cost. Thus, we mark the current course with <script type=\"math/tex; mode=display\">\\text{-1}</script> to indicate that the current course has not been taken.</p> \n  <p>At the end, the value of <script type=\"math/tex; mode=display\">count</script> gives the required result.</p> \n  <p>The following animation illustrates the process.</p> \n  <p>!?!../Documents/630_Course_Schedule_III.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/HnKoFCWN/shared\" frameborder=\"0\" name=\"HnKoFCWN\" width=\"100%\" height=\"462\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^2)</script>. We iterate over the <script type=\"math/tex; mode=display\">count</script> array of size <script type=\"math/tex; mode=display\">n</script> once. For every element currently considered, we could scan backwards till the first element, giving <script type=\"math/tex; mode=display\">O(n^2)</script> complexity. Sorting the <script type=\"math/tex; mode=display\">count</script> array takes <script type=\"math/tex; mode=display\">O\\big(nlog(n)\\big)</script> time for <script type=\"math/tex; mode=display\">count</script> array.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant extra space is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-4-optimized-iterative-accepted\">Approach #4 Optimized Iterative [Accepted]</h4> \n  <p>In the last approach, we've seen that, in the case of current course which can't be taken direclty, i.e. for <script type=\"math/tex; mode=display\">time + duration_i > end\\_day_i</script>, we need to traverse back in the <script type=\"math/tex; mode=display\">courses</script> array till the beginning to find a course with the maximum duration which is larger than the current course's duration. This backward traversal also goes through the courses which aren't taken and thus, can't be replaced, and have been marked as <script type=\"math/tex; mode=display\">\\text{-1}</script>. </p> \n  <p>We can bring in some optimization here. For this, we should search among only those courses which have been taken(and not the ones which haven't been taken). </p> \n  <p>To do so, as we iterate over the <script type=\"math/tex; mode=display\">courses</script> array, we also keep on updating it, such that the first <script type=\"math/tex; mode=display\">count</script> number of elements in this array now correspond to only those <script type=\"math/tex; mode=display\">count</script> number of courses which have been taken till now. </p> \n  <p>Thus, whenever we update the <script type=\"math/tex; mode=display\">count</script> to indicate that one more course has been taken, we also update the <script type=\"math/tex; mode=display\">courses[count]</script> entry to reflect the current course that has just been taken. </p> \n  <p>Whenever, we find a course for which <script type=\"math/tex; mode=display\">time + duration_i > end\\_day_i</script>, we find a <script type=\"math/tex; mode=display\">max_i</script> course from only amongst these first <script type=\"math/tex; mode=display\">count</script> number of courses in the <script type=\"math/tex; mode=display\">courses</script> array, which indicate the courses that have been taken till now. </p> \n  <p>Also, instead of marking this <script type=\"math/tex; mode=display\">max_i^{th}</script> course with a <script type=\"math/tex; mode=display\">\\text{-1}</script>, we can simply replace this course with the current course. Thus, the first <script type=\"math/tex; mode=display\">count</script> courses still reflect the courses that have been taken till now.</p> \n  <iframe src=\"https://leetcode.com/playground/v7EjYVQp/shared\" frameborder=\"0\" name=\"v7EjYVQp\" width=\"100%\" height=\"479\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n*count)</script>. We iterate over a total of <script type=\"math/tex; mode=display\">n</script> elements of the <script type=\"math/tex; mode=display\">courses</script> array. For every element, we can traverse backwards upto atmost <script type=\"math/tex; mode=display\">count</script>(final value) number of elements.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant extra space is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-5-using-extra-list-accepted\">Approach #5 Using Extra List [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In the last approach, we updated the <script type=\"math/tex; mode=display\">course</script> array itself so that the first <script type=\"math/tex; mode=display\">count</script> elements indicate the <script type=\"math/tex; mode=display\">count</script> number of courses that have been taken till now. If it is required to retain the <script type=\"math/tex; mode=display\">courses</script> array as such, we can do the same job by maintaining a separate list <script type=\"math/tex; mode=display\">valid\\_list</script> which is the list of those courses that have been taken till now. </p> \n  <p>Thus, to find the <script type=\"math/tex; mode=display\">max_i</script> course, we need to search in this list only. Further, when replacing this <script type=\"math/tex; mode=display\">max_i^{th}</script> course with the current course, we can replace this <script type=\"math/tex; mode=display\">max_i</script> course in the list with current course directly. The rest of the method remains the same as the last approach.</p> \n  <iframe src=\"https://leetcode.com/playground/esu9eSya/shared\" frameborder=\"0\" name=\"esu9eSya\" width=\"100%\" height=\"479\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n*m)</script>. We iterate over a total of <script type=\"math/tex; mode=display\">n</script> elements of the <script type=\"math/tex; mode=display\">courses</script> array. For every element, we can traverse over atmost <script type=\"math/tex; mode=display\">m</script> number of elements. Here, <script type=\"math/tex; mode=display\">m</script> refers to the final length of the <script type=\"math/tex; mode=display\">valid\\_list</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The <script type=\"math/tex; mode=display\">valid\\_list</script> can contain atmost <script type=\"math/tex; mode=display\">n</script> courses.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-6-using-priority-queue-accepted\">Approach #6 Using Priority Queue [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>This approach is inspired by <a href=\"https://leetcode.com/stomach_ache\">@stomach_ache</a></p> \n  <p>In the last few approaches, we've seen that we needed to traverse over the courses which have been taken to find the course(with the maximum duration) which can be replaced by the current course(if it can't be taken directly). These traversals can be saved, if we make use of a Priority Queue, <script type=\"math/tex; mode=display\">queue</script>(which is implemented as a Max-Heap) which contains the durations of all the courses that have been taken till now. </p> \n  <p>The iteration over the sorted <script type=\"math/tex; mode=display\">courses</script> remains the same as in the last approaches. Whenver the current course(<script type=\"math/tex; mode=display\">i^{th}</script> course) can be taken(<script type=\"math/tex; mode=display\">time + duration_i &leq; end\\_day_i</script>), it is added to the <script type=\"math/tex; mode=display\">queue</script> and the value of the current time is updated to <script type=\"math/tex; mode=display\">time + duration_i</script>. </p> \n  <p>If the current course can't be taken directly, as in the previous appraoches, we need to find a course whose duration <script type=\"math/tex; mode=display\">duration_j</script> is maximum from amongst the courses taken till now. Now, since we are maintaing a Max-Heap, <script type=\"math/tex; mode=display\">queue</script>, we can obtain this duration directly from this <script type=\"math/tex; mode=display\">queue</script>. If the duration <script type=\"math/tex; mode=display\">duration_j > duration_i</script>, we can replace the <script type=\"math/tex; mode=display\">j^{th}</script> course, with the current one. </p> \n  <p>Thus, we remove the <script type=\"math/tex; mode=display\">duration_j</script> from the <script type=\"math/tex; mode=display\">queue</script> and add the current course's duration <script type=\"math/tex; mode=display\">duration_i</script> to the <script type=\"math/tex; mode=display\">queue</script>. We also need to make proper adjustments to the <script type=\"math/tex; mode=display\">time</script> to account for this replacement done.</p> \n  <p>At the end, the number of elements in the <script type=\"math/tex; mode=display\">queue</script> represent the number of courses that have been taken till now.</p> \n  <iframe src=\"https://leetcode.com/playground/AaRNrEU7/shared\" frameborder=\"0\" name=\"AaRNrEU7\" width=\"100%\" height=\"343\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O\\big(nlog(n)\\big)</script>. At most <script type=\"math/tex; mode=display\">n</script> elements are added to the <script type=\"math/tex; mode=display\">queue</script>. Adding each element is followed by heapification, which takes <script type=\"math/tex; mode=display\">O\\big(log(n)\\big)</script> time.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The <script type=\"math/tex; mode=display\">queue</script> containing the durations of the courses taken can have atmost <script type=\"math/tex; mode=display\">n</script> elements</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 629,
    "article_live": true,
    "article_slug": "k-inverse-pairs-array",
    "title": "K Inverse Pairs Array",
    "title_slug": "k-inverse-pairs-array",
    "content": "<p>\r\nGiven two integers <code>n</code> and <code>k</code>, find how many different arrays consist of numbers from <code>1</code> to <code>n</code> such that there are exactly <code>k</code> inverse pairs. \r\n</p>\r\n<p>\r\nWe define an inverse pair as following:\r\nFor <code>i<sub>th</sub></code> and <code>j<sub>th</sub></code> element in the array, if <code>i</code> < <code>j</code> and <code>a[i]</code> > <code>a[j]</code> then it's an inverse pair; Otherwise, it's not.\r\n</p>\r\n\r\n<p>\r\nSince the answer may be very large, the answer should be modulo 10<sup>9</sup> + 7.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> n = 3, k = 0\r\n<b>Output:</b> 1\r\n<b>Explanation:</b> \r\nOnly the array [1,2,3] which consists of numbers from 1 to 3 has exactly 0 inverse pair.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> n = 3, k = 1\r\n<b>Output:</b> 2\r\n<b>Explanation:</b> \r\nThe array [1,3,2] and [2,1,3] have exactly 1 inverse pair.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The integer <code>n</code> is in the range [1, 1000] and <code>k</code> is in the range [0, 1000].</li>\r\n</ol>\r\n</p>",
    "tags": "Dynamic Programming",
    "difficulty": 3,
    "frontend_article_id": 629,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-using-recursion-with-memoization-time-limit-exceeded\">Approach #2 Using Recursion with memoization [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-3-dynamic-programming-time-limit-exceeded\">Approach #3 Dynamic Programming [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-4-dynamic-programming-with-cumulative-sumaccepted\">Approach #4 Dynamic Programming with Cumulative Sum[Accepted]:</a></li> \n      <li><a href=\"#approach-5-another-optimized-dynamic-programming-approachaccepted\">Approach #5 Another Optimized Dynamic Programming Approach[Accepted]:</a></li> \n      <li><a href=\"#approach-6-once-again-memoization-accepted\">Approach #6 Once Again Memoization [Accepted]:</a></li> \n      <li><a href=\"#approach-7-1-d-dynamic-programmming-accepted\">Approach #7 1-D dynamic Programmming [Accepted]:</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <h4 id=\"approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</h4> \n  <p>The most naive solution is to generate every permutation of the array consisting of numbers from <script type=\"math/tex; mode=display\">1</script> to <script type=\"math/tex; mode=display\">n</script>. Then, we can find out the number of inverse pairs in every array to determine if it is equal to 1. We can find out the count of permutations with the required number of inverse pairs. But, this solution is very terrible in terms of time complexity. Thus, we move on to the better approaches directly.</p> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O\\big(n!*nlog(n)\\big)</script>. A total of <script type=\"math/tex; mode=display\">n!</script> permutations will be generated. We need <script type=\"math/tex; mode=display\">O\\big(nlog(n)\\big)</script> time to find the number of inverse pairs in every such permutation, by making use of merge sort. Here, <script type=\"math/tex; mode=display\">n</script> refers to the given integer <script type=\"math/tex; mode=display\">n</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Each array generated during the permutations will require <script type=\"math/tex; mode=display\">n</script> space.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-using-recursion-with-memoization-time-limit-exceeded\">Approach #2 Using Recursion with memoization [Time Limit Exceeded]</h4> \n  <p>Before we discuss the solution, let's look at the idea behind it. Let's say, <script type=\"math/tex; mode=display\">n</script> represents the given number defining the upper limit of the elements in the arrays being considered and <script type=\"math/tex; mode=display\">k</script> represents the number of inverse pairs in the current array.</p> \n  <p>Let's start with a simple example with <script type=\"math/tex; mode=display\">n=4</script>, no <script type=\"math/tex; mode=display\">k</script> is defined right now. Now, for <script type=\"math/tex; mode=display\">k=0</script>, the only possible arrangement for the given array <script type=\"math/tex; mode=display\">a_0</script> will be <code>[1,2,3,4]</code>, since all the greater elements lie after the smaller elements. Now, in order to generate an arrangement with any arbitrary <script type=\"math/tex; mode=display\">k</script> value, we need to shift, an arbitrary number of elements(let's say <script type=\"math/tex; mode=display\">x</script> elements) in the array <script type=\"math/tex; mode=display\">a_0</script> towards the left, with each displacement(shift) being <script type=\"math/tex; mode=display\">s_1, s_2, ...., s_x</script>, such that the sum of these shifts equals <script type=\"math/tex; mode=display\">k</script>.</p> \n  <p>To see what we mean by the above statement, let's look at the case for <code>[1,2,4,3]</code>. The number of inverse pairs in this array is 1. This array is obtained by shifting the number 4 by one position towards the left. </p> \n  <p>Similarly, consider the case for <code>[2,4,1,3]</code>. This array can be obtained from <script type=\"math/tex; mode=display\">a_0</script> by shifting 2 by one position towards the left first and then shifting 4 by 2 positions towards the left. Thus, the total number of displacements is 3, which is equal to the number of inverse pairs in the new array. </p> \n  <p>This rule of displacements holds true because, whenever a number is shifted <script type=\"math/tex; mode=display\">y</script> times towards the left starting from the array <script type=\"math/tex; mode=display\">a_0</script>, after the shift, <script type=\"math/tex; mode=display\">y</script> numbers smaller than it lie towards its right, giving a total of <script type=\"math/tex; mode=display\">y</script> inverse pairs. </p> \n  <p>Now, let's say, we start with the one of the arrangements <script type=\"math/tex; mode=display\">a_3</script> <code>[2,4,1,3]</code>, with <script type=\"math/tex; mode=display\">k=3</script>. Now, if we want to add a new number 5 to this array to consider an array with <script type=\"math/tex; mode=display\">n=5</script>, let's say, initially, we append it to the end of <script type=\"math/tex; mode=display\">a_3</script>. Now, the new array will be <code>[2,4,1,3,5]</code>. Since, the largest number is added at the end, the new number 5 doesn't add any new inverse pair to the total set of inverse pairs relative to the ones in <script type=\"math/tex; mode=display\">a_3</script>(3). </p> \n  <p>Now, all the numbers in <script type=\"math/tex; mode=display\">a_3</script> are smaller than 5. Thus, if we add 5 at a position <script type=\"math/tex; mode=display\">y</script> steps from the right, <script type=\"math/tex; mode=display\">y</script> smaller numbers will lie towards its right. Thus, a total of <script type=\"math/tex; mode=display\">y</script> inverse pairs will exist with 5 being one of the elements in these pairs. </p> \n  <p>Thus, adding 5 at <script type=\"math/tex; mode=display\">y</script> steps from the right adds a total of <script type=\"math/tex; mode=display\">y</script> inverse pairs to the total set of inverse pairs in <script type=\"math/tex; mode=display\">a_3</script> giving a total of <script type=\"math/tex; mode=display\">3+y</script> inverse pairs now.</p> \n  <p>Looking at the same statement from another point of view, we can say that, if we know the number of inverse pairs(say <script type=\"math/tex; mode=display\">x</script>) in any arbitrary array <script type=\"math/tex; mode=display\">b</script> with some <script type=\"math/tex; mode=display\">n</script>, we can add a new element <script type=\"math/tex; mode=display\">n+1</script> to this array <script type=\"math/tex; mode=display\">b</script> at a position <script type=\"math/tex; mode=display\">p</script> steps from the right, such that <script type=\"math/tex; mode=display\">x+p=k</script> to generate an array with a total of <script type=\"math/tex; mode=display\">k</script> inverse pairs. </p> \n  <p>Extending this idea further, suppose we know the number of arrangements of an array with <script type=\"math/tex; mode=display\">n-1</script> elements, with the number of inverse pairs being <script type=\"math/tex; mode=display\">0, 1, 2,..., k</script>, let's say being equal to <script type=\"math/tex; mode=display\">count_0, count_1, count_2,.., count_k</script>. Now, we can determine the number of arrangements of an array with <script type=\"math/tex; mode=display\">n</script> elements with exactly <script type=\"math/tex; mode=display\">k</script> inverse pairs easily. </p> \n  <p>To generate the arrangements with exactly <script type=\"math/tex; mode=display\">k</script> inverse pairs and <script type=\"math/tex; mode=display\">n</script> elements, we can add the new number <script type=\"math/tex; mode=display\">n</script> to all the arrangements with <script type=\"math/tex; mode=display\">k</script> inverse pairs at the last position. For the arrangements with <script type=\"math/tex; mode=display\">k-1</script> inverse pairs , we can add <script type=\"math/tex; mode=display\">n</script> at a position 1 step from the right. </p> \n  <p>Similarly, for an element with <script type=\"math/tex; mode=display\">k-i</script> number of inverse pairs, we can add this new number <script type=\"math/tex; mode=display\">n</script> at a position <script type=\"math/tex; mode=display\">i</script> steps from the right. Each of these updations to the arrays leads to a new arrangement, each with the number of inverse pairs being equal to <script type=\"math/tex; mode=display\">k</script>. </p> \n  <p>The following image shows an example of how this is done for n=5 and k=4:</p> \n  <p align=\"center\"><img alt=\"Inversions\" src=\"../Figures/629/629_kinverse.PNG\"></p> \n  <p>Thus, to obtain the number of arrangements with exactly <script type=\"math/tex; mode=display\">k</script> inverse pairs and <script type=\"math/tex; mode=display\">n</script> numbers will be given by <script type=\"math/tex; mode=display\">count_0 + count_1 + ... + count_k</script>.</p> \n  <p>From the above discussion, we can obtain the recursive formula for finding the number of arrangements with exactly <script type=\"math/tex; mode=display\">k</script> inverse pairs as follows. Let's say <script type=\"math/tex; mode=display\">count(i,j)</script> represents the number of arrangements with <script type=\"math/tex; mode=display\">i</script> elements and exactly <script type=\"math/tex; mode=display\">j</script> inverse pairs.</p> \n  <ol> \n   <li> <p>If <script type=\"math/tex; mode=display\">n=0</script>, no inverse pairs exist. Thus, <script type=\"math/tex; mode=display\">count(0,k)=0</script>.</p> </li> \n   <li> <p>If <script type=\"math/tex; mode=display\">k=0</script>, only one arrangement is possible, which is all numbers sorted in ascending order. Thus, <script type=\"math/tex; mode=display\">count(n,0)=1</script>.</p> </li> \n   <li> <p>Otherwise, <script type=\"math/tex; mode=display\">count(n,k) = \\sum_{i=0}^{min(k,n-1)} count(n-1, k-i)</script>. </p> </li> \n  </ol> \n  <p>Note that the upper limit on the summation is <script type=\"math/tex; mode=display\">\\text{min}(k,n-1)</script>. This is because for <script type=\"math/tex; mode=display\">i>k</script>, <script type=\"math/tex; mode=display\">k-i<0</script>. No arrangement exists with negative number of inverse pairs. The reason for the other factor can be seen as follows. </p> \n  <p>To generate a new arrangement adding <script type=\"math/tex; mode=display\">k-i</script> new inverse pairs after adding the <script type=\"math/tex; mode=display\">n^{th}</script> number, we need to add this number at the <script type=\"math/tex; mode=display\">i^{th}</script> position from the right. For an array with size <script type=\"math/tex; mode=display\">n</script>, only <script type=\"math/tex; mode=display\">n-1</script> maximum shifts are possible.</p> \n  <p>We need to take the modulus at every step to keep the answer within integral limits.</p> \n  <p>We can see that a lot of duplicate function calls are made in the normal recursive solution. We can remove this redundancy by making use of a memoization array which stores the result for any function call <code>kInversePairs(i,j)</code> in <script type=\"math/tex; mode=display\">memo[i][j]</script>. Thus, whenver a duplicate function call is made again, we can return the result directly from this memoization array. This prunes the search space to a great extent.</p> \n  <iframe src=\"https://leetcode.com/playground/HrBSsxBN/shared\" frameborder=\"0\" name=\"HrBSsxBN\" width=\"100%\" height=\"343\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^2*k)</script>. The function <code>kInversePairs</code> is called <script type=\"math/tex; mode=display\">n^2</script> times to fill the <script type=\"math/tex; mode=display\">memo</script> array of size <script type=\"math/tex; mode=display\">n</script>x<script type=\"math/tex; mode=display\">k</script>. Each function call itself takes <script type=\"math/tex; mode=display\">O(n)</script> time.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. <script type=\"math/tex; mode=display\">memo</script> array of constant size <script type=\"math/tex; mode=display\">1001</script>x<script type=\"math/tex; mode=display\">1001</script> is used. The depth of recursion tree can go upto <script type=\"math/tex; mode=display\">n</script>. </p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-dynamic-programming-time-limit-exceeded\">Approach #3 Dynamic Programming [Time Limit Exceeded]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>As we've seen in the discussion above, the solution for if we know the solutions for <script type=\"math/tex; mode=display\">count(n-1,0)</script>, <script type=\"math/tex; mode=display\">count(n-1, 1)</script>..., <script type=\"math/tex; mode=display\">count(n-1,k)</script>, we can directly obtain the solution for <script type=\"math/tex; mode=display\">count(n,k)</script> as <script type=\"math/tex; mode=display\">count(n,k)=\\sum_{0}^{min(k,n-1)} count(n-1, k-i)</script>.</p> \n  <p>From this, we deduce that we can make use of Dynamic Programming to solve the given problem. To solve the given problem, we make use of a 2-D <script type=\"math/tex; mode=display\">dp</script>, where <script type=\"math/tex; mode=display\">dp[i][j]</script> is used to store the number of arrangements with <script type=\"math/tex; mode=display\">i</script> elements and exactly <script type=\"math/tex; mode=display\">j</script> inverse pairs. Based on the discussions above, the <script type=\"math/tex; mode=display\">dp</script> updation equations become:</p> \n  <ol> \n   <li> <p>If <script type=\"math/tex; mode=display\">n=0</script>, no inverse pairs exist. Thus, <script type=\"math/tex; mode=display\">dp[0][k]=0</script>.</p> </li> \n   <li> <p>If <script type=\"math/tex; mode=display\">k=0</script>, only one arrangement is possible, which is all numbers sorted in ascending order. Thus, <script type=\"math/tex; mode=display\">dp[n][0]=1</script>.</p> </li> \n   <li> <p>Otherwise, <script type=\"math/tex; mode=display\">dp[i,j] = \\sum_{p=0}^{min(j,i-1)} count(i-1, j-p)</script>.</p> </li> \n  </ol> \n  <p>Again, the limit <script type=\"math/tex; mode=display\">\\text{min}(j, i-1)</script> is used to account for the cases where the number of inverse pairs needed becomes negative(<script type=\"math/tex; mode=display\">p>j</script>) or the case where the new inverse pairs needed by adding the <script type=\"math/tex; mode=display\">n^{th}</script> number is more than <script type=\"math/tex; mode=display\">n-1</script> which isn't possible, since the new number can be added at <script type=\"math/tex; mode=display\">(n-1)^{th}</script> position at most from the right.</p> \n  <p>We start filling the <script type=\"math/tex; mode=display\">dp</script> in a row-wise order starting from the first row. At the end, the value of <script type=\"math/tex; mode=display\">dp[n][k]</script> gives the required result.</p> \n  <p>The following animation shows how the <script type=\"math/tex; mode=display\">dp</script> is filled for n=4 and k=5:</p> \n  <p>!?!../Documents/629_dp4.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/YaTc4PUF/shared\" frameborder=\"0\" name=\"YaTc4PUF\" width=\"100%\" height=\"343\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^2*k)</script>. <script type=\"math/tex; mode=display\">dp</script> of size <script type=\"math/tex; mode=display\">n</script>x<script type=\"math/tex; mode=display\">k</script> is filled once. Filling each <script type=\"math/tex; mode=display\">dp</script> entry takes <script type=\"math/tex; mode=display\">O(n)</script> time.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n*k)</script>. <script type=\"math/tex; mode=display\">dp</script> array of size <script type=\"math/tex; mode=display\">n</script>x<script type=\"math/tex; mode=display\">k</script> is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-4-dynamic-programming-with-cumulative-sumaccepted\">Approach #4 Dynamic Programming with Cumulative Sum[Accepted]:</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>From the last approach, we've observed that we need to traverse back to some limit in the previous row of the <script type=\"math/tex; mode=display\">dp</script> array to fill in the current <script type=\"math/tex; mode=display\">dp</script> entry. Instead of doing this traversal to find the sum of the required elements, we can ease the process if we fill the cumulative sum upto the current element in a row in any <script type=\"math/tex; mode=display\">dp</script> entry, instead of the actual value. </p> \n  <p>Thus, now, <script type=\"math/tex; mode=display\">dp[i][j]=count(i,j)+\\sum_{k=0}^{j-1} dp[i][k]</script>. Here, <script type=\"math/tex; mode=display\">count(i,j)</script> refers to the number of arrangements with <script type=\"math/tex; mode=display\">i</script> elements and exactly <script type=\"math/tex; mode=display\">j</script> inverse pairs. Thus, each entry contains the sum of all the previous elements in the same row along with its own result.</p> \n  <p>Now, we need to determine the value of <script type=\"math/tex; mode=display\">count(i,j)</script> to be added to the sum of previous elements in a row, in order to update the <script type=\"math/tex; mode=display\">dp[i][j]</script> entry. But, we need not traverse back in the previous row , since it contains entries representing the cumulative sums now. Thus, to obtain the sum of elements from <script type=\"math/tex; mode=display\">dp[i-1][j-i+1]</script> to <script type=\"math/tex; mode=display\">dp[i-1][j]</script>(including both), we can directly use <script type=\"math/tex; mode=display\">dp[i-1][j] - dp[i-1][j-i]</script>. </p> \n  <p>Now, to reflect the condition <script type=\"math/tex; mode=display\">\\text{min}(j, i-1)</script> used in the previous approaches, we can note that, we need to take the sum of only <script type=\"math/tex; mode=display\">i</script> elements in the previous row, if <script type=\"math/tex; mode=display\">i</script> elements exist till we reach the end of the array while traversing backwards. Otherwise, we simply take the sum of all the elements. </p> \n  <p>Only <script type=\"math/tex; mode=display\">i</script> elements are considered because for generating <script type=\"math/tex; mode=display\">j</script> new inverse pairs, by adding <script type=\"math/tex; mode=display\">i</script> as the new number at the <script type=\"math/tex; mode=display\">j^{th}</script> position, <script type=\"math/tex; mode=display\">j</script> could reach only upto <script type=\"math/tex; mode=display\">i-1</script>, as discussed in the last approaches as well. Thus, we need to consider the sum of elements from <script type=\"math/tex; mode=display\">dp[i-1][j-(i-1)]</script> to <script type=\"math/tex; mode=display\">dp[i-1][j]</script>(including both) using <script type=\"math/tex; mode=display\">dp[i-1][j] - dp[i-1][j-i]</script> if <script type=\"math/tex; mode=display\">j-i &geq; 0</script>.</p> \n  <p>Otherwise, we add all the elements of the previous row upto the current column <script type=\"math/tex; mode=display\">j</script> being considered. In other words, we can use <script type=\"math/tex; mode=display\">dp[i-1][j]</script> directly as the required sum.</p> \n  <p>At the end, while returning the result, we need to return <script type=\"math/tex; mode=display\">dp[n][k]-dp[n][k-1]</script> to obtain the required result from the cumulative sums. </p> \n  <p>The following animation illustrates the process of filling the <script type=\"math/tex; mode=display\">dp</script> array.</p> \n  <p>!?!../Documents/629_dp5.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/W8PNnR9j/shared\" frameborder=\"0\" name=\"W8PNnR9j\" width=\"100%\" height=\"343\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n*k)</script>. <script type=\"math/tex; mode=display\">dp</script> array of size <script type=\"math/tex; mode=display\">n</script>x<script type=\"math/tex; mode=display\">k</script> is filled once.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n*k)</script>. <script type=\"math/tex; mode=display\">dp</script> array of size <script type=\"math/tex; mode=display\">n</script>x<script type=\"math/tex; mode=display\">k</script> is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-5-another-optimized-dynamic-programming-approachaccepted\">Approach #5 Another Optimized Dynamic Programming Approach[Accepted]:</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Another way to use the Dynamic Programming Approach could be if we can somehow directly store the required <script type=\"math/tex; mode=display\">count(i,j)</script> in <script type=\"math/tex; mode=display\">dp[i][j]</script> entry, but still we should not need to traverse back in the previous row to find the sum of the required elements. </p> \n  <p>To do so, we can note that for the <script type=\"math/tex; mode=display\">i^{th}</script> row, we need to add the elements from <script type=\"math/tex; mode=display\">dp[i-1][j-i+1]</script> to <script type=\"math/tex; mode=display\">dp[i-1][j]</script>(including both) if <script type=\"math/tex; mode=display\">(j-1) > 0</script>. Otherwise, we need to add all the elements from <script type=\"math/tex; mode=display\">dp[i-1][0]</script> to <script type=\"math/tex; mode=display\">dp[i-1][j]</script>. This has already been discussed previously. </p> \n  <p>Now, when we go for filling in <script type=\"math/tex; mode=display\">dp[i][j+1]</script> after filling <script type=\"math/tex; mode=display\">dp[i][j]</script>, we know <script type=\"math/tex; mode=display\">dp[i][j]</script> already corresponds to the sum of the elements from <script type=\"math/tex; mode=display\">dp[i-1][j-i+1]</script> to <script type=\"math/tex; mode=display\">dp[i-1][j]</script>. But, for filling <script type=\"math/tex; mode=display\">dp[i][j+1]</script>, we require the sum of the elements from <script type=\"math/tex; mode=display\">dp[i-1][(j-i+1)+1]</script> to <script type=\"math/tex; mode=display\">dp[i-1][j+1]</script>. </p> \n  <p>We can observe that this sum only excludes <script type=\"math/tex; mode=display\">dp[i-1][j-i+1]</script> from the previous sum(<script type=\"math/tex; mode=display\">dp[i][j]</script>) and requires addition of only one new element(<script type=\"math/tex; mode=display\">dp[i-1][j+1]</script>) to the to this sum. If the value <script type=\"math/tex; mode=display\">j-i+1<0</script>, we need not remove any value.</p> \n  <p>Thus, we can directly obtain <script type=\"math/tex; mode=display\">dp[i][j]</script> value as <script type=\"math/tex; mode=display\">dp[i][j] = dp[i-1][j] - dp[i-1][j-i] + dp[i-1][j]</script>, if <script type=\"math/tex; mode=display\">j-i &geq; 0</script>. Otherwise, we can use: <script type=\"math/tex; mode=display\">dp[i][j] = dp[i-1][j] + dp[i-1][j]</script>. </p> \n  <p>We can also note that, since, here <script type=\"math/tex; mode=display\">j</script> represents the number of inverse pairs that need to be currently considered, we can place another upper limit on <script type=\"math/tex; mode=display\">j</script> as well. The maximum number of inverse pairs for any arbitrary <script type=\"math/tex; mode=display\">n</script> occur only when the array is sorted in descending order leading to <code>[n,n-1,....,3,2,1]</code> as the arrangement. </p> \n  <p>This arrangement has a total of <script type=\"math/tex; mode=display\">n*(n-1)/2</script> inverse pairs. Thus, for an array with <script type=\"math/tex; mode=display\">i</script> as the number of elements, the maximum number of inverse pairs possible is <script type=\"math/tex; mode=display\">i*(i-1)/2</script> only. Thus, for fillling in the <script type=\"math/tex; mode=display\">i^{th}</script> row of <script type=\"math/tex; mode=display\">dp</script>, we can place this limit on <script type=\"math/tex; mode=display\">j</script>'s value.</p> \n  <p>The following animation shows the <script type=\"math/tex; mode=display\">dp</script> filling process.</p> \n  <p>!?!../Documents/629_dp6.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/8azxXjrN/shared\" frameborder=\"0\" name=\"8azxXjrN\" width=\"100%\" height=\"394\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n*k)</script>. <script type=\"math/tex; mode=display\">dp</script> array of size <script type=\"math/tex; mode=display\">(n+1)</script>x<script type=\"math/tex; mode=display\">(k+1)</script> is filled once.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n*k)</script>. <script type=\"math/tex; mode=display\">dp</script> array of size <script type=\"math/tex; mode=display\">(n+1)</script>x<script type=\"math/tex; mode=display\">(k+1)</script> is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-6-once-again-memoization-accepted\">Approach #6 Once Again Memoization [Accepted]:</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>The Dynamic Programming solution discussed in Approach 5 can also be written down in the form of a recursive solution. But, again, that will include a lot of duplicate function calls. Thus, a better solution would be to use memoization to store the results of the previous function calls.</p> \n  <iframe src=\"https://leetcode.com/playground/KhoU86GW/shared\" frameborder=\"0\" name=\"KhoU86GW\" width=\"100%\" height=\"360\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n*k)</script>. <script type=\"math/tex; mode=display\">n</script>x<script type=\"math/tex; mode=display\">k</script> entries in the <script type=\"math/tex; mode=display\">memo</script> array are filled once.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. <script type=\"math/tex; mode=display\">memo</script> array of constant size <script type=\"math/tex; mode=display\">1001</script>x<script type=\"math/tex; mode=display\">1001</script> is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-7-1-d-dynamic-programmming-accepted\">Approach #7 1-D dynamic Programmming [Accepted]:</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>From the Dynamic Programming solution, we can also note that we only need the values of the previous row in the <script type=\"math/tex; mode=display\">dp</script> array, and not any other row. Thus, instead of storing the whole 2-D <script type=\"math/tex; mode=display\">dp</script> in memory, we can make use of a 1-D <script type=\"math/tex; mode=display\">dp</script> to store the previous row's entries only. The updations can be done in a 1-D <script type=\"math/tex; mode=display\">temp</script> array of the same size as <script type=\"math/tex; mode=display\">dp</script> and <script type=\"math/tex; mode=display\">dp</script> can be updated using this <script type=\"math/tex; mode=display\">temp</script> everytime a row is finished.</p> \n  <iframe src=\"https://leetcode.com/playground/4BjBwzaY/shared\" frameborder=\"0\" name=\"4BjBwzaY\" width=\"100%\" height=\"343\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n*k)</script>. <script type=\"math/tex; mode=display\">dp</script> array of size <script type=\"math/tex; mode=display\">k+1</script> is filled <script type=\"math/tex; mode=display\">n+1</script> times.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(k)</script>. <script type=\"math/tex; mode=display\">dp</script> array of size <script type=\"math/tex; mode=display\">(k+1)</script> is used.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 628,
    "article_live": true,
    "article_slug": "maximmum-product-of-three-numbers",
    "title": "Maximum Product of Three Numbers",
    "title_slug": "maximum-product-of-three-numbers",
    "content": "<p>Given an integer array, find three numbers whose product is maximum and output the maximum product.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [1,2,3]\r\n<b>Output:</b> 6\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> [1,2,3,4]\r\n<b>Output:</b> 24\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The length of the given array will be in range [3,10<sup>4</sup>] and all elements are in the range [-1000, 1000].</li>\r\n<li>Multiplication of any three numbers in the input won't exceed the range of 32-bit signed integer.</li>\r\n</ol>\r\n</p>",
    "tags": "Array, Math",
    "difficulty": 1,
    "frontend_article_id": 628,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-using-sorting-accepted\">Approach #2 Using Sorting [Accepted]</a></li> \n      <li><a href=\"#approach-3-single-scan-accepted\">Approach #3 Single Scan [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</h4> \n  <p>The simplest solution is to consider every triplet out of the given <script type=\"math/tex; mode=display\">nums</script> array and check their product and find out the maximum product out of them.</p> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^3)</script>. We need to consider every triplet from <script type=\"math/tex; mode=display\">nums</script> array of length <script type=\"math/tex; mode=display\">n</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant extra space is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-using-sorting-accepted\">Approach #2 Using Sorting [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Another solution could be to sort the given <script type=\"math/tex; mode=display\">nums</script> array(in ascending order) and find out the product of the last three numbers. </p> \n  <p>But, we can note that this product will be maximum only if all the numbers in <script type=\"math/tex; mode=display\">nums</script> array are positive. But, in the given problem statement, negative elements could exist as well. </p> \n  <p>Thus, it could also be possible that two negative numbers lying at the left extreme end could also contribute to lead to a larger product if the third number in the triplet being considered is the largest positive number in the <script type=\"math/tex; mode=display\">nums</script> array. </p> \n  <p>Thus, either the product <script type=\"math/tex; mode=display\">nums[0]</script>x<script type=\"math/tex; mode=display\">nums[1]</script>x<script type=\"math/tex; mode=display\">nums[n-1]</script> or <script type=\"math/tex; mode=display\">nums[n-3]</script>x<script type=\"math/tex; mode=display\">nums[n-2]</script>x<script type=\"math/tex; mode=display\">nums[n-1]</script> will give the required result. Thus, we need to find the larger one from out of these values.</p> \n  <iframe src=\"https://leetcode.com/playground/L7hasHZW/shared\" frameborder=\"0\" name=\"L7hasHZW\" width=\"100%\" height=\"173\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O\\big(nlog(n)\\big)</script>. Sorting the <script type=\"math/tex; mode=display\">nums</script> array takes <script type=\"math/tex; mode=display\">nlog(n)</script> time.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(log(n)))</script>. Sorting takes O(logn) space.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-single-scan-accepted\">Approach #3 Single Scan [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>We need not necessarily sort the given <script type=\"math/tex; mode=display\">nums</script> array to find the maximum product. Instead, we can only find the required 2 smallest values(<script type=\"math/tex; mode=display\">min1</script> and <script type=\"math/tex; mode=display\">min2</script>) and the three largest values(<script type=\"math/tex; mode=display\">max1, max2, max3</script>) in the <script type=\"math/tex; mode=display\">nums</script> array, by iterating over the <script type=\"math/tex; mode=display\">nums</script> array only once. </p> \n  <p>At the end, again we can find out the larger value out of <script type=\"math/tex; mode=display\">min1</script>x<script type=\"math/tex; mode=display\">min2</script>x<script type=\"math/tex; mode=display\">max1</script> and <script type=\"math/tex; mode=display\">max1</script>x<script type=\"math/tex; mode=display\">max2</script>x<script type=\"math/tex; mode=display\">max3</script> to find the required maximum product.</p> \n  <iframe src=\"https://leetcode.com/playground/bDifEipg/shared\" frameborder=\"0\" name=\"bDifEipg\" width=\"100%\" height=\"479\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Only one iteration over the <script type=\"math/tex; mode=display\">nums</script> array of length <script type=\"math/tex; mode=display\">n</script> is required.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant extra space is used.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 625,
    "article_live": true,
    "article_slug": "minimum-factorization",
    "title": "Minimum Factorization",
    "title_slug": "minimum-factorization",
    "tags": "Math, Recursion",
    "difficulty": 2,
    "frontend_article_id": 625,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-better-brute-force-time-limit-exceeded\">Approach #2 Better Brute Force [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-3-using-factorizationaccepted\">Approach #3 Using Factorization[Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</h4> \n  <p>The simplest solution is to consider every possible 32-bit number starting from 1 which satisfies the given criteria. To check this, we obtain each individual digit of every such number and check if their product is equal to the given number <script type=\"math/tex; mode=display\">a</script>. As soon as such a number is found, we return the same. If no such 32-bit number is found, we return a 0 value.</p> \n  <iframe src=\"https://leetcode.com/playground/W7M6JELz/shared\" frameborder=\"0\" name=\"W7M6JELz\" width=\"100%\" height=\"309\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(9999999999)</script>. In case of prime numbers loop can go upto this large number.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant space is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-better-brute-force-time-limit-exceeded\">Approach #2 Better Brute Force [Time Limit Exceeded]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Instead of considering every possible number from the total search space, we can do the search in a smarter way. We can start putting the numbers from 9 to 2 at the ones position and keep on proceeding towards more significant places. For every number currently generated, we can check if the product of its digits exceeds the given number <script type=\"math/tex; mode=display\">a</script>. If so, there is no point in appending more digitas to this number. Thus, we can change the composition of the number generated till now and continue the checking process. </p> \n  <p>For doing this, we make use of a recursive function <code>search()</code>, which takes the number generated till now, <script type=\"math/tex; mode=display\">res</script>(as a string) as one of its arguments along with the number to be appended next as the <script type=\"math/tex; mode=display\">res</script> as a prefix as one of the other arguments. We can note that to obtain the smallest possible number, we need to try to put the largest number(which will be one of the factors for constituting the product <script type=\"math/tex; mode=display\">a</script>) at the least significant position and the smallest one at the most significant position. Thus, we start from the least significant position by trying to place a 9 at this position and then continue by trying to place smaller numbers at this position if the numbers generated by the previous arrangements fail. If some arrangement leads to a product of digits not larger than <script type=\"math/tex; mode=display\">a</script>, we continue with placing digits, equal to or smaller than the last digit placed, at the more significant positions.</p> \n  <p>The following animation illustrates the recursive process:</p> \n  <p>!?!../Documents/625_Minimum_Factorization.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/mq3fEUtA/shared\" frameborder=\"0\" name=\"mq3fEUtA\" width=\"100%\" height=\"411\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(l)</script>. Here <script type=\"math/tex; mode=display\">l</script> refers to total number of combinations.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(log(a))</script>. In worst case, depth of recursion tree can go upto the <script type=\"math/tex; mode=display\">O(log(a))</script> .</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-using-factorizationaccepted\">Approach #3 Using Factorization[Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>We know that the final number generated, <script type=\"math/tex; mode=display\">res</script>, should be such that its digits should have a product equal to the given number <script type=\"math/tex; mode=display\">a</script>. In other words, the digits of <script type=\"math/tex; mode=display\">res</script> will be the factors of the given number <script type=\"math/tex; mode=display\">a</script>. Thus, our problem reduces to finding the factors(not necessarily prime) of <script type=\"math/tex; mode=display\">a</script> and finding their smallest possible arrangement. Thus, we start with trying with the largest possible factor <script type=\"math/tex; mode=display\">9</script>, obtain as many such counts of this factor as possible in <script type=\"math/tex; mode=display\">res</script> and place such factors obtianed at its least significant positions. Then, we go on decrementing the number currently considered as the possible factor and if it is a factor, we keep on placing it at relatively more significant positions in <script type=\"math/tex; mode=display\">res</script>. We go on getting such factors till we are done considering all the numbers from 9 to 2. At the end, <script type=\"math/tex; mode=display\">res</script> gives the required result.</p> \n  <iframe src=\"https://leetcode.com/playground/WHBgGGcX/shared\" frameborder=\"0\" name=\"WHBgGGcX\" width=\"100%\" height=\"309\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(8loga)</script>. Outer loop will iterate only 8 times, while inner loop takes <script type=\"math/tex; mode=display\">O(logi)</script> for particular <script type=\"math/tex; mode=display\">i</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant space is used.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 624,
    "article_live": true,
    "article_slug": "maximum-distance-in-array",
    "title": "Maximum Distance in Arrays",
    "title_slug": "maximum-distance-in-arrays",
    "tags": "Array, Hash Table",
    "difficulty": 1,
    "frontend_article_id": 624,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-better-brute-force-time-limit-exceeded\">Approach #2 Better Brute Force [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-3-single-scan-accepted\">Approach #3 Single Scan [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</h4> \n  <p>The simplest solution is to pick up every element of every array from the <script type=\"math/tex; mode=display\">list</script> and find its distance from every element in all the other arrays except itself and find the largest distance from out of those.</p> \n  <iframe src=\"https://leetcode.com/playground/rge5K69S/shared\" frameborder=\"0\" name=\"rge5K69S\" width=\"100%\" height=\"326\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O((n*x)^2)</script>. We traverse over all the arrays in <script type=\"math/tex; mode=display\">list</script> for every element of every array considered. Here, <script type=\"math/tex; mode=display\">n</script> refers to the number of arrays in the <script type=\"math/tex; mode=display\">list</script> and <script type=\"math/tex; mode=display\">x</script> refers to the average number of elements in each array in the <script type=\"math/tex; mode=display\">list</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant extra space is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-better-brute-force-time-limit-exceeded\">Approach #2 Better Brute Force [Time Limit Exceeded]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In the last approach, we didn't make use of the fact that every array in the <script type=\"math/tex; mode=display\">list</script> is sorted. Thus, instead of considering the distances among all the elements of all the arrays(except intra-array elements), we can consider only the distances between the first(minimum element) element of an array and the last(maximum element) element of the other arrays and find out the maximum distance from among all such distances. </p> \n  <iframe src=\"https://leetcode.com/playground/QdXWERJK/shared\" frameborder=\"0\" name=\"QdXWERJK\" width=\"100%\" height=\"275\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^2)</script>. We consider only max and min values directly for every array currenty considered. Here, <script type=\"math/tex; mode=display\">n</script> refers to the number of arrays in the <script type=\"math/tex; mode=display\">list</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant extra space is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-single-scan-accepted\">Approach #3 Single Scan [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>As discussed already, in order to find out the maximum distance between any two arrays, we need not compare every element of the arrays, since the arrays are already sorted. Thus, we can consider only the extreme points in the arrays to do the distance calculations.</p> \n  <p>Further, the two points being considered for the distance calculation should not both belong to the same array. Thus, for arrays <script type=\"math/tex; mode=display\">a</script> and <script type=\"math/tex; mode=display\">b</script> currently chosen, we can just find the maximum out of <script type=\"math/tex; mode=display\">a[n-1]-b[0]</script> and <script type=\"math/tex; mode=display\">b[m-1]-a[0]</script> to find the larger distance. Here, <script type=\"math/tex; mode=display\">n</script> and <script type=\"math/tex; mode=display\">m</script> refer to the lengths of arrays <script type=\"math/tex; mode=display\">a</script> and <script type=\"math/tex; mode=display\">b</script> respectively. </p> \n  <p>But, we need not compare all the array pairs possible to find the maximum distance. Instead, we can keep on traversing over the arrays in the <script type=\"math/tex; mode=display\">list</script> and keep a track of the maximum distance found so far. </p> \n  <p>To do so, we keep a track of the element with minimum value(<script type=\"math/tex; mode=display\">min\\_val</script>) and the one with maximum value(<script type=\"math/tex; mode=display\">max\\_val</script>) found so far. Thus, now these extreme values can be treated as if they represent the extreme points of a cumulative array of all the arrays that have been considered till now. </p> \n  <p>For every new array, <script type=\"math/tex; mode=display\">a</script> considered, we find the distance <script type=\"math/tex; mode=display\">a[n-1]-min\\_val</script> and <script type=\"math/tex; mode=display\">max\\_val - a[0]</script> to compete with the maximum distance found so far. Here, <script type=\"math/tex; mode=display\">n</script> refers to the number of elements in the current array, <script type=\"math/tex; mode=display\">a</script>. Further, we need to note that the maximum distance found till now needs not always be contributed by the end points of the distance being <script type=\"math/tex; mode=display\">max\\_val</script> and <script type=\"math/tex; mode=display\">min\\_val</script>. </p> \n  <p>But, such points could help in maximizing the distance in the future. Thus, we need to keep track of these maximum and minimum values along with the maximum distance found so far for future calculations. But, in general, the final maximum distance found will always be determined by one of these extreme values, <script type=\"math/tex; mode=display\">max\\_val</script> and <script type=\"math/tex; mode=display\">min\\_val</script>, or in some cases, by both of them.</p> \n  <p>The following animation illustrates the process.</p> \n  <p>!?!../Documents/624_Maximum_Distance.json:1000,563!?!</p> \n  <p>From the above illustration, we can clearly see that although the <script type=\"math/tex; mode=display\">max\\_val</script> or <script type=\"math/tex; mode=display\">min\\_val</script> could not contribute to the local maximum distance values, they could later on contribute to the maximum distance.</p> \n  <iframe src=\"https://leetcode.com/playground/tiaZo26H/shared\" frameborder=\"0\" name=\"tiaZo26H\" width=\"100%\" height=\"241\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. We traverse over the <script type=\"math/tex; mode=display\">list</script> of length <script type=\"math/tex; mode=display\">n</script> once only.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant extra space is used.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 623,
    "article_live": true,
    "article_slug": "add-one-row-in-a-tree",
    "title": "Add One Row to Tree",
    "title_slug": "add-one-row-to-tree",
    "content": "<p>Given the root of a binary tree, then value <code>v</code> and depth <code>d</code>, you need to add a row of nodes with value <code>v</code> at the given depth <code>d</code>. The root node is at depth 1. </p>\r\n\r\n<p>The adding rule is: given a positive integer depth <code>d</code>, for each NOT null tree nodes <code>N</code> in depth <code>d-1</code>, create two tree nodes with value <code>v</code> as <code>N's</code> left subtree root and right subtree root. And <code>N's</code> <b>original left subtree</b> should be the left subtree of the new left subtree root, its <b>original right subtree</b> should be the right subtree of the new right subtree root. If depth <code>d</code> is 1 that means there is no depth d-1 at all, then create a tree node with value <b>v</b> as the new root of the whole original tree, and the original tree is the new root's left subtree.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\nA binary tree as following:\r\n       4\r\n     /   \\\r\n    2     6\r\n   / \\   / \r\n  3   1 5   \r\n\r\n<b>v = 1</b>\r\n\r\n<b>d = 2</b>\r\n\r\n<b>Output:</b> \r\n       4\r\n      / \\\r\n     1   1\r\n    /     \\\r\n   2       6\r\n  / \\     / \r\n 3   1   5   \r\n\r\n</pre>\r\n</p>\r\n\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\nA binary tree as following:\r\n      4\r\n     /   \r\n    2    \r\n   / \\   \r\n  3   1    \r\n\r\n<b>v = 1</b>\r\n\r\n<b>d = 3</b>\r\n\r\n<b>Output:</b> \r\n      4\r\n     /   \r\n    2\r\n   / \\    \r\n  1   1\r\n /     \\  \r\n3       1\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The given d is in range [1, maximum depth of the given tree + 1].</li>\r\n<li>The given binary tree has at least one tree node.</li>\r\n</ol>\r\n</p>",
    "tags": "Tree",
    "difficulty": 2,
    "frontend_article_id": 623,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-using-recursiondfs-accepted\">Approach #1 Using Recursion(DFS) [Accepted]</a></li> \n      <li><a href=\"#approach-2-using-stackdfs-accepted\">Approach #2 Using stack(DFS) [Accepted]</a></li> \n      <li><a href=\"#approach-3-using-queuebfs-accepted\">Approach #3 Using queue(BFS) [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-using-recursiondfs-accepted\">Approach #1 Using Recursion(DFS) [Accepted]</h4> \n  <p>If the given depth <script type=\"math/tex; mode=display\">d</script> happens to be equal to 1, we can directly put the whole current tree as a left child of the newly added node. Otherwise, we need to put the new node at appropriate levels. </p> \n  <p>To do so, we make use of a recursive function <code>insert(val,node,depth,n)</code>. Here, <script type=\"math/tex; mode=display\">val</script> refers to the value of the new node to be inserted, <script type=\"math/tex; mode=display\">depth</script> refers to the depth of the node currently considered, <script type=\"math/tex; mode=display\">node</script> refers to the node calling the current function for its child subtrees and <script type=\"math/tex; mode=display\">n</script> refers to the height at which the new node needs to be inserted. </p> \n  <p>For inserting the new node at appropriate level, we can start by making a call to <code>insert</code> with the root node and 1 as the current level. Inside every such call, we check if we've reached one level prior to the level where the new node needs to be inserted. </p> \n  <p>From this level, we can store the roots of the left and right subtrees of the current node temporarily, and insert the new node as the new left and right subchild of the current node, with the temporarily stored left and right subtrees as the left and right subtrees of the newly inserted left or right subchildren appropriately.</p> \n  <p>But, if we haven't reached the destined level, we keep on continuing the recursive calling process with the left and right children of the current node respectively. At every such call, we also incrmenet the depth of the current level to reflect the depth change appropriately.</p> \n  <p>The animation below illustrates the process:</p> \n  <p>!?!../Documents/623_Add_One_Row_Recursion_New.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/mqAnMFzQ/shared\" frameborder=\"0\" name=\"mqAnMFzQ\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. A total of <script type=\"math/tex; mode=display\">n</script> nodes of the given tree will be considered.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The depth of the recursion tree can go upto <script type=\"math/tex; mode=display\">n</script> in the worst case(skewed tree).</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-using-stackdfs-accepted\">Approach #2 Using stack(DFS) [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>We can do the same task as discussed in the last approach by making use of a <script type=\"math/tex; mode=display\">stack</script> as well. But, we need to make use of a new data structure, <script type=\"math/tex; mode=display\">Node</script> here, to keep a track of the depth of the current node along with its value. </p> \n  <p>We start by pushing the root <script type=\"math/tex; mode=display\">Node</script> onto the <script type=\"math/tex; mode=display\">stack</script>. Then, at every step we do as follows:</p> \n  <ul> \n   <li> <p>Pop an element from the <script type=\"math/tex; mode=display\">stack</script>. </p> </li> \n   <li> <p>For every Node popped, check if its depth corresponds to one prior to the depth at which the new node needs to be inserted. </p> </li> \n   <li> <p>If yes, insert the new nodes appropriately as in the last approach. </p> </li> \n   <li> <p>If no, we push both the left and the right child Node(value+depth) of the current node onto the <script type=\"math/tex; mode=display\">stack</script>. </p> </li> \n   <li> <p>Continue the popping and pushing process till the <script type=\"math/tex; mode=display\">stack</script> becomes empty.</p> </li> \n  </ul> \n  <p>Look at the animation below for a better understanding.</p> \n  <p>!?!../Documents/623_Add_One_Row_Stack_new.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/6Gut8kVG/shared\" frameborder=\"0\" name=\"6Gut8kVG\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. A total of <script type=\"math/tex; mode=display\">n</script> nodes of the given tree will be considered.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The depth of the <script type=\"math/tex; mode=display\">stack</script> can go upto <script type=\"math/tex; mode=display\">n</script> in the worst case(skewed tree).</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-using-queuebfs-accepted\">Approach #3 Using queue(BFS) [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>The idea of traversal in the last approach is similar to Depth First Search. In that case, we need to traverse through all the nodes of the given tree in the order of branches. Firstly we explored one branch to as much depth as possible and then continued with the other ones. </p> \n  <p>If, instead, we go for Breadth First Search, along with keeping track of the depth of the nodes being considered at any moment during the Breadth First Search, we can stop the search process as soon as all the nodes at the depth <script type=\"math/tex; mode=display\">d - 1</script> have been considered once. </p> \n  <p>To implement this BFS, we make use of a <script type=\"math/tex; mode=display\">queue</script>. We start off by pushing the root node of the given tree at the back of the <script type=\"math/tex; mode=display\">queue</script> and with the depth of the current level set as 1. Then, at every step, we do the following:</p> \n  <ul> \n   <li> <p>Remove an element from the front of the <script type=\"math/tex; mode=display\">queue</script> and add all its children to the back of another temporary queue, <script type=\"math/tex; mode=display\">temp</script>. </p> </li> \n   <li> <p>Keep on adding the elements to the back of the <script type=\"math/tex; mode=display\">temp</script> till <script type=\"math/tex; mode=display\">queue</script> becomes empty. (Once <script type=\"math/tex; mode=display\">queue</script> becomes empty, it indicates that all the nodes at the current level have been considered and now <script type=\"math/tex; mode=display\">temp</script> contains all the nodes lying at the next level).</p> </li> \n   <li> <p>Reinitialize <script type=\"math/tex; mode=display\">queue</script> with its value as <script type=\"math/tex; mode=display\">temp</script>. Update the current value of the <script type=\"math/tex; mode=display\">depth</script> to reflect the level of nodes currently being considered. </p> </li> \n   <li> <p>Repeat the process till we reach the depth <script type=\"math/tex; mode=display\">d - 1</script>. </p> </li> \n   <li> <p>On hitting this depth level(<script type=\"math/tex; mode=display\">d-1</script>), add the new nodes appropriately to all the nodes in the <script type=\"math/tex; mode=display\">queue</script> currently, as done in the previous approaches.</p> </li> \n  </ul> \n  <p>The following animation illustrates the process.</p> \n  <p>!?!../Documents/623_Add_One_Row_queue_new.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/EC8ne3QM/shared\" frameborder=\"0\" name=\"EC8ne3QM\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. A total of <script type=\"math/tex; mode=display\">n</script> nodes of the given tree will be considered in the worst case.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(x)</script>. The size of the <script type=\"math/tex; mode=display\">queue</script> or <script type=\"math/tex; mode=display\">temp</script> queue can grow upto <script type=\"math/tex; mode=display\">x</script> only. Here, <script type=\"math/tex; mode=display\">x</script> refers to the number of maximum number of nodes at any level in the given tree.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 621,
    "article_live": true,
    "article_slug": "task-scheduler",
    "title": "Task Scheduler",
    "title_slug": "task-scheduler",
    "content": "<p>Given a char array representing tasks CPU need to do. It contains capital letters A to Z where different letters represent different tasks.Tasks could be done without original order. Each task could be done in one interval. For each interval, CPU could finish one task or just be idle.</p>\r\n\r\n<p>However, there is a non-negative cooling interval <b>n</b> that means between two <b>same tasks</b>, there must be at least n intervals that CPU are doing different tasks or just be idle.</p>\r\n\r\n<p>You need to return the <b>least</b> number of intervals the CPU will take to finish all the given tasks.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Example:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> tasks = [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n = 2\r\n<b>Output:</b> 8\r\n<b>Explanation:</b> A -&gt; B -&gt; idle -&gt; A -&gt; B -&gt; idle -&gt; A -&gt; B.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Note:</b></p>\r\n\r\n<ol>\r\n\t<li>The number of tasks is in the range [1, 10000].</li>\r\n\t<li>The integer n is in the range [0, 100].</li>\r\n</ol>\r\n",
    "tags": "Array, Greedy, Queue",
    "difficulty": 2,
    "frontend_article_id": 621,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-using-sorting-accepted\">Approach #1 Using Sorting [Accepted]</a></li> \n      <li><a href=\"#approach-2-using-priority-queue-accepted\">Approach #2 Using Priority-Queue [Accepted]</a></li> \n      <li><a href=\"#approach-3-calculating-idle-slots-accepted\">Approach #3 Calculating Idle slots [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-using-sorting-accepted\">Approach #1 Using Sorting [Accepted]</h4> \n  <p>Before we start off with the solution, we can note that the names of the tasks are irrelevant for obtaining the solution of the given problem. The time taken for the tasks to be finished is only dependent on the number of instances of each task and not on the names of tasks. </p> \n  <p>The first solution that comes to the mind is to consider the tasks to be executed in the descending order of their number of instances. For every task executed, we can keep a track of the time at which this task was executed in order to consider the impact of cooling time in the future. We can execute all the tasks in the descending order of their number of instances and can keep on updating the number of instances pending for each task as well. After one cycle of the task list is executed, we can again start with the first task(largest count of instances) and keep on continuing the process by inserting idle cycles wherever appropriate by considering the last execution time of the task and the cooling time as well. </p> \n  <p>But, there is a flaw in the above idea. Consider the case, where say the number of instances of tasks A, B, C, D, E are 6, 1, 1, 1, 1 respectively with n=2(cooling time). If we go by the above method, firstly we give 1 round to each A, B, C, D and E. Now, only 5 instances of A are pending, but each instance will take 3 time units to complete because of cooling time. But a better way to schedule the tasks will be this: A, B, C, A, D, E, ... . In this way, by giving turn to the task A as soon as its cooling time is over, we can save a good number of clock cycles.</p> \n  <p>From the above example, we are clear with one idea. It is that, the tasks with the currently maximum number of outstanding (pending)instances will contribute to a large number of idle cycles in the future, if not executed with appropriate interleavings with the other tasks. Thus, we need to re-execute such a task as soon as its cooling time is finished. </p> \n  <p>Thus, based on the above ideas, firstly, we obtain a count of the number of instances of each task in <script type=\"math/tex; mode=display\">map</script> array. Then, we start executing the tasks in the order of descending number of their initial instances. As soon as we execute the first task, we start its cooling timer as well(<script type=\"math/tex; mode=display\">i</script>). For every task executed, we update the pending number of instances of the current task. We update the current time, <script type=\"math/tex; mode=display\">time</script>, at every instant as well. Now, as soon as the timer, <script type=\"math/tex; mode=display\">i</script>'s value exceeds the cooling time, as discussed above, we again need to consider the task with the largest number of pending instances. Thus, we again sort the <script type=\"math/tex; mode=display\">tasks</script> array with updated counts of instances and again pick up the tasks in the descending order of their number of instances. </p> \n  <p>Now, the task picked up first after the sorting, will either be the first task picked up in the last iteration(which will now be picked after its cooling time has been finished) or the task picked will be the one which lies at <script type=\"math/tex; mode=display\">(n+1)^{th}</script> position in the previous descending <script type=\"math/tex; mode=display\">tasks</script> array. In either of the cases, the cooling time won't cause any conflicts(it has been considered implicitly). Further, the task most critical currently will always be picked up which was the main requirement.</p> \n  <p>We stop this process, when the pending instances of all the tasks have been reduced to 0. At this moment, <script type=\"math/tex; mode=display\">time</script> gives the required result.</p> \n  <iframe src=\"https://leetcode.com/playground/MxzSpcHY/shared\" frameborder=\"0\" name=\"MxzSpcHY\" width=\"100%\" height=\"428\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(time)</script>. Number of iterations will be equal to resultant time <script type=\"math/tex; mode=display\">time</script>. </p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant size array <script type=\"math/tex; mode=display\">map</script> is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-using-priority-queue-accepted\">Approach #2 Using Priority-Queue [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Instead of making use of sorting as done in the last approach, we can also make use of a Max-Heap(<script type=\"math/tex; mode=display\">queue</script>) to pick the order in which the tasks need to be executed. But we need to ensure that the heapification occurs only after the intervals of cooling time, <script type=\"math/tex; mode=display\">n</script>, as done in the last approach.</p> \n  <p>To do so, firstly, we put only those elements from <script type=\"math/tex; mode=display\">map</script> into the <script type=\"math/tex; mode=display\">queue</script> which have non-zero number of instances. Then, we start picking up the largest task from the <script type=\"math/tex; mode=display\">queue</script> for current execution. (Again, at every instant, we update the current <script type=\"math/tex; mode=display\">time</script> as well.) We pop this element from the <script type=\"math/tex; mode=display\">queue</script>. We also decrement its pending number of instances and if any more instances of the current task are pending, we store them(count) in a temporary <script type=\"math/tex; mode=display\">temp</script> list, to be added later on back into the <script type=\"math/tex; mode=display\">queue</script>. We keep on doing so, till a cycle of cooling time has been finished. After every such cycle, we add the generated <script type=\"math/tex; mode=display\">temp</script> list back to the <script type=\"math/tex; mode=display\">queue</script> for considering the most critical task again. </p> \n  <p>We keep on doing so till the <script type=\"math/tex; mode=display\">queue</script>(and <script type=\"math/tex; mode=display\">temp</script>) become totally empty. At this instant, the current value of <script type=\"math/tex; mode=display\">time</script> gives the required result.</p> \n  <iframe src=\"https://leetcode.com/playground/cAjn8Sxo/shared\" frameborder=\"0\" name=\"cAjn8Sxo\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Number of iterations will be equal to resultant time <script type=\"math/tex; mode=display\">time</script>. </p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. <script type=\"math/tex; mode=display\">queue</script> and <script type=\"math/tex; mode=display\">temp</script> size will not exceed O(26).</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-calculating-idle-slots-accepted\">Approach #3 Calculating Idle slots [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>This approach is inpired by <a href=\"https://leetcode.com/zhanzq\">@zhanzq</a></p> \n  <p>If we are able to, somehow, determine the number of idle slots(<script type=\"math/tex; mode=display\">idle\\_slots</script>), we can find out the time required to execute all the tasks as <script type=\"math/tex; mode=display\">idle\\_slots + Total Number Of Tasks</script>. Thus, the idea is to find out the idle time first.</p> \n  <p>To find the idle time, consider figure 1 below.</p> \n  <p align=\"align\"><img alt=\"Tasks\" src=\"../Figures/621_Task_Scheduler_new.PNG\"></p> \n  <p>From this figure, we can observe that the maximum number of idle slots will always be given by the product of the cooling time and the number of instances of the task with maximum count less 1(in case only multiple instances of the same task need to be executed, and each, then, is executed after lapse of every cooling time). The factor of 1 is deducted from the task's count with maximum number of instances, as is clear from the figure, is that in the last round of execution of the tasks, the idle slots need not be considered for insertion following the execution of the related task. Now, based on the count of the instances of the other tasks, we can reduce the number of idle slots from this maximum value, to determine the minimum number of idle slots needed.</p> \n  <p>To do so, consider figure 2 as shown above. From the figure above, assuming the tasks are executed in row-wise order, we can see that in case the number of instances of another task equal the number of instances of the task with maximum number of instances, the number of idle slots saved is equal to its number of instances less 1 as is clear for the case of task B above. But, if the count of the number of instances, say <script type=\"math/tex; mode=display\">i</script> is lesser than the this maximum value, the number of idle slots saved is equal to the value <script type=\"math/tex; mode=display\">i</script> itself as is clear for the case of task C. Further, we can observe that for any arbitrary task other than A, B or C with the count of number of instances lesser than C, this task can be easily accomodated into the idle slots or if no more idle slot is available, this task can be appended after every row of tasks without interfering with the cooling time. In the first case, subtracting its number of intances from the number of idle slots leads to obtaining the correct number of available idle slots. In the second case, which will only occur if the number of idle slots pending is already zero, it leads to negative net idle slots, which can later be considered as zero for the purpose of calculations.</p> \n  <p>Thus, we can easily obtain the number of pending idle slots by subtracting appropriate number of slots from the available ones and at the end, we can obtain the total time required as the sum of pending idle slots and the total number of tasks.</p> \n  <iframe src=\"https://leetcode.com/playground/jC8vicao/shared\" frameborder=\"0\" name=\"jC8vicao\" width=\"100%\" height=\"275\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. We iterate over <script type=\"math/tex; mode=display\">tasks</script> array only once. (<script type=\"math/tex; mode=display\">O(n)</script>).Sorting <script type=\"math/tex; mode=display\">tasks</script> array of length <script type=\"math/tex; mode=display\">n</script> takes <script type=\"math/tex; mode=display\">O\\big(26log(26)\\big)= O(1)</script> time. After this, only one iteration over 26 elements of <script type=\"math/tex; mode=display\">map</script> is done(<script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. <script type=\"math/tex; mode=display\">map</script> array of constant size(26) is used.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 617,
    "article_live": true,
    "article_slug": "merge-two-binary-trees",
    "title": "Merge Two Binary Trees",
    "title_slug": "merge-two-binary-trees",
    "content": "<p>Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.</p>\r\n\r\n<p>You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.</p>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> \r\n\tTree 1                     Tree 2                  \r\n          1                         2                             \r\n         / \\                       / \\                            \r\n        3   2                     1   3                        \r\n       /                           \\   \\                      \r\n      5                             4   7                  \r\n<b>Output:</b> \r\nMerged tree:\r\n\t     3\r\n\t    / \\\r\n\t   4   5\r\n\t  / \\   \\ \r\n\t 5   4   7\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Note:</b> The merging process must start from the root nodes of both trees.</p>\r\n",
    "tags": "Tree",
    "difficulty": 1,
    "frontend_article_id": 617,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-using-recursion-accepted\">Approach #1 Using Recursion [Accepted]</a></li> \n      <li><a href=\"#approach-2-iterative-method-accepted\">Approach #2 Iterative Method [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-using-recursion-accepted\">Approach #1 Using Recursion [Accepted]</h4> \n  <p>We can traverse both the given trees in a preorder fashion. At every step, we check if the current node exists(isn't null) for both the trees. If so, we add the values in the current nodes of both the trees and update the value in the current node of the first tree to reflect this sum obtained. At every step, we also call the original function <code>mergeTrees()</code> with the left children and then with the right children of the current nodes of the two trees. If at any step, one of these children happens to be null, we return the child of the other tree(representing the corresponding child subtree) to be added as a child subtree to the calling parent node in the first tree. At the end, the first tree will represent the required resultant merged binary tree.</p> \n  <p>The following animation illustrates the process.</p> \n  <p>!?!../Documents/617_Merge_Trees_Recursion.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/d9nZDPEJ/shared\" frameborder=\"0\" name=\"d9nZDPEJ\" width=\"100%\" height=\"428\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(m)</script>. A total of <script type=\"math/tex; mode=display\">m</script> nodes need to be traversed. Here, <script type=\"math/tex; mode=display\">m</script> represents the minimum number of nodes from the two given trees.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(m)</script>. The depth of the recursion tree can go upto <script type=\"math/tex; mode=display\">m</script> in the case of a skewed tree. In average case, depth will be <script type=\"math/tex; mode=display\">O(logm)</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-iterative-method-accepted\">Approach #2 Iterative Method [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In the current approach, we again traverse the two trees, but this time we make use of a <script type=\"math/tex; mode=display\">stack</script> to do so instead of making use of recursion. Each entry in the <script type=\"math/tex; mode=display\">stack</script> strores data in the form <script type=\"math/tex; mode=display\">[node_{tree1}, node_{tree2}]</script>. Here, <script type=\"math/tex; mode=display\">node_{tree1}</script> and <script type=\"math/tex; mode=display\">node_{tree2}</script> are the nodes of the first tree and the second tree respectively.</p> \n  <p>We start off by pushing the root nodes of both the trees onto the <script type=\"math/tex; mode=display\">stack</script>. Then, at every step, we remove a node pair from the top of the stack. For every node pair removed, we add the values corresponding to the two nodes and update the value of the corresponding node in the first tree. Then, if the left child of the first tree exists, we push the left child(pair) of both the trees onto the stack. If the left child of the first tree doesn't exist, we append the left child(subtree) of the second tree to the current node of the first tree. We do the same for the right child pair as well. </p> \n  <p>If, at any step, both the current nodes are null, we continue with popping the next nodes from the <script type=\"math/tex; mode=display\">stack</script>.</p> \n  <p>The following animation depicts the process.</p> \n  <p>!?!../Documents/617_Merge_Trees_Stack.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/v2TK7i2x/shared\" frameborder=\"0\" name=\"v2TK7i2x\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. We traverse over a total of <script type=\"math/tex; mode=display\">n</script> nodes. Here, <script type=\"math/tex; mode=display\">n</script> refers to the smaller of the number of nodes in the two trees.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The depth of stack can grow upto <script type=\"math/tex; mode=display\">n</script> in case of a skewed tree.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 616,
    "article_live": true,
    "article_slug": "add-bold-tag-in-a-string",
    "title": "Add Bold Tag in String",
    "title_slug": "add-bold-tag-in-string",
    "tags": "String",
    "difficulty": 2,
    "frontend_article_id": 616,
    "article_content": ""
},
{
    "frontend_question_id": 611,
    "article_live": true,
    "article_slug": "valid-triangle-number",
    "title": "Valid Triangle Number",
    "title_slug": "valid-triangle-number",
    "content": "Given an array consists of non-negative integers,  your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [2,2,3,4]\r\n<b>Output:</b> 3\r\n<b>Explanation:</b>\r\nValid combinations are: \r\n2,3,4 (using the first 2)\r\n2,3,4 (using the second 2)\r\n2,2,3\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The length of the given array won't exceed 1000.</li>\r\n<li>The integers in the given array are in the range of [0, 1000].</li>\r\n</ol>\r\n</p>\r\n",
    "tags": "Array",
    "difficulty": 2,
    "frontend_article_id": 611,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-using-binary-search-accepted\">Approach #2 Using Binary Search [Accepted]</a></li> \n      <li><a href=\"#approach-3-linear-scan-accepted\">Approach #3 Linear Scan [Accepted]:</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</h4> \n  <p>The condition for the triplets <script type=\"math/tex; mode=display\">(a, b, c)</script> representing the lengths of the sides of a triangle, to form a valid triangle, is that the sum of any two sides should always be greater than the third side alone. i.e. <script type=\"math/tex; mode=display\">a + b > c</script>, <script type=\"math/tex; mode=display\">b + c > a</script>, <script type=\"math/tex; mode=display\">a + c > b</script>. </p> \n  <p>The simplest method to check this is to consider every possible triplet in the given <script type=\"math/tex; mode=display\">nums</script> array and checking if the triplet satisfies the three inequalities mentioned above. Thus, we can keep a track of the <script type=\"math/tex; mode=display\">count</script> of the number of triplets satisfying these inequalities. When all the triplets have been considered, the <script type=\"math/tex; mode=display\">count</script> gives the required result.</p> \n  <iframe src=\"https://leetcode.com/playground/gdURWBgv/shared\" frameborder=\"0\" name=\"gdURWBgv\" width=\"100%\" height=\"309\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^3)</script>. Three nested loops are there to check every triplet.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant space is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-using-binary-search-accepted\">Approach #2 Using Binary Search [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>If we sort the given <script type=\"math/tex; mode=display\">nums</script> array once, we can solve the given problem in a better way. This is because, if we consider a triplet <script type=\"math/tex; mode=display\">(a, b, c)</script> such that <script type=\"math/tex; mode=display\">a &leq; b &leq; c</script>, we need not check all the three inequalities for checking the validity of the triangle formed by them. But, only one condition <script type=\"math/tex; mode=display\">a + b > c</script> would suffice. This happens because <script type=\"math/tex; mode=display\">c &geq; b</script> and <script type=\"math/tex; mode=display\">c &geq; a</script>. Thus, adding any number to <script type=\"math/tex; mode=display\">c</script> will always produce a sum which is greater than either <script type=\"math/tex; mode=display\">a</script> or <script type=\"math/tex; mode=display\">b</script> considered alone. Thus, the inequalities <script type=\"math/tex; mode=display\">c + a > b</script> and <script type=\"math/tex; mode=display\">c + b > a</script> are satisfied implicitly by virtue of the property <script type=\"math/tex; mode=display\">a < b < c</script>.</p> \n  <p>From this, we get the idea that we can sort the given <script type=\"math/tex; mode=display\">nums</script> array. Then, for every pair <script type=\"math/tex; mode=display\">(nums[i], nums[j])</script> considered starting from the beginning of the array, such that <script type=\"math/tex; mode=display\">j > i</script>(leading to <script type=\"math/tex; mode=display\">nums[j] &geq; nums[i]</script>), we can find out the count of elements <script type=\"math/tex; mode=display\">nums[k]</script>(<script type=\"math/tex; mode=display\">k > j</script>), which satisfy the inequality <script type=\"math/tex; mode=display\">nums[k] > nums[i] + nums[j]</script>. We can do so for every pair <script type=\"math/tex; mode=display\">(i, j)</script> considered and get the required result.</p> \n  <p>We can also observe that, since we've sorted the <script type=\"math/tex; mode=display\">nums</script> array, as we traverse towards the right for choosing the index <script type=\"math/tex; mode=display\">k</script>(for number <script type=\"math/tex; mode=display\">nums[k]</script>), the value of <script type=\"math/tex; mode=display\">nums[k]</script> could increase or remain the same(doesn't decrease relative to the previous value). Thus, there will exist a right limit on the value of index <script type=\"math/tex; mode=display\">k</script>, such that the elements satisfy <script type=\"math/tex; mode=display\">nums[k] > nums[i] + nums[j]</script>. Any elements beyond this value of <script type=\"math/tex; mode=display\">k</script> won't satisfy this inequality as well, which is obvious.</p> \n  <p>Thus, if we are able to find this right limit value of <script type=\"math/tex; mode=display\">k</script>(indicating the element just greater than <script type=\"math/tex; mode=display\">nums[i] + nums[j]</script>), we can conclude that all the elements in <script type=\"math/tex; mode=display\">nums</script> array in the range <script type=\"math/tex; mode=display\">(j+1, k-1)</script>(both included) satisfy the required inequality. Thus, the <script type=\"math/tex; mode=display\">count</script> of elements satisfying the inequality will be given by <script type=\"math/tex; mode=display\">(k-1) - (j+1) + 1 = k - j - 1</script>.</p> \n  <p>Since the <script type=\"math/tex; mode=display\">nums</script> array has been sorted now, we can make use of Binary Search to find this right limit of <script type=\"math/tex; mode=display\">k</script>. The following animation shows how Binary Search can be used to find the right limit for a simple example.</p> \n  <p>!?!../Documents/Valid_Triangle_Binary.json:1000,563!?!</p> \n  <p>Another point to be observed is that once we find a right limit index <script type=\"math/tex; mode=display\">k_{(i,j)}</script> for a particular pair <script type=\"math/tex; mode=display\">(i, j)</script> chosen, when we choose a higher value of <script type=\"math/tex; mode=display\">j</script> for the same value of <script type=\"math/tex; mode=display\">i</script>, we need not start searching for the right limit <script type=\"math/tex; mode=display\">k_{(i,j+1)}</script> from the index <script type=\"math/tex; mode=display\">j+2</script>. Instead, we can start off from the index <script type=\"math/tex; mode=display\">k_{(i,j)}</script> directly where we left off for the last <script type=\"math/tex; mode=display\">j</script> chosen. </p> \n  <p>This holds correct because when we choose a higher value of <script type=\"math/tex; mode=display\">j</script>(higher or equal <script type=\"math/tex; mode=display\">nums[j]</script> than the previous one), all the <script type=\"math/tex; mode=display\">nums[k]</script>, such that <script type=\"math/tex; mode=display\">k < k_{(i,j)}</script> will obviously satisfy <script type=\"math/tex; mode=display\">nums[i] + nums[j] > nums[k]</script> for the new value of <script type=\"math/tex; mode=display\">j</script> chosen.</p> \n  <p>By taking advantage of this observation, we can limit the range of Binary Search for <script type=\"math/tex; mode=display\">k</script> to shorter values for increasing values of <script type=\"math/tex; mode=display\">j</script> considered while choosing the pairs <script type=\"math/tex; mode=display\">(i, j)</script>.</p> \n  <iframe src=\"https://leetcode.com/playground/UpFbPxRd/shared\" frameborder=\"0\" name=\"UpFbPxRd\" width=\"100%\" height=\"462\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^2logn)</script>. In worst case inner loop will take <script type=\"math/tex; mode=display\">nlogn</script> (binary search applied <script type=\"math/tex; mode=display\">n</script> times).</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(logn)</script>. Sorting takes <script type=\"math/tex; mode=display\">O(logn)</script> space.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-linear-scan-accepted\">Approach #3 Linear Scan [Accepted]:</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>As discussed in the last approach, once we sort the given <script type=\"math/tex; mode=display\">nums</script> array, we need to find the right limit of the index <script type=\"math/tex; mode=display\">k</script> for a pair of indices <script type=\"math/tex; mode=display\">(i, j)</script> chosen to find the <script type=\"math/tex; mode=display\">count</script> of elements satisfying <script type=\"math/tex; mode=display\">nums[i] + nums[j] > nums[k]</script> for the triplet <script type=\"math/tex; mode=display\">(nums[i], nums[j], nums[k])</script> to form a valid triangle. </p> \n  <p>We can find this right limit by simply traversing the index <script type=\"math/tex; mode=display\">k</script>'s values starting from the index <script type=\"math/tex; mode=display\">k=j+1</script> for a pair <script type=\"math/tex; mode=display\">(i, j)</script> chosen and stopping at the first value of <script type=\"math/tex; mode=display\">k</script> not satisfying the above inequality. Again, the <script type=\"math/tex; mode=display\">count</script> of elements <script type=\"math/tex; mode=display\">nums[k]</script> satisfying <script type=\"math/tex; mode=display\">nums[i] + nums[j] > nums[k]</script> for the pair of indices <script type=\"math/tex; mode=display\">(i, j)</script> chosen is given by <script type=\"math/tex; mode=display\">k - j - 1</script> as discussed in the last approach.</p> \n  <p>Further, as discussed in the last approach, when we choose a higher value of index <script type=\"math/tex; mode=display\">j</script> for a particular <script type=\"math/tex; mode=display\">i</script> chosen, we need not start from the index <script type=\"math/tex; mode=display\">j + 1</script>. Instead, we can start off directly from the value of <script type=\"math/tex; mode=display\">k</script> where we left for the last index <script type=\"math/tex; mode=display\">j</script>. This helps to save redundant computations.</p> \n  <p>The following animation depicts the process:</p> \n  <p>!?!../Documents/Valid_Triangle_Linear.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/GW5LZ3tx/shared\" frameborder=\"0\" name=\"GW5LZ3tx\" width=\"100%\" height=\"309\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^2)</script>. Loop of <script type=\"math/tex; mode=display\">k</script> and <script type=\"math/tex; mode=display\">j</script> will be executed <script type=\"math/tex; mode=display\">O(n^2)</script> times in total, because, we do not reinitialize the value of <script type=\"math/tex; mode=display\">k</script> for a new value of <script type=\"math/tex; mode=display\">j</script> chosen(for the same <script type=\"math/tex; mode=display\">i</script>). Thus the complexity will be O(n^2+n^2)=O(n^2).</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(logn)</script>. Sorting takes O(logn) space.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 609,
    "article_live": true,
    "article_slug": "find-duplicate",
    "title": "Find Duplicate File in System",
    "title_slug": "find-duplicate-file-in-system",
    "content": "<p>Given a list of directory info including directory path, and all the files with contents in this directory, you need to find out all the groups of duplicate files in the file system in terms of their paths.</p>\r\n\r\n<p>A group of duplicate files consists of at least <b>two</b> files that have exactly the same content.</p>\r\n\r\n<p>A single directory info string in the <b>input</b> list has the following format: </p>\r\n<p><code>\"root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)\"</code><br></p>\r\n<p>It means there are <b>n</b> files (<code>f1.txt</code>, <code>f2.txt</code> ... <code>fn.txt</code> with content <code>f1_content</code>, <code>f2_content</code> ... <code>fn_content</code>, respectively) in directory <code>root/d1/d2/.../dm</code>. Note that n >= 1 and m >= 0. If m = 0, it means the directory is just the root directory.</p>\r\n\r\n<p>The <b>output</b> is a list of group of duplicate file paths. For each group, it contains all the file paths of the files that have the same content. A file path is a string that has the following format: </p>\r\n<p><code>\"directory_path/file_name.txt\"</code></p>\r\n\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b>\r\n[\"root/a 1.txt(abcd) 2.txt(efgh)\", \"root/c 3.txt(abcd)\", \"root/c/d 4.txt(efgh)\", \"root 4.txt(efgh)\"]\r\n<b>Output:</b>  \r\n[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]\r\n</pre>\r\n</p>\r\n\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>No order is required for the final output.</li>\r\n<li>You may assume the directory name, file name and file content only has letters and digits, and the length of file content is in the range of [1,50].</li>\r\n<li>The number of files given is in the range of [1,20000].</li>\r\n<li>You may assume no files or directories share the same name in the same directory.</li>\r\n<li>You may assume each given directory info represents a unique directory. Directory path and file info are separated by a single blank space.</li>\r\n</ol>\r\n</p>\r\n\r\n\r\n<b>Follow-up beyond contest:</b> \r\n<ol>\r\n<li> Imagine you are given a real file system, how will you search files? DFS or BFS?</li>\r\n<li> If the file content is very large (GB level), how will you modify your solution?</li>\r\n<li> If you can only read the file by 1kb each time, how will you modify your solution?</li>\r\n<li> What is the time complexity of your modified solution? What is the most time-consuming part and memory consuming part of it? How to optimize?</li>\r\n<li> How to make sure the duplicated files you find are not false positive?</li>\r\n</ol>",
    "tags": "Hash Table, String",
    "difficulty": 2,
    "frontend_article_id": 609,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-using-hashmap-accepted\">Approach #2 Using HashMap [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>For the brute force solution, firstly we obtain the directory paths, the filenames and file contents separately by appropriately splitting the elements of the <script type=\"math/tex; mode=display\">paths</script> list. While doing so, we keep on creating a <script type=\"math/tex; mode=display\">list</script> which contains the full path of every file along with the contents of the file. The <script type=\"math/tex; mode=display\">list</script> contains data in the form <script type=\"math/tex; mode=display\">[ [file_1\\_full\\_path, file_1\\_contents], [file_2\\_full\\_path, file_2\\_contents]..., [file_n\\_full\\_path, file_n\\_contents] ]</script>.</p> \n  <p>Once this is done, we iterate over this <script type=\"math/tex; mode=display\">list</script>. For every element <script type=\"math/tex; mode=display\">i</script> chosen from the list, we iterate over the whole <script type=\"math/tex; mode=display\">list</script> to find another element <script type=\"math/tex; mode=display\">j</script> whose file contents are the same as the <script type=\"math/tex; mode=display\">i^{th}</script> element. For every such element found, we put the <script type=\"math/tex; mode=display\">j^{th}</script> element's file path in a temporary list <script type=\"math/tex; mode=display\">l</script> and we also mark the <script type=\"math/tex; mode=display\">j^{th}</script> element as visited so that this element isn't considered again in the future. Thus, when we reach the end of the array for every <script type=\"math/tex; mode=display\">i^{th}</script> element, we obtain a list of file paths in <script type=\"math/tex; mode=display\">l</script>, which have the same contents as the file corresponding to the <script type=\"math/tex; mode=display\">i^{th}</script> element. If this list isn't empty, it indicates that there exists content duplicate to the <script type=\"math/tex; mode=display\">i^{th}</script> element. Thus, we also need to put the <script type=\"math/tex; mode=display\">i^{th}</script> element's file path in the <script type=\"math/tex; mode=display\">l</script>. </p> \n  <p>At the end of each iteration, we put this list <script type=\"math/tex; mode=display\">l</script> obtained in the resultant list <script type=\"math/tex; mode=display\">res</script> and reset the list <script type=\"math/tex; mode=display\">l</script> for finding the duplicates of the next element.</p> \n  <iframe src=\"https://leetcode.com/playground/P5yYSqFy/shared\" frameborder=\"0\" name=\"P5yYSqFy\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n*x + f^2*s)</script>. Creation of <script type=\"math/tex; mode=display\">list</script> will take <script type=\"math/tex; mode=display\">O(n*x)</script>, where n is the number of directories and x is the average string length. Every file is compared with every other file. Let <script type=\"math/tex; mode=display\">f</script> files are there with average size of <script type=\"math/tex; mode=display\">s</script>, then files comparision will take <script type=\"math/tex; mode=display\">O(f^2*s)</script>, equals can take <script type=\"math/tex; mode=display\">O(s)</script>. Here, Worst case will be when all files are unique.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n*x)</script>. Size of lists <script type=\"math/tex; mode=display\">res</script> and <script type=\"math/tex; mode=display\">list</script> can grow upto <script type=\"math/tex; mode=display\">n*x</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-using-hashmap-accepted\">Approach #2 Using HashMap [Accepted]</h4> \n  <p>In this approach, firstly we obtain the directory paths, the file names and their contents separately by appropriately splitting each string in the given <script type=\"math/tex; mode=display\">paths</script> list. In order to find the files with duplicate contents, we make use of a HashMap <script type=\"math/tex; mode=display\">map</script>, which stores the data in the form <script type=\"math/tex; mode=display\">(contents, list\\_of\\_file\\_paths\\_with\\_this\\_content)</script>. Thus, for every file's contents, we check if the same content already exist in the hashmap. If so, we add the current file's path to the list of files corresponding to the current contents. Otherwise, we create a new entry in the <script type=\"math/tex; mode=display\">map</script>, with the current contents as the key and the value being a list with only one entry(the current file's path).</p> \n  <p>At the end, we find out the contents corresponding to which atleast two file paths exist. We obtain the resultant list <script type=\"math/tex; mode=display\">res</script>, which is a list of lists containing these file paths corresponding to the same contents.</p> \n  <p>The following animation illustrates the process for a clearer understanding.</p> \n  <p>!?!../Documents/609_Find_Duplicate.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/9pU24YeR/shared\" frameborder=\"0\" name=\"9pU24YeR\" width=\"100%\" height=\"428\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n*x)</script>. <script type=\"math/tex; mode=display\">n</script> strings of average length <script type=\"math/tex; mode=display\">x</script> is parsed.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n*x)</script>. <script type=\"math/tex; mode=display\">map</script> and <script type=\"math/tex; mode=display\">res</script> size grows upto <script type=\"math/tex; mode=display\">n*x</script>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 606,
    "article_live": true,
    "article_slug": "construct-string-from-binary-tree",
    "title": "Construct String from Binary Tree",
    "title_slug": "construct-string-from-binary-tree",
    "content": "<p>You need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way.</p>\r\n\r\n<p>The null node needs to be represented by empty parenthesis pair \"()\". And you need to omit all the empty parenthesis pairs that don't affect the one-to-one mapping relationship between the string and the original binary tree.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> Binary tree: [1,2,3,4]\r\n       1\r\n     /   \\\r\n    2     3\r\n   /    \r\n  4     \r\n\r\n<b>Output:</b> \"1(2(4))(3)\"\r\n<br/><b>Explanation:</b> Originallay it needs to be \"1(2(4)())(3()())\", <br/>but you need to omit all the unnecessary empty parenthesis pairs. <br/>And it will be \"1(2(4))(3)\".\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> Binary tree: [1,2,3,null,4]\r\n       1\r\n     /   \\\r\n    2     3\r\n     \\  \r\n      4 \r\n\r\n<b>Output:</b> \"1(2()(4))(3)\"\r\n<br/><b>Explanation:</b> Almost the same as the first example, <br/>except we can't omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output.\r\n</pre>\r\n</p>",
    "tags": "String, Tree",
    "difficulty": 1,
    "frontend_article_id": 606,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-using-recursion-accepted\">Approach #1 Using Recursion [Accepted]</a></li> \n      <li><a href=\"#approach-2-iterative-method-using-stack-accepted\">Approach #2 Iterative Method Using stack [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-using-recursion-accepted\">Approach #1 Using Recursion [Accepted]</h4> \n  <p>This solution is very simple. We simply need to do the preorder traversal of the given Binary Tree. But, along with this, we need to make use of braces at appropriate positions. But, we also need to make sure that we omit the unnecessary braces. To do the preorder traversal, we make use of recursion. We print the current node and call the same given function for the left and the right children of the node in that order(if they exist). For every node encountered, the following cases are possible.</p> \n  <p>Case 1: Both the left child and the right child exist for the current node. In this case, we need to put the braces <code>()</code> around both the left child's preorder traversal output and the right child's preorder traversal output.</p> \n  <p>Case 2: None of the left or the right child exist for the current node. In this case, as shown in the figure below, considering empty braces for the null left and right children is redundant. Hence, we need not put braces for any of them.</p> \n  <p align=\"center\"><img alt=\"No_child\" src=\"../Figures/606/606_Case2.PNG\"></p> \n  <p>Case 3: Only the left child exists for the current node. As the figure below shows, putting empty braces for the right child in this case is unnecessary while considering the preorder traversal. This is because the right child will always come after the left child in the preorder traversal. Thus, omitting the empty braces for the right child also leads to same mapping between the string and the binary tree.</p> \n  <p align=\"center\"><img alt=\"Left_child\" src=\"../Figures/606/606_Case3.PNG\"></p> \n  <p>Case 4: Only the right child exists for the current node. In this case, we need to consider the empty braces for the left child. This is because, during the preorder traversal, the left child needs to be considered first. Thus, to indicate that the child following the current node is a right child we need to put a pair of empty braces for the left child. </p> \n  <p align=\"center\"><img alt=\"Right_child\" src=\"../Figures/606/606_Case4.PNG\"></p> \n  <p>Just by taking care of the cases, mentioned above, we can obtain the required output string.</p> \n  <iframe src=\"https://leetcode.com/playground/AQ3oFiCv/shared\" frameborder=\"0\" name=\"AQ3oFiCv\" width=\"100%\" height=\"411\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The preorder traversal is done over the <script type=\"math/tex; mode=display\">n</script> nodes of the given Binary Tree.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The depth of the recursion tree can go upto <script type=\"math/tex; mode=display\">n</script> in case of a skewed tree.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-iterative-method-using-stack-accepted\">Approach #2 Iterative Method Using stack [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In order to solve the given problem, we can also make use of a <script type=\"math/tex; mode=display\">stack</script>. To see how to do it, we'll go through the implementation and we'll also look at the idea behind each step.</p> \n  <p>We make use of a <script type=\"math/tex; mode=display\">stack</script> onto which various nodes of the given tree will be pushed during the process. The node at the top of the <script type=\"math/tex; mode=display\">stack</script> represents the current node to be processed. Whenever a node has been processed once, it is marked as visited. The reasoning behind this will be discussed soon. </p> \n  <p>We start off by pushing the root of the binary tree onto the <script type=\"math/tex; mode=display\">stack</script>. Now, the root acts as the current node. For every current node encountered, firstly, we check if it has not been visited already. If not, we add it to the set of visited nodes. </p> \n  <p>Since, for the preorder traversal, we know, we need to process the nodes in the order current-left-right. Thus, we add a <code>(</code> followed by the current node to the string <script type=\"math/tex; mode=display\">s</script> to be returned. </p> \n  <p>Now, if both the left and the right children of the current node exist, we need to process them in the order left-right. To do so, we need to push them onto the <script type=\"math/tex; mode=display\">stack</script> in the reverse order, so that when they are picked up later on, their order of processing gets corrected.</p> \n  <p>Since we've already added <script type=\"math/tex; mode=display\">(current\\_node</script> to the string <script type=\"math/tex; mode=display\">s</script>, if only the right child of the current node exists, as discussed in case 4 in the last approach, we need to put a <code>()</code> in <script type=\"math/tex; mode=display\">s</script> representing the null left node. We need not push anything onto the <script type=\"math/tex; mode=display\">stack</script> for the left node and we can directly add the <code>()</code> to <script type=\"math/tex; mode=display\">s</script> for this. But, we still need to push the right child onto the <script type=\"math/tex; mode=display\">stack</script> for future processing. </p> \n  <p>If only the left child exists, we need not consider the right child at all, as discussed in case 3 in the last approach. We can continue the process by just pushing the left child onto the <script type=\"math/tex; mode=display\">stack</script>.</p> \n  <p>Now, we need to note that even when a node is being processed, if it has not already been visited, it isn't popped off from the <script type=\"math/tex; mode=display\">stack</script>. But, if a node that has already been processed(i.e. its children have been considered already), it is popped off from the <script type=\"math/tex; mode=display\">stack</script> when encountered again. Such a situation will occur for a node only when the preorder traversal of both its left and right sub-trees has been completely done. Thus, we need to add a <code>)</code> to mark the end of the preorder traversal of the current node as well.</p> \n  <p>Thus, at the end, we get the required pre-order traversal in the substring <script type=\"math/tex; mode=display\">s(1:n-1)</script>. Here, <script type=\"math/tex; mode=display\">n</script> represents the length of <script type=\"math/tex; mode=display\">s</script>. This is because, we need not put the parentheses(redundant) at the outermost level.</p> \n  <p>The following animation better depicts the process.</p> \n  <p>!?!../Documents/Construct_Binary_Tree_stack.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/qvqkT2qU/shared\" frameborder=\"0\" name=\"qvqkT2qU\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. <script type=\"math/tex; mode=display\">n</script> nodes are pushed and popped in a stack.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. <script type=\"math/tex; mode=display\">stack</script> size can grow upto <script type=\"math/tex; mode=display\">n</script>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 605,
    "article_live": true,
    "article_slug": "can-place-flowers",
    "title": "Can Place Flowers",
    "title_slug": "can-place-flowers",
    "content": "<p>Suppose you have a long flowerbed in which some of the plots are planted and some are not. However, flowers cannot be planted in adjacent plots - they would compete for water and both would die.</p>\r\n\r\n<p>Given a flowerbed (represented as an array containing 0 and 1, where 0 means empty and 1 means not empty), and a number <b>n</b>, return if <b>n</b> new flowers can be planted in it without violating the no-adjacent-flowers rule.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> flowerbed = [1,0,0,0,1], n = 1\r\n<b>Output:</b> True\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> flowerbed = [1,0,0,0,1], n = 2\r\n<b>Output:</b> False\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The input array won't violate no-adjacent-flowers rule.</li>\r\n<li>The input array size is in the range of [1, 20000].</li>\r\n<li><b>n</b> is a non-negative integer which won't exceed the input array size.</li>\r\n</ol>\r\n</p>",
    "tags": "Array",
    "difficulty": 1,
    "frontend_article_id": 605,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-single-scan-accepted\">Approach #1 Single Scan [Accepted]</a></li> \n      <li><a href=\"#approach-2-optimized-accepted\">Approach #2 Optimized [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-single-scan-accepted\">Approach #1 Single Scan [Accepted]</h4> \n  <p>The solution is very simple. We can find out the extra maximum number of flowers, <script type=\"math/tex; mode=display\">count</script>, that can be planted for the given <script type=\"math/tex; mode=display\">flowerbed</script> arrangement. To do so, we can traverse over all the elements of the <script type=\"math/tex; mode=display\">flowerbed</script> and find out those elements which are 0(implying an empty position). For every such element, we check if its both adjacent positions are also empty. If so, we can plant a flower at the current position without violating the no-adjacent-flowers-rule. For the first and last elements, we need not check the previous and the next adjacent positions respectively.</p> \n  <p>If the <script type=\"math/tex; mode=display\">count</script> obtained is greater than or equal to <script type=\"math/tex; mode=display\">n</script>, the required number of flowers to be planted, we can plant <script type=\"math/tex; mode=display\">n</script> flowers in the empty spaces, otherwise not.</p> \n  <iframe src=\"https://leetcode.com/playground/Dbm5A5CN/shared\" frameborder=\"0\" name=\"Dbm5A5CN\" width=\"100%\" height=\"292\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. A single scan of the <script type=\"math/tex; mode=display\">flowerbed</script> array of size <script type=\"math/tex; mode=display\">n</script> is done.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant extra space is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-optimized-accepted\">Approach #2 Optimized [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Instead of finding the maximum value of <script type=\"math/tex; mode=display\">count</script> that can be obtained, as done in the last approach, we can stop the process of checking the positions for planting the flowers as soon as <script type=\"math/tex; mode=display\">count</script> becomes equal to <script type=\"math/tex; mode=display\">n</script>. Doing this leads to an optimization of the first approach. If <script type=\"math/tex; mode=display\">count</script> never becomes equal to <script type=\"math/tex; mode=display\">n</script>, <script type=\"math/tex; mode=display\">n</script> flowers can't be planted at the empty positions.</p> \n  <iframe src=\"https://leetcode.com/playground/GtCBiouS/shared\" frameborder=\"0\" name=\"GtCBiouS\" width=\"100%\" height=\"326\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. A single scan of the <script type=\"math/tex; mode=display\">flowerbed</script> array of size <script type=\"math/tex; mode=display\">n</script> is done.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant extra space is used.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 604,
    "article_live": true,
    "article_slug": "desing-compressed-string-iterator",
    "title": "Design Compressed String Iterator",
    "title_slug": "design-compressed-string-iterator",
    "tags": "Design",
    "difficulty": 1,
    "frontend_article_id": 604,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-uncompressing-the-string-time-limit-exceeded\">Approach #1 Uncompressing the String [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-pre-computation-accepted\">Approach #2 Pre-Computation [Accepted]</a></li> \n      <li><a href=\"#approach-3-demand-computation-accepted\">Approach #3 Demand-Computation [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <h4 id=\"approach-1-uncompressing-the-string-time-limit-exceeded\">Approach #1 Uncompressing the String [Time Limit Exceeded]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In this approach, we make use of precomputation. We already form the uncompressed string and append the uncompressed letters for each compressed letter in the <script type=\"math/tex; mode=display\">compressedString</script> to the <script type=\"math/tex; mode=display\">res</script> stringbuilder. To find the uncompressed strings to be stored in <script type=\"math/tex; mode=display\">res</script>, we traverse over the given <script type=\"math/tex; mode=display\">compressedString</script>. Whenver we find an alphabet, we find the number following it by making use of decimal mathematics. Thus, we get the two elements(alphabet and the count) required for forming the current constituent of the uncompressed string.</p> \n  <p>Now, we'll look at how the <code>next()</code> and <code>hasNext()</code> operations are performed:</p> \n  <ol> \n   <li> <p><code>next()</code>: We start off by checking if the compressed string has more uncompressed letters pending. If not, <code>hasNext()</code> returns a False value and <code>next()</code> returns a ' '. Otherwise, we return the letter pointed by <script type=\"math/tex; mode=display\">ptr</script>, which indicates the next letter to be returned. Before returning the letter, we also update the <script type=\"math/tex; mode=display\">ptr</script> to point to the next letter in <script type=\"math/tex; mode=display\">res</script>.</p> </li> \n   <li> <p><code>hasNext()</code>: If the pointer <script type=\"math/tex; mode=display\">ptr</script> reaches beyond the end of <script type=\"math/tex; mode=display\">res</script> array, it indicates that no more uncompressed letters are left beyond the current index pointed by <script type=\"math/tex; mode=display\">ptr</script>. Thus, we return a False in this case. Otherwise, we return a True value.</p> </li> \n  </ol> \n  <iframe src=\"https://leetcode.com/playground/fddFPkFm/shared\" frameborder=\"0\" name=\"fddFPkFm\" width=\"100%\" height=\"479\"></iframe> \n  <p><strong>Performance Analysis</strong></p> \n  <ul> \n   <li> <p>We precompute the elements of the uncompressed string. Thus, the space required in this case is <script type=\"math/tex; mode=display\">O(m)</script>, where <script type=\"math/tex; mode=display\">m</script> refers to the length of the uncompressed string.</p> </li> \n   <li> <p>The time required for precomputation is <script type=\"math/tex; mode=display\">O(m)</script> since we need to generate the uncompressed string of length <script type=\"math/tex; mode=display\">m</script>.</p> </li> \n   <li> <p>Once the precomputation has been done, the time required for performing <code>next()</code> and <code>hasNext()</code> is <script type=\"math/tex; mode=display\">O(1)</script> for both.</p> </li> \n   <li> <p>This approach can be easily extended to include <code>previous()</code>, <code>last()</code> and <code>find()</code> operations. All these operations require the use an index only and thus, take <script type=\"math/tex; mode=display\">O(1)</script> time. Operations like <code>hasPrevious()</code> can also be easily included.</p> </li> \n   <li> <p>Since, once the precomputation has been done, <code>next()</code> requires <script type=\"math/tex; mode=display\">O(1)</script> time, this approach is useful if <code>next()</code> operation needs to be performed a large number of times. However, if <code>hasNext()</code> is performed most of the times, this approach isn't much advantageous since precomputation needs to be done anyhow.</p> </li> \n   <li> <p>A potential problem with this approach could arise if the length of the uncompressed string is very large. In such a case, the size of the complete uncompressed string could become so large that it can't fit in the memory limits, leading to memory overflow.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-pre-computation-accepted\">Approach #2 Pre-Computation [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In this approach, firstly, we split the given <script type=\"math/tex; mode=display\">compressedString</script> based on numbers(0-9) and store the values(alphabets) obtained in <script type=\"math/tex; mode=display\">chars</script> array. We also split the <script type=\"math/tex; mode=display\">compressedString</script> based on the alphabets(a-z, A-Z) and store the numbers(in the form of a string) in a <script type=\"math/tex; mode=display\">nums</script> array(after converting the strings obtained into integers). We do the splitting by making use of regular expression matching.</p> \n  <p>A regular expression is a special sequence of letters that helps you match or find other strings or sets of strings, using a specialized syntax held in a pattern. They can be used to search, edit, or manipulate text and data.</p> \n  <p>This splitting using regex is done as a precomputation step. Now we'll look at how the <code>next()</code> and <code>hasNext()</code> operations are implemented.</p> \n  <ol> \n   <li> <p><code>next()</code>: Every time the <code>next()</code> operation is performed, firstly we check if there are any more letters to be uncompressed. We check it by making use of <code>hasNext()</code> function. If there aren't any more letters left, we return a ' '. We make use of a pointer <script type=\"math/tex; mode=display\">ptr</script> to keep a track of the letter in the <script type=\"math/tex; mode=display\">compressedString</script> that needs to be returned next. If there are more letters left in the uncompressed string, we return the current letter pointed to by <script type=\"math/tex; mode=display\">ptr</script>. But, before returning this letter, we also decrement the <script type=\"math/tex; mode=display\">nums[ptr]</script> entry to indicate that the current letter is pending in the uncompressed string by one lesser count. On decrementing this entry, if it becomes zero, it indicates that no more instances of the current letter exist in the uncompressed string. Thus, we update the pointer <script type=\"math/tex; mode=display\">ptr</script> to point to the next letter.</p> </li> \n   <li> <p><code>hasNext()</code>: For performing <code>hasNext()</code> operation, we simply need to check if the <script type=\"math/tex; mode=display\">ptr</script> has already reached beyong the end of <script type=\"math/tex; mode=display\">chars</script> array. If so, it indicates that no more compressed letters exist in the <script type=\"math/tex; mode=display\">compressedString</script>. Hence, we return a False value in this case. Otherwise, more compressed letters exist. Hence, we return a True value in this case.</p> </li> \n  </ol> \n  <iframe src=\"https://leetcode.com/playground/rRUsHDy3/shared\" frameborder=\"0\" name=\"rRUsHDy3\" width=\"100%\" height=\"428\"></iframe> \n  <p><strong>Performance Analysis</strong></p> \n  <ul> \n   <li> <p>The space required for storing the results of the precomputation is <script type=\"math/tex; mode=display\">O(n)</script>, where <script type=\"math/tex; mode=display\">n</script> refers to the length of the compressed string. The <script type=\"math/tex; mode=display\">nums</script> and <script type=\"math/tex; mode=display\">chars</script> array contain a total of <script type=\"math/tex; mode=display\">n</script> elements.</p> </li> \n   <li> <p>The precomputation step requires <script type=\"math/tex; mode=display\">O(n)</script> time. Thus, if <code>hasNext()</code> operation is performed most of the times, this precomputation turns out to be non-advantageous.</p> </li> \n   <li> <p>Once the precomputation has been done, <code>hasNext()</code> and <code>next()</code> requires <script type=\"math/tex; mode=display\">O(1)</script> time. </p> </li> \n   <li> <p>This approach can be extended to include the <code>previous()</code> and <code>hasPrevious()</code> operations, but that would require making some simple modifications to the current implementation.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-demand-computation-accepted\">Approach #3 Demand-Computation [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In this approach, we don't make use of regex for finding the individual components of the given <script type=\"math/tex; mode=display\">compressedString</script>. We do not perform any form of precomputation. Whenever an operation needs to be performed, the required results are generated from the scratch. Thus, the operations are performed only on demand.</p> \n  <p>Let's look at the implementation of the required operations:</p> \n  <ol> \n   <li> <p><code>next()</code>: We make use of a global pointer <script type=\"math/tex; mode=display\">ptr</script> to keep a track of which compressed letter in the <script type=\"math/tex; mode=display\">compressedString</script> needs to be processed next. We also make use of a global variable <script type=\"math/tex; mode=display\">num</script> to keep a track of the number of instances of the current letter which are still pending. Whenever <code>next()</code> operation needs to be performed, firstly, we check if there are more uncompressed letters left in the <script type=\"math/tex; mode=display\">compressedString</script>. If not, we return a ' '. Otherwise, we check if there are more instances of the current letter still pending. If so, we directly decrement the count of instances indicated by <script type=\"math/tex; mode=display\">nums</script> and return the current letter. But, if there aren't more instances pending for the current letter, we update the <script type=\"math/tex; mode=display\">ptr</script> to point to the next letter in the <script type=\"math/tex; mode=display\">compressedString</script>. We also update the <script type=\"math/tex; mode=display\">num</script> by obtaining the count for the next letter from the <script type=\"math/tex; mode=display\">compressedString</script>. This number is obtained by making use of decimal arithmetic.</p> </li> \n   <li> <p><code>hasNext()</code>: If the pointer <script type=\"math/tex; mode=display\">ptr</script> has reached beyond the last index of the <script type=\"math/tex; mode=display\">compressedString</script> and <script type=\"math/tex; mode=display\">num</script> becomes, it indicates that no more uncompressed letters exist in the compressed string. Hence, we return a False in this case. Otherwise, a True value is returned indicating that more compressed letters exist in the <script type=\"math/tex; mode=display\">compressedString</script>.</p> </li> \n  </ol> \n  <iframe src=\"https://leetcode.com/playground/nto5MsQu/shared\" frameborder=\"0\" name=\"nto5MsQu\" width=\"100%\" height=\"479\"></iframe> \n  <p><strong>Performance Analysis</strong></p> \n  <ul> \n   <li> <p>Since no precomputation is done, constant space is required in this case.</p> </li> \n   <li> <p>The time required to perform <code>next()</code> operation is <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n   <li> <p>The time required for <code>hasNext()</code> operation is <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n   <li> <p>Since no precomputations are done, and <code>hasNext()</code> requires only <script type=\"math/tex; mode=display\">O(1)</script> time, this solution is advantageous if <code>hasNext()</code> operation is performed most of the times.</p> </li> \n   <li> <p>This approach can be extended to include <code>previous()</code> and <code>hasPrevious()</code> operationsm, but this will require the use of some additional variables.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 600,
    "article_live": true,
    "article_slug": "non-negative-integers-without-consecutive-ones",
    "title": "Non-negative Integers without Consecutive Ones",
    "title_slug": "non-negative-integers-without-consecutive-ones",
    "content": "<p>Given a positive integer n, find the number of <b>non-negative</b> integers less than or equal to n, whose binary representations do NOT contain <b>consecutive ones</b>.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> 5\r\n<b>Output:</b> 5\r\n<b>Explanation:</b> \r\nHere are the non-negative integers <= 5 with their corresponding binary representations:\r\n0 : 0\r\n1 : 1\r\n2 : 10\r\n3 : 11\r\n4 : 100\r\n5 : 101\r\nAmong them, only integer 3 disobeys the rule (two consecutive ones) and the other 5 satisfy the rule. \r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\n1 <= n <= 10<sup>9</sup>\r\n</p>\r\n",
    "tags": "Dynamic Programming",
    "difficulty": 3,
    "frontend_article_id": 600,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-better-brute-force-time-limit-exceeded\">Approach #2 Better Brute Force [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-3-using-bit-manipulation-accepted\">Approach #3 Using Bit Manipulation [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</h4> \n  <p>The brute force approach is simple. We can traverse through all the numbers from <script type=\"math/tex; mode=display\">1</script> to <script type=\"math/tex; mode=display\">num</script>. For every current number chosen, we can check all the consecutive positions in this number to check if the number contains two consecutive ones or not. If not, we increment the <script type=\"math/tex; mode=display\">count</script> of the resultant numbers with no consecutive ones. </p> \n  <p>To check if a <script type=\"math/tex; mode=display\">1</script> exists at the position <script type=\"math/tex; mode=display\">x</script>(counting from the LSB side), in the current number <script type=\"math/tex; mode=display\">n</script>, we can proceed as follows. We can shift a binary <script type=\"math/tex; mode=display\">1</script> <script type=\"math/tex; mode=display\">x-1</script> times towards the left to get a number <script type=\"math/tex; mode=display\">y</script> which has a <script type=\"math/tex; mode=display\">1</script> only at the <script type=\"math/tex; mode=display\">x^{th}</script> position. Now, logical ANDing of <script type=\"math/tex; mode=display\">n</script> and <script type=\"math/tex; mode=display\">y</script> will result in a logical <script type=\"math/tex; mode=display\">1</script> output only if <script type=\"math/tex; mode=display\">n</script> contains <script type=\"math/tex; mode=display\">1</script> at the <script type=\"math/tex; mode=display\">x^{th}</script> position.</p> \n  <iframe src=\"https://leetcode.com/playground/EvkBtbbs/shared\" frameborder=\"0\" name=\"EvkBtbbs\" width=\"100%\" height=\"377\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(32*n)</script>. We test the 32 consecutive positions of every number from <script type=\"math/tex; mode=display\">0</script> to <script type=\"math/tex; mode=display\">n</script>. Here, <script type=\"math/tex; mode=display\">n</script> refers to given number. </p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant space is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-better-brute-force-time-limit-exceeded\">Approach #2 Better Brute Force [Time Limit Exceeded]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In the last approach, we generated every number and then checked if it contains consecutive ones at any position or not. Instead of this, we can generate only the required kind of numbers. e.g. If we genearte numbers in the order of the number of bits in the current number, if we get a binary number <code>110</code> on the way at the step of 3-bit number generation. Now, since this number already contains two consecutive ones, it is useless to generate number with more number of bits with the current bitstream as the suffix(e.g. numbers of the form <code>1110</code> and <code>0110</code>).</p> \n  <p>The current approach is based on the above idea. We can start with the LSB position, by placing a <code>0</code> and a <code>1</code> at the LSB. These two initial numbers correspond to the 1-bit numbers which don't contain any consecutive ones. Now, taking <code>0</code> as the initial suffix, if we want to generate two bit numbers with no two consecutive 1's, we can append a <code>1</code> and a <code>0</code> both in front of the initial <code>0</code> generating the numbers <code>10</code> and <code>00</code> as the two bit numbers ending with a <code>0</code> with no two consecutive 1's.</p> \n  <p>But, when we take <code>1</code> as the initial suffix, we can append a <code>0</code> to it to generate <code>01</code> which doesn't contain any consecutive ones. But, adding a <code>1</code> won't satisfy this criteria(<code>11</code> will be generated). Thus, while generating the current number, we need to keep a track of the point that whether a <code>1</code> was added as the last prefix or not. If yes, we can't append a new <code>1</code> and only <code>0</code> can be appended. If a <code>0</code> was appended as the last prefix, both <code>0</code> and <code>1</code> can be appended in the new bit-pattern without creating a violating number. Thus, we can continue forward with the 3-bit number generation only with <code>00</code>, <code>01</code> and <code>10</code> as the new suffixes in the same manner. </p> \n  <p>To get a count of numbers lesser than <script type=\"math/tex; mode=display\">num</script>, with no two consecutive 1's, based on the above discussion, we make use of a recursive function <code>find(i, sum, num, prev)</code>. This function returns the count of binary numbers with <script type=\"math/tex; mode=display\">i</script> bits with no two consecutive 1's. Here, <script type=\"math/tex; mode=display\">sum</script> refers to the binary number generated till now(the prefix obtained as the input). <script type=\"math/tex; mode=display\">num</script> refers to the given number. <script type=\"math/tex; mode=display\">prev</script> is a boolean variable that indicates whether the last prefix added was a <code>1</code> or a <code>0</code>.</p> \n  <p>If the last prefix was a <code>0</code>, we can add both <code>1</code> and <code>0</code> as the new prefix. Thus, we need to make a function call <code>find(i + 1, sum, num, false) + find(i + 1, sum + (1 &lt;&lt; i), num, true)</code>. Here, the first sub-part refers to a <code>0</code> being added at the <script type=\"math/tex; mode=display\">i^{th}</script> position. Thus, we pass a <code>false</code> as the prefix in this case. The second sub-part refers to a <code>1</code> being added at the <script type=\"math/tex; mode=display\">i^{th}</script> position. Thus, we pass <code>true</code> as the prefix in this case. </p> \n  <p>If the last prefix was a <code>1</code>, we can add only a <code>0</code> as the new prefix. Thus, only one function call <code>find(i + 1, sum, num, false)</code> is made in this case. </p> \n  <p>Further, we need to stop the number generation whenver the current input number(<script type=\"math/tex; mode=display\">sum</script>) exceeds the given number <script type=\"math/tex; mode=display\">num</script>. </p> \n  <p><img alt=\"Tree\" src=\"../Figures/600_Non_Negative_2.PNG\"></p> \n  <iframe src=\"https://leetcode.com/playground/QN3EABd5/shared\" frameborder=\"0\" name=\"QN3EABd5\" width=\"100%\" height=\"292\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(x)</script>. Only <script type=\"math/tex; mode=display\">x</script> numbers are generated. Here, <script type=\"math/tex; mode=display\">x</script> refers to the resultant count to be returned.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(log(max\\_int)=32)</script>. The depth of recursion tree can go upto <script type=\"math/tex; mode=display\">32</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-using-bit-manipulation-accepted\">Approach #3 Using Bit Manipulation [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Before we discuss the idea behind this approach, we consider another simple idea that will be used in the current approach. </p> \n  <p>Suppose, we need to find the count of binary numbers with <script type=\"math/tex; mode=display\">n</script> bits such that these numbers don't contain consecutive 1's. In order to do so, we can look at the problem in a recursive fashion. Suppose <script type=\"math/tex; mode=display\">f[i]</script> gives the count of such binary numbers with <script type=\"math/tex; mode=display\">i</script> bits. In order to determine the value of <script type=\"math/tex; mode=display\">f[n]</script>, which is the requirement, we can consider the cases shown below:</p> \n  <p><img alt=\"Recursive_Function\" src=\"../Figures/600_Non_Negative_1.png\"></p> \n  <p>From the above figure, we can see that if we know the value of <script type=\"math/tex; mode=display\">f[n-1]</script> and <script type=\"math/tex; mode=display\">f[n-2]</script>, in order to generate the required binary numbers with <script type=\"math/tex; mode=display\">n</script> bits, we can append a <code>0</code> to all the binary numbers contained in <script type=\"math/tex; mode=display\">f[n-1]</script> without creating an invalid number. These numbers give a factor of <script type=\"math/tex; mode=display\">f[n-1]</script> to be included in <script type=\"math/tex; mode=display\">f[n]</script>. But, we can't append a <code>1</code> to all these numbers, since it could lead to the presence of two consecutive ones in the newly generated numbers. Thus, for the currently generated numbers to end with a <code>1</code>, we need to ensure that the second last position is always <code>0</code>. Thus, we need to fix a <code>01</code> at the end of all the numbers contained in <script type=\"math/tex; mode=display\">f[n-2]</script>. This gives a factor of <script type=\"math/tex; mode=display\">f[n-2]</script> to be included in <script type=\"math/tex; mode=display\">f[n]</script>. Thus, in total, we get <script type=\"math/tex; mode=display\">f[n] = f[n-1] + f[n-2]</script>.</p> \n  <p>Now, let's look into the current approach. We'll try to understand the idea behind the approach by taking two simple examples. Firstly, we look at the case where the given number doesn't contain any consecutive 1's.Say, <script type=\"math/tex; mode=display\">num = \\text{1010100}</script>(7 bit number). Now, we'll see how we can find the numbers lesser than <script type=\"math/tex; mode=display\">num</script> with no two consecutive 1's. We start off with the MSB of <script type=\"math/tex; mode=display\">nums</script>. If we fix a <script type=\"math/tex; mode=display\">\\text{0}</script> at the MSB position, and find out the count of 6 bit numbers(corresponding to the 6 LSBs) with no two consecutive 1's, these 6-bit numbers will lie in the range <script type=\"math/tex; mode=display\">\\textbf{0}\\text{000000} -> \\textbf{0}\\text{111111}</script>. For finding this count we can make use of <script type=\"math/tex; mode=display\">f[6]</script> which we'll have already calculated based on the discussion above. </p> \n  <p>But, even after doing this, all the numbers in the required range haven't been covered yet. Now, if we try to fix <script type=\"math/tex; mode=display\">\\text{1}</script> at the MSB, the numbers considered will lie in the range <script type=\"math/tex; mode=display\">\\textbf{1}\\text{000000} -> \\textbf{1}\\text{111111}</script>. As we can see, this covers the numbers in the range <script type=\"math/tex; mode=display\">\\textbf{1}\\text{000000} -> \\textbf{1}\\text{010100}</script>, but it covers the numbers in the range beyond limit as well. Thus, we can't fix <script type=\"math/tex; mode=display\">\\text{1}</script> at the MSB and consider all the 6-bit numbers at the LSBs. </p> \n  <p>For covering the pending range, we fix <script type=\"math/tex; mode=display\">\\text{1}</script> at the MSB, and move forward to proceed with the second digit(counting from MSB). Now, since we've already got a <script type=\"math/tex; mode=display\">\\text{0}</script> at this position, we can't substitute a <script type=\"math/tex; mode=display\">\\text{1}</script> here, since doing so will lead to generation of numbers exceeding <script type=\"math/tex; mode=display\">num</script>. Thus, the only option left here is to substitute a <script type=\"math/tex; mode=display\">\\text{0}</script> at the second position. But, if we do so, and consider the 5-bit numbers(at the 5 LSBs) with no two consecutive 1's, these new numbers will fall in the range <script type=\"math/tex; mode=display\">\\textbf{10}\\text{00000} -> \\textbf{10}\\text{11111}</script>. But, again we can observe that considering these numbers leads to exceeding the required range. Thus, we can't consider all the 5-bit numbers for the required count by fixing <script type=\"math/tex; mode=display\">\\text{0}</script> at the second position. </p> \n  <p>Thus, now, we fix <script type=\"math/tex; mode=display\">\\text{0}</script> at the second position and proceed further. Again, we encounter a <script type=\"math/tex; mode=display\">\\text{1}</script> at the third position. Thus, as discussed above, we can fix a <script type=\"math/tex; mode=display\">\\text{0}</script> at this position and find out the count of 4-bit consecutive numbers with no two consecutive 1's(by varying only the 4 LSB bits). We can obtain this value from <script type=\"math/tex; mode=display\">f[4]</script>. Thus, now the numbers in the range <script type=\"math/tex; mode=display\">\\textbf{100}\\text{0000} -> \\textbf{100}\\text{1111}</script> have been covered up. </p> \n  <p>Again, as discussed above, now we fix a <script type=\"math/tex; mode=display\">\\text{1}</script> at the third position, and proceed with the fourth bit. It is a <script type=\"math/tex; mode=display\">\\text{0}</script>. So, we need to fix it as such as per the above discussion, and proceed with the fifth bit. It is a <script type=\"math/tex; mode=display\">\\text{1}</script>. So, we fix a <script type=\"math/tex; mode=display\">\\text{0}</script> here and consider all the numbers by varying the two LSBs for finding the required count of numbers in the range <script type=\"math/tex; mode=display\">\\textbf{10101}\\text{00} -> \\textbf{10101}\\text{11}</script>. Now, we proceed to the sixth bit, find a <script type=\"math/tex; mode=display\">\\text{0}</script> there. So, we fix <script type=\"math/tex; mode=display\">\\text{0}</script> at the sixth position and proceed to the seventh bit which is again <script type=\"math/tex; mode=display\">\\text{0}</script>. So, we fix a <script type=\"math/tex; mode=display\">\\text{0}</script> at the seventh position as well.</p> \n  <p>Now, we can see, that based on the above procedure, the numbers in the range <script type=\"math/tex; mode=display\">\\textbf{1}\\text{000000} -> \\textbf{1}\\text{111111}</script>, <script type=\"math/tex; mode=display\">\\textbf{100}\\text{0000} -> \\textbf{100}\\text{1111}</script>, <script type=\"math/tex; mode=display\">\\textbf{100}\\text{0000} -> \\textbf{100}\\text{1111}</script> have been considered and the counts for these ranges have been obtained as <script type=\"math/tex; mode=display\">f[6]</script>, <script type=\"math/tex; mode=display\">f[4]</script> and <script type=\"math/tex; mode=display\">f[2]</script> respectively. Now, only <script type=\"math/tex; mode=display\">\\text{1010100}</script> is pending to be considered in the required count. Since, it doesn't contain any consecutive 1's, we add a 1 to the total count obtained till now to consider this number. Thus, the result returned is <script type=\"math/tex; mode=display\">f[6] + f[4] + f[2] + 1</script>.</p> \n  <p>!?!../Documents/600_Non_Negative1.json:1000,563!?!</p> \n  <p>Now, we look at the case, where <script type=\"math/tex; mode=display\">num</script> contains some consecutive 1's. The idea will be the same as the last example, with the only exception taken when the two consecutive 1's are encountered. Let's say, <script type=\"math/tex; mode=display\">num = \\text{1011010}</script>(7 bit number). Now, as per the last discussion, we start with the MSB. We find a <script type=\"math/tex; mode=display\">\\text{1}</script> at this position. Thus, we initially fix a <script type=\"math/tex; mode=display\">\\text{0}</script> at this position to consider the numbers in the range <script type=\"math/tex; mode=display\">\\textbf{0}\\text{000000} -> \\textbf{0}\\text{111111}</script>, by varying the 6 LSB bits only. The count of the required numbers in this range is again given by <script type=\"math/tex; mode=display\">f[6]</script>.</p> \n  <p>Now, we fix a <script type=\"math/tex; mode=display\">\\text{1}</script> at the MSB and move on to the second bit. It is a <script type=\"math/tex; mode=display\">\\text{0}</script>, so we have no choice but to fix <script type=\"math/tex; mode=display\">\\text{0}</script> at this position and to proceed with the third bit. It is a <script type=\"math/tex; mode=display\">\\text{1}</script>, so we fix a <script type=\"math/tex; mode=display\">\\text{0}</script> here, considering the numbers in the range <script type=\"math/tex; mode=display\">\\textbf{100}\\text{0000} -> \\textbf{100}\\text{1111}</script>. This accounts for a factor of <script type=\"math/tex; mode=display\">f[4]</script>. Now, we fix a <script type=\"math/tex; mode=display\">\\text{1}</script> at the third positon, and proceed with the fourth bit. It is a <script type=\"math/tex; mode=display\">\\text{1}</script>(consecutive to the previous <script type=\"math/tex; mode=display\">\\text{1}</script>). Now, initially we fix a <script type=\"math/tex; mode=display\">\\text{0}</script> at the fourth position, considering the numbers in the range <script type=\"math/tex; mode=display\">\\textbf{1010}\\text{000} -> \\textbf{1010}\\text{111}</script>. This adds a factor of <script type=\"math/tex; mode=display\">f[3]</script> to the required count. </p> \n  <p>Now, we can see that till now the numbers in the range <script type=\"math/tex; mode=display\">\\textbf{0}\\text{000000} -> \\textbf{0}\\text{111111}</script>, <script type=\"math/tex; mode=display\">\\textbf{100}\\text{0000} -> \\textbf{100}\\text{1111}</script>, <script type=\"math/tex; mode=display\">\\textbf{1010}\\text{000} -> \\textbf{1010}\\text{111}</script> have been considered. But, if we try to consider any number larger than <script type=\"math/tex; mode=display\">\\text{1010111}</script>, it leads to the presence of two consecutive 1's in the new number at the third and fourth position. Thus, all the valid numbers upto <script type=\"math/tex; mode=display\">num</script> have been considered with this, giving a resultant count of <script type=\"math/tex; mode=display\">f[6] + f[4] + f[3]</script>.</p> \n  <p>!?!../Documents/600_Non_Negative2.json:1000,563!?!</p> \n  <p>Thus, summarizing the above discussion, we can say that we start scanning the given number <script type=\"math/tex; mode=display\">num</script> from its MSB. For every 1 encountered at the <script type=\"math/tex; mode=display\">i^{th}</script> bit position(counting from 0 from LSB), we add a factor of <script type=\"math/tex; mode=display\">f[i]</script> to the resultant count. For every 0 encountered, we don't add any factor. We also keep a track of the last bit checked. If we happen to find two consecutive 1's at any time, we add the factors for the positions of both the 1's and stop the traversal immediately. If we don't find any two consecutive 1's, we proceed till reaching the LSB and add an extra 1 to account for the given number <script type=\"math/tex; mode=display\">num</script> as well, since the procedure discussed above considers numbers upto <script type=\"math/tex; mode=display\">num</script> without including itself.</p> \n  <iframe src=\"https://leetcode.com/playground/NbrrZGdh/shared\" frameborder=\"0\" name=\"NbrrZGdh\" width=\"100%\" height=\"462\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(log_2(max\\_int)=32)</script>. One loop to fill <script type=\"math/tex; mode=display\">f</script> array and one loop to check all bits of <script type=\"math/tex; mode=display\">num</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(log_2(max\\_int)=32)</script>. <script type=\"math/tex; mode=display\">f</script> array of size 32 is used.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 599,
    "article_live": true,
    "article_slug": "minimum-index-sum-of-two-lists",
    "title": "Minimum Index Sum of Two Lists",
    "title_slug": "minimum-index-sum-of-two-lists",
    "content": "<p>\r\nSuppose Andy and Doris want to choose a restaurant for dinner, and they both have a list of favorite restaurants represented by strings. \r\n</p>\r\n<p>\r\nYou need to help them find out their <b>common interest</b> with the <b>least list index sum</b>. If there is a choice tie between answers, output all of them with no order requirement. You could assume there always exists an answer.\r\n</p>\r\n\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b>\r\n[\"Shogun\", \"Tapioca Express\", \"Burger King\", \"KFC\"]\r\n[\"Piatti\", \"The Grill at Torrey Pines\", \"Hungry Hunter Steakhouse\", \"Shogun\"]\r\n<b>Output:</b> [\"Shogun\"]\r\n<b>Explanation:</b> The only restaurant they both like is \"Shogun\".\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b>\r\n[\"Shogun\", \"Tapioca Express\", \"Burger King\", \"KFC\"]\r\n[\"KFC\", \"Shogun\", \"Burger King\"]\r\n<b>Output:</b> [\"Shogun\"]\r\n<b>Explanation:</b> The restaurant they both like and have the least index sum is \"Shogun\" with index sum 1 (0+1).\r\n</pre>\r\n</p>\r\n\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The length of both lists will be in the range of [1, 1000].</li>\r\n<li>The length of strings in both lists will be in the range of [1, 30].</li>\r\n<li>The index is starting from 0 to the list length minus 1.</li>\r\n<li>No duplicates in both lists.</li>\r\n</ol>\r\n</p>",
    "tags": "Hash Table",
    "difficulty": 1,
    "frontend_article_id": 599,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-using-hashmap-accepted\">Approach #1 Using HashMap [Accepted]</a></li> \n      <li><a href=\"#approach-2-without-using-hashmap-accepted\">Approach #2 Without Using HashMap [Accepted]</a></li> \n      <li><a href=\"#approach-3-using-hashmap-linear-accepted\">Approach #3 Using HashMap (linear) [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-using-hashmap-accepted\">Approach #1 Using HashMap [Accepted]</h4> \n  <p>In this approach, we compare every string in <script type=\"math/tex; mode=display\">list1</script> and <script type=\"math/tex; mode=display\">list2</script> by traversing over the whole list <script type=\"math/tex; mode=display\">list2</script> for every string chosen from <script type=\"math/tex; mode=display\">list1</script>. We make use of a hashmap <script type=\"math/tex; mode=display\">map</script>, which contains elements of the form <script type=\"math/tex; mode=display\">(sum : list_{sum})</script>. Here, <script type=\"math/tex; mode=display\">sum</script> refers to the sum of indices of matching elements and <script type=\"math/tex; mode=display\">list_{sum}</script> refers to the list of matching strings whose indices' sum equals <script type=\"math/tex; mode=display\">sum</script>. </p> \n  <p>Thus, while doing the comparisons, whenever a match between a string at <script type=\"math/tex; mode=display\">i^{th}</script> index of <script type=\"math/tex; mode=display\">list1</script> and <script type=\"math/tex; mode=display\">j^{th}</script> index of <script type=\"math/tex; mode=display\">list2</script> is found, we make an entry in the <script type=\"math/tex; mode=display\">map</script> corresponding to the sum <script type=\"math/tex; mode=display\">i + j</script>, if this entry isn't already present. If an entry with this sum already exists, we need to keep a track of all the strings which lead to the same index sum. Thus, we append the current string to the list of strings corresponding to sum <script type=\"math/tex; mode=display\">i + j</script>.</p> \n  <p>At the end, we traverse over the keys of the <script type=\"math/tex; mode=display\">map</script> and find out the list of strings corresponding to the key reprsenting the minimum sum.</p> \n  <iframe src=\"https://leetcode.com/playground/Rxg7wbHW/shared\" frameborder=\"0\" name=\"Rxg7wbHW\" width=\"100%\" height=\"394\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(l_1*l_2*x)</script>. Every item of <script type=\"math/tex; mode=display\">list1</script> is compared with all the items of <script type=\"math/tex; mode=display\">list2</script>. <script type=\"math/tex; mode=display\">l_1</script> and <script type=\"math/tex; mode=display\">l_2</script> are the lengths of <script type=\"math/tex; mode=display\">list1</script> and <script type=\"math/tex; mode=display\">list2</script> respectively. And <script type=\"math/tex; mode=display\">x</script> refers to average string length.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(l_1*l_2*x)</script>. In worst case all items of <script type=\"math/tex; mode=display\">list1</script> and <script type=\"math/tex; mode=display\">list2</script> are same. In that case, hashmap size grows upto <script type=\"math/tex; mode=display\">l_1*l_2*x</script>, where <script type=\"math/tex; mode=display\">x</script> refers to average string length.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-without-using-hashmap-accepted\">Approach #2 Without Using HashMap [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Another method could be to traverse over the various <script type=\"math/tex; mode=display\">sum</script>(index sum) values and determine if any such string exists in <script type=\"math/tex; mode=display\">list1</script> and <script type=\"math/tex; mode=display\">list2</script> such that the sum of its indices in the two lists equals <script type=\"math/tex; mode=display\">sum</script>. </p> \n  <p>Now, we know that the value of index sum, <script type=\"math/tex; mode=display\">sum</script> could range from 0 to <script type=\"math/tex; mode=display\">m + n - 1</script>. Here, <script type=\"math/tex; mode=display\">m</script> and <script type=\"math/tex; mode=display\">n</script> refer to the length of lists <script type=\"math/tex; mode=display\">list1</script> and <script type=\"math/tex; mode=display\">list2</script> respectively. Thus, we choose every value of <script type=\"math/tex; mode=display\">sum</script> in ascending order. For every <script type=\"math/tex; mode=display\">sum</script> chosen, we iterate over <script type=\"math/tex; mode=display\">list1</script>. Suppose, currently the string at <script type=\"math/tex; mode=display\">i^{th}</script> index in <script type=\"math/tex; mode=display\">list1</script> is being considered. Now, in order for the index sum <script type=\"math/tex; mode=display\">sum</script> to be the one corresponding to matching strings in <script type=\"math/tex; mode=display\">list1</script> and <script type=\"math/tex; mode=display\">list2</script>, the string at index <script type=\"math/tex; mode=display\">j</script> in <script type=\"math/tex; mode=display\">list2</script> should match the string at index <script type=\"math/tex; mode=display\">i</script> in <script type=\"math/tex; mode=display\">list1</script>, such that <script type=\"math/tex; mode=display\">sum = i + j</script>.</p> \n  <p>Or, stating in other terms, the string at index <script type=\"math/tex; mode=display\">j</script> in <script type=\"math/tex; mode=display\">list2</script> should be equal to the string at index <script type=\"math/tex; mode=display\">i</script> in <script type=\"math/tex; mode=display\">list1</script>, such that <script type=\"math/tex; mode=display\">j = sum - i</script>. Thus, for a particular <script type=\"math/tex; mode=display\">sum</script> and <script type=\"math/tex; mode=display\">i</script>(from <script type=\"math/tex; mode=display\">list1</script>), we can directly determine that we need to check the element at index <script type=\"math/tex; mode=display\"> j= sum - i</script> in <script type=\"math/tex; mode=display\">list2</script>, instead of traversing over the whole <script type=\"math/tex; mode=display\">list2</script>. </p> \n  <p>Doing such checks/comparisons, iterate over all the indices of <script type=\"math/tex; mode=display\">list1</script> for every <script type=\"math/tex; mode=display\">sum</script> value chosen. Whenver a match occurs between <script type=\"math/tex; mode=display\">list1</script> and <script type=\"math/tex; mode=display\">list2</script>, we put the matching string in a list <script type=\"math/tex; mode=display\">res</script>. </p> \n  <p>We do the same process of checking the strings for all the values of <script type=\"math/tex; mode=display\">sum</script> in ascending order. After completing every iteration over <script type=\"math/tex; mode=display\">list1</script> for a particular <script type=\"math/tex; mode=display\">sum</script>, we check if the <script type=\"math/tex; mode=display\">res</script> list is empty or not. If it is empty, we need to continue the process with the next <script type=\"math/tex; mode=display\">sum</script> value considered. If not, the current <script type=\"math/tex; mode=display\">res</script> gives the required list with minimum index sum. This is because we are already considering the index sum values in ascending order. So, the first list to be found is the required resultant list.</p> \n  <p>The following example depicts the process:</p> \n  <p>!?!../Documents/599_Min_Index_Sum.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/HhLorCYq/shared\" frameborder=\"0\" name=\"HhLorCYq\" width=\"100%\" height=\"309\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O((l_1+l_2)^2*x)</script>. There are two nested loops upto <script type=\"math/tex; mode=display\">l_1+l_2</script> and string comparison takes <script type=\"math/tex; mode=display\">x</script> time. Here, <script type=\"math/tex; mode=display\">x</script> refers to the average string length.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(r*x)</script>. <script type=\"math/tex; mode=display\">res</script> list is used to store the result. Assuming <script type=\"math/tex; mode=display\">r</script> is the length of <script type=\"math/tex; mode=display\">res</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-using-hashmap-linear-accepted\">Approach #3 Using HashMap (linear) [Accepted]</h4> \n  <p>We make use of a HashMap to solve the given problem in a different way in this approach. Firstly, we traverse over the whole <script type=\"math/tex; mode=display\">list1</script> and create an entry for each element of <script type=\"math/tex; mode=display\">list1</script> in a HashMap <script type=\"math/tex; mode=display\">map</script>, of the form <script type=\"math/tex; mode=display\">(list[i], i)</script>. Here, <script type=\"math/tex; mode=display\">i</script> refers to the index of the <script type=\"math/tex; mode=display\">i^{th}</script> element, and <script type=\"math/tex; mode=display\">list[i]</script> is the <script type=\"math/tex; mode=display\">i^{th}</script> element itself. Thus, we create a mapping from the elements of <script type=\"math/tex; mode=display\">list1</script> to their indices.</p> \n  <p>Now, we traverse over <script type=\"math/tex; mode=display\">list2</script>. For every element ,<script type=\"math/tex; mode=display\">list2[j]</script>, of <script type=\"math/tex; mode=display\">list2</script> encountered, we check if the same element already exists as a key in the <script type=\"math/tex; mode=display\">map</script>. If so, it means that the element exists in both <script type=\"math/tex; mode=display\">list1</script> and <script type=\"math/tex; mode=display\">list2</script>. Thus, we find out the sum of indices corresponding to this element in the two lists, given by <script type=\"math/tex; mode=display\">sum = map.get(list[j]) + j</script>. If this <script type=\"math/tex; mode=display\">sum</script> is lesser than the minimum sum obtained till now, we update the resultant list to be returned, <script type=\"math/tex; mode=display\">res</script>, with the element <script type=\"math/tex; mode=display\">list2[j]</script> as the only entry in it. </p> \n  <p>If the <script type=\"math/tex; mode=display\">sum</script> is equal to the minimum sum obtained till now, we put an extra entry corresponding to the element <script type=\"math/tex; mode=display\">list2[j]</script> in the <script type=\"math/tex; mode=display\">res</script> list.</p> \n  <p>Below code is inspired by <a href=\"https://leetcode.com/cloud.runner\">@cloud.runner</a></p> \n  <iframe src=\"https://leetcode.com/playground/FatTyfy6/shared\" frameborder=\"0\" name=\"FatTyfy6\" width=\"100%\" height=\"411\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(l_1+l_2)</script>. Every item of <script type=\"math/tex; mode=display\">list2</script> is checked in a map of <script type=\"math/tex; mode=display\">list1</script>. <script type=\"math/tex; mode=display\">l_1</script> and <script type=\"math/tex; mode=display\">l_2</script> are the lengths of <script type=\"math/tex; mode=display\">list1</script> and <script type=\"math/tex; mode=display\">list2</script> respectively.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(l_1*x)</script>. hashmap size grows upto <script type=\"math/tex; mode=display\">l_1*x</script>, where <script type=\"math/tex; mode=display\">x</script> refers to average string length.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 598,
    "article_live": true,
    "article_slug": "range-addition-ii",
    "title": "Range Addition II",
    "title_slug": "range-addition-ii",
    "content": "<p>Given an m * n matrix <b>M</b> initialized with all <b>0</b>'s and several update operations.</p>\r\n<p>Operations are represented by a 2D array, and each operation is represented by an array with two <b>positive</b> integers <b>a</b> and <b>b</b>, which means <b>M[i][j]</b> should be <b>added by one</b> for all <b>0 <= i < a</b> and <b>0 <= j < b</b>. </p>\r\n<p>You need to count and return the number of maximum integers in the matrix after performing all the operations.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\nm = 3, n = 3\r\noperations = [[2,2],[3,3]]\r\n<b>Output:</b> 4\r\n<b>Explanation:</b> \r\nInitially, M = \r\n[[0, 0, 0],\r\n [0, 0, 0],\r\n [0, 0, 0]]\r\n\r\nAfter performing [2,2], M = \r\n[[1, 1, 0],\r\n [1, 1, 0],\r\n [0, 0, 0]]\r\n\r\nAfter performing [3,3], M = \r\n[[2, 2, 1],\r\n [2, 2, 1],\r\n [1, 1, 1]]\r\n\r\nSo the maximum integer in M is 2, and there are four of it in M. So return 4.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The range of m and n is [1,40000].</li>\r\n<li>The range of a is [1,m], and the range of b is [1,n].</li>\r\n<li>The range of operations size won't exceed 10,000.</li>\r\n</ol>\r\n</p>",
    "tags": "Math",
    "difficulty": 1,
    "frontend_article_id": 598,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-single-pass-accepted\">Approach #2 Single Pass [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</h4> \n  <p>The simplest method is to create a actual 2-D array of size <script type=\"math/tex; mode=display\">m</script>x<script type=\"math/tex; mode=display\">n</script>(<script type=\"math/tex; mode=display\">arr</script>), perform all the operations one by one on the given range of elements, and then count the number of maximum elements. Now, we know that all the operations performed always include the element at index <script type=\"math/tex; mode=display\">(0,0)</script>. Thus, the element <script type=\"math/tex; mode=display\">arr[0][0]</script> will always be the maximum. After performing all the operations, we can count the number of elements equal to <script type=\"math/tex; mode=display\">arr[0][0]</script> to get the required count of the maximum elements.</p> \n  <iframe src=\"https://leetcode.com/playground/awQVAxR8/shared\" frameborder=\"0\" name=\"awQVAxR8\" width=\"100%\" height=\"411\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(x*m*n)</script>. Array is updated <script type=\"math/tex; mode=display\">x</script> times, where <script type=\"math/tex; mode=display\">x</script> represents number of times operation is preformed i.e. <script type=\"math/tex; mode=display\">ops.length</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(m*n)</script>. Array of size <script type=\"math/tex; mode=display\">m*n</script> is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-single-pass-accepted\">Approach #2 Single Pass [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>As per the given problem statement, all the operations are performed on a rectangular sub-matrix of the initial all 0's <script type=\"math/tex; mode=display\">M</script> matrix. The upper left corner of each such rectangle is given by the index <script type=\"math/tex; mode=display\">(0, 0)</script> and the lower right corner for an operation <script type=\"math/tex; mode=display\">[i, j]</script> is given by the index <script type=\"math/tex; mode=display\">(i, j)</script>. </p> \n  <p>The maximum element will be the one on which all the operations have been performed. The figure below shows an example of two operations being performed on the initial <script type=\"math/tex; mode=display\">M</script> array. </p> \n  <p><img alt=\"Range_Addition\" src=\"../Figures/598_Range_Addition2.PNG\"></p> \n  <p>From this figure, we can observe that the maximum elements will be the ones which lie in the intersection region of the rectangles representing the operations. Further, we can observe that to count the number of elements lying in this intersection region, we don't actually need to perform the operations, but we need to determine the lower right cornerof the intersecting region only. This corner is given by <script type=\"math/tex; mode=display\">\\big(x, y\\big) = \\big(\\text{min}(op[0], \\text{min}(op[1])\\big)</script>, where <script type=\"math/tex; mode=display\">\\text{min}(op[i])</script> reprsents the minimum value of <script type=\"math/tex; mode=display\">op[i]</script> from among all the <script type=\"math/tex; mode=display\">op[i]</script>'s in the given set of operations.</p> \n  <p>Thus, the resultant count of elements lying in the intersection is given by: <script type=\"math/tex; mode=display\">x</script>x<script type=\"math/tex; mode=display\">y</script>.</p> \n  <iframe src=\"https://leetcode.com/playground/eUWGJ45b/shared\" frameborder=\"0\" name=\"eUWGJ45b\" width=\"100%\" height=\"224\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(x)</script>. Single traversal of all operations is done. <script type=\"math/tex; mode=display\">x</script> refers to the number of operations.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. No extra space is used.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 594,
    "article_live": true,
    "article_slug": "longest-harmonious-subsequence",
    "title": "Longest Harmonious Subsequence",
    "title_slug": "longest-harmonious-subsequence",
    "content": "<p>We define a harmonious array is an array where the difference between its maximum value and its minimum value is <b>exactly</b> 1.</p>\r\n\r\n<p>Now, given an integer array, you need to find the length of its longest harmonious subsequence among all its possible <a href=\"https://en.wikipedia.org/wiki/Subsequence\">subsequences</a>.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [1,3,2,2,5,2,3,7]\r\n<b>Output:</b> 5\r\n<b>Explanation:</b> The longest harmonious subsequence is [3,2,2,2,3].\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\nThe length of the input array will not exceed 20,000.\r\n</p>\r\n\r\n",
    "tags": "Hash Table",
    "difficulty": 1,
    "frontend_article_id": 594,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-better-brute-force-time-limit-exceeded\">Approach #2 Better Brute Force [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-3-using-sorting-accepted\">Approach #3 Using Sorting [Accepted]</a></li> \n      <li><a href=\"#approach-4-using-hashmapaccepted\">Approach #4 Using HashMap[Accepted]:</a></li> \n      <li><a href=\"#approach-5-in-single-loop-accepted\">Approach #5 In single loop [Accepted]:</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</h4> \n  <p>In the brute force solution, we consider every possible subsequence that can be formed using the elements of the given array. For every subsequence, we find the maximum and minimum values in the subsequence. If the difference between the maximum and the minimum values obtained is 1, it means the current subsequence forms a harmonious subsequence. Thus, we can consider the number of elements in this subsequence to be compared with the length of the last longest harmonious subsequence. </p> \n  <p>In order to obtain all the subseqeuences possible, we make use of binary number representation of decimal numbers. For a binary number of size <script type=\"math/tex; mode=display\">n</script>, a total of <script type=\"math/tex; mode=display\">2^n</script> different binary numbers can be generated. We generate all these binary numbers from <script type=\"math/tex; mode=display\">0</script> to <script type=\"math/tex; mode=display\">2^n</script>. For every binary number generated, we consider the subsequence to be comprised of only those elements of <script type=\"math/tex; mode=display\">nums</script> which have a 1 at the corresponding position in the current binary number. The following figure shows an example of the way the elements of <script type=\"math/tex; mode=display\">nums</script> are considered in the current subsequence.</p> \n  <p><img alt=\"Harmonic_Subsequence\" src=\"../Figures/594_Harmonic_Subsequence_Binary.PNG\"></p> \n  <iframe src=\"https://leetcode.com/playground/zbivYJiH/shared\" frameborder=\"0\" name=\"zbivYJiH\" width=\"100%\" height=\"394\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(2^n)</script>. Number of subsequences generated will be <script type=\"math/tex; mode=display\">2^n</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant space required.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-better-brute-force-time-limit-exceeded\">Approach #2 Better Brute Force [Time Limit Exceeded]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In the last approach, we created every possible subsequence, and for every such subsequence, we found out if it satisfies the harmonicity condition. Instead of doing this, we can do as follows. We can consider every element of the given <script type=\"math/tex; mode=display\">nums</script> array one by one. For <script type=\"math/tex; mode=display\">nums[i]</script> chosen to be the current element, we determine the <script type=\"math/tex; mode=display\">count</script> of all the elements in the <script type=\"math/tex; mode=display\">nums</script> array, which satisfy the harmonicity condition with <script type=\"math/tex; mode=display\">nums[i]</script>, i.e. the <script type=\"math/tex; mode=display\">count</script> of all such <script type=\"math/tex; mode=display\">nums[j]</script> satisfying <script type=\"math/tex; mode=display\">nums[i] == nums[j]</script> or <script type=\"math/tex; mode=display\">nums[i] == nums[j] + 1</script>. When we reach the end of the array for <script type=\"math/tex; mode=display\">nums[i]</script> being the current element, we compare this <script type=\"math/tex; mode=display\">count</script> obtained with the result obtained from the previous traversals and update the result appropriately. When all the elements of the array have been chosen as the element to be chosen as the base for harmonicity check, we get the required length of the longest harmonic subsequence.</p> \n  <p>The following animation illustrates the process:</p> \n  <p>!?!../Documents/594_Harmonic_Subsequence_1.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/2PtVgy2R/shared\" frameborder=\"0\" name=\"2PtVgy2R\" width=\"100%\" height=\"428\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^2)</script>. Two nested loops are there.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant space required.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-using-sorting-accepted\">Approach #3 Using Sorting [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Since we are concerned only with the count of elements which are at a difference of 1, we can use sorting to our advantage. If we sort the given <script type=\"math/tex; mode=display\">nums</script> array, the related elements will get arranged close to each other. Thus, we can traverse over the sorted array, and find the count of similar elements and elements one larger than the current ones, which occur consecutively(all the similar elements will be lying consecutively now). Initially, this value is stored in <script type=\"math/tex; mode=display\">prev\\_count</script> variable. Then, if we encounter an element which is just 1 larger than the last elements, we count the occurences of such elements as well. This value is stored in <script type=\"math/tex; mode=display\">count</script> variable. </p> \n  <p>Thus, now for the harmonic subsequence comprised of only these two elements is a subsequence of length <script type=\"math/tex; mode=display\">count + prev\\_count</script>. This result is stored in <script type=\"math/tex; mode=display\">res</script> for each subsequence found. When we move forward to considering the next set of similar consecutive elements, we need to update the <script type=\"math/tex; mode=display\">prev\\_count</script> with the <script type=\"math/tex; mode=display\">count</script>'s value, since now <script type=\"math/tex; mode=display\">count</script> will act as the count of the elements 1 lesser than the next elements encountered. The value of <script type=\"math/tex; mode=display\">res</script> is always updated to be the larger of previous <script type=\"math/tex; mode=display\">res</script> and the current <script type=\"math/tex; mode=display\">count + prev\\_count</script> value.</p> \n  <p>When we are done traversing over the whole array, the value of <script type=\"math/tex; mode=display\">res</script> gives us the required result.</p> \n  <iframe src=\"https://leetcode.com/playground/u6hDRMkp/shared\" frameborder=\"0\" name=\"u6hDRMkp\" width=\"100%\" height=\"462\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(nlogn)</script>. Sorting takes <script type=\"math/tex; mode=display\">O(nlogn)</script> time.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(logn)</script>. <script type=\"math/tex; mode=display\">logn</script> space is required by sorting in average case.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-4-using-hashmapaccepted\">Approach #4 Using HashMap[Accepted]:</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In this approach, we make use of a hashmap <script type=\"math/tex; mode=display\">map</script> which stores the number of times an element occurs in the array along with the element's value in the form <script type=\"math/tex; mode=display\">(num: count\\_num)</script>, where <script type=\"math/tex; mode=display\">num</script> refers to an element in the array and <script type=\"math/tex; mode=display\">count\\_num</script> refers to the number of times this <script type=\"math/tex; mode=display\">num</script> occurs in the <script type=\"math/tex; mode=display\">nums</script> array. We traverse over the <script type=\"math/tex; mode=display\">nums</script> array and fill this <script type=\"math/tex; mode=display\">map</script> once.</p> \n  <p>After this, we traverse over the keys of the <script type=\"math/tex; mode=display\">map</script> created. For every key of the <script type=\"math/tex; mode=display\">map</script> considered, say <script type=\"math/tex; mode=display\">key</script>, we find out if the map contains the <script type=\"math/tex; mode=display\">key + 1</script>. Such an element is found, since only such elements can be counted for the harmonic subsequence if <script type=\"math/tex; mode=display\">key</script> is considered as one of the element of the harmonic subsequence. We need not care about <script type=\"math/tex; mode=display\">key - 1</script>, because if <script type=\"math/tex; mode=display\">key</script> is present in the harmonic subsequence, at one time either <script type=\"math/tex; mode=display\">key + 1</script> or <script type=\"math/tex; mode=display\">key - 1</script> only could be included in the harmonic subsequence. The case of <script type=\"math/tex; mode=display\">key - 1</script> being in the harmonic subsequence will automatically be considered, when <script type=\"math/tex; mode=display\">key - 1</script> is encountered as the current key. </p> \n  <p>Now, whenver we find that <script type=\"math/tex; mode=display\">key + 1</script> exists in the keys of <script type=\"math/tex; mode=display\">map</script>, we determine the count of the current harmonic subsequence as <script type=\"math/tex; mode=display\">count_{key} + count_{key+1}</script>, where <script type=\"math/tex; mode=display\">count_i</script> refers to the value corresponding to the key <script type=\"math/tex; mode=display\">i</script> in <script type=\"math/tex; mode=display\">map</script>, which reprents the number of times <script type=\"math/tex; mode=display\">i</script> occurs in the array <script type=\"math/tex; mode=display\">nums</script>.</p> \n  <p>Look at the animation below for a pictorial view of the process:</p> \n  <p>!?!../Documents/594_Harmonic_Subsequence_2.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/goJjGNub/shared\" frameborder=\"0\" name=\"goJjGNub\" width=\"100%\" height=\"292\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. One loop is required to fill <script type=\"math/tex; mode=display\">map</script> and one for traversing the <script type=\"math/tex; mode=display\">map</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. In worst case map size grows upto size <script type=\"math/tex; mode=display\">n</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-5-in-single-loop-accepted\">Approach #5 In single loop [Accepted]:</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Instead of filling the <script type=\"math/tex; mode=display\">map</script> first and then traversing over the <script type=\"math/tex; mode=display\">map</script> to determine the lengths of the harmonic subsequences encountered, we can traverse over the <script type=\"math/tex; mode=display\">nums</script> array, and while doing the traversals, we can determine the lengths of the harmonic subsequences possible till the current index of the <script type=\"math/tex; mode=display\">nums</script> array. </p> \n  <p>The method of finding the length of harmonic subsequence remains the same as the last approach. But, this time, we need to consider the existence of both <script type=\"math/tex; mode=display\">key + 1</script> and <script type=\"math/tex; mode=display\">key - 1</script> exclusively and determine the counts corresponding to both the cases. This is needed now because it could be possible that <script type=\"math/tex; mode=display\">key</script> has already been added to the <script type=\"math/tex; mode=display\">map</script> and later on <script type=\"math/tex; mode=display\">key - 1</script> is encountered. In this case, if we consider the presence of <script type=\"math/tex; mode=display\">key + 1</script> only, we'll go in the wrong direction.</p> \n  <p>Thus, we consider the <script type=\"math/tex; mode=display\">count</script>s corresponding to both the cases separately for every <script type=\"math/tex; mode=display\">key</script> and determine the maximum out of them. Thus, now the same task can be done only in a single traveral of the <script type=\"math/tex; mode=display\">nums</script> array.</p> \n  <p>See the animation below for understanding the process:</p> \n  <p>!?!../Documents/594_Harmonic_Subsequence_3.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/w3zAS2Rm/shared\" frameborder=\"0\" name=\"w3zAS2Rm\" width=\"100%\" height=\"309\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Only one loop is there.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. <script type=\"math/tex; mode=display\">map</script> size grows upto size <script type=\"math/tex; mode=display\">n</script>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 593,
    "article_live": true,
    "article_slug": "valid-square",
    "title": "Valid Square",
    "title_slug": "valid-square",
    "content": "<p>Given the coordinates of four points in 2D space, return whether the four points could construct a square.</p>\r\n\r\n<p>The coordinate (x,y) of a point is represented by an integer array with two integers.</p>\r\n\r\n<p><b>Example:</b><br />\r\n<pre>\r\n<b>Input:</b> p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]\r\n<b>Output:</b> True\r\n</pre>\r\n</p>\r\n\r\n<p> Note: \r\n<ol>\r\n<li>All the input integers are in the range [-10000, 10000].</li>\r\n<li>A valid square has four equal sides with positive length and four equal angles (90-degree angles).</li>\r\n<li>Input points have no order.</li>\r\n</ol>\r\n</p>",
    "tags": "Math",
    "difficulty": 2,
    "frontend_article_id": 593,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-accepted\">Approach #1 Brute Force [Accepted]</a></li> \n      <li><a href=\"#approach-2-using-sorting-accepted\">Approach #2 Using Sorting [Accepted]</a></li> \n      <li><a href=\"#approach-3-checking-every-case-accepted\">Approach #3 Checking every case [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-accepted\">Approach #1 Brute Force [Accepted]</h4> \n  <p>The idea behind determining whether 4 given set of points constitute a valid square or not is really simple. Firstly, we need to determine if the sides of the qaudrilateral formed by these 4 points are equal. But checking only this won't suffice. Since, this condition will be satisfied even in the case of a rhombus, where all the four sides are equal but the adjacent sides aren't perpendicular to each other. Thus, we also need to check if the lengths of the diagonals formed between the corners of the quadrilateral are equal. If both the conditions are satisfied, then only the given set of points can be deemed appropriate for constituting a square.</p> \n  <p>Now, the problem arises in determining which pairs of points act as the adjacent points on the square boundary. So, the simplest method is to consider every possible case. For the given 4 points, <script type=\"math/tex; mode=display\">[p_0, p_1, p_2, p_3]</script>, there are a total of 4! ways in which these points can be arranged to be considered as the square's boundaries. We can generate every possible permutation and check if any permutation leads to the valid square arrangement of points.</p> \n  <iframe src=\"https://leetcode.com/playground/kR62YSDY/shared\" frameborder=\"0\" name=\"kR62YSDY\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant number of permutations(<script type=\"math/tex; mode=display\">4!</script>) are generated.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant space is required.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-using-sorting-accepted\">Approach #2 Using Sorting [Accepted]</h4> \n  <p>Instead of considering all the permutations of arrangements possible, we can make use of maths to simplify this problem a bit. If we sort the given set of points based on their x-coordinate values, and in the case of a tie, based on their y-coordinate value, we can obtain an arrangement, which directly reflects the arrangement of points on a valid square boundary possible.</p> \n  <p>Consider the only possible cases as shown in the figure below:</p> \n  <p><img alt=\"Valid_Square\" src=\"../Figures/593_Valid_Square_1.PNG\"></p> \n  <p>In each case, after sorting, we obtain the following conclusion regarding the connections of the points:</p> \n  <ol> \n   <li> <p> <script type=\"math/tex; mode=display\">p_0p_1</script>, <script type=\"math/tex; mode=display\">p_1p_3</script>, <script type=\"math/tex; mode=display\">p_3p_2</script> and <script type=\"math/tex; mode=display\">p_2p_0</script> form the four sides of any valid square.</p> </li> \n   <li> <p> <script type=\"math/tex; mode=display\">p_0p_3</script> and <script type=\"math/tex; mode=display\">p_1p_2</script> form the diagonals of the square.</p> </li> \n  </ol> \n  <p>Thus, once the sorting of the points is done, based on the above knowledge, we can directly compare <script type=\"math/tex; mode=display\">p_0p_1</script>, <script type=\"math/tex; mode=display\">p_1p_3</script>, <script type=\"math/tex; mode=display\">p_3p_2</script> and <script type=\"math/tex; mode=display\">p_2p_0</script> for equality of lengths(corresponding to the sides); and <script type=\"math/tex; mode=display\">p_0p_3</script> and <script type=\"math/tex; mode=display\">p_1p_2</script> for equality of lengths(corresponding to the diagonals).</p> \n  <iframe src=\"https://leetcode.com/playground/xp6gv2NM/shared\" frameborder=\"0\" name=\"xp6gv2NM\" width=\"100%\" height=\"241\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Sorting 4 points takes constant time.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant space is required.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-checking-every-case-accepted\">Approach #3 Checking every case [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>If we consider all the permutations descripting the arrangement of points as in the brute force approach, we can come up with the following set of 24 arrangements:</p> \n  <p><img alt=\"Valid_Square\" src=\"../Figures/593_Valid_Square_2.PNG\"></p> \n  <p>In this figure, the rows with the same shaded color indicate that the corresponding arrangements lead to the same set of edges and diagonals. Thus, we can see that only three unique cases exist. Thus, instead of generating all the 24 permutations, we check for the equality of edges and diagonals for only the three distinct cases.</p> \n  <iframe src=\"https://leetcode.com/playground/7wt6ZUJR/shared\" frameborder=\"0\" name=\"7wt6ZUJR\" width=\"100%\" height=\"258\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(1)</script>. A fixed number of comparisons are done.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. No extra space required.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 592,
    "article_live": true,
    "article_slug": "kill-process-3",
    "title": "Fraction Addition and Subtraction",
    "title_slug": "fraction-addition-and-subtraction",
    "content": "<p>Given a string representing an expression of fraction addition and subtraction, you need to return the calculation result in string format. The final result should be <a href = \"https://en.wikipedia.org/wiki/Irreducible_fraction\">irreducible fraction</a>. If your final result is an integer, say <code>2</code>, you need to change it to the format of fraction that has denominator <code>1</code>. So in this case, <code>2</code> should be converted to <code>2/1</code>.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b>\"-1/2+1/2\"\r\n<b>Output:</b> \"0/1\"\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b>\"-1/2+1/2+1/3\"\r\n<b>Output:</b> \"1/3\"\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 3:</b><br />\r\n<pre>\r\n<b>Input:</b>\"1/3-1/2\"\r\n<b>Output:</b> \"-1/6\"\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 4:</b><br />\r\n<pre>\r\n<b>Input:</b>\"5/3+1/3\"\r\n<b>Output:</b> \"2/1\"\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The input string only contains <code>'0'</code> to <code>'9'</code>, <code>'/'</code>, <code>'+'</code> and <code>'-'</code>. So does the output.</li>\r\n<li>Each fraction (input and output) has format <code>±numerator/denominator</code>. If the first input fraction or the output is positive, then <code>'+'</code> will be omitted.</li>\r\n<li>The input only contains valid <b>irreducible fractions</b>, where the <b>numerator</b> and <b>denominator</b> of each fraction will always be in the range [1,10]. If the denominator is 1, it means this fraction is actually an integer in a fraction format defined above.</li> \r\n<li>The number of given fractions will be in the range [1,10].</li>\r\n<li>The numerator and denominator of the <b>final result</b> are guaranteed to be valid and in the range of 32-bit int.</li>\r\n</ol>\r\n</p>",
    "tags": "Math",
    "difficulty": 2,
    "frontend_article_id": 592,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-using-lcmaccepted\">Approach #1 Using LCM[Accepted]</a></li> \n      <li><a href=\"#approach-2-using-gcdaccepted\">Approach #2 Using GCD[Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-using-lcmaccepted\">Approach #1 Using LCM[Accepted]</h4> \n  <p>The first obvious step to be undertaken is to split the given string into individual fractions. We split the string based on <code>+</code> and <code>-</code> sign. We store the signs in the order in which they appear in the string in <script type=\"math/tex; mode=display\">sign</script> array. Further, after getting the individual fractions, we further split the fractions based on <code>/</code> sign. Thus, we obtain the individual numerator and denominator parts. We store the same in <script type=\"math/tex; mode=display\">num</script> and <script type=\"math/tex; mode=display\">den</script> arrays respectively.</p> \n  <p>Now, we've got the data ready to be worked upon. In order to see the method we've used in this implementation, we'll take an example and understand the way we work on it.</p> \n  <p>Let's say, the given fraction is:</p> \n  <p> <script type=\"math/tex; mode=display\">\\frac{3}{2} + \\frac{5}{3} -\\frac{7}{6}</script> </p> \n  <p>We need to equalize all the denominators so as to be able to add and subtract the numerators easily. The nearest value the denominators can be scaled upto is the LCM of all the denominators. Thus, we need to find the LCM of all the denominators and then multiply all the denominators with appropriate integer factors to make them equal to the LCM. But, in order to keep the individual fraction values unchanged, we need to multiply the individual numerators also with the same factors. </p> \n  <p>In order to find the LCM, we can go as follows. We use the method <script type=\"math/tex; mode=display\">lcm(a,b,c) = lcm( lcm(a,b), c)</script>. Thus, if we can compute the lcm of two denominators, we can keep on repeating the process iteratively over the denominators to get the overall lcm. To find the lcm of two numbers <script type=\"math/tex; mode=display\">a</script> and <script type=\"math/tex; mode=display\">b</script>, we use <script type=\"math/tex; mode=display\">lcm(a,b) = (a*b)/gcd(a,b)</script>. For the above example, the <script type=\"math/tex; mode=display\">lcm</script> turns out to be 6.</p> \n  <p>Thus, we scale up the denominators to 6 as follows:</p> \n  <p> <script type=\"math/tex; mode=display\">\\frac{3*3}{2*3} + \\frac{5*2}{3*2} -\\frac{7}{6}</script> </p> \n  <p>Thus, we can observe that, the scaling factor for a fraction <script type=\"math/tex; mode=display\">\\frac{num}{den}</script> is given by: <script type=\"math/tex; mode=display\">{num*x}/{den*x}</script>, where <script type=\"math/tex; mode=display\">x</script> is the corresponding scaling factor. Note that, <script type=\"math/tex; mode=display\">den*x=lcm</script>. Thus, <script type=\"math/tex; mode=display\">x=lcm/den</script>. Thus, we find out the corresponding scaling factor <script type=\"math/tex; mode=display\">x_i</script> for each fraction.</p> \n  <p>After this, we can directly add or subtract the new scaled numerators.</p> \n  <p>In the current example, we obtain <script type=\"math/tex; mode=display\">\\frac{12}{6}</script> as the result. Now, we need to convert this into an irreducible fraction. Thus, if we obtain <script type=\"math/tex; mode=display\">\\frac{num_i}{den_i}</script> as the final result, we need to find a largest factor <script type=\"math/tex; mode=display\">y</script>, which divides both <script type=\"math/tex; mode=display\">num_i</script> and <script type=\"math/tex; mode=display\">den_i</script>. Such a number, as we know, is the gcd of <script type=\"math/tex; mode=display\">num_i</script> and <script type=\"math/tex; mode=display\">den_i</script>.</p> \n  <p>Thus, to convert the result <script type=\"math/tex; mode=display\">\\frac{num_i}{den_i}</script>, we divide both the numerator and denominator by the gcd of the two numbers <script type=\"math/tex; mode=display\">y</script> to obtain the final irreducible <script type=\"math/tex; mode=display\">\\frac{num_i/y}{den_i/y}</script>.</p> \n  <p>Note: A problem with this approach is that we find the lcm of all the denominators in a single go and then reduce the overall fraction at the end. Thus, the lcm value could become very large and could lead to an overflow. But, this solution suffices for the current range of numbers.</p> \n  <iframe src=\"https://leetcode.com/playground/8oKguDZy/shared\" frameborder=\"0\" name=\"8oKguDZy\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(nlogx)</script>. Euclidean GCD algorithm takes <script type=\"math/tex; mode=display\">O(log(a.b))</script> time for finding gcd of two numbers <script type=\"math/tex; mode=display\">a</script> and <script type=\"math/tex; mode=display\">b</script>. Here <script type=\"math/tex; mode=display\">n</script> refers to the number of fractions in the input string and <script type=\"math/tex; mode=display\">x</script> is the maximum possible value of denominator.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Size of <script type=\"math/tex; mode=display\">num</script>, <script type=\"math/tex; mode=display\">den</script> and <script type=\"math/tex; mode=display\">sign</script> list grows upto <script type=\"math/tex; mode=display\">n</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-using-gcdaccepted\">Approach #2 Using GCD[Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>We know that we can continue the process of evaluating the given fractions by considering pairs of fractions at a time and continue the process considering the result obtained and the new fraction to be evaluated this time. We make use of this observation, and thus, instead of segregating the signs, numerators and denominators first, we directly start scanning the given strings and operate on the fractions obtained till now whenever a new sign is encountered.</p> \n  <p>We operate on the pairs of fractions, and keep on reducing the result obtained to irreducible fractions on the way. By doing this, we can reduce the chances of the problem of potential overflow possible in case the denominators lead to a large value of lcm.</p> \n  <p>We also observed from the last approach, that we need to equalize the denominators of a pair of fractions say:</p> \n  <p> <script type=\"math/tex; mode=display\">\\frac{a}{b} + \\frac{c}{d}</script> </p> \n  <p>We used a scaling factor of <script type=\"math/tex; mode=display\">x</script> for the first fraction(both numerator and denominator). Here, <script type=\"math/tex; mode=display\">x=lcm(b,d)/b</script>. For the second fraction, the scaling factor <script type=\"math/tex; mode=display\">y</script> is given by <script type=\"math/tex; mode=display\">y=lcm(b,d)/d</script>. Here, $<script type=\"math/tex; mode=display\">lcm(b,d)=b*d/gcd(b,d)</script>. Thus, instead of finding the lcm and then again determining the scaling factor, we can directly use: <script type=\"math/tex; mode=display\">x=(b*d)/(gcd(b,d)*b) = d/gcd(b,d)</script>, and <script type=\"math/tex; mode=display\">y=(b*d)/(gcd(b,d)*d)</script>. Thus, we need to scale the numerators appropriately and add/subtract them in terms of pairs. The denominators are scaled in the same manner to the lcm of the two denominators involved.</p> \n  <p>After evaluting every pair of fractions, we again reduce them to irreducible fractions by diving both the numerator and denominator of the resultant fraction by the gcd of the two.</p> \n  <iframe src=\"https://leetcode.com/playground/Nt5WV8C2/shared\" frameborder=\"0\" name=\"Nt5WV8C2\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(nlogx)</script>. Euclidean GCD algorithm takes <script type=\"math/tex; mode=display\">O(log(a.b))</script> time for finding gcd of two numbers <script type=\"math/tex; mode=display\">a</script> and <script type=\"math/tex; mode=display\">b</script>. Here <script type=\"math/tex; mode=display\">n</script> refers to the number of fractions in the input string and <script type=\"math/tex; mode=display\">x</script> is the maximum possible value of denominator.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Size of <script type=\"math/tex; mode=display\">sign</script> list grows upto <script type=\"math/tex; mode=display\">n</script>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 591,
    "article_live": true,
    "article_slug": "tag-validator",
    "title": "Tag Validator",
    "title_slug": "tag-validator",
    "content": "<p>Given a string representing a code snippet, you need to implement a tag validator to parse the code and return whether it is valid. A code snippet is valid if all the following rules hold:<p>\r\n<ol>\r\n<li>The code must be wrapped in a <b>valid closed tag</b>. Otherwise, the code is invalid.</li>\r\n<li>A <b>closed tag</b> (not necessarily valid) has exactly the following format : <code>&lt;TAG_NAME&gt;TAG_CONTENT&lt;/TAG_NAME&gt;</code>. Among them, <code>&lt;TAG_NAME&gt;</code> is the start tag, and <code>&lt;/TAG_NAME&gt;</code> is the end tag. The TAG_NAME in start and end tags should be the same. A closed tag is <b>valid</b> if and only if the TAG_NAME and TAG_CONTENT are valid.</li>\r\n<li>A <b>valid</b> <code>TAG_NAME</code> only contain <b>upper-case letters</b>, and has length in range [1,9]. Otherwise, the <code>TAG_NAME</code> is <b>invalid</b>.</li>\r\n<li>A <b>valid</b> <code>TAG_CONTENT</code> may contain other <b>valid closed tags</b>, <b>cdata</b> and any characters (see note1) <b>EXCEPT</b> unmatched <code>&lt;</code>, unmatched start and end tag, and unmatched or closed tags with invalid TAG_NAME. Otherwise, the <code>TAG_CONTENT</code> is <b>invalid</b>.</li>\r\n<li>A start tag is unmatched if no end tag exists with the same TAG_NAME, and vice versa. However, you also need to consider the issue of unbalanced when tags are nested.</li>\r\n<li>A <code>&lt;</code> is unmatched if you cannot find a subsequent <code>></code>. And when you find a <code>&lt;</code> or <code>&lt;/</code>, all the subsequent characters until the next <code>></code> should be parsed as TAG_NAME  (not necessarily valid).</li>\r\n<li>The cdata has the following format : <code>&lt;![CDATA[CDATA_CONTENT]]&gt;</code>. The range of <code>CDATA_CONTENT</code> is defined as the characters between <code>&lt;![CDATA[</code> and the <b>first subsequent</b> <code>]]></code>. </li>\r\n<li><code>CDATA_CONTENT</code> may contain <b>any characters</b>. The function of cdata is to forbid the validator to parse <code>CDATA_CONTENT</code>, so even it has some characters that can be parsed as tag (no matter valid or invalid), you should treat it as <b>regular characters</b>. </li>\r\n</ol>\r\n\r\n<p><b>Valid Code Examples:</b><br />\r\n<pre>\r\n<b>Input:</b> \"&lt;DIV&gt;This is the first line &lt;![CDATA[&lt;div&gt;]]&gt;&lt;/DIV&gt;\"<br />\r\n<b>Output:</b> True<br />\r\n<b>Explanation:</b> <br>\r\nThe code is wrapped in a closed tag : &lt;DIV> and &lt;/DIV>. <br>\r\nThe TAG_NAME is valid, the TAG_CONTENT consists of some characters and cdata. <br>\r\nAlthough CDATA_CONTENT has unmatched start tag with invalid TAG_NAME, it should be considered as plain text, not parsed as tag.<br>\r\nSo TAG_CONTENT is valid, and then the code is valid. Thus return true.<br />\r\n\r\n<b>Input:</b> \"&lt;DIV>>>  ![cdata[]] &lt;![CDATA[&lt;div>]>]]>]]>>]&lt;/DIV>\"<br />\r\n<b>Output:</b> True<br />\r\n<b>Explanation:</b><br />\r\nWe first separate the code into : start_tag|tag_content|end_tag.<br />\r\nstart_tag -> <b>\"&lt;DIV&gt;\"</b><br />\r\nend_tag -> <b>\"&lt;/DIV>\"</b><br />\r\ntag_content could also be separated into : text1|cdata|text2.<br />\r\ntext1 -> <b>\">>  ![cdata[]] \"</b><br />\r\ncdata -> <b>\"&lt;![CDATA[&lt;div>]>]]>\"</b>, where the CDATA_CONTENT is <b>\"&lt;div>]>\"</b><br />\r\ntext2 -> <b>\"]]>>]\"</b><br />\r\n\r\nThe reason why start_tag is NOT <b>\"&lt;DIV>>>\"</b> is because of the rule 6.\r\nThe reason why cdata is NOT <b>\"&lt;![CDATA[&lt;div>]>]]>]]>\"</b> is because of the rule 7.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Invalid Code Examples:</b><br />\r\n<pre>\r\n<b>Input:</b> \"&lt;A>  &lt;B> &lt;/A>   &lt;/B>\"\r\n<b>Output:</b> False\r\n<b>Explanation:</b> Unbalanced. If \"&lt;A>\" is closed, then \"&lt;B>\" must be unmatched, and vice versa.\r\n\r\n<b>Input:</b> \"&lt;DIV&gt;  div tag is not closed  &lt;DIV&gt;\"\r\n<b>Output:</b> False\r\n\r\n<b>Input:</b> \"&lt;DIV&gt;  unmatched &lt  &lt;/DIV&gt;\"\r\n<b>Output:</b> False\r\n\r\n<b>Input:</b> \"&lt;DIV&gt; closed tags with invalid tag name  &lt;b>123&lt;/b> &lt;/DIV&gt;\"\r\n<b>Output:</b> False\r\n\r\n<b>Input:</b> \"&lt;DIV&gt; unmatched tags with invalid tag name  &lt;/1234567890> and &lt;CDATA[[]]>  &lt;/DIV&gt;\"\r\n<b>Output:</b> False\r\n\r\n<b>Input:</b> \"&lt;DIV&gt;  unmatched start tag &lt;B>  and unmatched end tag &lt;/C>  &lt;/DIV&gt;\"\r\n<b>Output:</b> False\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>For simplicity, you could assume the input code (including the <b>any characters</b> mentioned above) only contain <code>letters</code>, <code>digits</code>, <code>'&lt;'</code>,<code>'>'</code>,<code>'/'</code>,<code>'!'</code>,<code>'['</code>,<code>']'</code> and <code>' '</code>.</li>\r\n</ol>\r\n</p>",
    "tags": "String, Stack",
    "difficulty": 3,
    "frontend_article_id": 591,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-using-stack-accepted\">Approach #1 Using Stack [Accepted]</a></li> \n      <li><a href=\"#approach-2-using-regex-accepted\">Approach #2 Using Regex [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-using-stack-accepted\">Approach #1 Using Stack [Accepted]</h4> \n  <p>Summarizing the given problem, we can say that we need to determine whether a tag is valid or not, by checking the following properties.</p> \n  <ol> \n   <li> <p>The code should be wrapped in valid closed tag.</p> </li> \n   <li> <p>The <code>TAG_NAME</code> should be valid.</p> </li> \n   <li> <p>The <code>TAG_CONTENT</code> should be valid.</p> </li> \n   <li> <p>The <strong>cdata</strong> should be valid.</p> </li> \n   <li> <p>All the tags should be closed. i.e. each start-tag should have a corresponding end-tag and vice-versa and the order of the tags should be correct as well.</p> </li> \n  </ol> \n  <p>In order to check the validity of all these, firstly, we need to identify which parts of the given <script type=\"math/tex; mode=display\">code</script> string act as which part from the above mentioned categories. To understand how it's done, we'll go through the implementation and the reasoning behind it step by step.</p> \n  <p>We iterate over the given <script type=\"math/tex; mode=display\">code</script> string. Whenever a <code>&lt;</code> is encountered(unless we are currently inside <code>&lt;![CDATA[...]]&gt;</code>), it indicates the beginning of either a <code>TAG_NAME</code>(start tag or end tag) or the beginning of cdata as per the conditions given in the problem statement. </p> \n  <p>If the character immediately following this <code>&lt;</code> is an <code>!</code>, the characters following this <code>&lt;</code> can't be a part of a valid <code>TAG_NAME</code>, since only upper-case letters(in case of a start tag) or <code>/</code> followed by upper-case letters(in the case of an end tag). Thus, the choice now narrows down to only <strong>cdata</strong>. Thus, we need to check if the current bunch of characters following <code>&lt;!</code>(including it) constitute a valid <strong>cdata</strong>. For doing this, firstly we find out the first matching <code>]]&gt;</code> following the current <code>&lt;!</code> to mark the ending of <strong>cdata</strong>. If no such matching <code>]]&gt;</code> exists, the <script type=\"math/tex; mode=display\">code</script> string is considered as invalid. Apart from this, the <code>&lt;!</code> should also be immediately followed by <code>CDATA[</code> for the <strong>cdata</strong> to be valid. The characters lying inside the <code>&lt;![CDATA[</code> and <code>]]&gt;</code> do not have any constraints on them.</p> \n  <p>If the character immediately following the <code>&lt;</code> encountered isn't an <code>!</code>, this <code>&lt;</code> can only mark the beginnning of <code>TAG_NAME</code>. Now, since a valid start tag can't contain anything except upper-case letters, if a <code>/</code> is found after <code>&lt;</code>, the <code>&lt;/</code> pair indicates the beginning of an end tag. Now, when a <code>&lt;</code> refers to the beginning of a <code>TAG_NAME</code>(either start-tag or end-tag), we find out the first closing <code>&gt;</code> following the <code>&lt;</code> to find out the substring(say <script type=\"math/tex; mode=display\">s</script>), that constitutes the <code>TAG_NAME</code>. This <script type=\"math/tex; mode=display\">s</script> should satisfy all the criterion to constitute a valid <code>TAG_NAME</code>. Thus, for every such <script type=\"math/tex; mode=display\">s</script>, we check if it contains all upper-case letters and also check its length(It should be between 1 to 9). If any of the criteria isn't fulfilled, <script type=\"math/tex; mode=display\">s</script> doesn't constitue a valid <code>TAG_NAME</code>. Hence, the <script type=\"math/tex; mode=display\">code</script> string turns out to be invalid as well.</p> \n  <p>Apart from checking the validity of the <code>TAG_NAME</code>, we also need to ensure that the tags always exist in pairs. i.e. for every start-tag, a corresponding end-tag should always exist. Further, we can note that in case of multiple <code>TAG_NAME</code>'s, the <code>TAG_NAME</code> whose start-tag comes later than the other ones, should have its end-tag appearing before the end-tags of those other <code>TAG_NAME</code>'s. i.e. the tag which starts later should end first. </p> \n  <p>From this, we get the intuition that we can make use of a <script type=\"math/tex; mode=display\">stack</script> to check the existence of matching start and end-tags. Thus, whenever we find out a valid start-tag, as mentioned above, we push its <code>TAG_NAME</code> string onto a <script type=\"math/tex; mode=display\">stack</script>. Now, whenever an end-tag is found, we compare its <code>TAG_NAME</code> with the <code>TAG_NAME</code> at the top the <script type=\"math/tex; mode=display\">stack</script> and remove this element from the <script type=\"math/tex; mode=display\">stack</script>. If the two don't match, this implies that either the current end-tag has no corresponding start-tag or there is a problem with the ordering of the tags. The two need to match for the tag-pair to be valid, since there can't exist an end-tag without a corresponding start-tag and vice-versa. Thus, if a match isn't found, we can conclude that the given <script type=\"math/tex; mode=display\">code</script> string is invalid.</p> \n  <p>Now, after the complete <script type=\"math/tex; mode=display\">code</script> string has been traversed, the <script type=\"math/tex; mode=display\">stack</script> should be empty if all the start-tags have their corresponding end-tags as well. If the <script type=\"math/tex; mode=display\">stack</script> isn't empty, this implies that some start-tag doesn't have the corresponding end-tag, violating the closed-tag's validity condition.</p> \n  <p>Further, we also need to ensure that the given <script type=\"math/tex; mode=display\">code</script> is completely enclosed within closed tags. For this, we need to ensure that the first <strong>cdata</strong> found is also inside the closed tags. Thus, when we find a possibility of the presence of <strong>cdata</strong>, we proceed further only if we've already found a start tag, indicated by a non-empty stack. Further, to ensure that no data lies after the last end-tag, we need to ensure that the <script type=\"math/tex; mode=display\">stack</script> doesn't become empty before we reach the end of the given <script type=\"math/tex; mode=display\">code</script> string, since an empty <script type=\"math/tex; mode=display\">stack</script> indicates that the last end-tag has been encountered.</p> \n  <p>The following animation depicts the process.</p> \n  <p>!?!../Documents/Tag_Validator_Stack.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/cELPrQEw/shared\" frameborder=\"0\" name=\"cELPrQEw\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. We traverse over the given <script type=\"math/tex; mode=display\">code</script> string of length <script type=\"math/tex; mode=display\">n</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The stack can grow upto a size of <script type=\"math/tex; mode=display\">n/3</script> in the worst case. e.g. In case of <code>&lt;A&gt;&lt;B&gt;&lt;C&gt;&lt;D&gt;</code>, <script type=\"math/tex; mode=display\">n</script>=12 and number of tags = 12/3 = 4.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-using-regex-accepted\">Approach #2 Using Regex [Accepted]</h4> \n  <p>Instead of manually checking the given <script type=\"math/tex; mode=display\">code</script> string for checking the validity of <code>TAG_NAME</code>, <code>TAG_CONTENT</code> and <strong>cdata</strong>, we can make use of an inbuilt java fuunctionality known as regular expressions.</p> \n  <p>A regular expression is a special sequence of characters that helps you match or find other strings or sets of strings, using a specialized syntax held in a pattern. They can be used to search, edit, or manipulate text and data. The most common quantifiers used in regular expressions are listed below. A quantifier after a token (such as a character) or group specifies how often that preceding element is allowed to occur.</p> \n  <p><code>?</code> The question mark indicates zero or one occurrences of the preceding element. For example, colou?r matches both \"color\" and \"colour\".</p> \n  <p><code>*</code> The asterisk indicates zero or more occurrences of the preceding element. For example, ab*c matches \"ac\", \"abc\", \"abbc\", \"abbbc\", and so on.</p> \n  <p><code>+</code> The plus sign indicates one or more occurrences of the preceding element. For example, ab+c matches \"abc\", \"abbc\", \"abbbc\", and so on, but not \"ac\".</p> \n  <p><code>{n}</code> The preceding item is matched exactly <strong>n</strong> times.</p> \n  <p><code>{min,}</code> The preceding item is matched <strong>min</strong> or more times.</p> \n  <p><code>{min,max}</code> The preceding item is matched at least <strong>min</strong> times, but not more than <strong>max</strong> times.</p> \n  <p><code>|</code> A vertical bar separates alternatives. For example, gray|grey can match \"gray\" or \"grey\".</p> \n  <p><code>()</code> Parentheses are used to define the scope and precedence of the operators (among other uses). For example, gray|grey and gr(a|e)y are equivalent patterns which both describe the set of \"gray\" or \"grey\".</p> \n  <p><code>[...]</code> Matches any single character in brackets.</p> \n  <p><code>[^...]</code> Matches any single character not in brackets.</p> \n  <p>Thus, by making use of regex, we can directly check the validity of the <script type=\"math/tex; mode=display\">code</script> string directly(except the nesting of the inner tags) by using the regex expression below:</p> \n  <p><code>&lt;([A-Z]{1,9})&gt;([^&lt;]*((&lt;\\/?[A-Z]{1,9}&gt;)|(&lt;!\\[CDATA\\[(.*?)]]&gt;))?[^&lt;]*)*&lt;\\/\\1&gt;</code></p> \n  <p>The image below shows the portion of the string that each part of the expression helps to match:</p> \n  <p align=\"center\"><img alt=\"Regex\" src=\"../Figures/591/591_Tag_Validator.PNG\"></p> \n  <p>But, if we make use of back-referencing as mentioned above, the matching process takes a very large amount of CPU time. Thus, we use the regex only to check the validity of the <code>TAG_CONTENT</code>, <code>TAG_NAME</code> and the <strong>cdata</strong>. We check the presence of the outermost closed tags by making use of a <script type=\"math/tex; mode=display\">stack</script> as done in the last approach.</p> \n  <p>The rest of the process remains the same as in the last approach, except that we need not manually check the validity of <code>TAG_CONTENT</code>, <code>TAG_NAME</code> and the <strong>cdata</strong>, since it is already done by the regex expression. We only need to check the presence of inner closed tags.</p> \n  <p>Check <a href=\"https://regexr.com/\">this</a> link for testing any regular expression on a sample text.</p> \n  <iframe src=\"https://leetcode.com/playground/vvcbT3rc/shared\" frameborder=\"0\" name=\"vvcbT3rc\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : Regular Expressions are/can be implemented in the form of Finite State Machines. Thus, the time complexity is dependent on the internal representation. In case of any suggestions, please comment below.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The stack can grow upto a size of <script type=\"math/tex; mode=display\">n/3</script> in the worst case. e.g. In case of <code>&lt;A&gt;&lt;B&gt;&lt;C&gt;&lt;D&gt;</code>, <script type=\"math/tex; mode=display\">n</script>=12 and number of tags = 12/3 = 4.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 588,
    "article_live": true,
    "article_slug": "design-in-memory-file-system",
    "title": "Design In-Memory File System",
    "title_slug": "design-in-memory-file-system",
    "tags": "Design",
    "difficulty": 3,
    "frontend_article_id": 588,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-using-separate-directory-and-file-listaccepted\">Approach #1 Using separate Directory and File List[Accepted]</a></li> \n      <li><a href=\"#approach-2-using-unified-directory-and-file-listaccepted\">Approach #2 Using unified Directory and File List[Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-using-separate-directory-and-file-listaccepted\">Approach #1 Using separate Directory and File List[Accepted]</h4> \n  <p>We start our discussion by looking at the directory structure used. The root directory acts as the base of the directory structure. Each directory contains two hashmaps namely <script type=\"math/tex; mode=display\">dirs</script> and <script type=\"math/tex; mode=display\">files</script>. The <script type=\"math/tex; mode=display\">dirs</script> contains data in the form <script type=\"math/tex; mode=display\">[(subdirectory_1\\_name: subdirectory_{1\\_structure}), (subdirectory_2\\_name: subdirectory_{2\\_structure})...]</script>. The <script type=\"math/tex; mode=display\">files</script> contains data in the form <script type=\"math/tex; mode=display\">[(file_1: file_{1\\_contents}), (file_2: file_{2\\_contents})...]</script>. This directory structure is shown below with a sample showing just the first two levels.</p> \n  <p><img alt=\"Design_Memory\" src=\"../Figures/588_Design_In_Memory.PNG\"></p> \n  <p>Now, we'll discuss how we implement the various commands required.</p> \n  <ol> \n   <li> <p><code>ls</code>: In this case, we start off by initializing <script type=\"math/tex; mode=display\">t</script>, a temporary directory pointer, to the root directory. We split the input directory path based on <code>/</code> and obtain the individual levels of directory names in a <script type=\"math/tex; mode=display\">d</script> array. Then, we traverse over the tree directory structure based on the individual directories found and we keep on updating the <script type=\"math/tex; mode=display\">t</script> directory pointer to point to the new level of directory(child) as we go on entering deeper into the directory structure. At the end, we will stop at either the end level directory or at the file name depending upon the input given. If the last level in the input happens to be a file name, we simply need to return the file name. So, we directly return the last entry in the <script type=\"math/tex; mode=display\">d</script> array. If the last level entry happens to be a directory, we can obtain its subdirectory list from the list of keys in its <script type=\"math/tex; mode=display\">dirs</script> hashmap. Similarly, we can obtain the list of files in the last directory from the keys in the corresponding <script type=\"math/tex; mode=display\">files</script> hashmap. We append the two lists obtained, sort them and return the sorted appended list.</p> </li> \n   <li> <p><code>mkdir</code>: In response to this command, as in case of <code>ls</code>, we start entering the directory structure level by level. Whenever we reach a state where a directory mentioned in the path of <code>mkdir</code> doesn't exist, we create a new entry in the last valid directory's <script type=\"math/tex; mode=display\">dirs</script> structure and initialize its subdirectory list as an empty list. We keep on doing so till we reach the end level directory.</p> </li> \n   <li> <p><code>addContentToFile</code>: In response to this command as well, as in case of <code>ls</code>, we start entering the directory structure level by level. When we reach the level of the file name, we check if the file name already exists in the <script type=\"math/tex; mode=display\">files</script> keys. If it exists, we concatenate the current contents to the contents of the file(in the value section of the corresponding file). If it doesn't exist, we create a new entry in the current directory's <script type=\"math/tex; mode=display\">files</script> and initialize its contents with the current contents.</p> </li> \n   <li> <p><code>readContentFromFile</code>: As the previous cases, we reach the last directory level by traversing through the directory structure level by level. Then, in the last directory, we search for the file name entry in the corresponding <script type=\"math/tex; mode=display\">files</script>' keys and return its corresponding value as the contents of the file.</p> </li> \n  </ol> \n  <iframe src=\"https://leetcode.com/playground/EUzUEgvo/shared\" frameborder=\"0\" name=\"EUzUEgvo\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Performance Analysis</strong></p> \n  <ul> \n   <li> <p>The time complexity of executing an <code>ls</code> command is <script type=\"math/tex; mode=display\">O\\big(m+n+klog(k)\\big)</script>. Here, <script type=\"math/tex; mode=display\">m</script> refers to the length of the input string. We need to scan the input string once to split it and determine the various levels. <script type=\"math/tex; mode=display\">n</script> refers to the depth of the last directory level in the given input for <code>ls</code>. This factor is taken because we need to enter <script type=\"math/tex; mode=display\">n</script> levels of the tree structure to reach the last level. <script type=\"math/tex; mode=display\">k</script> refers to the number of entries(files+subdirectories) in the last level directory(in the current input). We need to sort these names giving a factor of <script type=\"math/tex; mode=display\">klog(k)</script>.</p> </li> \n   <li> <p>The time complexity of executing an <code>mkdir</code> command is <script type=\"math/tex; mode=display\">O(m+n)</script>. Here, <script type=\"math/tex; mode=display\">m</script> refers to the length of the input string. We need to scan the input string once to split it and determine the various levels. <script type=\"math/tex; mode=display\">n</script> refers to the depth of the last directory level in the <code>mkdir</code> input. This factor is taken because we need to enter <script type=\"math/tex; mode=display\">n</script> levels of the tree structure to reach the last level.</p> </li> \n   <li> <p>The time complexity of both <code>addContentToFile</code> and <code>readContentFromFile</code> is <script type=\"math/tex; mode=display\">O(m+n)</script>. Here, <script type=\"math/tex; mode=display\">m</script> refers to the length of the input string. We need to scan the input string once to split it and determine the various levels. <script type=\"math/tex; mode=display\">n</script> refers to the depth of the file name in the current input. This factor is taken because we need to enter <script type=\"math/tex; mode=display\">n</script> levels of the tree structure to reach the level where the files's contents need to be added/read from.</p> </li> \n   <li> <p>The advantage of this scheme of maintaining the directory structure is that it is expandable to include even more commands easily. For example, <code>rmdir</code> to remove a directory given an input directory path. We need to simply reach to the destined directory level and remove the corresponding directory entry from the corresponding <script type=\"math/tex; mode=display\">dirs</script> keys.</p> </li> \n   <li> <p>Renaming files/directories is also very simple, since all we need to do is to create a temporary copy of the directory structure/file with a new name and delete the last entry.</p> </li> \n   <li> <p>Relocating a hierarchichal subdirectory structure from one directory to the other is also very easy, since, all we need to do is obtain the address for the corresponding subdirectory class, and assign the same at the new positon in the new directory structure.</p> </li> \n   <li> <p>Extracting only directories or files list on any path is easy in this case, since we maintain separate entires for <script type=\"math/tex; mode=display\">dirs</script> and <script type=\"math/tex; mode=display\">files</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-using-unified-directory-and-file-listaccepted\">Approach #2 Using unified Directory and File List[Accepted]</h4> \n  <p>This design differs from the first design in that the current data structure for a Directory contains a unified <script type=\"math/tex; mode=display\">files</script> hashmap, which contains the list of all the files and subdirectories in the current directory. Apart from this, we contain an entry <script type=\"math/tex; mode=display\">isfile</script>, which when True indicates that the current <script type=\"math/tex; mode=display\">files</script> entry is actually corresponding to a file, otherwise it represents a directory. Further, since we are considering the directory and files' entries in the same manner, we need an entry for <script type=\"math/tex; mode=display\">content</script>, which contains the contents of the current file(if <script type=\"math/tex; mode=display\">isfile</script> entry is True in the current case). For entries corresponding to directories, the <script type=\"math/tex; mode=display\">content</script> field is kept empty.</p> \n  <p>The following figure shows the directory structure for the same example as in the case above, for the first two levels of the hierarchical structure. </p> \n  <p><img alt=\"Design_In_Memory\" src=\"../Figures/588_Design_In_Memory_3.PNG\"></p> \n  <p>The implementation of all the commands remains the same as in the last design, except that we need to make entries in the same <script type=\"math/tex; mode=display\">files</script> hashmap for both files and directories, corresponding to <code>addContentToFile</code> and <code>mkdir</code> respectively. Further, for <code>ls</code>, we need not extract entries separately for the files and directories, since they are unified in the current case, and can be obtained in a single go.</p> \n  <p>This approach is inspired by <a href=\"https://leetcode.com/shwangao\">@shawngao</a></p> \n  <iframe src=\"https://leetcode.com/playground/a7jiya7b/shared\" frameborder=\"0\" name=\"a7jiya7b\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Performance Analysis</strong></p> \n  <ul> \n   <li> <p>The time complexity of executing an <code>ls</code> command is <script type=\"math/tex; mode=display\">O\\big(m+n+klog(k)\\big)</script>. Here, <script type=\"math/tex; mode=display\">m</script> refers to the length of the input string. We need to scan the input string once to split it and determine the various levels. <script type=\"math/tex; mode=display\">n</script> refers to the depth of the last directory level in the given input for <code>ls</code>. This factor is taken because we need to enter <script type=\"math/tex; mode=display\">n</script> levels of the tree structure to reach the last level. <script type=\"math/tex; mode=display\">k</script> refers to the number of entries(files+subdirectories) in the last level directory(in the current input). We need to sort these names giving a factor of <script type=\"math/tex; mode=display\">klog(k)</script>.</p> </li> \n   <li> <p>The time complexity of executing an <code>mkdir</code> command is <script type=\"math/tex; mode=display\">O(m+n)</script>. Here, <script type=\"math/tex; mode=display\">m</script> refers to the length of the input string. We need to scan the input string once to split it and determine the various levels. <script type=\"math/tex; mode=display\">n</script> refers to the depth of the last directory level in the <code>mkdir</code> input. This factor is taken because we need to enter <script type=\"math/tex; mode=display\">n</script> levels of the tree structure to reach the last level.</p> </li> \n   <li> <p>The time complexity of both <code>addContentToFile</code> and <code>readContentFromFile</code> is <script type=\"math/tex; mode=display\">O(m+n)</script>. Here, <script type=\"math/tex; mode=display\">m</script> refers to the length of the input string. We need to scan the input string once to split it and determine the various levels. <script type=\"math/tex; mode=display\">n</script> refers to the depth of the file name in the current input. This factor is taken because we need to enter <script type=\"math/tex; mode=display\">n</script> levels of the tree structure to reach the level where the files's contents need to be added/read from.</p> </li> \n   <li> <p>The advantage of this scheme of maintaining the directory structure is that it is expandable to include even more commands easily. For example, <code>rmdir</code> to remove a directory given an input directory path. We need to simply reach to the destined directory level and remove the corresponding directory entry from the corresponding <script type=\"math/tex; mode=display\">dirs</script> keys.</p> </li> \n   <li> <p>Renaming files/directories is also very simple, since all we need to do is to create a temporary copy of the directory structure/file with a new name and delete the last entry.</p> </li> \n   <li> <p>Relocating a hierarchichal subdirectory structure from one directory to the other is also very easy, since, all we need to do is obtain the address for the corresponding subdirectory class, and assign the same at the new positon in the new directory structure.</p> </li> \n   <li> <p>If the number of directories is very large, we waste redundant space for <script type=\"math/tex; mode=display\">isfile</script> and <script type=\"math/tex; mode=display\">content</script>, which wasn't needed in the first design.</p> </li> \n   <li> <p>A problem with the current design could occur if we want to list only the directories(and not the files), on any given path. In this case, we need to traverse over the whole contents of the current directory, check for each entry, whether it is a file or a directory, and then extract the required data.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 587,
    "article_live": true,
    "article_slug": "erect-the-fence",
    "title": "Erect the Fence",
    "title_slug": "erect-the-fence",
    "content": "<p>There are some trees, where each tree is represented by (x,y) coordinate in a two-dimensional garden. Your job is to fence the entire garden using the <b>minimum length</b> of rope as it is expensive. The garden is well fenced only if all the trees are enclosed. Your task is to help find the coordinates of trees which are exactly located on the fence perimeter.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]\r\n<b>Output:</b> [[1,1],[2,0],[4,2],[3,3],[2,4]]\r\n<b>Explanation:</b>\r\n<img src=\"https://assets.leetcode.com/uploads/2018/10/12/erect_the_fence_1.png\" style=\"width: 100%; max-width: 320px\" />\r\n</pre>\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> [[1,2],[2,2],[4,2]]\r\n<b>Output:</b> [[1,2],[2,2],[4,2]]\r\n<b>Explanation:</b>\r\n<img src=\"https://assets.leetcode.com/uploads/2018/10/12/erect_the_fence_2.png\" style=\"width: 100%; max-width: 320px\" />\r\nEven you only have trees in a line, you need to use rope to enclose them. \r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li>All trees should be enclosed together. You cannot cut the rope to enclose trees that will separate them in more than one group.</li>\r\n\t<li>All input integers will range from 0 to 100.</li>\r\n\t<li>The garden has at least one tree.</li>\r\n\t<li>All coordinates are distinct.</li>\r\n\t<li>Input points have <b>NO</b> order. No order required for output.</li>\r\n</ol>\r\n",
    "tags": "Geometry",
    "difficulty": 3,
    "frontend_article_id": 587,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#summary\">Summary</a></li> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-jarvis-algorithm-accepted\">Approach #1 Jarvis Algorithm [Accepted]</a></li> \n      <li><a href=\"#approach-2-graham-scan-accepted\">Approach #2 Graham Scan [Accepted]</a></li> \n      <li><a href=\"#approach-3-monotone-chain-accepted\">Approach #3 Monotone Chain [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"summary\">Summary</h2> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-jarvis-algorithm-accepted\">Approach #1 Jarvis Algorithm [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>The idea behind Jarvis Algorithm is really simple. We start with the leftmost point among the given set of points and try to wrap up all the given points considering the boundary points in counterclockwise direction. </p> \n  <p>This means that for every point <script type=\"math/tex; mode=display\">p</script> considered, we try to find out a point <script type=\"math/tex; mode=display\">q</script>, such that this point <script type=\"math/tex; mode=display\">q</script> is the most counterclockwise relative to <script type=\"math/tex; mode=display\">p</script> than all the other points. For checking this, we make use of <code>orientation()</code> function in the current implementation. This function takes three arguments <script type=\"math/tex; mode=display\">p</script>, the current point added in the hull; <script type=\"math/tex; mode=display\">q</script>, the next point being considered to be added in the hull; <script type=\"math/tex; mode=display\">r</script>, any other point in the given point space. This function returns a negative value if the point <script type=\"math/tex; mode=display\">q</script> is more counterclockwise to <script type=\"math/tex; mode=display\">p</script> than the point <script type=\"math/tex; mode=display\">r</script>. </p> \n  <p>The following figure shows the concept. The point <script type=\"math/tex; mode=display\">q</script> is more counterclockwise to <script type=\"math/tex; mode=display\">p</script> than the point <script type=\"math/tex; mode=display\">r</script>. </p> \n  <p><img alt=\"Erect_Fence\" src=\"../Figures/587_Erect_Fence_Jarvis.PNG\"></p> \n  <p>From the above figure, we can observe that in order for the points <script type=\"math/tex; mode=display\">p</script>, <script type=\"math/tex; mode=display\">q</script> and <script type=\"math/tex; mode=display\">r</script> need to be traversed in the same order in a counterclockwise direction, the cross product of the vectors <script type=\"math/tex; mode=display\">\\vec{pq}</script> and <script type=\"math/tex; mode=display\">\\vec{qr}</script> should be in a direction out of the plane of the screen i.e. it should be positive.</p> \n  <p> <script type=\"math/tex; mode=display\">\\vec{pq} </script>x<script type=\"math/tex; mode=display\"> \\vec{qr} > 0</script> </p> \n  <p> <script type=\"math/tex; mode=display\">\\begin{vmatrix} (q_x-p_x) & (q_y-p_y) \\\\ (r_x-q_x) & (r_y-p_y) \\end{vmatrix} > 0</script> </p> \n  <p> <script type=\"math/tex; mode=display\">(q_x - p_x)*(r_y - q_y) - (q_y - p_y)*(r_x - q_x) > 0</script> </p> \n  <p> <script type=\"math/tex; mode=display\">(q_y - p_y)*(r_x - q_x) - (r_y - q_y)*(q_x - p_x) < 0</script> </p> \n  <p>The above result is being calculated by the <code>orientation()</code> function.</p> \n  <p>Thus, we scan over all the points <script type=\"math/tex; mode=display\">r</script> and find out the point <script type=\"math/tex; mode=display\">q</script> which is the most counterclockwise relative to <script type=\"math/tex; mode=display\">p</script> and add it to the convex hull. Further, if there exist two points(say <script type=\"math/tex; mode=display\">i</script> and <script type=\"math/tex; mode=display\">j</script>) with the same relative orientation to <script type=\"math/tex; mode=display\">p</script>, i.e. if the points <script type=\"math/tex; mode=display\">i</script> and <script type=\"math/tex; mode=display\">j</script> are collinear relative to <script type=\"math/tex; mode=display\">p</script>, we need to consider the point <script type=\"math/tex; mode=display\">i</script> which lies in between the two points <script type=\"math/tex; mode=display\">p</script> and <script type=\"math/tex; mode=display\">j</script>. For considering such a situation, we've made use of a function <code>inBetween()</code> in the current implementation. Even after finding out a point <script type=\"math/tex; mode=display\">q</script>, we need to consider all the other points which are collinear to <script type=\"math/tex; mode=display\">q</script> relative to <script type=\"math/tex; mode=display\">p</script> so as to be able to consider all the points lying on the boundary.</p> \n  <p>Thus, we keep on including the points in the hull till we reach the beginning point. </p> \n  <p>The following animation depicts the process for a clearer understanding.</p> \n  <p>!?!../Documents/587_Erect_Fence_1.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/ho9e8Hs9/shared\" frameborder=\"0\" name=\"ho9e8Hs9\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(m*n)</script>. For every point on the hull we examine all the other points to determine the next point. Here n is number of input points and m is number of output or hull points ($$m ≤ n). </p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(m)</script>. List <script type=\"math/tex; mode=display\">hull</script> grows upto size <script type=\"math/tex; mode=display\">m</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-graham-scan-accepted\">Approach #2 Graham Scan [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Graham Scan Algorithm is also a standard algorithm for finding the convex hull of a given set of points. Consider the animation below to follow along with the discussion. </p> \n  <p>!?!../Documents/587_Erect_Fence_2.json:1000,563!?!</p> \n  <p>The method works as follows. Firsly we select an initial point(<script type=\"math/tex; mode=display\">bm</script>) to start the hull with. This point is chosen as the point with the lowest y-coordinate. In case of a tie, we need to choose the point with the lowest x-coordinate, from among all the given set of points. This point is indicated as point 0 in the animation. Then, we sort the given set of points based on their polar angles formed w.r.t. a vertical line drawn throught the intial point. </p> \n  <p>This sorting of the points gives us a rough idea of the way in which we should consider the points to be included in the hull while considering the boundary in counter-clockwise order. In order to sort the points, we make use of <code>orientation</code> function which is the same as discussed in the last approach. The points with a lower polar angle relative to the vertical line come first in the sorted array. In case, if the orientation of two points happens to be the same, the points are sorted based on their distance from the beginning point(<script type=\"math/tex; mode=display\">bm</script>). Later on we'll be considering the points in the sorted array in the same order. Because of this, we need to do the sorting based on distance for points collinear relative to <script type=\"math/tex; mode=display\">bm</script>, so that all the collinear points lying on the hull are included in the boundary.</p> \n  <p>But, we need to consider another important case. In case, the collinear points lie on the closing(last) edge of the hull, we need to consider the points such that the points which lie farther from the initial point <script type=\"math/tex; mode=display\">bm</script> are considered first. Thus, after sorting the array, we traverse the sorted array from the end and reverse the order of the points which are collinear and lie towards the end of the sorted array, since these will be the points which will be considered at the end while forming the hull and thus, will be considered at the end. Thus, after these preprocessing steps, we've got the points correctly arranged in the way that they need to be considered while forming the hull.</p> \n  <p>Now, as per the algorithm, we start off by considering the line formed by the first two points(0 and 1 in the animation) in the sorted array. We push the points on this line onto a <script type=\"math/tex; mode=display\">stack</script>. After this, we start traversing over the sorted <script type=\"math/tex; mode=display\">points</script> array from the third point onwards. If the current point being considered appears after taking a left turn(or straight path) relative to the previous line(line's direction), we push the point onto the stack, indicating that the point has been temporarily added to the hull boundary.</p> \n  <p>This checking of left or right turn is done by making use of <code>orientation</code> again. An orientation greater than 0, considering the points on the line and the current point, indicates a counterclockwise direction or a right turn. A negative orientation indicates a left turn similarly.</p> \n  <p>If the current point happens to be occuring by taking a right turn from the previous line's direction, it means that the last point included in the hull was incorrect, since it needs to lie inside the boundary and not on the boundary(as is indicated by point 4 in the animation). Thus, we pop off the last point from the stack and consider the second last line's direction with the current point. </p> \n  <p>Thus, the same process continues, and the popping keeps on continuing till we reach a state where the current point can be included in the hull by taking a right turn. Thus, in this way, we ensure that the hull includes only the boundary points and not the points inside the boundary. After all the points have been traversed, the points lying in the stack constitute the boundary of the convex hull. </p> \n  <p>The below code is inspired by <a href=\"https://leetcode.com/yuxiangmusic\">@yuxiangmusic</a> solution.</p> \n  <iframe src=\"https://leetcode.com/playground/FRb4Wch9/shared\" frameborder=\"0\" name=\"FRb4Wch9\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O\\big(nlog(n)\\big)</script>. Sorting the given points takes <script type=\"math/tex; mode=display\">O\\big(nlog(n)\\big)</script> time. Further, after sorting the points can be considered in two cases, while being pushed onto the <script type=\"math/tex; mode=display\">stack</script> or while popping from the <script type=\"math/tex; mode=display\">stack</script>. Atmost, every point is touched twice(both push and pop) taking <script type=\"math/tex; mode=display\">2n</script>(<script type=\"math/tex; mode=display\">O(n)</script>) time in the worst case.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Stack size grows upto <script type=\"math/tex; mode=display\">n</script> in worst case.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-monotone-chain-accepted\">Approach #3 Monotone Chain [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>The idea behing Monotone Chain Algorithm is somewhat similar to Graham Scan Algorithm. It mainly differs in the order in which the points are considered while being included in the hull. Instead of sorting the points based on their polar angles as in Graham Scan, we sort the points on the basis of their x-coordinate values. If two points have the same x-coordinate values, the points are sorted based on their y-coordinate values. The reasoning behind this will be explained soon.</p> \n  <p>In this algorithm, we consider the hull as being comprised of two sub-boundaries- The upper hull and the lower hull. We form the two portions in a slightly different manner. </p> \n  <p>We traverse over the sorted <script type=\"math/tex; mode=display\">points</script> array after adding the initial two points in the hull temporarily(which are pushed over the stack <script type=\"math/tex; mode=display\">hull</script>). For every new point considered, we check if the current point lies in the counter-clockwise direction relative to the last two points. If so, the current point is staightaway pushed onto <script type=\"math/tex; mode=display\">hull</script>. If not(indicated by a positive <code>orientation</code>), we again get the inference that the last point on the <script type=\"math/tex; mode=display\">hull</script> needs to lie inside the boundary and not on the boundary. Thus, we keep on popping the points from <script type=\"math/tex; mode=display\">hull</script> till the current point lies in a counterclockwise direction relative to the top two points on the <script type=\"math/tex; mode=display\">hull</script>. </p> \n  <p>Note that this time, we need not consider the case of collinear points explicitly, since the points have already been sorted based on their x-coordinate values. So, the collinear points, if any, will implicitly be considered in the correct order.</p> \n  <p>Doing so, we reach a state such that we reach the point with the largest x-coordinate. But, the hull isn't complete yet. The portion of the hull formed till now constitutes the lower poriton of the hull. Now, we need to form the upper portion of the hull.</p> \n  <p>Thus, we continue the process of finding the next counterclockwise points and popping in case of a conflict, but this time we consider the points in the reverse order of their x-coordinate values. For this, we can simply traverse over the sorted <script type=\"math/tex; mode=display\">points</script> array in the reverse order. We append the new upper hull values obtained to the previous <script type=\"math/tex; mode=display\">hull</script> itself. At the end, <script type=\"math/tex; mode=display\">hull</script> gives the points on the required boundary.</p> \n  <p>The following animation depicts the process for a better understanding of the process:</p> \n  <p>!?!../Documents/587_Erect_Fence_3.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/vworasPc/shared\" frameborder=\"0\" name=\"vworasPc\" width=\"100%\" height=\"479\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O\\big(nlog(n)\\big)</script>. Sorting the given points takes <script type=\"math/tex; mode=display\">O\\big(nlog(n)\\big)</script> time. Further, after sorting the points can be considered in two cases, while being pushed onto the <script type=\"math/tex; mode=display\">hull</script> or while popping from the <script type=\"math/tex; mode=display\">hull</script>. Atmost, every point is touched twice(both push and pop) taking <script type=\"math/tex; mode=display\">2n</script>(<script type=\"math/tex; mode=display\">O(n)</script>) time in the worst case.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. <script type=\"math/tex; mode=display\">hull</script> stack can grow upto size <script type=\"math/tex; mode=display\">n</script>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 583,
    "article_live": true,
    "article_slug": "delete-operation-for-two-strings",
    "title": "Delete Operation for Two Strings",
    "title_slug": "delete-operation-for-two-strings",
    "content": "<p>\r\nGiven two words <i>word1</i> and <i>word2</i>, find the minimum number of steps required to make <i>word1</i> and <i>word2</i> the same, where in each step you can delete one character in either string.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \"sea\", \"eat\"\r\n<b>Output:</b> 2\r\n<b>Explanation:</b> You need one step to make \"sea\" to \"ea\" and another step to make \"eat\" to \"ea\".\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The length of given words won't exceed 500.</li>\r\n<li>Characters in given words can only be lower-case letters.</li>\r\n</ol>\r\n</p>",
    "tags": "String",
    "difficulty": 2,
    "frontend_article_id": 583,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-using-longest-common-subsequence-time-limit-exceeded\">Approach #1 Using Longest Common Subsequence [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-longest-common-subsequence-with-memoization-accepted\">Approach #2 Longest Common Subsequence with Memoization [Accepted]</a></li> \n      <li><a href=\"#approach-3-using-longest-common-subsequence-dynamic-programming-accepted\">Approach #3 Using Longest Common Subsequence- Dynamic Programming [Accepted]</a></li> \n      <li><a href=\"#approach-4-without-using-lcs-dynamic-programmming-accepted\">Approach #4 Without using LCS Dynamic Programmming [Accepted]:</a></li> \n      <li><a href=\"#approach-5-1-d-dynamic-programming-accepted\">Approach #5 1-D Dynamic Programming [Accepted]:</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-using-longest-common-subsequence-time-limit-exceeded\">Approach #1 Using Longest Common Subsequence [Time Limit Exceeded]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In order to determine the minimum number of delete operations needed, we can make use of the length of the longest common sequence among the two given strings <script type=\"math/tex; mode=display\">s1</script> and <script type=\"math/tex; mode=display\">s2</script>, say given by <script type=\"math/tex; mode=display\">lcs</script>. If we can find this <script type=\"math/tex; mode=display\">lcs</script> value, we can easily determine the required result as <script type=\"math/tex; mode=display\">m + n - 2*lcs</script>. Here, <script type=\"math/tex; mode=display\">m</script> and <script type=\"math/tex; mode=display\">n</script> refer to the length of the two given strings <script type=\"math/tex; mode=display\">s1</script> and <script type=\"math/tex; mode=display\">s2</script>.</p> \n  <p>The above equation works because in case of complete mismatch(i.e. if the two strings can't be equalized at all), the total number of delete operations required will be <script type=\"math/tex; mode=display\">m + n</script>. Now, if there is a common sequence among the two strings of length <script type=\"math/tex; mode=display\">lcs</script>, we need to do <script type=\"math/tex; mode=display\">lcs</script> lesser deletions in both the strings leading to a total of <script type=\"math/tex; mode=display\">2lcs</script> lesser deletions, which then leads to the above equation.</p> \n  <p>In order to find the length of the longest common sequence, we make use of a recursive function <code>lcs(s1,s2,i,j)</code> which returns the length of the longest common sequence among the strings <script type=\"math/tex; mode=display\">s1</script> and <script type=\"math/tex; mode=display\">s2</script> considering their lengths upto <script type=\"math/tex; mode=display\">i</script> and <script type=\"math/tex; mode=display\">j</script> respectively. For evaluating the function, we check if the characters <script type=\"math/tex; mode=display\">s1[m-1]</script> and <script type=\"math/tex; mode=display\">s2[n-1]</script> for equality. If they match, we can consider the corresponding strings upto 1 lesser lengths since the last characters have already been considered and add 1 to the result to be returned for strings of 1 lesser lengths. Thus, we make the function call <code>lcs(s1, s2, i-1, j-1)</code>. </p> \n  <p>If the last characters don't match, we have two options, either we can consider the second last character of <script type=\"math/tex; mode=display\">s1</script> and the last character of <script type=\"math/tex; mode=display\">s2</script>, or we can consider the second last character of <script type=\"math/tex; mode=display\">s2</script> and the last character of <script type=\"math/tex; mode=display\">s1</script>. We need to consider the larger result obtained out of the two considerations for getting the required length. </p> \n  <p>Thus, the function call <code>lcs(s1,s2,m,n)</code> returns the required <script type=\"math/tex; mode=display\">lcs</script> value.</p> \n  <iframe src=\"https://leetcode.com/playground/QCLZ3ajV/shared\" frameborder=\"0\" name=\"QCLZ3ajV\" width=\"100%\" height=\"309\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(2^{max(m,n)})</script>. Size of recursion tree will be <script type=\"math/tex; mode=display\">2^(m+n)</script>. Here, <script type=\"math/tex; mode=display\">m</script> and <script type=\"math/tex; mode=display\">n</script> refer to the lengths of <script type=\"math/tex; mode=display\">s1</script> and <script type=\"math/tex; mode=display\">s2</script> respectively.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(\\text{max}(m,n))</script>. The depth of the recursion tree will go upto <script type=\"math/tex; mode=display\">\\text{max}(m,n)</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-longest-common-subsequence-with-memoization-accepted\">Approach #2 Longest Common Subsequence with Memoization [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>We can observe that in the last approach, while determining the <script type=\"math/tex; mode=display\">lcs</script> value, a lot of redundant function calls are made, since the same <script type=\"math/tex; mode=display\">m</script> and <script type=\"math/tex; mode=display\">n</script> values to be used for the function calls could be obtained going through many different paths. We can remove this redundancy by making use of a <script type=\"math/tex; mode=display\">memo</script> array to store the value to be returned for these function calls if they have been called once with the corresponding parameters. Thus, <script type=\"math/tex; mode=display\">memo[i][j]</script> is used to store the result for the function call <code>lcs(s1,s2,i,j)</code>.</p> \n  <p>Thus, by returning the already stored values from the <script type=\"math/tex; mode=display\">memo</script> array, we can prune the search space to a great extent.</p> \n  <iframe src=\"https://leetcode.com/playground/dPT69gpC/shared\" frameborder=\"0\" name=\"dPT69gpC\" width=\"100%\" height=\"377\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(m*n)</script>. <script type=\"math/tex; mode=display\">memo</script> array of size <script type=\"math/tex; mode=display\">m</script>x<script type=\"math/tex; mode=display\">n</script> needs to be filled once. Here, <script type=\"math/tex; mode=display\">m</script> and <script type=\"math/tex; mode=display\">n</script> refer to the length of the strings <script type=\"math/tex; mode=display\">s1</script> and <script type=\"math/tex; mode=display\">s2</script> respectively.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(m*n)</script>. <script type=\"math/tex; mode=display\">memo</script> array of size <script type=\"math/tex; mode=display\">m</script>x<script type=\"math/tex; mode=display\">n</script> is used. Also, The depth of the recursion tree will go upto <script type=\"math/tex; mode=display\">\\text{max}(m,n)</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-using-longest-common-subsequence-dynamic-programming-accepted\">Approach #3 Using Longest Common Subsequence- Dynamic Programming [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Another method to obtain the value of <script type=\"math/tex; mode=display\">lcs</script> is to make use of Dynamic Programming. We'll look at the implemenation and carry-on alongside the idea behind it.</p> \n  <p>We make use of a 2-D <script type=\"math/tex; mode=display\">dp</script>, in which <script type=\"math/tex; mode=display\">dp[i][j]</script> represents the length of the longest common subsequence among the strings <script type=\"math/tex; mode=display\">s1</script> and <script type=\"math/tex; mode=display\">s2</script> considering their lengths upto <script type=\"math/tex; mode=display\">(i-1)^{th}</script> index and <script type=\"math/tex; mode=display\">(j-1)^{th}</script> index only respectively. We fill the <script type=\"math/tex; mode=display\">dp</script> array in row-by-row order.</p> \n  <p>In order to fill the entry for <script type=\"math/tex; mode=display\">dp[i][j]</script>, we can have two cases:</p> \n  <ol> \n   <li> <p>The characters <script type=\"math/tex; mode=display\">s1[i-1]</script> and <script type=\"math/tex; mode=display\">s2[j-1]</script> match with each other. In this case, the entry for <script type=\"math/tex; mode=display\">dp[i][j]</script> will be one more than the entry obtained for the strings considering their lengths upto one lesser index, since the matched character adds one to the length of LCS formed till the current indices. Thus, the <script type=\"math/tex; mode=display\">dp[i][j]</script> entry is updated as <script type=\"math/tex; mode=display\">dp[i][j] = 1 + dp[i-1][j-1]</script>. Note that <script type=\"math/tex; mode=display\">dp[i-1][j-1]</script> has been used because the matched character belongs to both <script type=\"math/tex; mode=display\">s1</script> and <script type=\"math/tex; mode=display\">s2</script>.</p> </li> \n   <li> <p>The characters <script type=\"math/tex; mode=display\">s1[i-1]</script> and <script type=\"math/tex; mode=display\">s2[j-1]</script> don't match with each other. In this case, we can't increment the current entry as compared to entries corresponding to the previous indices, but we need to replicate the previous entry again to indicate that the length of LCS upto the current indices also remains the same. But, which entry to pick up? Now, since the current character hasn't matched, we have got two options. We can remove the current character from consideration from either <script type=\"math/tex; mode=display\">s1</script> or <script type=\"math/tex; mode=display\">s2</script> and use the corresponding <script type=\"math/tex; mode=display\">dp</script> entries given by <script type=\"math/tex; mode=display\">dp[i-1][j]</script> and <script type=\"math/tex; mode=display\">dp[i][j-1]</script> respectively. Since we are considering the length of LCS upto the current indices we need to pick up the larger entry out of these two to update the current <script type=\"math/tex; mode=display\">dp</script> entry.</p> </li> \n  </ol> \n  <p>At the end, again, we obtain the number of deletions required as <script type=\"math/tex; mode=display\">m + n - 2*dp[m][n]</script>, where <script type=\"math/tex; mode=display\">m</script> and <script type=\"math/tex; mode=display\">n</script> refer to the lengths of <script type=\"math/tex; mode=display\">s1</script> and <script type=\"math/tex; mode=display\">s2</script>. <script type=\"math/tex; mode=display\">dp[m][n]</script> now refers to the length of LCS among the two given strings.</p> \n  <p>!?!../Documents/583_Delete1.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/xQZCgSyw/shared\" frameborder=\"0\" name=\"xQZCgSyw\" width=\"100%\" height=\"326\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(m*n)</script>. We need to fill in the <script type=\"math/tex; mode=display\">dp</script> array of size <script type=\"math/tex; mode=display\">m</script>x<script type=\"math/tex; mode=display\">n</script>. Here, <script type=\"math/tex; mode=display\">m</script> and <script type=\"math/tex; mode=display\">n</script> refer to the lengths of <script type=\"math/tex; mode=display\">s1</script> and <script type=\"math/tex; mode=display\">s2</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(m*n)</script>. <script type=\"math/tex; mode=display\">dp</script> array of size <script type=\"math/tex; mode=display\">m</script>x<script type=\"math/tex; mode=display\">n</script> is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-4-without-using-lcs-dynamic-programmming-accepted\">Approach #4 Without using LCS Dynamic Programmming [Accepted]:</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Instead of finding the length of LCS and then determining the number of deletions required, we can make use of Dynamic Programming to directly determine the number of deletions required till the current indices of the strings.</p> \n  <p>In order to do so, we make use of a 2-D <script type=\"math/tex; mode=display\">dp</script> array. Now, <script type=\"math/tex; mode=display\">dp[i][j]</script> refers to the number of deletions required to equalize the two strings if we consider the strings' length upto <script type=\"math/tex; mode=display\">(i-1)^{th}</script> index and <script type=\"math/tex; mode=display\">(j-1)^{th}</script> index for <script type=\"math/tex; mode=display\">s1</script> and <script type=\"math/tex; mode=display\">s2</script> respectively. Again, we fill in the <script type=\"math/tex; mode=display\">dp</script> array in a row-by-row order. Now, in order to fill the entry for <script type=\"math/tex; mode=display\">dp[i][j]</script>, we need to consider two cases only:</p> \n  <ol> \n   <li> <p>The characters <script type=\"math/tex; mode=display\">s1[i-1]</script> and <script type=\"math/tex; mode=display\">s2[j-1]</script> match with each other. In this case, we need to replicate the entry corresponding to <script type=\"math/tex; mode=display\">dp[i-1][j-1]</script> itself. This is because, the matched character doesn't need to be deleted from any of the strings.</p> </li> \n   <li> <p>The characters <script type=\"math/tex; mode=display\">s1[i-1]</script> and <script type=\"math/tex; mode=display\">s2[j-1]</script> don't match with each other. In this case, we need to delete either the current character of <script type=\"math/tex; mode=display\">s1</script> or <script type=\"math/tex; mode=display\">s2</script>. Thus, an increment of 1 needs to be done relative to the entries corresponding to the previous indices. The two options available at this moment are <script type=\"math/tex; mode=display\">dp[i-1][j]</script> and <script type=\"math/tex; mode=display\">dp[i][j-1]</script>. Since, we are keeping track of the minimum number of deletions required, we pick up the minimum out of these two values.</p> </li> \n  </ol> \n  <p>At the end, <script type=\"math/tex; mode=display\">dp[m][n]</script> gives the required minimum number of deletions. Here, <script type=\"math/tex; mode=display\">m</script> and <script type=\"math/tex; mode=display\">n</script> refer to the lengths of <script type=\"math/tex; mode=display\">s1</script> and <script type=\"math/tex; mode=display\">s2</script>.</p> \n  <p>!?!../Documents/583_Delete2.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/aPU8b3Fd/shared\" frameborder=\"0\" name=\"aPU8b3Fd\" width=\"100%\" height=\"326\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(m*n)</script>. We need to fill in the <script type=\"math/tex; mode=display\">dp</script> array of size <script type=\"math/tex; mode=display\">m</script>x<script type=\"math/tex; mode=display\">n</script>. Here, <script type=\"math/tex; mode=display\">m</script> and <script type=\"math/tex; mode=display\">n</script> refer to the lengths of <script type=\"math/tex; mode=display\">s1</script> and <script type=\"math/tex; mode=display\">s2</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(m*n)</script>. <script type=\"math/tex; mode=display\">dp</script> array of size <script type=\"math/tex; mode=display\">m</script>x<script type=\"math/tex; mode=display\">n</script> is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-5-1-d-dynamic-programming-accepted\">Approach #5 1-D Dynamic Programming [Accepted]:</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>We can observe that in the last approach, in order to update the current <script type=\"math/tex; mode=display\">dp</script> entries, we need only the values of the previous row of <script type=\"math/tex; mode=display\">dp</script>. Thus, rather than using a 2-D array, we can do the same job by making use of a 1-D <script type=\"math/tex; mode=display\">dp</script> array.</p> \n  <p>Thus, now, <script type=\"math/tex; mode=display\">dp[i]</script> refers to the number of deletions that need to be made in order to equalize the strings <script type=\"math/tex; mode=display\">s1</script> and <script type=\"math/tex; mode=display\">s2</script> if we consider string <script type=\"math/tex; mode=display\">s1</script> upto the <script type=\"math/tex; mode=display\">(i-1)^{th}</script> index and string <script type=\"math/tex; mode=display\">s2</script> upto the last to current index of <script type=\"math/tex; mode=display\">s2</script>. </p> \n  <p>Now, we make the updations for the current row in an array <script type=\"math/tex; mode=display\">temp</script> of the same size as <script type=\"math/tex; mode=display\">dp</script>, and use the <script type=\"math/tex; mode=display\">dp</script> entries as if they correspond to the previous row's entries. When, the whole <script type=\"math/tex; mode=display\">temp</script> array has been filled, we copy it the <script type=\"math/tex; mode=display\">dp</script> array so that <script type=\"math/tex; mode=display\">dp</script> array now reflects the new row's entries.</p> \n  <iframe src=\"https://leetcode.com/playground/jfeuFUeS/shared\" frameborder=\"0\" name=\"jfeuFUeS\" width=\"100%\" height=\"360\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(m*n)</script>. We need to fill in the <script type=\"math/tex; mode=display\">dp</script> array of size <script type=\"math/tex; mode=display\">n</script>, <script type=\"math/tex; mode=display\">m</script> times. Here, <script type=\"math/tex; mode=display\">m</script> and <script type=\"math/tex; mode=display\">n</script> refer to the lengths of <script type=\"math/tex; mode=display\">s1</script> and <script type=\"math/tex; mode=display\">s2</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. <script type=\"math/tex; mode=display\">dp</script> array of size <script type=\"math/tex; mode=display\">n</script> is used.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 582,
    "article_live": true,
    "article_slug": "kill-process",
    "title": "Kill Process",
    "title_slug": "kill-process",
    "tags": "Tree, Queue",
    "difficulty": 2,
    "frontend_article_id": 582,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-depth-first-search-time-limit-exceeded\">Approach #1 Depth First Search [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-tree-simulation-accepted\">Approach #2 Tree Simulation [Accepted]</a></li> \n      <li><a href=\"#approach-3-hashmap-depth-first-search-accepted\">Approach #3 HashMap + Depth First Search [Accepted]</a></li> \n      <li><a href=\"#approach-4-hashmap-breadth-first-search-accepted\">Approach #4 HashMap + Breadth First Search [Accepted]:</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-depth-first-search-time-limit-exceeded\">Approach #1 Depth First Search [Time Limit Exceeded]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Since killing a process leads to killing all its children processes, the simplest solution is to traverse over the <script type=\"math/tex; mode=display\">ppid</script> array and find out all the children of the process to be killed. Further, for every child chosen to be killed we recursively make call to the <code>killProcess</code> function now treating this child as the new parent to be killed. In every such call, we again traverse over the <script type=\"math/tex; mode=display\">ppid</script> array now considering the id of the child process, and continue in the same fashion. Further, at every step, for every process chosen to be killed, it is added to the list <script type=\"math/tex; mode=display\">l</script> that needs to be returned at the end.</p> \n  <iframe src=\"https://leetcode.com/playground/aMxgv45H/shared\" frameborder=\"0\" name=\"aMxgv45H\" width=\"100%\" height=\"309\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^n)</script>. <script type=\"math/tex; mode=display\">O(n^n)</script> function calls will be made in the worst case</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The depth of the recursion tree can go upto <script type=\"math/tex; mode=display\">n</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-tree-simulation-accepted\">Approach #2 Tree Simulation [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>We can view the given process relationships in the form of a tree. We can construct the tree in such a way that every node stores information about its own value as well as the list of all its direct children nodes. Thus, now, once the tree has been generated, we can simply start off by killing the required node, and recursively killing the children of each node encountered rather than traversing over the whole <script type=\"math/tex; mode=display\">ppid</script> array for every node as done in the previous approach.</p> \n  <p>In order to implement this, we've made use of a <script type=\"math/tex; mode=display\">Node</script> class which represents a node of a tree. Each node represents a process. Thus, every node stores its own value(<script type=\"math/tex; mode=display\">Node.val</script>) and the list of all its direct children(<script type=\"math/tex; mode=display\">Node.children</script>). We traverse over the whole <script type=\"math/tex; mode=display\">pid</script> array and create nodes for all of them. Then, we traverse over the <script type=\"math/tex; mode=display\">ppid</script> array, and make the parent nodes out of them, and at the same time add all their direct children nodes in their <script type=\"math/tex; mode=display\">Node.children</script> list. In this way, we convert the given process structure into a tree structure. </p> \n  <p>Now, that we've obtained the tree structure, we can add the node to be killed to the return list <script type=\"math/tex; mode=display\">l</script>. Now, we can directly obtain all the direct children of this node from the tree, and add its direct children to the return list. For every node added to the return list, we repeat the same process of obtaining the children recursively. </p> \n  <iframe src=\"https://leetcode.com/playground/3vVYTuvw/shared\" frameborder=\"0\" name=\"3vVYTuvw\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. We need to traverse over the <script type=\"math/tex; mode=display\">ppid</script> and <script type=\"math/tex; mode=display\">pid</script> array of size <script type=\"math/tex; mode=display\">n</script> once. The <code>getAllChildren</code> function also takes atmost <script type=\"math/tex; mode=display\">n</script> time, since no node can be a child of two nodes.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. <script type=\"math/tex; mode=display\">map</script> of size <script type=\"math/tex; mode=display\">n</script> is used. </p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-hashmap-depth-first-search-accepted\">Approach #3 HashMap + Depth First Search [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Instead of making the tree structure, we can directly make use of a data structure which stores a particular process value and the list of its direct children. For this, in the current implementation, we make use of a hashmap <script type=\"math/tex; mode=display\">map</script>, which stores the data in the form <script type=\"math/tex; mode=display\">{parent: [list of all its direct children]}</script>.</p> \n  <p>Thus, now, by traversing just once over the <script type=\"math/tex; mode=display\">ppid</script> array, and adding the corresponding <script type=\"math/tex; mode=display\">pid</script> values to the children list at the same time, we can obtain a better structure storing the parent-children relationship.</p> \n  <p>Again, similar to the previous approach, now we can add the process to be killed to the return list, and keep on adding its children to the return list in a recursive manner by obtaining the child information from the structure created previously.</p> \n  <p>!?!../Documents/582_Kill_Process.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/RqpXvrnt/shared\" frameborder=\"0\" name=\"RqpXvrnt\" width=\"100%\" height=\"462\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. We need to traverse over the <script type=\"math/tex; mode=display\">ppid</script> array of size <script type=\"math/tex; mode=display\">n</script> once. The <code>getAllChildren</code> function also takes atmost <script type=\"math/tex; mode=display\">n</script> time, since no node can be a child of two nodes.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. <script type=\"math/tex; mode=display\">map</script> of size <script type=\"math/tex; mode=display\">n</script> is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-4-hashmap-breadth-first-search-accepted\">Approach #4 HashMap + Breadth First Search [Accepted]:</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>We can also make use of Breadth First Search to obtain all the children(direct+indirect) of a particular node, once the data structure of the form <script type=\"math/tex; mode=display\">(process: [list of all its direct children]</script> has been obtained. The process of obtaining the data structure is the same as in the previous approach. </p> \n  <p>In order to obtain all the child processes to be killed for a particular parent chosen to be killed, we can make use of Breadth First Search. For this, we add the node to be killed to a <script type=\"math/tex; mode=display\">queue</script>. Then, we remove an element from the front of the <script type=\"math/tex; mode=display\">queue</script> and add it to the return list. Further, for every element removed from the front of the queue, we add all its direct children(obtained from the data structure created) to the end of the queue. We keep on doing so till the queue becomes empty.</p> \n  <p>!?!../Documents/582_Kill_Process_BFS.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/XkRcahEn/shared\" frameborder=\"0\" name=\"XkRcahEn\" width=\"100%\" height=\"462\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. We need to traverse over the <script type=\"math/tex; mode=display\">ppid</script> array of size <script type=\"math/tex; mode=display\">n</script> once. Also, atmost <script type=\"math/tex; mode=display\">n</script> additions/removals are done from the <script type=\"math/tex; mode=display\">queue</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. <script type=\"math/tex; mode=display\">map</script> of size <script type=\"math/tex; mode=display\">n</script> is used.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 581,
    "article_live": true,
    "article_slug": "shortest-unsorted-continous-subarray",
    "title": "Shortest Unsorted Continuous Subarray",
    "title_slug": "shortest-unsorted-continuous-subarray",
    "content": "<p>Given an integer array, you need to find one <b>continuous subarray</b> that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order, too. </p> \r\n\r\n<p>You need to find the <b>shortest</b> such subarray and output its length.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [2, 6, 4, 8, 10, 9, 15]\r\n<b>Output:</b> 5\r\n<b>Explanation:</b> You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>Then length of the input array is in range [1, 10,000].</li>\r\n<li>The input array may contain duplicates, so ascending order here means <b><=</b>. </li>\r\n</ol>\r\n</p>",
    "tags": "Array",
    "difficulty": 1,
    "frontend_article_id": 581,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-better-brute-force-time-limit-exceeded\">Approach #2 Better Brute Force [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-3-using-sorting-accepted\">Approach #3 Using Sorting [Accepted]</a></li> \n      <li><a href=\"#approach-4-using-stack-accepted\">Approach #4 Using Stack [Accepted]:</a></li> \n      <li><a href=\"#approach-5-without-using-extra-space-accepted\">Approach #5 Without Using Extra Space [Accepted]:</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In the brute force approach, we consider every possible subarray that can be formed from the given array <script type=\"math/tex; mode=display\">nums</script>. For every subarray <script type=\"math/tex; mode=display\">nums[i:j]</script> considered, we need to check whether this is the smallest unsorted subarray or not. Thus, for every such subarray considered, we find out the maximum and minimum values lying in that subarray given by <script type=\"math/tex; mode=display\">max</script> and <script type=\"math/tex; mode=display\">min</script> respectively.</p> \n  <p>If the subarrays <script type=\"math/tex; mode=display\">nums[0:i-1]</script> and <script type=\"math/tex; mode=display\">nums[j:n-1]</script> are correctly sorted, then only <script type=\"math/tex; mode=display\">nums[i:j]</script> could be the required subrray. Further, the elements in <script type=\"math/tex; mode=display\">nums[0:i-1]</script> all need to be lesser than the <script type=\"math/tex; mode=display\">min</script> for satisfying the required condition. Similarly, all the elements in <script type=\"math/tex; mode=display\">nums[j:n-1]</script> need to be larger than <script type=\"math/tex; mode=display\">max</script>. We check for these conditions for every possible <script type=\"math/tex; mode=display\">i</script> and <script type=\"math/tex; mode=display\">j</script> selected.</p> \n  <p>Further, we also need to check if <script type=\"math/tex; mode=display\">nums[0:i-1]</script> and <script type=\"math/tex; mode=display\">nums[j:n-1]</script> are sorted correctly. If all the above conditions are satisfied, we determine the length of the unsorted subarray as <script type=\"math/tex; mode=display\">j-i</script>. We do the same process for every subarray chosen and determine the length of the smallest unsorted subarray found.</p> \n  <iframe src=\"https://leetcode.com/playground/SdybCxt5/shared\" frameborder=\"0\" name=\"SdybCxt5\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^3)</script>. Three nested loops are there.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant space is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-better-brute-force-time-limit-exceeded\">Approach #2 Better Brute Force [Time Limit Exceeded]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In this approach, we make use of an idea based on selection sort. We can traverse over the given <script type=\"math/tex; mode=display\">nums</script> array choosing the elements <script type=\"math/tex; mode=display\">nums[i]</script>. For every such element chosen, we try to determine its correct position in the sorted array. For this, we compare <script type=\"math/tex; mode=display\">nums[i]</script> with every <script type=\"math/tex; mode=display\">nums[j]</script>, such that <script type=\"math/tex; mode=display\">i < j < n</script>. Here, <script type=\"math/tex; mode=display\">n</script> refers to the length of <script type=\"math/tex; mode=display\">nums</script> array.</p> \n  <p>If any <script type=\"math/tex; mode=display\">nums[j]</script> happens to be lesser than <script type=\"math/tex; mode=display\">nums[i]</script>, it means both <script type=\"math/tex; mode=display\">nums[i]</script> and <script type=\"math/tex; mode=display\">nums[j]</script> aren't at their correct position for the sorted array. Thus, we need to swap the two elements to bring them at their correct positions. Here, instead of swapping, we just note the position of <script type=\"math/tex; mode=display\">nums[i]</script>(given by <script type=\"math/tex; mode=display\">i</script>) and <script type=\"math/tex; mode=display\">nums[j]</script>(given by <script type=\"math/tex; mode=display\">j</script>). These two elements now mark the boundary of the unsorted subarray(atleast for the time being).</p> \n  <p>Thus, out of all the <script type=\"math/tex; mode=display\">nums[i]</script> chosen, we determine the leftmost <script type=\"math/tex; mode=display\">nums[i]</script> which isn't at its correct position. This marks the left boundary of the smallest unsorted subarray(<script type=\"math/tex; mode=display\">l</script>). Similarly, out of all the <script type=\"math/tex; mode=display\">nums[j]</script>'s considered for all <script type=\"math/tex; mode=display\">nums[i]</script>'s we determine the rightmost <script type=\"math/tex; mode=display\">nums[j]</script> which isn't at its correct position. This marks the right boundary of the smallest unsorted subarray(<script type=\"math/tex; mode=display\">r</script>).</p> \n  <p><img alt=\"Unsorted_subarray\" src=\"../Figures/581/Unsorted_subarray_1.PNG\"></p> \n  <p>Thus, we can determine the length of the smallest unsorted subarray as <script type=\"math/tex; mode=display\">r - l + 1</script>.</p> \n  <iframe src=\"https://leetcode.com/playground/g9YJRHj4/shared\" frameborder=\"0\" name=\"g9YJRHj4\" width=\"100%\" height=\"292\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^2)</script>. Two nested loops are there.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant space is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-using-sorting-accepted\">Approach #3 Using Sorting [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Another very simple idea is as follows. We can sort a copy of the given array <script type=\"math/tex; mode=display\">nums</script>, say given by <script type=\"math/tex; mode=display\">nums\\_sorted</script>. Then, if we compare the elements of <script type=\"math/tex; mode=display\">nums</script> and <script type=\"math/tex; mode=display\">nums\\_sorted</script>, we can determine the leftmost and rightmost elements which mismatch. The subarray lying between them is, then, the required shorted unsorted subarray.</p> \n  <iframe src=\"https://leetcode.com/playground/H3PB4vbF/shared\" frameborder=\"0\" name=\"H3PB4vbF\" width=\"100%\" height=\"309\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(nlogn)</script>. Sorting takes <script type=\"math/tex; mode=display\">nlogn</script> time.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. We are making copy of original array.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-4-using-stack-accepted\">Approach #4 Using Stack [Accepted]:</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>The idea behind this approach is also based on selective sorting. We need to determine the correct position of the minimum and the maximum element in the unsorted subarray to determine the boundaries of the required unsorted subarray.</p> \n  <p>To do so, in this implementation, we make use of a <script type=\"math/tex; mode=display\">stack</script>. We traverse over the <script type=\"math/tex; mode=display\">nums</script> array starting from the beginning. As we go on facing elements in ascending order(a rising slope), we keep on pushing the elements' indices over the <script type=\"math/tex; mode=display\">stack</script>. This is done because such elements are in the correct sorted order(as it seems till now). As soon as we encounter a falling slope, i.e. an element <script type=\"math/tex; mode=display\">nums[j]</script> which is smaller than the element on the top of the <script type=\"math/tex; mode=display\">stack</script>, we know that <script type=\"math/tex; mode=display\">nums[j]</script> isn't at its correct position.</p> \n  <p>In order to determine the correct position of <script type=\"math/tex; mode=display\">nums[j]</script>, we keep on popping the elemnents from the top of the <script type=\"math/tex; mode=display\">stack</script> until we reach the stage where the element(corresponding to the index) on the top of the <script type=\"math/tex; mode=display\">stack</script> is lesser than <script type=\"math/tex; mode=display\">nums[j]</script>. Let's say the popping stops when the index on <script type=\"math/tex; mode=display\">stack</script>'s top is <script type=\"math/tex; mode=display\">k</script>. Now, <script type=\"math/tex; mode=display\">nums[j]</script> has found its correct position. It needs to lie at an index <script type=\"math/tex; mode=display\">k + 1</script>.</p> \n  <p>We follow the same process while traversing over the whole array, and determine the value of minimum such <script type=\"math/tex; mode=display\">k</script>. This marks the left boundary of the unsorted subarray.</p> \n  <p>Similarly, to find the right boundary of the unsorted subarray, we traverse over the <script type=\"math/tex; mode=display\">nums</script> array backwards. This time we keep on pushing the elements if we see a falling slope. As soon as we find a rising slope, we trace forwards now and determine the larger element's correct position. We do so for the complete array and thus, determine the right boundary.</p> \n  <p>We can look at the figure below for reference. We can observe that the slopes directly indicate the relative ordering. We can also observe that the point <script type=\"math/tex; mode=display\">b</script> needs to lie just after index 0 marking the left boundary and the point <script type=\"math/tex; mode=display\">a</script> needs to lie just before index 7 marking the right boundary of the unsorted subarray.</p> \n  <p><img alt=\"Unsorted_subarray\" src=\"../Figures/581/Unsorted_subarray_2.PNG\"></p> \n  <p>Below code is inpired by <a href=\"https://leetcode.com/fallcreek\">@fallcreek</a></p> \n  <iframe src=\"https://leetcode.com/playground/tjLosXGs/shared\" frameborder=\"0\" name=\"tjLosXGs\" width=\"100%\" height=\"377\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Stack of size <script type=\"math/tex; mode=display\">n</script> is filled.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Stack size grows upto <script type=\"math/tex; mode=display\">n</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-5-without-using-extra-space-accepted\">Approach #5 Without Using Extra Space [Accepted]:</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>The idea behind this method is that the correct position of the minimum element in the unsorted subarray helps to determine the required left boundary. Similarly, the correct position of the maximum element in the unsorted subarray helps to determine the required right boundary.</p> \n  <p>Thus, firstly we need to determine when the correctly sorted array goes wrong. We keep a track of this by observing rising slope starting from the beginning of the array. Whenever the slope falls, we know that the unsorted array has surely started. Thus, now we determine the minimum element found till the end of the array <script type=\"math/tex; mode=display\">nums</script>, given by <script type=\"math/tex; mode=display\">min</script>.</p> \n  <p>Similarly, we scan the array <script type=\"math/tex; mode=display\">nums</script> in the reverse order and when the slope becomes rising instead of falling, we start looking for the maximum element till we reach the beginning of the array, given by <script type=\"math/tex; mode=display\">max</script>.</p> \n  <p>Then, we traverse over <script type=\"math/tex; mode=display\">nums</script> and determine the correct position of <script type=\"math/tex; mode=display\">min</script> and <script type=\"math/tex; mode=display\">max</script> by comparing these elements with the other array elements. e.g. To determine the correct position of <script type=\"math/tex; mode=display\">min</script>, we know the initial portion of <script type=\"math/tex; mode=display\">nums</script> is already sorted. Thus, we need to find the first element which is just larger than <script type=\"math/tex; mode=display\">min</script>. Similarly, for <script type=\"math/tex; mode=display\">max</script>'s position, we need to find the first element which is just smaller than <script type=\"math/tex; mode=display\">max</script> searching in <script type=\"math/tex; mode=display\">nums</script> backwards.</p> \n  <p>We can take this figure for reference again:</p> \n  <p><img alt=\"Unsorted_subarray\" src=\"../Figures/581/Unsorted_subarray_2.PNG\"></p> \n  <p>We can observe that the point <script type=\"math/tex; mode=display\">b</script> needs to lie just after index 0 marking the left boundary and the point <script type=\"math/tex; mode=display\">a</script> needs to lie just before index 7 marking the right boundary of the unsorted subarray.</p> \n  <iframe src=\"https://leetcode.com/playground/vgbmarrv/shared\" frameborder=\"0\" name=\"vgbmarrv\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Four <script type=\"math/tex; mode=display\">O(n)</script> loops are used.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant space is used.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 576,
    "article_live": true,
    "article_slug": "out-of-boundary-paths",
    "title": "Out of Boundary Paths",
    "title_slug": "out-of-boundary-paths",
    "content": "<p>There is an <b>m</b> by <b>n</b> grid with a ball. Given the start coordinate <b>(i,j)</b> of the ball, you can move the ball to <b>adjacent</b> cell or cross the grid boundary in four directions (up, down, left, right). However, you can <b>at most</b> move <b>N</b> times. Find out the number of paths to move the ball out of grid boundary. The answer may be very large, return it after mod 10<sup>9</sup> + 7.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\n<b>Input: </b>m = 2, n = 2, N = 2, i = 0, j = 0\r\n<b>Output:</b> 6\r\n<b>Explanation:</b>\r\n<img src=\"https://assets.leetcode.com/uploads/2018/10/13/out_of_boundary_paths_1.png\" style=\"width: 100%; max-width: 400px\" />\r\n</pre>\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\n<b>Input: </b>m = 1, n = 3, N = 3, i = 0, j = 1\r\n<b>Output:</b> 12\r\n<b>Explanation:</b>\r\n<img src=\"https://assets.leetcode.com/uploads/2018/10/12/out_of_boundary_paths_2.png\" style=\"width: 100%; max-width: 400px\" />\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Note:</b></p>\r\n\r\n<ol>\r\n\t<li>Once you move the ball out of boundary, you cannot move it back.</li>\r\n\t<li>The length and height of the grid is in range [1,50].</li>\r\n\t<li>N is in range [0,50].</li>\r\n</ol>\r\n",
    "tags": "Dynamic Programming, Depth-first Search",
    "difficulty": 2,
    "frontend_article_id": 576,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#summary\">Summary</a></li> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-recursion-with-memoization-accepted\">Approach #2 Recursion with memoization [Accepted]</a></li> \n      <li><a href=\"#approach-3-dynamic-programming-accepted\">Approach #3 Dynamic Programming [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"summary\">Summary</h2> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In the brute force approach, we try to take one step in every direction and decrement the number of pending moves for each step taken. Whenever we reach out of the boundary while taking the steps, we deduce that one extra path is available to take the ball out. </p> \n  <p>In order to implement the same, we make use of a recursive function <code>findPaths(m,n,N,i,j)</code> which takes the current number of moves(<script type=\"math/tex; mode=display\">N</script>) along with the current position(<script type=\"math/tex; mode=display\">(i,j)</script> as some of the parameters and returns the number of moves possible to take the ball out with the current pending moves from the current position. Now, we take a step in every direction and update the corresponding indices involved along with the current number of pending moves. </p> \n  <p>Further, if we run out of moves at any moment, we return a 0 indicating that the current set of moves doesn't take the ball out of boundary.</p> \n  <iframe src=\"https://leetcode.com/playground/Q7b3GKsJ/shared\" frameborder=\"0\" name=\"Q7b3GKsJ\" width=\"100%\" height=\"224\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(4^n)</script>. Size of recursion tree will be <script type=\"math/tex; mode=display\">4^n</script>. Here, <script type=\"math/tex; mode=display\">n</script> refers to the number of moves allowed.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The depth of the recursion tree can go upto <script type=\"math/tex; mode=display\">n</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-recursion-with-memoization-accepted\">Approach #2 Recursion with memoization [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In the brute force approach, while going through the various branches of the recursion tree, we could reach the same position with the same number of moves left. </p> \n  <p>Thus, a lot of redundant function calls are made with the same set of parameters leading to a useless increase in runtime. We can remove this redundancy by making use of a memoization array, <script type=\"math/tex; mode=display\">memo</script>. <script type=\"math/tex; mode=display\">memo[i][j][k]</script> is used to store the number of possible moves leading to a path out of the boundary if the current position is given by the indices <script type=\"math/tex; mode=display\">(i, j)</script> and number of moves left is <script type=\"math/tex; mode=display\">k</script>. </p> \n  <p>Thus, now if a function call with some parameters is repeated, the <script type=\"math/tex; mode=display\">memo</script> array will already contain valid values corresponding to that function call resulting in pruning of the search space.</p> \n  <iframe src=\"https://leetcode.com/playground/o22neiZb/shared\" frameborder=\"0\" name=\"o22neiZb\" width=\"100%\" height=\"411\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(m*n*N)</script>. We need to fill the <script type=\"math/tex; mode=display\">memo</script> array once with dimensions <script type=\"math/tex; mode=display\">m</script>x<script type=\"math/tex; mode=display\">n</script>x<script type=\"math/tex; mode=display\">N</script>. Here, <script type=\"math/tex; mode=display\">m</script>, <script type=\"math/tex; mode=display\">n</script> refer to the number of rows and columns of the given grid respectively. <script type=\"math/tex; mode=display\">N</script> refers to the total number of allowed moves.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(m*n*N)</script>. <script type=\"math/tex; mode=display\">memo</script> array of size <script type=\"math/tex; mode=display\">m*n*N</script> is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-dynamic-programming-accepted\">Approach #3 Dynamic Programming [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>The idea behind this approach is that if we can reach some position in <script type=\"math/tex; mode=display\">x</script> moves, we can reach all its adjacent positions in <script type=\"math/tex; mode=display\">x+1</script> moves. Based on this idea, we make use of a 2-D <script type=\"math/tex; mode=display\">dp</script> array to store the number of ways in which a particular position can be reached. <script type=\"math/tex; mode=display\">dp[i][j]</script> refers to the number of ways the position corresponding to the indices <script type=\"math/tex; mode=display\">(i,j)</script> can be reached given some particular number of moves.</p> \n  <p>Now, if the current <script type=\"math/tex; mode=display\">dp</script> array stores the number of ways the various positions can be reached by making use of <script type=\"math/tex; mode=display\">x-1</script> moves, in order to determine the number of ways the position <script type=\"math/tex; mode=display\">(i,j)</script> can be reached by making use of <script type=\"math/tex; mode=display\">x</script> moves, we need to update the corresponding <script type=\"math/tex; mode=display\">dp</script> entry as <script type=\"math/tex; mode=display\">dp[i][j] = dp[i-1][j] + dp[i+1][j] + dp[i][j-1] + dp[i][j+1]</script> taking care of boundary conditions. This happens because we can reach the index <script type=\"math/tex; mode=display\">(i,j)</script> from any of the four adjacent positions and the total number of ways of reaching the index <script type=\"math/tex; mode=display\">(i,j)</script> in <script type=\"math/tex; mode=display\">x</script> moves is the sum of the ways of reaching the adjacent positions in <script type=\"math/tex; mode=display\">x-1</script> moves. </p> \n  <p>But, if we alter the <script type=\"math/tex; mode=display\">dp</script> array, now some of the entries will correspond to <script type=\"math/tex; mode=display\">x-1</script> moves and the updated ones will correspond to <script type=\"math/tex; mode=display\">x</script> moves. Thus, we need to find a way to tackle this issue. So, instead of updating the <script type=\"math/tex; mode=display\">dp</script> array for the current(<script type=\"math/tex; mode=display\">x</script>) moves, we make use of a temporary 2-D array <script type=\"math/tex; mode=display\">temp</script> to store the updated results for <script type=\"math/tex; mode=display\">x</script> moves, making use of the results obtained for <script type=\"math/tex; mode=display\">dp</script> array corresponding to <script type=\"math/tex; mode=display\">x-1</script> moves. After all the entries for all the positions have been considered for <script type=\"math/tex; mode=display\">x</script> moves, we update the <script type=\"math/tex; mode=display\">dp</script> array based on <script type=\"math/tex; mode=display\">temp</script>. Thus, <script type=\"math/tex; mode=display\">dp</script> now contains the entries corresponding to <script type=\"math/tex; mode=display\">x</script> moves.</p> \n  <p>Thus, we start off by considering zero move available for which we make an initial entry of <script type=\"math/tex; mode=display\">dp[x][y] = 1</script>(<script type=\"math/tex; mode=display\">(x,y)</script> is the initial position), since we can reach only this position in zero move. Then, we increase the number of moves to 1 and update all the <script type=\"math/tex; mode=display\">dp</script> entries appropriately. We do so for all the moves possible from 1 to N. </p> \n  <p>In order to update <script type=\"math/tex; mode=display\">count</script>, which indicates the total number of possible moves which lead an out of boundary path, we need to perform the update only when we reach the boundary. We update the count as <script type=\"math/tex; mode=display\">count = count + dp[i][j]</script>, where <script type=\"math/tex; mode=display\">(i,j)</script> corresponds to one of the boundaries. But, if <script type=\"math/tex; mode=display\">(i,j)</script> is simultaneously a part of multiple boundaries, we need to add the <script type=\"math/tex; mode=display\">dp[i][j]</script> factor multiple times(same as the number of boundaries to which <script type=\"math/tex; mode=display\">(i,j)</script> belongs).</p> \n  <p>After we are done with all the <script type=\"math/tex; mode=display\">N</script> moves, <script type=\"math/tex; mode=display\">count</script> gives the required result.</p> \n  <p>The following animation illustrates the process:</p> \n  <p>!?!../Documents/576_Boundary_Paths.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/MvuV89Mf/shared\" frameborder=\"0\" name=\"MvuV89Mf\" width=\"100%\" height=\"513\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(N*m*n)</script>. We need to fill the <script type=\"math/tex; mode=display\">dp</script>$ array with dimensions <script type=\"math/tex; mode=display\">m</script>x<script type=\"math/tex; mode=display\">n</script> <script type=\"math/tex; mode=display\">N</script> times. Here <script type=\"math/tex; mode=display\">m</script>x<script type=\"math/tex; mode=display\">n</script> refers to the size of the grid and <script type=\"math/tex; mode=display\">N</script> refers to the number of moves available.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(m*n)</script>. <script type=\"math/tex; mode=display\">dp</script> and <script type=\"math/tex; mode=display\">temp</script> array of size <script type=\"math/tex; mode=display\">m</script>x<script type=\"math/tex; mode=display\">n</script> are used.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 575,
    "article_live": true,
    "article_slug": "distribute-candies",
    "title": "Distribute Candies",
    "title_slug": "distribute-candies",
    "content": "Given an integer array with <b>even</b> length, where different numbers in this array represent different <b>kinds</b> of candies. Each number means one candy of the corresponding kind. You need to distribute these candies <b>equally</b> in number to brother and sister. Return the maximum number of <b>kinds</b> of candies the sister could gain. \r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> candies = [1,1,2,2,3,3]\r\n<b>Output:</b> 3\r\n<b>Explanation:</b>\r\nThere are three different kinds of candies (1, 2 and 3), and two candies for each kind.\r\nOptimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too. \r\nThe sister has three different kinds of candies. \r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> candies = [1,1,2,3]\r\n<b>Output:</b> 2\r\n<b>Explanation:</b> For example, the sister has candies [2,3] and the brother has candies [1,1]. \r\nThe sister has two different kinds of candies, the brother has only one kind of candies. \r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\n<ol>\r\n<li>The length of the given array is in range [2, 10,000], and will be even.</li>\r\n<li>The number in given array is in range [-100,000, 100,000].</li>\r\n<ol>\r\n</p>",
    "tags": "Hash Table",
    "difficulty": 1,
    "frontend_article_id": 575,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-better-brute-force-time-limit-exceeded\">Approach #2 Better Brute Force [Time Limit Exceeded]:</a></li> \n      <li><a href=\"#approach-3-using-sortingaccepted\">Approach #3 Using sorting[Accepted]</a></li> \n      <li><a href=\"#approach-4-using-set-accepted\">Approach #4 Using set [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>The brute force approach is really simple. We can generate all the permutations of the given <script type=\"math/tex; mode=display\">nums</script> array representing the candies and determine the number of unique elements in the first half of the generated array.</p> \n  <p>In order to determine the number of unique elements in the first half of the array, we put all the required elements in a set and count the number of elements in the set. We count such unique elements in the first half of the generated arrays for all the permutations possible and return the size of the largest set.</p> \n  <iframe src=\"https://leetcode.com/playground/BjLCxvkM/shared\" frameborder=\"0\" name=\"BjLCxvkM\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n!)</script>. A total of <script type=\"math/tex; mode=display\">n!</script> permutations are possible for <script type=\"math/tex; mode=display\">nums</script> array of size <script type=\"math/tex; mode=display\">n</script>. </p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The depth of the recursion tree can go upto <script type=\"math/tex; mode=display\">n</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-better-brute-force-time-limit-exceeded\">Approach #2 Better Brute Force [Time Limit Exceeded]:</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Before looking into the idea behind this approach, firstly we need to observe one point. The maximum no. of unique candies which the girl can obtain could be atmost <script type=\"math/tex; mode=display\">n/2</script>, where <script type=\"math/tex; mode=display\">n</script> refers to the number of candies. Further, in case the number of unique candies are below <script type=\"math/tex; mode=display\">n/2</script>, to maximize the number of unique candies that the girl will obtain, we'll assign all the unique candies to the girl. Thus, in such a case, the number of unique candies the girl gets is equal to the total number of unique candies in the given <script type=\"math/tex; mode=display\">candies</script> array. </p> \n  <p>Now, let's look at the idea behind this approach. We need to find the total number of unique candies in the given <script type=\"math/tex; mode=display\">candies</script> array. One way to find the number of unique candies is to traverse over the given <script type=\"math/tex; mode=display\">candies</script> array. Whenever we encounter an element, say <script type=\"math/tex; mode=display\">candies[j]</script>, we can mark all the elements which are the same as <script type=\"math/tex; mode=display\">candies[j]</script> as invalid and increment the count of unique elements by 1.</p> \n  <p>Thus, we need to do such markings for all the elements of <script type=\"math/tex; mode=display\">candies</script> array. At the end, <script type=\"math/tex; mode=display\">count</script> gives the required number of unique candies that can be given to the girl. Further, the value to be returned is given by: <script type=\"math/tex; mode=display\">\\text{min}(\\frac{n}{2}, count)</script>. Instead of finding the <script type=\"math/tex; mode=display\">\\text{min}</script>, we can stop the traversal over the given <script type=\"math/tex; mode=display\">candies</script> array as soon as the <script type=\"math/tex; mode=display\">count</script> exceeds <script type=\"math/tex; mode=display\">\\frac{n}{2}</script>. </p> \n  <iframe src=\"https://leetcode.com/playground/ttcdibF7/shared\" frameborder=\"0\" name=\"ttcdibF7\" width=\"100%\" height=\"309\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^2)</script>. We traverse over all the elements of <script type=\"math/tex; mode=display\">candies</script> for every new element found. In the worst case, we do so for every element of <script type=\"math/tex; mode=display\">candies</script> array. <script type=\"math/tex; mode=display\">n</script> refers to the size of <script type=\"math/tex; mode=display\">candies</script> array.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant space is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-using-sortingaccepted\">Approach #3 Using sorting[Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>We can sort the given <script type=\"math/tex; mode=display\">candies</script> array and find out the elements which are unique by comparing the adjacent elements of the sorted array. For every new element found(which isn't the same as the previous element), we need to update the <script type=\"math/tex; mode=display\">count</script>. At the end, we can return the required result as <script type=\"math/tex; mode=display\">\\text{min}(n/2, count)</script>, as discussed in the previous approach.</p> \n  <iframe src=\"https://leetcode.com/playground/757QK7we/shared\" frameborder=\"0\" name=\"757QK7we\" width=\"100%\" height=\"224\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(nlogn)</script>. Sorting takes <script type=\"math/tex; mode=display\">O(nlogn)</script> time.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant space is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-4-using-set-accepted\">Approach #4 Using set [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Another way to find the number of unique elements is to traverse over all the elements of the given <script type=\"math/tex; mode=display\">candies</script> array and keep on putting the elements in a set. By the property of a set, it will contain only unique elements. At the end, we can count the number of elements in the set, given by, say <script type=\"math/tex; mode=display\">count</script>. The value to be returned will again be given by <script type=\"math/tex; mode=display\">\\text{min}(count, n/2)</script>, as discussed in previous approaches. Here, <script type=\"math/tex; mode=display\">n</script> refers to the size of the <script type=\"math/tex; mode=display\">candies</script> array.</p> \n  <iframe src=\"https://leetcode.com/playground/ahWVHEov/shared\" frameborder=\"0\" name=\"ahWVHEov\" width=\"100%\" height=\"224\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The entire <script type=\"math/tex; mode=display\">candies</script> array is traversed only once. Here, <script type=\"math/tex; mode=display\">n</script> refers to the size of <script type=\"math/tex; mode=display\">candies</script> array.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. <script type=\"math/tex; mode=display\">set</script> will be of size <script type=\"math/tex; mode=display\">n</script> in the worst case.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 573,
    "article_live": true,
    "article_slug": "squirrel-simulation",
    "title": "Squirrel Simulation",
    "title_slug": "squirrel-simulation",
    "tags": "Math",
    "difficulty": 2,
    "frontend_article_id": 573,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-simple-solution-accepted\">Approach #1 Simple Solution [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-simple-solution-accepted\">Approach #1 Simple Solution [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>We know, the distance between any two points(tree, squirrel, nut) is given by the absolute difference between the corresponding x-coordinates and the corresponding y-coordinates. </p> \n  <p>Now, in order to determine the required minimum distance, we need to observe a few points. Firstly, the order in which the nuts are picked doesn't affect the final result, except one of the nuts which needs to be visited first from the squirrel's starting position. For the rest of the nuts, it is mandatory to go from the tree to the nut and then come back as well. </p> \n  <p>For the first visited nut, the saving obtained, given by <script type=\"math/tex; mode=display\">d</script>, is the difference between the distance between the tree and the current nut &amp; the distance between the current nut and the squirrel. This is because for this nut, we need not travel from the tree to the nut, but need to travel an additional distance from the squirrel's original position to the nut.</p> \n  <p>While traversing over the <script type=\"math/tex; mode=display\">nuts</script> array and adding the to-and-fro distance, we find out the saving, <script type=\"math/tex; mode=display\">d</script>, which can be obtained if the squirrel goes to the current nut first. Out of all the nuts, we find out the nut which maximizes the saving and then deduct this maximum saving from the sum total of the to-and-fro distance of all the nuts.</p> \n  <p>Note that the first nut to be picked needs not necessarily be the nut closest to the squirrel's start point, but it's the one which maximizes the savings.</p> \n  <p align=\"center\"><img alt=\"Squirrel_Nuts\" src=\"../Figures/573_Squirrel.PNG\"></p> \n  <iframe src=\"https://leetcode.com/playground/ETPUcUyj/shared\" frameborder=\"0\" name=\"ETPUcUyj\" width=\"100%\" height=\"309\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. We need to traverse over the whole <script type=\"math/tex; mode=display\">nuts</script> array once. <script type=\"math/tex; mode=display\">n</script> refers to the size of <script type=\"math/tex; mode=display\">nuts</script> array.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant space is used.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 572,
    "article_live": true,
    "article_slug": "subtree-of-another-tree",
    "title": "Subtree of Another Tree",
    "title_slug": "subtree-of-another-tree",
    "content": "<p>\r\nGiven two non-empty binary trees <b>s</b> and <b>t</b>, check whether tree <b>t</b> has exactly the same structure and node values with a subtree of <b>s</b>. A subtree of <b>s</b> is a tree consists of a node in <b>s</b> and all of this node's descendants. The tree <b>s</b> could also be considered as a subtree of itself.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br>\r\n\r\nGiven tree s:\r\n<pre>\r\n     3\r\n    / \\\r\n   4   5\r\n  / \\\r\n 1   2\r\n</pre>\r\nGiven tree t:\r\n<pre>\r\n   4 \r\n  / \\\r\n 1   2\r\n</pre>\r\nReturn <b>true</b>, because t has the same structure and node values with a subtree of s.\r\n</p>\r\n\r\n<p><b>Example 2:</b><br>\r\n\r\nGiven tree s:\r\n<pre>\r\n     3\r\n    / \\\r\n   4   5\r\n  / \\\r\n 1   2\r\n    /\r\n   0\r\n</pre>\r\nGiven tree t:\r\n<pre>\r\n   4\r\n  / \\\r\n 1   2\r\n</pre>\r\nReturn <b>false</b>.\r\n</p>",
    "tags": "Tree",
    "difficulty": 1,
    "frontend_article_id": 572,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-using-preorder-traversal-accepted\">Approach #1 Using Preorder Traversal [Accepted]</a></li> \n      <li><a href=\"#approach-2-by-comparison-of-nodes-accepted\">Approach #2 By Comparison of Nodes [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-using-preorder-traversal-accepted\">Approach #1 Using Preorder Traversal [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>We can find the preorder traversal of the given tree <script type=\"math/tex; mode=display\">s</script> and <script type=\"math/tex; mode=display\">t</script>, given by, say <script type=\"math/tex; mode=display\">s_{preorder}</script> and <script type=\"math/tex; mode=display\">t_{preorder}</script> respectively(represented in the form of a string). Now, we can check if <script type=\"math/tex; mode=display\">t_{preorder}</script> is a substring of <script type=\"math/tex; mode=display\">s_{preorder}</script>. </p> \n  <p>But, in order to use this approach, we need to treat the given tree in a different manner. Rather than assuming a <script type=\"math/tex; mode=display\">null</script> value for the childern of the leaf nodes, we need to treat the left and right child as a <script type=\"math/tex; mode=display\">lnull</script> and <script type=\"math/tex; mode=display\">rnull</script> value respectively. This is done to ensure that the <script type=\"math/tex; mode=display\">t_{preorder}</script> doesn't become a substring of <script type=\"math/tex; mode=display\">s_{preorder}</script> even in cases when <script type=\"math/tex; mode=display\">t</script> isn't a subtree of <script type=\"math/tex; mode=display\">s</script>. </p> \n  <p>You can also note that we've added a '#' before every considering every value. If this isn't done, the trees of the form <code>s:[23, 4, 5]</code> and <code>t:[3, 4, 5]</code> will also give a true result since the preorder string of the <code>t(\"23 4 lnull rull 5 lnull rnull\")</code> will be a substring of the preorder string of <code>s(\"3 4 lnull rull 5 lnull rnull\")</code>. Adding a '#' before the node's value solves this problem.</p> \n  <p align=\"center\"><img alt=\"Preorder_null\" src=\"../Figures/572_Subtree_1.PNG\"></p> \n  <p align=\"center\"><img alt=\"Preorder_lnull_rnull\" src=\"../Figures/572_Subtree_2.PNG\"></p> \n  <iframe src=\"https://leetcode.com/playground/cagXWqSv/shared\" frameborder=\"0\" name=\"cagXWqSv\" width=\"100%\" height=\"513\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(m^2+n^2+m*n)</script>. A total of <script type=\"math/tex; mode=display\">n</script> nodes of the tree <script type=\"math/tex; mode=display\">s</script> and <script type=\"math/tex; mode=display\">m</script> nodes of tree <script type=\"math/tex; mode=display\">t</script> are traversed. Assuming string concatenation takes <script type=\"math/tex; mode=display\">O(k)</script> time for strings of length <script type=\"math/tex; mode=display\">k</script> and <code>indexOf</code> takes <script type=\"math/tex; mode=display\">O(m*n)</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(max(m,n))</script>. The depth of the recursion tree can go upto <script type=\"math/tex; mode=display\">n</script> for tree <script type=\"math/tex; mode=display\">t</script> and <script type=\"math/tex; mode=display\">m</script> for tree <script type=\"math/tex; mode=display\">s</script> in worst case.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-by-comparison-of-nodes-accepted\">Approach #2 By Comparison of Nodes [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Instead of creating an inorder traversal, we can treat every node of the given tree <script type=\"math/tex; mode=display\">t</script> as the root, treat it as a subtree and compare the corresponding subtree with the given subtree <script type=\"math/tex; mode=display\">s</script> for equality. For checking the equality, we can compare the all the nodes of the two subtrees. </p> \n  <p>For doing this, we make use a function <code>traverse(s,t)</code> which traverses over the given tree <script type=\"math/tex; mode=display\">s</script> and treats every node as the root of the subtree currently being considered. It also checks the two subtrees currently being considered for their equality. In order to check the equality of the two subtrees, we make use of <code>equals(x,y)</code> function, which takes <script type=\"math/tex; mode=display\">x</script> and <script type=\"math/tex; mode=display\">y</script>, which are the roots of the two subtrees to be compared as the inputs and returns True or False depending on whether the two are equal or not. It compares all the nodes of the two subtrees for equality. Firstly, it checks whether the roots of the two trees for equality and then calls itself recursively for the left subtree and the right subtree.</p> \n  <p>The follwowing animation depicts an abstracted view of the process:</p> \n  <p>!?!../Documents/572_Subtree.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/A6ipy4aH/shared\" frameborder=\"0\" name=\"A6ipy4aH\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(m*n)</script>. In worst case(skewed tree) <code>traverse</code> function takes <script type=\"math/tex; mode=display\">O(m*n)</script> time. </p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The depth of the recursion tree can go upto <script type=\"math/tex; mode=display\">n</script>. <script type=\"math/tex; mode=display\">n</script> refers to the number of nodes in <script type=\"math/tex; mode=display\">s</script>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 568,
    "article_live": true,
    "article_slug": "maximum-vacation-days",
    "title": "Maximum Vacation Days",
    "title_slug": "maximum-vacation-days",
    "tags": "Dynamic Programming",
    "difficulty": 3,
    "frontend_article_id": 568,
    "article_content": ""
},
{
    "frontend_question_id": 567,
    "article_live": true,
    "article_slug": "short-permutation-in-a-long-string",
    "title": "Permutation in String",
    "title_slug": "permutation-in-string",
    "content": "Given two strings <b>s1</b> and <b>s2</b>, write a function to return true if <b>s2</b> contains the permutation of <b>s1</b>. In other words, one of the first string's permutations is the <b>substring</b> of the second string.\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b>s1 = \"ab\" s2 = \"eidbaooo\"\r\n<b>Output:</b>True\r\n<b>Explanation:</b> s2 contains one permutation of s1 (\"ba\").\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b>s1= \"ab\" s2 = \"eidboaoo\"\r\n<b>Output:</b> False\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The input strings only contain lower case letters.</li>\r\n<li>The length of both given strings is in range [1, 10,000].</li>\r\n</ol>\r\n</p>",
    "tags": "Two Pointers",
    "difficulty": 2,
    "frontend_article_id": 567,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-using-sorting-time-limit-exceeded\">Approach #2 Using sorting [Time Limit Exceeded]:</a></li> \n      <li><a href=\"#approach-3-using-hashmap-time-limit-exceeded\">Approach #3 Using Hashmap [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-4-using-array-accepted\">Approach #4 Using Array [Accepted]</a></li> \n      <li><a href=\"#approach-5-sliding-window-accepted\">Approach #5 Sliding Window [Accepted]:</a></li> \n      <li><a href=\"#approach-6-optimized-sliding-window-accepted\">Approach #6 Optimized Sliding Window [Accepted]:</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>The simplest method is to generate all the permutations of the short string and to check if the generated permutation is a substring of the longer string.</p> \n  <p>In order to generate all the possible pairings, we make use of a function <code>permute(string_1, string_2, current_index)</code>. This function creates all the possible permutations of the short string <script type=\"math/tex; mode=display\">s1</script>.</p> \n  <p>To do so, permute takes the index of the current element <script type=\"math/tex; mode=display\">current_index</script> as one of the arguments. Then, it swaps the current element with every other element in the array, lying towards its right, so as to generate a new ordering of the array elements. After the swapping has been done, it makes another call to permute but this time with the index of the next element in the array. While returning back, we reverse the swapping done in the current function call.</p> \n  <p>Thus, when we reach the end of the array, a new ordering of the array's elements is generated. The following animation depicts the process of generating the permutations.</p> \n  <p>!?!../Documents/561_Array.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/p3HAqkFZ/shared\" frameborder=\"0\" name=\"p3HAqkFZ\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n!)</script>. We match all the permutations of the short string <script type=\"math/tex; mode=display\">s1</script>, of length <script type=\"math/tex; mode=display\">s1</script>, with <script type=\"math/tex; mode=display\">s2</script>. Here, <script type=\"math/tex; mode=display\">n</script> refers to the length of <script type=\"math/tex; mode=display\">s1</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n^2)</script>. The depth of the recursion tree is <script type=\"math/tex; mode=display\">n</script>(<script type=\"math/tex; mode=display\">n</script> refers to the length of the short string <script type=\"math/tex; mode=display\">s1</script>). Every node of the recursion tree contains a string of max. length <script type=\"math/tex; mode=display\">n</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-using-sorting-time-limit-exceeded\">Approach #2 Using sorting [Time Limit Exceeded]:</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>The idea behind this approach is that one string will be a permutation of another string only if both of them contain the same characters the same number of times. One string <script type=\"math/tex; mode=display\">x</script> is a permutation of other string <script type=\"math/tex; mode=display\">y</script> only if <script type=\"math/tex; mode=display\">sorted(x)=sorted(y)</script>. </p> \n  <p>In order to check this, we can sort the two strings and compare them. We sort the short string <script type=\"math/tex; mode=display\">s1</script> and all the substrings of <script type=\"math/tex; mode=display\">s2</script>, sort them and compare them with the sorted <script type=\"math/tex; mode=display\">s1</script> string. If the two match completely, <script type=\"math/tex; mode=display\">s1</script>'s permutation is a substring of <script type=\"math/tex; mode=display\">s2</script>, otherwise not.</p> \n  <iframe src=\"https://leetcode.com/playground/zWvWj8oK/shared\" frameborder=\"0\" name=\"zWvWj8oK\" width=\"100%\" height=\"326\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O\\big(l_1log(l_1)+(l_2-l_1)l_1log(l_1)\\big)</script>. where <script type=\"math/tex; mode=display\">l_1</script> is the length of string <script type=\"math/tex; mode=display\">l_1</script> and <script type=\"math/tex; mode=display\">l_2</script> is the length of string <script type=\"math/tex; mode=display\">l_2</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(l_1)</script>. <script type=\"math/tex; mode=display\">t</script> array is used .</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-using-hashmap-time-limit-exceeded\">Approach #3 Using Hashmap [Time Limit Exceeded]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>As discussed above, one string will be a permutation of another string only if both of them contain the same charaters with the same frequency. We can consider every possible substring in the long string <script type=\"math/tex; mode=display\">s2</script> of the same length as that of <script type=\"math/tex; mode=display\">s1</script> and check the frequency of occurence of the characters appearing in the two. If the frequencies of every letter match exactly, then only <script type=\"math/tex; mode=display\">s1</script>'s permutation can be a substring of <script type=\"math/tex; mode=display\">s2</script>. </p> \n  <p>In order to implement this approach, instead of sorting and then comparing the elements for equality, we make use of a hashmap <script type=\"math/tex; mode=display\">s1map</script> which stores the frequency of occurence of all the characters in the short string <script type=\"math/tex; mode=display\">s1</script>. We consider every possible substring of <script type=\"math/tex; mode=display\">s2</script> of the same length as that of <script type=\"math/tex; mode=display\">s1</script>, find its corresponding hashmap as well, namely <script type=\"math/tex; mode=display\">s2map</script>. Thus, the substrings considered can be viewed as a window of length as that of <script type=\"math/tex; mode=display\">s1</script> iterating over <script type=\"math/tex; mode=display\">s2</script>. If the two hashmaps obtained are identical for any such window, we can conclude that <script type=\"math/tex; mode=display\">s1</script>'s permutation is a substring of <script type=\"math/tex; mode=display\">s2</script>, otherwise not.</p> \n  <iframe src=\"https://leetcode.com/playground/SvwMjwJX/shared\" frameborder=\"0\" name=\"SvwMjwJX\" width=\"100%\" height=\"513\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(l_1+26*l_1*(l_2-l_1))</script>. hashmap contains atmost 26 keys. where <script type=\"math/tex; mode=display\">l_1</script> is the length of string <script type=\"math/tex; mode=display\">l_1</script> and <script type=\"math/tex; mode=display\">l_2</script> is the length of string <script type=\"math/tex; mode=display\">l_2</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. hashmap contains atmost 26 key-value pairs.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-4-using-array-accepted\">Approach #4 Using Array [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Instead of making use of a special HashMap datastructure just to store the frequency of occurence of characters, we can use a simpler array data structure to store the frequencies. Given strings contains only lowercase alphabets ('a' to 'z'). So we need to take an array of size 26.The rest of the process remains the same as the last approach.</p> \n  <iframe src=\"https://leetcode.com/playground/48H3F2LJ/shared\" frameborder=\"0\" name=\"48H3F2LJ\" width=\"100%\" height=\"496\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(l_1+26*l_1*(l_2-l_1))</script>, where <script type=\"math/tex; mode=display\">l_1</script> is the length of string <script type=\"math/tex; mode=display\">l_1</script> and <script type=\"math/tex; mode=display\">l_2</script> is the length of string <script type=\"math/tex; mode=display\">l_2</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. <script type=\"math/tex; mode=display\">s1map</script> and <script type=\"math/tex; mode=display\">s2map</script> of size 26 is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-5-sliding-window-accepted\">Approach #5 Sliding Window [Accepted]:</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Instead of generating the hashmap afresh for every window considered in <script type=\"math/tex; mode=display\">s2</script>, we can create the hashmap just once for the first window in <script type=\"math/tex; mode=display\">s2</script>. Then, later on when we slide the window, we know that we add one preceding character and add a new succeeding character to the new window considered. Thus, we can update the hashmap by just updating the indices associated with those two characters only. Again, for every updated hashmap, we compare all the elements of the hashmap for equality to get the required result.</p> \n  <iframe src=\"https://leetcode.com/playground/o4pqWwhn/shared\" frameborder=\"0\" name=\"o4pqWwhn\" width=\"100%\" height=\"496\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(l_1+26*(l_2-l_1))</script>, where <script type=\"math/tex; mode=display\">l_1</script> is the length of string <script type=\"math/tex; mode=display\">l_1</script> and <script type=\"math/tex; mode=display\">l_2</script> is the length of string <script type=\"math/tex; mode=display\">l_2</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant space is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-6-optimized-sliding-window-accepted\">Approach #6 Optimized Sliding Window [Accepted]:</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>The last approach can be optimized, if instead of comparing all the elements of the hashmaps for every updated <script type=\"math/tex; mode=display\">s2map</script> corresponding to every window of <script type=\"math/tex; mode=display\">s2</script> considered, we keep a track of the number of elements which were already matching in the earlier hashmap and update just the count of matching elements when we shift the window towards the right.</p> \n  <p>To do so, we maintain a <script type=\"math/tex; mode=display\">count</script> variable, which stores the number of characters(out of the 26 alphabets), which have the same frequency of occurence in <script type=\"math/tex; mode=display\">s1</script> and the current window in <script type=\"math/tex; mode=display\">s2</script>. When we slide the window, if the deduction of the last element and the addition of the new element leads to a new frequency match of any of the characters, we increment the <script type=\"math/tex; mode=display\">count</script> by 1. If not, we keep the <script type=\"math/tex; mode=display\">count</script> intact. But, if a character whose frequency was the same earlier(prior to addition and removal) is added, it now leads to a frequency mismatch which is taken into account by decrementing the same <script type=\"math/tex; mode=display\">count</script> variable. If, after the shifting of the window, the <script type=\"math/tex; mode=display\">count</script> evaluates to 26, it means all the characters match in frequency totally. So, we return a True in that case immediately.</p> \n  <iframe src=\"https://leetcode.com/playground/T5J3SxqR/shared\" frameborder=\"0\" name=\"T5J3SxqR\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(l_1+(l_2-l_1))</script>. where <script type=\"math/tex; mode=display\">l_1</script> is the length of string <script type=\"math/tex; mode=display\">l_1</script> and <script type=\"math/tex; mode=display\">l_2</script> is the length of string <script type=\"math/tex; mode=display\">l_2</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant space is used.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 566,
    "article_live": true,
    "article_slug": "reshape-the-matrix",
    "title": "Reshape the Matrix",
    "title_slug": "reshape-the-matrix",
    "content": "<p>In MATLAB, there is a very useful function called 'reshape', which can reshape a matrix into a new one with different size but keep its original data.\r\n</p>\r\n\r\n<p>\r\nYou're given a matrix represented by a two-dimensional array, and two <b>positive</b> integers <b>r</b> and <b>c</b> representing the <b>row</b> number and <b>column</b> number of the wanted reshaped matrix, respectively.</p>\r\n\r\n <p>The reshaped matrix need to be filled with all the elements of the original matrix in the same <b>row-traversing</b> order as they were.\r\n</p>\r\n\r\n<p>\r\nIf the 'reshape' operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\nnums = \r\n[[1,2],\r\n [3,4]]\r\nr = 1, c = 4\r\n<b>Output:</b> \r\n[[1,2,3,4]]\r\n<b>Explanation:</b><br>The <b>row-traversing</b> of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\nnums = \r\n[[1,2],\r\n [3,4]]\r\nr = 2, c = 4\r\n<b>Output:</b> \r\n[[1,2],\r\n [3,4]]\r\n<b>Explanation:</b><br>There is no way to reshape a 2 * 2 matrix to a 2 * 4 matrix. So output the original matrix.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The height and width of the given matrix is in range [1, 100].</li>\r\n<li>The given r and c are all positive.</li>\r\n</ol>\r\n</p>",
    "tags": "Array",
    "difficulty": 1,
    "frontend_article_id": 566,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-using-queue-accepted\">Approach #1 Using queue [Accepted]</a></li> \n      <li><a href=\"#approach-2-without-using-extra-space-accepted\">Approach #2 Without using extra Space [Accepted]</a></li> \n      <li><a href=\"#approach-3-using-division-and-modulus-accepted\">Approach #3 Using division and modulus [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-using-queue-accepted\">Approach #1 Using queue [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>The simplest method is to extract all the elements of the given matrix by reading the elements in a row-wise fashion. In this implementation, we use a queue to put the extracted elements. Then, we can take out the elements of the queue formed in a serial order and arrange the elements in the resultant required matrix in a row-by-row order again.</p> \n  <p>The formation of the resultant matrix won't be possible if the number of elements in the original matrix isn't equal to the number of elements in the resultant matrix.</p> \n  <iframe src=\"https://leetcode.com/playground/QiYrHtjz/shared\" frameborder=\"0\" name=\"QiYrHtjz\" width=\"100%\" height=\"428\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(m*n)</script>. We traverse over <script type=\"math/tex; mode=display\">m*n</script> elements twice. Here, <script type=\"math/tex; mode=display\">m</script> and <script type=\"math/tex; mode=display\">n</script> refer to the number of rows and columns of the given matrix respectively.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(m*n)</script>. The queue formed will be of size <script type=\"math/tex; mode=display\">m*n</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-without-using-extra-space-accepted\">Approach #2 Without using extra Space [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Instead of unnecessarily using the queue as in the brute force approach, we can keep putting the numbers in the resultant matrix directly while iterating over the given matrix in a row-by-row order. While putting the numbers in the resultant array, we fix a particular row and keep on incrementing the column numbers only till we reach the end of the required columns indicated by <script type=\"math/tex; mode=display\">c</script>. At this moment, we update the row index by incrementing it and reset the column index to start from 0 again. Thus, we can save the space consumed by the queue for storing the data that just needs to be copied into a new array.</p> \n  <iframe src=\"https://leetcode.com/playground/JvBHJ8mJ/shared\" frameborder=\"0\" name=\"JvBHJ8mJ\" width=\"100%\" height=\"394\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(m*n)</script>. We traverse the entire matrix of size <script type=\"math/tex; mode=display\">m*n</script> once only. Here, <script type=\"math/tex; mode=display\">m</script> and <script type=\"math/tex; mode=display\">n</script> refers to the number of rows and columns in the given matrix.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(m*n)</script>. The resultant matrix of size <script type=\"math/tex; mode=display\">m*n</script> is used. </p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-using-division-and-modulus-accepted\">Approach #3 Using division and modulus [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In the last approach, we needed to keep a track of when we reached the end of columns for the resultant matrix and needed to update the current row and column number for putting the extracted elements by checking the current indices every time. Instead of doing these limit checks at every step, we can make use of maths to help ease the situation. </p> \n  <p>The idea behind this approach is as follows. Do you know how a 2-D array is stored in the main memory(which is 1-D in nature)? It is internally represented as a 1-D array only. The element <script type=\"math/tex; mode=display\">nums[i][j]</script> of <script type=\"math/tex; mode=display\">nums</script> array is represented in the form of a one dimensional array by using the index in the form: <script type=\"math/tex; mode=display\">nums[n*i + j]</script>, where <script type=\"math/tex; mode=display\">m</script> is the number of columns in the given matrix. Looking at the same in the reverse order, while putting the elements in the elements in the resultant matrix, we can make use of a <script type=\"math/tex; mode=display\">count</script> variable which gets incremented for every element traversed as if we are putting the elements in a 1-D resultant array. But, to convert the <script type=\"math/tex; mode=display\">count</script> back into 2-D matrix indices with a column count of <script type=\"math/tex; mode=display\">c</script>, we can obtain the indices as <script type=\"math/tex; mode=display\">res[count/c][count\\%c]</script> where <script type=\"math/tex; mode=display\">count/c</script> is the row number and <script type=\"math/tex; mode=display\">count\\%c</script> is the coloumn number. Thus, we can save the extra checking required at each step.</p> \n  <iframe src=\"https://leetcode.com/playground/3U3C5txm/shared\" frameborder=\"0\" name=\"3U3C5txm\" width=\"100%\" height=\"309\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(m*n)</script>. We traverse the entire matrix of size <script type=\"math/tex; mode=display\">m*n</script> once only. Here, <script type=\"math/tex; mode=display\">m</script> and <script type=\"math/tex; mode=display\">n</script> refers to the number of rows and columns in the given matrix.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(m*n)</script>. The resultant matrix of size <script type=\"math/tex; mode=display\">m*n</script> is used. </p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 565,
    "article_live": true,
    "article_slug": "array-nesting",
    "title": "Array Nesting",
    "title_slug": "array-nesting",
    "content": "<p>A zero-indexed array A of length N contains all integers from 0 to N-1. Find and return the longest length of set S, where S[i] = {A[i], A[A[i]], A[A[A[i]]], ... } subjected to the rule below.</p>\r\n\r\n<p>Suppose the first element in S starts with the selection of element A[i] of index = i, the next element in S should be A[A[i]], and then A[A[A[i]]]… By that analogy, we stop adding right before a duplicate element occurs in S.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> A = [5,4,0,3,1,6,2]\r\n<b>Output:</b> 4\r\n<b>Explanation:</b> \r\nA[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.\r\n\r\nOne of the longest S[K]:\r\nS[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>N is an integer within the range [1, 20,000].</li>\r\n<li>The elements of A are all distinct.</li>\r\n<li>Each element of A is an integer within the range [0, N-1].</li>\r\n</ol>\r\n</p>",
    "tags": "Array",
    "difficulty": 2,
    "frontend_article_id": 565,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-using-visited-array-accepted\">Approach #2 Using Visited Array [Accepted]</a></li> \n      <li><a href=\"#approach-3-without-using-extra-space-accepted\">Approach #3 Without Using Extra Space [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</h4> \n  <p>The simplest method is to iterate over all the indices of the given <script type=\"math/tex; mode=display\">nums</script> array. For every index <script type=\"math/tex; mode=display\">i</script> chosen, we find the element <script type=\"math/tex; mode=display\">nums[i]</script> and increment the <script type=\"math/tex; mode=display\">count</script> for a new element added for the current index <script type=\"math/tex; mode=display\">i</script>. Since <script type=\"math/tex; mode=display\">nums[i]</script> has to act as the new index for finding the next element belonging to the set corresponding to the index <script type=\"math/tex; mode=display\">i</script>, the new index is <script type=\"math/tex; mode=display\">j=nums[i]</script>.</p> \n  <p>We continue this process of index updation and keep on incrementing the <script type=\"math/tex; mode=display\">count</script> for new elements added to the set corresponding to the index <script type=\"math/tex; mode=display\">i</script>. Now, since all the elements in <script type=\"math/tex; mode=display\">nums</script> lie in the range <script type=\"math/tex; mode=display\">(0,..., N-1)</script>, the new indices generated will never lie outside the array size limits. But, we'll always reach a point where the current element becomes equal to the element <script type=\"math/tex; mode=display\">nums[i]</script> with which we started the nestings in the first place. Thus, after this, the new indices generated will be just the repetitions of the previously generated ones, and thus would not lead to an increase in the size of the current set. Thus, this condition of the current number being equal to the starting number acts as the terminating condition for <script type=\"math/tex; mode=display\">count</script> incrementation for a particular index.</p> \n  <p>We do the same process for every index chosen as the starting index. At the end, the maximum value of <script type=\"math/tex; mode=display\">count</script> obtained gives the size of the largest set.</p> \n  <iframe src=\"https://leetcode.com/playground/K6QuRdnw/shared\" frameborder=\"0\" name=\"K6QuRdnw\" width=\"100%\" height=\"326\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^2)</script>. In worst case, for example- <code>[1,2,3,4,5,0]</code>, loop body will be executed <script type=\"math/tex; mode=display\">n^2</script> times.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant space is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-using-visited-array-accepted\">Approach #2 Using Visited Array [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In the last approach, we observed that in the worst case, all the elements of the <script type=\"math/tex; mode=display\">nums</script> array are added to the sets corresponding to all the starting indices. But, all these sets correspond to the same set of elements only, leading to redundant calculations.</p> \n  <p>We consider a simple example and see how this problem can be resolved. From the figure below, we can see that the elements in the current nesting shown by arrows form a cycle. Thus, the same elements will be added to the current set irrespective of the first element chosen to be added to the set out of these marked elements.</p> \n  <p><img alt=\"Array_Nesting\" src=\"../Figures/565/Array_Nesting.PNG\"></p> \n  <p>Thus, when we add an element <script type=\"math/tex; mode=display\">nums[j]</script> to a set corresponding to any of the indices, we mark its position as visited in a <script type=\"math/tex; mode=display\">visited</script> array. This is done so that whenever this index is chosen as the starting index in the future, we do not go for redundant <script type=\"math/tex; mode=display\">count</script> calculations, since we've already considered the elements linked with this index, which will be added to a new(duplicate) set.</p> \n  <p>By doing so, we ensure that the duplicate sets aren't considered again and again.</p> \n  <p>Further, we can also observe that no two elements at indices <script type=\"math/tex; mode=display\">i</script> and <script type=\"math/tex; mode=display\">j</script> will lead to a jump to the same index <script type=\"math/tex; mode=display\">k</script>, since it would require <script type=\"math/tex; mode=display\">nums[i] = nums[j] = k</script>, which isn't possible since all the elements are distinct. Also, because of the same reasoning, no element outside any cycle could lead to an element inside the cycle. Because of this, the use of <script type=\"math/tex; mode=display\">visited</script> array goes correctly. </p> \n  <iframe src=\"https://leetcode.com/playground/XQA6FiH7/shared\" frameborder=\"0\" name=\"XQA6FiH7\" width=\"100%\" height=\"394\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Every element of the <script type=\"math/tex; mode=display\">nums</script> array will be considered atmost once.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. <script type=\"math/tex; mode=display\">visited</script> array of size <script type=\"math/tex; mode=display\">n</script> is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-without-using-extra-space-accepted\">Approach #3 Without Using Extra Space [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In the last approach, the <script type=\"math/tex; mode=display\">visited</script> array is used just to keep a track of the elements of the array which have already been visited. Instead of making use of a separate array to keep track of the same, we can mark the visited elements in the original array <script type=\"math/tex; mode=display\">nums</script> itself. Since, the range of the elements can only be between 1 to 20,000, we can put a very large integer value <script type=\"math/tex; mode=display\">\\text{Integer.MAX_VALUE}</script> at the position which has been visited. The rest process of traversals remains the same as in the last approach.</p> \n  <iframe src=\"https://leetcode.com/playground/7DmKnygx/shared\" frameborder=\"0\" name=\"7DmKnygx\" width=\"100%\" height=\"394\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Every element of the <script type=\"math/tex; mode=display\">nums</script> array will be considered atmost once.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant Space is used.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 564,
    "article_live": true,
    "article_slug": "find-the-closest-palindrome",
    "title": "Find the Closest Palindrome",
    "title_slug": "find-the-closest-palindrome",
    "content": "<p>Given an integer n, find the closest integer (not including itself), which is a palindrome. </p>\r\n\r\n<p>The 'closest' is defined as absolute difference minimized between two integers.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \"123\"\r\n<b>Output:</b> \"121\"\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The input <b>n</b> is a positive integer represented by string, whose length will not exceed 18.</li>\r\n<li>If there is a tie, return the smaller one as answer.</li>\r\n</ol>\r\n</p>",
    "tags": "String",
    "difficulty": 3,
    "frontend_article_id": 564,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-forcetime-limit-exceeded\">Approach #1 Brute Force[Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-using-mathaccepted\">Approach #2 Using Math[Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-forcetime-limit-exceeded\">Approach #1 Brute Force[Time Limit Exceeded]</h4> \n  <p>The simplest solution is to consider every possible number smaller than the given number <script type=\"math/tex; mode=display\">n</script>, starting by decrementing 1 from the given number and go on in descending order. Similarly, we can consider every possible number greater than <script type=\"math/tex; mode=display\">n</script> starting by incrementing 1 from the given number and going in ascending order. We can continue doing so in an alternate manner till we find a number which is a palindrome.</p> \n  <iframe src=\"https://leetcode.com/playground/DvreVK8V/shared\" frameborder=\"0\" name=\"DvreVK8V\" width=\"100%\" height=\"377\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(\\sqrt{n})</script>. Upto <script type=\"math/tex; mode=display\">2*\\sqrt{n}</script> numbers could be generated in the worst case.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant space is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-using-mathaccepted\">Approach #2 Using Math[Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>To understand this method, let's start with a simple illustration. Assume that the number given to us is \"abcxy\". One way to convert this number into a palindrome is to replicate one half of the string to the other half. If we try replicating the second half to the first half, the new palindrome obtained will be \"yxcxy\" which lies at an absolute of <script type=\"math/tex; mode=display\">\\left|10000(a-y) + 1000(b-x)\\right|</script> from the original number. But, if we replicate the first half to the second half of the string, we obtain \"abcba\", which lies at an absolute difference of <script type=\"math/tex; mode=display\">\\left|10(x-b) + (y-a)\\right|</script>. Trying to change <script type=\"math/tex; mode=display\">c</script> additionaly in either case would incur an additional value of atleast 100 in the absolute difference.</p> \n  <p>From the above illustration, we can conclude that if replication is used to generate the palindromic number, we should always replicate the first half to the second half. In this implementation, we've stored such a number in <script type=\"math/tex; mode=display\">a</script> at a difference of <script type=\"math/tex; mode=display\">diff1</script> from <script type=\"math/tex; mode=display\">n</script>.</p> \n  <p>But, there exists another case as well, where the digit at the middle index is incremented or decremented. In such cases, it could be profitable to make changes to the central digit only since such changes could lead to a palindrome formation nearer to the original digit. e.g. 10987. Using the above criteria, the palindrome obtained will be 10901 which is at a more difference from 10987 than 11011. A similar situation occurs if a 0 occurs at the middle digit. But, again as discussed previously, we need to consider only the first half digits to obtain the new palindrome. This special effect occurs with 0 or 9 at the middle digit since, only decrementing 0 and incrementing 9 at that digit place can lead to the change in the rest of the digits towards their left. In any other case, the situation boils down to the one discussed in the first paragraph.</p> \n  <p>Now, whenever we find a 0 near the middle index, in order to consider the palindromes which are lesser than <script type=\"math/tex; mode=display\">n</script>, we subtract a 1 from the first half of the number to obtain a new palindromic half e.g. If the given number <script type=\"math/tex; mode=display\">n</script> is 20001, we subtract a 1 from 200 creating a number of the form 199xx. To obtain the new palindrome, we replicate the first half to obtain 19991. Taking another example of 10000, (with a 1 at the MSB), we subtract a 1 from 100 creating 099xx as the new number transforming to a 9999 as the new palindrome. This number is stored in <script type=\"math/tex; mode=display\">b</script> having a difference of <script type=\"math/tex; mode=display\">diff2</script> from <script type=\"math/tex; mode=display\">n</script> </p> \n  <p>Similar treatment needs to be done with a 9 at the middle digit, except that this time we need to consider the numbers larger than the current number. For this, we add a 1 to the first half. e.g. Taking the number 10987, we add a 1 to 109 creating a number of the form 110xx(11011 is the new palindrome). This palindrome is stored in <script type=\"math/tex; mode=display\">c</script> having a difference of <script type=\"math/tex; mode=display\">diff3</script> from <script type=\"math/tex; mode=display\">n</script>.</p> \n  <p>Out of these three palindromes, we can choose the one with a minimum difference from <script type=\"math/tex; mode=display\">n</script>. Further, in case of a tie, we need to return the smallest palindrome obtained. For resolving this tie's conflict, we can observe that a tie is possible only if one number is larger than <script type=\"math/tex; mode=display\">n</script> and another is lesser than <script type=\"math/tex; mode=display\">n</script>. Further, we know that the number <script type=\"math/tex; mode=display\">b</script> is obtained by decreasing <script type=\"math/tex; mode=display\">n</script>. Thus, in case of conflict between <script type=\"math/tex; mode=display\">b</script> and any other number, we need to choose <script type=\"math/tex; mode=display\">b</script>. Similarly, <script type=\"math/tex; mode=display\">c</script> is obtained by increasing <script type=\"math/tex; mode=display\">n</script>. Thus, in case of a tie between <script type=\"math/tex; mode=display\">c</script> and any other number, we need to choose the number other than <script type=\"math/tex; mode=display\">c</script>.</p> \n  <iframe src=\"https://leetcode.com/playground/Y6G9NDDf/shared\" frameborder=\"0\" name=\"Y6G9NDDf\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(l)</script>. Scanning, insertion, deletion,, mirroring takes <script type=\"math/tex; mode=display\">O(l)</script>, where <script type=\"math/tex; mode=display\">l</script> is the length of the string.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(l)</script>. Temporary variables are used to store the strings.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 563,
    "article_live": true,
    "article_slug": "binary-tree-tilt",
    "title": "Binary Tree Tilt",
    "title_slug": "binary-tree-tilt",
    "content": "<p>Given a binary tree, return the tilt of the <b>whole tree</b>.</p>\r\n\r\n<p>The tilt of a <b>tree node</b> is defined as the <b>absolute difference</b> between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0.</p>\r\n\r\n<p>The tilt of the <b>whole tree</b> is defined as the sum of all nodes' tilt.</p>\r\n\r\n<p><b>Example:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\n         1\r\n       /   \\\r\n      2     3\r\n<b>Output:</b> 1\r\n<b>Explanation:</b> \r\nTilt of node 2 : 0\r\nTilt of node 3 : 0\r\nTilt of node 1 : |2-3| = 1\r\nTilt of binary tree : 0 + 0 + 1 = 1\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\n<ol>\r\n<li>The sum of node values in any subtree won't exceed the range of 32-bit integer. </li>\r\n<li>All the tilt values won't exceed the range of 32-bit integer.</li>\r\n</ol>\r\n</p>",
    "tags": "Tree",
    "difficulty": 1,
    "frontend_article_id": 563,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-using-recursion-accepted\">Approach #1 Using Recursion [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-using-recursion-accepted\">Approach #1 Using Recursion [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>From the problem statement, it is clear that we need to find the tilt value at every node of the given tree and add up all the tilt values to obtain the final result. To find the tilt value at any node, we need to subtract the sum of all the nodes in its left subtree and the sum of all the nodes in its right subtree. </p> \n  <p>Thus, to find the solution, we make use of a recursive function <code>traverse</code> which when called from any node, returns the sum of the nodes below the current node including itself. With the help of such sum values for the right and left subchild of any node, we can directly obtain the tilt value corresponding to that node.</p> \n  <p>The below animation depicts how the value passing and tilt calculation:</p> \n  <p>!?!../Documents/563_Binary.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/CGp6bPXz/shared\" frameborder=\"0\" name=\"CGp6bPXz\" width=\"100%\" height=\"496\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. where <script type=\"math/tex; mode=display\">n</script> is the number of nodes. Each node is visited once.</li> \n   <li>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. In worst case when the tree is skewed depth of tree will be <script type=\"math/tex; mode=display\">n</script>. In average case depth will be <script type=\"math/tex; mode=display\">logn</script>.</li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 562,
    "article_live": true,
    "article_slug": "longest-line-of-consecutive-one-in-a-matrix",
    "title": "Longest Line of Consecutive One in Matrix",
    "title_slug": "longest-line-of-consecutive-one-in-matrix",
    "tags": "Array",
    "difficulty": 2,
    "frontend_article_id": 562,
    "article_content": ""
},
{
    "frontend_question_id": 561,
    "article_live": true,
    "article_slug": "array-partitioning-i",
    "title": "Array Partition I",
    "title_slug": "array-partition-i",
    "content": "<p>\r\nGiven an array of <b>2n</b> integers, your task is to group these integers into <b>n</b> pairs of integer, say (a<sub>1</sub>, b<sub>1</sub>), (a<sub>2</sub>, b<sub>2</sub>), ..., (a<sub>n</sub>, b<sub>n</sub>) which makes sum of min(a<sub>i</sub>, b<sub>i</sub>) for all i from 1 to n as large as possible.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [1,4,3,2]\r\n\r\n<b>Output:</b> 4\r\n<b>Explanation:</b> n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li><b>n</b> is a positive integer, which is in the range of [1, 10000].</li>\r\n<li>All the integers in the array will be in the range of [-10000, 10000].</li>\r\n</ol>\r\n</p>",
    "tags": "Array",
    "difficulty": 1,
    "frontend_article_id": 561,
    "article_content": ""
},
{
    "frontend_question_id": 560,
    "article_live": true,
    "article_slug": "subarray-sum-equals-k",
    "title": "Subarray Sum Equals K",
    "title_slug": "subarray-sum-equals-k",
    "content": "<p>Given an array of integers and an integer <b>k</b>, you need to find the total number of continuous subarrays whose sum equals to <b>k</b>.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b>nums = [1,1,1], k = 2\r\n<b>Output:</b> 2\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The length of the array is in range [1, 20,000].</li>\r\n<li>The range of numbers in the array is [-1000, 1000] and the range of the integer <b>k</b> is [-1e7, 1e7].</li>\r\n</ol>\r\n</p>\r\n",
    "tags": "Array, Hash Table",
    "difficulty": 2,
    "frontend_article_id": 560,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#summary\">Summary</a></li> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-using-cummulative-sum-accepted\">Approach #2 Using Cummulative sum [Accepted]</a></li> \n      <li><a href=\"#approach-3-without-space-accepted\">Approach #3 Without space [Accepted]</a></li> \n      <li><a href=\"#approach-4-using-hashmap-accepted\">Approach #4 Using hashmap [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"summary\">Summary</h2> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>The simplest method is to consider every possible subarray of the given <script type=\"math/tex; mode=display\">nums</script> array, find the sum of the elements of each of those subarrays and check for the equality of the sum obtained with the given <script type=\"math/tex; mode=display\">k</script>. Whenver the sum equals <script type=\"math/tex; mode=display\">k</script>, we can increment the <script type=\"math/tex; mode=display\">count</script> used to store the required result.</p> \n  <iframe src=\"https://leetcode.com/playground/uzdLhWrz/shared\" frameborder=\"0\" name=\"uzdLhWrz\" width=\"100%\" height=\"309\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^3)</script>. Considering every possible subarray takes <script type=\"math/tex; mode=display\">O(n^2)</script> time. For each of the subarray we calculate the sum taking <script type=\"math/tex; mode=display\">O(n)</script> time in the worst case, taking a total of <script type=\"math/tex; mode=display\">O(n^3)</script> time.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant space is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-using-cummulative-sum-accepted\">Approach #2 Using Cummulative sum [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Instead of determining the sum of elements everytime for every new subarray considered, we can make use of a cumulative sum array , <script type=\"math/tex; mode=display\">sum</script>. Then, in order to calculate the sum of elements lying between two indices, we can subtract the cumulative sum corresponding to the two indices to obtain the sum directly, instead of iterating over the subarray to obtain the sum.</p> \n  <p>In this implementation, we make use of a cumulative sum array, <script type=\"math/tex; mode=display\">sum</script>, such that <script type=\"math/tex; mode=display\">sum[i]</script> is used to store the cumulative sum of <script type=\"math/tex; mode=display\">nums</script> array upto the element corresponding to the <script type=\"math/tex; mode=display\">(i-1)^{th}</script> index. Thus, to determine the sum of elements for the subarray <script type=\"math/tex; mode=display\">nums[i:j]</script>, we can directly use <script type=\"math/tex; mode=display\">sum[j+1] - sum[i]</script>.</p> \n  <iframe src=\"https://leetcode.com/playground/YnknRnC6/shared\" frameborder=\"0\" name=\"YnknRnC6\" width=\"100%\" height=\"326\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^2)</script>. Considering every possible subarray takes <script type=\"math/tex; mode=display\">O(n^2)</script> time. Finding out the sum of any subarray takes <script type=\"math/tex; mode=display\">O(1)</script> time after the initial processing of <script type=\"math/tex; mode=display\">O(n)</script> for creating the cumulative sum array.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Cumulative sum array <script type=\"math/tex; mode=display\">sum</script> of size <script type=\"math/tex; mode=display\">n+1</script> is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-without-space-accepted\">Approach #3 Without space [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Instead of considering all the <script type=\"math/tex; mode=display\">start</script> and <script type=\"math/tex; mode=display\">end</script> points and then finding the sum for each subarray corresponding to those points, we can directly find the sum on the go while considering different <script type=\"math/tex; mode=display\">end</script> points. i.e. We can choose a particular <script type=\"math/tex; mode=display\">start</script> point and while iterating over the <script type=\"math/tex; mode=display\">end</script> points, we can add the element corresponding to the <script type=\"math/tex; mode=display\">end</script> point to the sum formed till now. Whenver the <script type=\"math/tex; mode=display\">sum</script> equals the required <script type=\"math/tex; mode=display\">k</script> value, we can update the <script type=\"math/tex; mode=display\">count</script> value. We do so while iterating over all the <script type=\"math/tex; mode=display\">end</script> indices possible for every <script type=\"math/tex; mode=display\">start</script> index. Whenver, we update the <script type=\"math/tex; mode=display\">start</script> index, we need to reset the <script type=\"math/tex; mode=display\">sum</script> value to 0.</p> \n  <iframe src=\"https://leetcode.com/playground/MGuUEEUy/shared\" frameborder=\"0\" name=\"MGuUEEUy\" width=\"100%\" height=\"292\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^2)</script>. We need to consider every subarray possible.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant space is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-4-using-hashmap-accepted\">Approach #4 Using hashmap [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>The idea behind this approach is as follows: If the cumulative sum(repreesnted by <script type=\"math/tex; mode=display\">sum[i]</script> for sum upto <script type=\"math/tex; mode=display\">i^{th}</script> index) upto two indices is the same, the sum of the elements lying in between those indices is zero. Extending the same thought further, if the cumulative sum upto two indices, say <script type=\"math/tex; mode=display\">i</script> and <script type=\"math/tex; mode=display\">j</script> is at a difference of <script type=\"math/tex; mode=display\">k</script> i.e. if <script type=\"math/tex; mode=display\">sum[i] - sum[j] = k</script>, the sum of elements lying between indices <script type=\"math/tex; mode=display\">i</script> and <script type=\"math/tex; mode=display\">j</script> is <script type=\"math/tex; mode=display\">k</script>.</p> \n  <p>Based on these thoughts, we make use of a hashmap <script type=\"math/tex; mode=display\">map</script> which is used to store the cumulative sum upto all the indices possible along with the number of times the same sum occurs. We store the data in the form: <script type=\"math/tex; mode=display\">(sum_i, no. of occurences of sum_i)</script>. We traverse over the array <script type=\"math/tex; mode=display\">nums</script> and keep on finding the cumulative sum. Every time we encounter a new sum, we make a new entry in the hashmap corresponding to that sum. If the same sum occurs again, we increment the count corresponding to that sum in the hashmap. Further, for every sum encountered, we also determine the number of times the sum <script type=\"math/tex; mode=display\">sum-k</script> has occured already, since it will determine the number of times a subarray with sum <script type=\"math/tex; mode=display\">k</script> has occured upto the current index. We increment the <script type=\"math/tex; mode=display\">count</script> by the same amount. </p> \n  <p>After the complete array has been traversed, the <script type=\"math/tex; mode=display\">count</script> gives the required result.</p> \n  <p>The animation below depicts the process.</p> \n  <p>!?!../Documents/560_Subarray.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/S6xciAtN/shared\" frameborder=\"0\" name=\"S6xciAtN\" width=\"100%\" height=\"292\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The entire <script type=\"math/tex; mode=display\">nums</script> array is traversed only once.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Hashmap <script type=\"math/tex; mode=display\">map</script> can contain upto <script type=\"math/tex; mode=display\">n</script> distinct entries in the worst case.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 557,
    "article_live": true,
    "article_slug": "reverse-words-in-a-string",
    "title": "Reverse Words in a String III",
    "title_slug": "reverse-words-in-a-string-iii",
    "content": "<p>Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \"Let's take LeetCode contest\"\r\n<b>Output:</b> \"s'teL ekat edoCteeL tsetnoc\"\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\nIn the string, each word is separated by single space and there will not be any extra space in the string.\r\n</p>",
    "tags": "String",
    "difficulty": 1,
    "frontend_article_id": 557,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-simple-solutionaccepted\">Approach #1 Simple Solution[Accepted]</a></li> \n      <li><a href=\"#approach-2-without-using-pre-defined-split-and-reverse-function-accepted\">Approach #2 Without using pre-defined split and reverse function [Accepted]</a></li> \n      <li><a href=\"#approach-3-using-stringbuilder-and-reverse-method-accepted\">Approach #3 Using StringBuilder and reverse method [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-simple-solutionaccepted\">Approach #1 Simple Solution[Accepted]</h4> \n  <p>The first method is really simple. We simply split up the given string based on whitespaces and put the individual words in an array of strings. Then, we reverse each individual string and concatenate the result. We return the result after removing the additional whitespaces at the end.</p> \n  <iframe src=\"https://leetcode.com/playground/DjRyo9vA/shared\" frameborder=\"0\" name=\"DjRyo9vA\" width=\"100%\" height=\"207\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. where <script type=\"math/tex; mode=display\">n</script> is the length of the string.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. <script type=\"math/tex; mode=display\">res</script> of size <script type=\"math/tex; mode=display\">n</script> is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-without-using-pre-defined-split-and-reverse-function-accepted\">Approach #2 Without using pre-defined split and reverse function [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>We can create our own split and reverse function. Split function splits the string based on the delimiter \" \"(space) and returns the array of words. Reverse function returns the string after reversing the characters.</p> \n  <iframe src=\"https://leetcode.com/playground/oxasWgHd/shared\" frameborder=\"0\" name=\"oxasWgHd\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. where <script type=\"math/tex; mode=display\">n</script> is the length of the string.</li> \n   <li>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. <script type=\"math/tex; mode=display\">res</script> of size <script type=\"math/tex; mode=display\">n</script> is used.</li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-using-stringbuilder-and-reverse-method-accepted\">Approach #3 Using StringBuilder and reverse method [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Instead of using split method, we can use temporary string <script type=\"math/tex; mode=display\">word</script> to store the word. We simply append the characters to the <script type=\"math/tex; mode=display\">word</script> until <code>' '</code> character is not found. On getting <code>' '</code> we append the reverse of the <script type=\"math/tex; mode=display\">word</script> to the resultant string <script type=\"math/tex; mode=display\">result</script>. Also after completion of loop , we still have to append the <script type=\"math/tex; mode=display\">reverse</script> of the <script type=\"math/tex; mode=display\">word</script>(last word) to the <script type=\"math/tex; mode=display\">result</script> string. </p> \n  <p>Below code is inspired by <a href=\"https://leetcode.com/apolloX\">@ApolloX</a>.</p> \n  <iframe src=\"https://leetcode.com/playground/Xt8eMTKv/shared\" frameborder=\"0\" name=\"Xt8eMTKv\" width=\"100%\" height=\"343\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Single loop upto <script type=\"math/tex; mode=display\">n</script> is there, where <script type=\"math/tex; mode=display\">n</script> is the length of the string.</li> \n   <li>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. <script type=\"math/tex; mode=display\">result</script> and <script type=\"math/tex; mode=display\">word</script> size will grow upto <script type=\"math/tex; mode=display\">n</script>.</li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 556,
    "article_live": true,
    "article_slug": "next-greater-element-iii",
    "title": "Next Greater Element III",
    "title_slug": "next-greater-element-iii",
    "content": "<p>Given a positive <strong>32-bit</strong> integer <strong>n</strong>, you need to find the smallest <strong>32-bit</strong> integer which has exactly the same digits existing in the integer <strong>n</strong> and is greater in value than n. If no such positive <strong>32-bit</strong> integer exists, you need to return -1.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 12\r\n<strong>Output:</strong> 21\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 21\r\n<strong>Output:</strong> -1\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n",
    "tags": "String",
    "difficulty": 2,
    "frontend_article_id": 556,
    "article_content": ""
},
{
    "frontend_question_id": 555,
    "article_live": true,
    "article_slug": "split-assembled-strings",
    "title": "Split Concatenated Strings",
    "title_slug": "split-concatenated-strings",
    "tags": "String",
    "difficulty": 2,
    "frontend_article_id": 555,
    "article_content": ""
},
{
    "frontend_question_id": 554,
    "article_live": true,
    "article_slug": "brick-wall",
    "title": "Brick Wall",
    "title_slug": "brick-wall",
    "content": "<p>There is a brick wall in front of you. The wall is rectangular and has several rows of bricks. The bricks have the same height but different width. You want to draw a vertical line from the <b>top</b> to the <b>bottom</b> and cross the <b>least</b> bricks.</p>\r\n\r\n<p>The brick wall is represented by a list of rows. Each row is a list of integers representing the width of each brick in this row from left to right.</p>\r\n\r\n<p>If your line go through the edge of a brick, then the brick is not considered as crossed. You need to find out how to draw the line to cross the least bricks and return the number of crossed bricks.</p>\r\n\r\n<p><b>You cannot draw a line just along one of the two vertical edges of the wall, in which case the line will obviously cross no bricks. </b></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Example:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> [[1,2,2,1],\r\n        [3,1,2],\r\n        [1,3,2],\r\n        [2,4],\r\n        [3,1,2],\r\n        [1,3,1,1]]\r\n\r\n<b>Output:</b> 2\r\n\r\n<b>Explanation:</b> \r\n<img src=\"https://assets.leetcode.com/uploads/2018/10/12/brick_wall.png\" style=\"width: 100%; max-width: 350px\" />\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Note:</b></p>\r\n\r\n<ol>\r\n\t<li>The width sum of bricks in different rows are the same and won&#39;t exceed INT_MAX.</li>\r\n\t<li>The number of bricks in each row is in range [1,10,000]. The height of wall is in range [1,10,000]. Total number of bricks of the wall won&#39;t exceed 20,000.</li>\r\n</ol>\r\n",
    "tags": "Hash Table",
    "difficulty": 2,
    "frontend_article_id": 554,
    "article_content": ""
},
{
    "frontend_question_id": 553,
    "article_live": true,
    "article_slug": "optimal-division",
    "title": "Optimal Division",
    "title_slug": "optimal-division",
    "content": "<p>Given a list of <b>positive integers</b>, the adjacent integers will perform the float division. For example, [2,3,4] -> 2 / 3 / 4.</p>\r\n\r\n<p>However, you can add any number of parenthesis at any position to change the priority of operations. You should find out how to add parenthesis to get the <b>maximum</b> result, and return the corresponding expression in string format. <b>Your expression should NOT contain redundant parenthesis.</b></p>\r\n\r\n<p><b>Example:</b><br />\r\n<pre>\r\n<b>Input:</b> [1000,100,10,2]\r\n<b>Output:</b> \"1000/(100/10/2)\"\r\n<b>Explanation:</b>\r\n1000/(100/10/2) = 1000/((100/10)/2) = 200\r\nHowever, the bold parenthesis in \"1000/(<b>(</b>100/10<b>)</b>/2)\" are redundant, <br/>since they don't influence the operation priority. So you should return \"1000/(100/10/2)\". \r\n\r\nOther cases:\r\n1000/(100/10)/2 = 50\r\n1000/(100/(10/2)) = 50\r\n1000/100/10/2 = 0.5\r\n1000/100/(10/2) = 2\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\n<ol>\r\n<li>The length of the input array is [1, 10].</li>\r\n<li>Elements in the given array will be in range [2, 1000].</li>\r\n<li>There is only one optimal division for each test case.</li>\r\n</ol>\r\n</p>",
    "tags": "Math, String",
    "difficulty": 2,
    "frontend_article_id": 553,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-accepted\">Approach #1 Brute Force [Accepted]</a></li> \n      <li><a href=\"#approach-2-using-memorization-accepted\">Approach #2 Using Memorization [Accepted]</a></li> \n      <li><a href=\"#approach-3-using-some-math-accepted\">Approach #3 Using some Math [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-accepted\">Approach #1 Brute Force [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Brute force of this problem is to divide the list into two parts <script type=\"math/tex; mode=display\">left</script> and <script type=\"math/tex; mode=display\">right</script> and call function for these two parts. We will iterate <script type=\"math/tex; mode=display\">i</script> from <script type=\"math/tex; mode=display\">start</script> to <script type=\"math/tex; mode=display\">end</script> so that <script type=\"math/tex; mode=display\">left=(start,i)</script> and <script type=\"math/tex; mode=display\">right=(i+1,end)</script>.</p> \n  <p> <script type=\"math/tex; mode=display\">left</script> and <script type=\"math/tex; mode=display\">right</script> parts return their maximum and minimum value and corresponding strings.</p> \n  <p>Minimum value can be found by dividing minimum of left by maximum of right i.e. <script type=\"math/tex; mode=display\">minVal=left.min/right.max</script>.</p> \n  <p>Similarly,Maximum value can be found by dividing maximum of left value by minimum of right value. i.e. <script type=\"math/tex; mode=display\">maxVal=left.max/right.min</script>.</p> \n  <p>Now, how to add parenthesis? As associativity of division operator is from left to right i.e. by default left most divide should be done first, we need not have to add paranthesis to the left part, but we must add parenthesis to the right part.</p> \n  <p>eg- \"2/(3/4)\" will be formed as leftPart+\"/\"+\"(\"+rightPart+\")\", assuming leftPart is \"2\" and rightPart is\"3/4\".</p> \n  <p>One more point, we also don't require parenthesis to right part when it contains single digit.</p> \n  <p>eg- \"2/3\", here left part is \"2\" and right part is \"3\" (contains single digit) . 2/(3) is not valid.</p> \n  <iframe src=\"https://leetcode.com/playground/CAbJyzm4/shared\" frameborder=\"0\" name=\"CAbJyzm4\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n!)</script>. Number of permutations of expression after applying brackets will be in <script type=\"math/tex; mode=display\">O(n!)</script> where <script type=\"math/tex; mode=display\">n</script> is the number of items in the list.</p> </li> \n   <li> <p>Space complexity: <script type=\"math/tex; mode=display\">O(n^2)</script>. Depth of recursion tree will be <script type=\"math/tex; mode=display\">O(n)</script> and each node contains string of maximum length <script type=\"math/tex; mode=display\">O(n)</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-using-memorization-accepted\">Approach #2 Using Memorization [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In the above approach we called optimal function recursively for ever <script type=\"math/tex; mode=display\">start</script> and <script type=\"math/tex; mode=display\">end</script>. We can notice that there are many redundant calls in the above approach, we can reduce these calls by using memorization to store the result of different function calls. Here, <script type=\"math/tex; mode=display\">memo</script> array is used for this purpose.</p> \n  <iframe src=\"https://leetcode.com/playground/xFgr7Cpd/shared\" frameborder=\"0\" name=\"xFgr7Cpd\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^3)</script>. <script type=\"math/tex; mode=display\">memo</script> array of size <script type=\"math/tex; mode=display\">n^2</script> is filled and filling of each cell of the <script type=\"math/tex; mode=display\">memo</script> array takes <script type=\"math/tex; mode=display\">O(n)</script> time.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n^3)</script>. <script type=\"math/tex; mode=display\">memo</script> array of size <script type=\"math/tex; mode=display\">n^2</script> where each cell of array contains string of length <script type=\"math/tex; mode=display\">O(n)</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-using-some-math-accepted\">Approach #3 Using some Math [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Using some simple math we can find the easy solution of this problem. Consider the input in the form of [a,b,c,d], now we have to set priority of operations to maximize a/b/c/d. We know that to maximize fraction <script type=\"math/tex; mode=display\">p/q</script>, <script type=\"math/tex; mode=display\">q</script>(denominator) should be minimized. So, to maximize <script type=\"math/tex; mode=display\">a/b/c/d</script> we have to first minimize b/c/d. Now our objective turns to minimize the expression b/c/d.</p> \n  <p>There are two possible combinations of this expression, b/(c/d) and (b/c)/d.</p> \n  <div class=\"codehilite\">\n   <pre><span></span>b/(c/d)        (b/c)/d = b/c/d\n(b*d)/c        b/(d*c)\nd/c            1/(d*c)\n</pre>\n  </div> \n  <p>Obviously, <script type=\"math/tex; mode=display\">d/c > 1/(d*c)</script> for <script type=\"math/tex; mode=display\">d>1</script>.</p> \n  <p>You can see that second combination will always be less than first one for numbers greater than <script type=\"math/tex; mode=display\">1</script>. So, the answer will be a/(b/c/d). Similarly for expression like a/b/c/d/e/f... answer will be a/(b/c/d/e/f...).</p> \n  <iframe src=\"https://leetcode.com/playground/wUbJEUre/shared\" frameborder=\"0\" name=\"wUbJEUre\" width=\"100%\" height=\"309\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Single loop to traverse <script type=\"math/tex; mode=display\">nums</script> array.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. <script type=\"math/tex; mode=display\">res</script> variable is used to store the result.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 552,
    "article_live": true,
    "article_slug": "student-attendance-record-ii",
    "title": "Student Attendance Record II",
    "title_slug": "student-attendance-record-ii",
    "content": "<p>Given a positive integer <b>n</b>, return the number of all possible attendance records with length n, which will be regarded as rewardable. The answer may be very large, return it after mod 10<sup>9</sup> + 7.</p>\r\n\r\n<p>A student attendance record is a string that only contains the following three characters:</p>\r\n\r\n<p>\r\n<ol>\r\n<li><b>'A'</b> : Absent. </li>\r\n<li><b>'L'</b> : Late.</li>\r\n<li> <b>'P'</b> : Present. </li>\r\n</ol>\r\n</p>\r\n\r\n<p>\r\nA record is regarded as rewardable if it doesn't contain <b>more than one 'A' (absent)</b> or <b>more than two continuous 'L' (late)</b>.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> n = 2\r\n<b>Output:</b> 8 \r\n<b>Explanation:</b>\r\nThere are 8 records with length 2 will be regarded as rewardable:\r\n\"PP\" , \"AP\", \"PA\", \"LP\", \"PL\", \"AL\", \"LA\", \"LL\"\r\nOnly \"AA\" won't be regarded as rewardable owing to more than one absent times. \r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\nThe value of <b>n</b> won't exceed 100,000.\r\n</p>\r\n\r\n\r\n",
    "tags": "Dynamic Programming",
    "difficulty": 3,
    "frontend_article_id": 552,
    "article_content": ""
},
{
    "frontend_question_id": 551,
    "article_live": true,
    "article_slug": "student-attendance-record-i",
    "title": "Student Attendance Record I",
    "title_slug": "student-attendance-record-i",
    "content": "You are given a string representing an attendance record for a student. The record only contains the following three characters:\r\n\r\n<p>\r\n<ol>\r\n<li><b>'A'</b> : Absent. </li>\r\n<li><b>'L'</b> : Late.</li>\r\n<li> <b>'P'</b> : Present. </li>\r\n</ol>\r\n</p>\r\n\r\n<p>\r\nA student could be rewarded if his attendance record doesn't contain <b>more than one 'A' (absent)</b> or <b>more than two continuous 'L' (late)</b>.    </p>\r\n\r\n<p>You need to return whether the student could be rewarded according to his attendance record.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \"PPALLP\"\r\n<b>Output:</b> True\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> \"PPALLL\"\r\n<b>Output:</b> False\r\n</pre>\r\n</p>\r\n\r\n\r\n",
    "tags": "String",
    "difficulty": 1,
    "frontend_article_id": 551,
    "article_content": ""
},
{
    "frontend_question_id": 549,
    "article_live": true,
    "article_slug": "binary-tree-longest-consecutive-sequence-ii",
    "title": "Binary Tree Longest Consecutive Sequence II",
    "title_slug": "binary-tree-longest-consecutive-sequence-ii",
    "tags": "Tree",
    "difficulty": 2,
    "frontend_article_id": 549,
    "article_content": ""
},
{
    "frontend_question_id": 548,
    "article_live": true,
    "article_slug": "split-array-with-equal-sum",
    "title": "Split Array with Equal Sum",
    "title_slug": "split-array-with-equal-sum",
    "tags": "Array",
    "difficulty": 2,
    "frontend_article_id": 548,
    "article_content": ""
},
{
    "frontend_question_id": 547,
    "article_live": true,
    "article_slug": "friend-circles",
    "title": "Friend Circles",
    "title_slug": "friend-circles",
    "content": "<p>\r\nThere are <b>N</b> students in a class. Some of them are friends, while some are not. Their friendship is transitive in nature. For example, if A is a <b>direct</b> friend of B, and B is a <b>direct</b> friend of C, then A is an <b>indirect</b> friend of C. And we defined a friend circle is a group of students who are direct or indirect friends.\r\n</p>\r\n\r\n<p>\r\nGiven a <b>N*N</b> matrix <b>M</b> representing the friend relationship between students in the class. If M[i][j] = 1, then the i<sub>th</sub> and j<sub>th</sub> students are <b>direct</b> friends with each other, otherwise not. And you have to output the total number of friend circles among all the students.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\n[[1,1,0],\r\n [1,1,0],\r\n [0,0,1]]\r\n<b>Output:</b> 2\r\n<b>Explanation:</b>The 0<sub>th</sub> and 1<sub>st</sub> students are direct friends, so they are in a friend circle. <br/>The 2<sub>nd</sub> student himself is in a friend circle. So return 2.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\n[[1,1,0],\r\n [1,1,1],\r\n [0,1,1]]\r\n<b>Output:</b> 1\r\n<b>Explanation:</b>The 0<sub>th</sub> and 1<sub>st</sub> students are direct friends, the 1<sub>st</sub> and 2<sub>nd</sub> students are direct friends, <br/>so the 0<sub>th</sub> and 2<sub>nd</sub> students are indirect friends. All of them are in the same friend circle, so return 1.\r\n</pre>\r\n</p>\r\n\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>N is in range [1,200].</li>\r\n<li>M[i][i] = 1 for all students.</li>\r\n<li>If M[i][j] = 1, then M[j][i] = 1.</li>\r\n</ol>\r\n</p>",
    "tags": "Depth-first Search, Union Find",
    "difficulty": 2,
    "frontend_article_id": 547,
    "article_content": ""
},
{
    "frontend_question_id": 546,
    "article_live": true,
    "article_slug": "remove-boxes",
    "title": "Remove Boxes",
    "title_slug": "remove-boxes",
    "content": "<p>Given several boxes with different colors represented by different positive numbers. <br />\r\nYou may experience several rounds to remove boxes until there is no box left. Each time you can choose some continuous boxes with the same color (composed of k boxes, k >= 1), remove them and get <code>k*k</code> points.<br />\r\nFind the maximum points you can get.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br>\r\nInput: \r\n<pre>\r\n[1, 3, 2, 2, 2, 3, 4, 3, 1]\r\n</pre>\r\nOutput:\r\n<pre>\r\n23\r\n</pre>\r\nExplanation: \r\n<pre>\r\n[1, 3, 2, 2, 2, 3, 4, 3, 1] \r\n----> [1, 3, 3, 4, 3, 1] (3*3=9 points) \r\n----> [1, 3, 3, 3, 1] (1*1=1 points) \r\n----> [1, 1] (3*3=9 points) \r\n----> [] (2*2=4 points)\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\nThe number of boxes <code>n</code> would not exceed 100.\r\n</p>\r\n",
    "tags": "Dynamic Programming, Depth-first Search",
    "difficulty": 3,
    "frontend_article_id": 546,
    "article_content": ""
},
{
    "frontend_question_id": 545,
    "article_live": true,
    "article_slug": "boundary-of-binary-tree",
    "title": "Boundary of Binary Tree",
    "title_slug": "boundary-of-binary-tree",
    "tags": "Tree",
    "difficulty": 2,
    "frontend_article_id": 545,
    "article_content": ""
},
{
    "frontend_question_id": 544,
    "article_live": true,
    "article_slug": "output-contest-matches",
    "title": "Output Contest Matches",
    "title_slug": "output-contest-matches",
    "tags": "String, Recursion",
    "difficulty": 2,
    "frontend_article_id": 544,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-simulation-accepted\">Approach #1: Simulation [Accepted]</a></li> \n    <li><a href=\"#approach-2-linear-write-accepted\">Approach #2: Linear Write [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-simulation-accepted\">Approach #1: Simulation [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Let <code>team[i]</code> be the correct team string of the <code>i</code>-th strongest team for that round. We will maintain these correctly as the rounds progress.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>In each round, the <code>i</code>-th team becomes <code>\"(\" + team[i] + \",\" + team[n-1-i] + \")\"</code>, and then there are half as many teams.</p> \n  <iframe src=\"https://leetcode.com/playground/q4aFLoLB/shared\" frameborder=\"0\" width=\"100%\" height=\"276\" name=\"q4aFLoLB\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N \\log N)</script>. Each of <script type=\"math/tex; mode=display\">O(\\log N)</script> rounds performs <script type=\"math/tex; mode=display\">O(N)</script> work.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N \\log N)</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-linear-write-accepted\">Approach #2: Linear Write [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Let's try to solve the problem in linear time. We can treat this problem as two separate problems: outputting the correct sequence of parentheses and commas, and outputting the correct team number. With a little effort, one can be convinced that a linear time solution probably exists.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Let's focus on the parentheses first. We can use recursion to find the answer. For example, when <code>N = 8</code>, let <code>R = log_2(N) = 3</code> be the number of rounds. The parentheses and commas look like this:</p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"p\">(((</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"n\">x</span><span class=\"p\">),(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"n\">x</span><span class=\"p\">)),((</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"n\">x</span><span class=\"p\">),(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"n\">x</span><span class=\"p\">)))</span>\n</pre>\n  </div> \n  <p>But this is just recursively</p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"s2\">\"(\"</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"n\">sequence</span> <span class=\"k\">for</span> <span class=\"n\">R</span> <span class=\"o\">=</span> <span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"s2\">\",\"</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"n\">sequence</span> <span class=\"k\">for</span> <span class=\"n\">R</span> <span class=\"o\">=</span> <span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"s2\">\")\"</span>\n<span class=\"o\">=</span> <span class=\"s2\">\"(\"</span> <span class=\"o\">+</span> <span class=\"s2\">\"((x,x),(x,x))\"</span> <span class=\"o\">+</span> <span class=\"s2\">\",\"</span> <span class=\"o\">+</span> <span class=\"s2\">\"((x,x),(x,x))\"</span> <span class=\"o\">+</span> <span class=\"s2\">\")\"</span>\n</pre>\n  </div> \n  <p>Now let's look at the team numbers. For <code>N = 16</code>, the team numbers are:</p> \n  <p><code>team = [1, 16, 8, 9, 4, 13, 5, 12, 2, 15, 7, 10, 3, 14, 6, 11]</code></p> \n  <p>One thing we might notice is that adjacent numbers sum to <code>17</code>. More specifically, indices that are 0 and 1 (mod 2) sum to <code>17</code>. Also, indices 0 and 2 (mod 4) sum to <code>9</code>, indices 0 and 4 (mod 8) sum to <code>5</code>, and so on.</p> \n  <p>The pattern in general is: indices <code>0</code> and <code>2**r</code> (mod <code>2**(r+1)</code>) sum to <code>N * 2**-r + 1</code>.</p> \n  <p>If we want to find the next <code>team[i]</code>, then the lowest bit of <code>i</code> will help determine it's lower neighbor. For example, <code>team[12] = team[0b1100]</code> has lower bit <code>w = 4 = 0b100</code>, so <code>12</code> has lower neighbor <code>12 - w = 8</code>, and also those team numbers sum to <code>N / w + 1</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/rHTkiGV4/shared\" frameborder=\"0\" width=\"100%\" height=\"497\" name=\"rHTkiGV4\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. We print each of <script type=\"math/tex; mode=display\">O(N)</script> characters in order.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. </p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 543,
    "article_live": true,
    "article_slug": "diameter-of-binary-tree",
    "title": "Diameter of Binary Tree",
    "title_slug": "diameter-of-binary-tree",
    "content": "<p>\r\nGiven a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the <b>longest</b> path between any two nodes in a tree. This path may or may not pass through the root.\r\n</p>\r\n\r\n<p>\r\n<b>Example:</b><br />\r\nGiven a binary tree <br />\r\n<pre>\r\n          1\r\n         / \\\r\n        2   3\r\n       / \\     \r\n      4   5    \r\n</pre>\r\n</p>\r\n<p>\r\nReturn <b>3</b>, which is the length of the path [4,2,1,3] or [5,2,1,3].\r\n</p>\r\n\r\n<p><b>Note:</b>\r\nThe length of path between two nodes is represented by the number of edges between them.\r\n</p>",
    "tags": "Tree",
    "difficulty": 1,
    "frontend_article_id": 543,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-depth-first-search-accepted\">Approach #1: Depth-First Search [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-depth-first-search-accepted\">Approach #1: Depth-First Search [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Any path can be written as two <em>arrows</em> (in different directions) from some node, where an arrow is a path that starts at some node and only travels down to child nodes.</p> \n  <p>If we knew the maximum length arrows <code>L, R</code> for each child, then the best path touches <code>L + R + 1</code> nodes.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Let's calculate the depth of a node in the usual way: max(depth of node.left, depth of node.right) + 1. While we do, a path \"through\" this node uses 1 + (depth of node.left) + (depth of node.right) nodes. Let's search each node and remember the highest number of nodes used in some path. The desired length is 1 minus this number.</p> \n  <iframe src=\"https://leetcode.com/playground/6ahaRHCG/shared\" frameborder=\"0\" width=\"100%\" height=\"310\" name=\"6ahaRHCG\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. We visit every node once.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the size of our implicit call stack during our depth-first search.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 542,
    "article_live": true,
    "article_slug": "01-matrix",
    "title": "01 Matrix",
    "title_slug": "01-matrix",
    "content": "<p>\r\nGiven a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell.\r\n</p>\r\nThe distance between two adjacent cells is 1.\r\n\r\n<p><b>Example 1: </b><br>\r\nInput:\r\n<pre>\r\n0 0 0\r\n0 1 0\r\n0 0 0\r\n</pre>\r\nOutput:\r\n<pre>\r\n0 0 0\r\n0 1 0\r\n0 0 0\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2: </b><br>\r\nInput:\r\n<pre>\r\n0 0 0\r\n0 1 0\r\n1 1 1\r\n</pre>\r\nOutput:\r\n<pre>\r\n0 0 0\r\n0 1 0\r\n1 2 1\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The number of elements of the given matrix will not exceed 10,000.</li>\r\n<li>There are at least one 0 in the given matrix.</li>\r\n<li>The cells are adjacent in only four directions: up, down, left and right.</li>\r\n</ol>\r\n</p>\r\n",
    "tags": "Depth-first Search, Breadth-first Search",
    "difficulty": 2,
    "frontend_article_id": 542,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute force [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-using-bfs-accepted\">Approach #2 Using BFS [Accepted]</a></li> \n      <li><a href=\"#approach-3-dp-approach-accepted\">Approach #3 DP Approach [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute force [Time Limit Exceeded]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Do what the question says.</p> \n  <p><strong>Algorithm</strong></p> \n  <ul> \n   <li>Initialize <code>dist[i][j]=INT_MAX</code> for all <code>{i,j}</code> cells.</li> \n   <li>Iterate over the matrix.</li> \n   <li>If cell is <code>0</code>, <code>dist[i][j]=0</code>,</li> \n   <li>Else, for each <code>1</code> cell,\n    <ul> \n     <li>Iterate over the entire matrix</li> \n     <li>If the cell is <code>0</code>, calculate its distance from current cell as <code>abs(k-i)+abs(l-j)</code>.</li> \n     <li>If the distance is smaller than the current distance, update it.</li> \n    </ul> </li> \n  </ul> \n  <iframe src=\"https://leetcode.com/playground/WrxDXrW3/shared\" frameborder=\"0\" name=\"WrxDXrW3\" width=\"100%\" height=\"445\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity: <script type=\"math/tex; mode=display\">O((r \\cdot c)^2)</script>. Iterating over the entire matrix for each <code>1</code> in the matrix.</p> </li> \n   <li> <p>Space complexity: <script type=\"math/tex; mode=display\">O(r \\cdot c)</script>. No extra space required than the <code>vector&lt;vector&lt;int&gt; &gt; dist</code></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-using-bfs-accepted\">Approach #2 Using BFS [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p><em>A better brute force</em>: Looking over the entire matrix appears wasteful and hence, we can use Breadth First Search(BFS) to limit the search to the nearest <code>0</code> found for each <code>1</code>. As soon as a <code>0</code> appears during the BFS, we know that the <code>0</code> is nearest, and hence, we move to the next <code>1</code>.</p> \n  <p><em>Think again</em>: But, in this approach, we will only be able to update the distance of one <code>1</code> using one BFS, which could in fact, result in slightly higher complexity than the Approach #1 brute force. But hey,this could be optimised if we start the BFS from <code>0</code>s and thereby, updating the distances of all the <code>1</code>s in the path.</p> \n  <p><strong>Algorithm</strong></p> \n  <ul> \n   <li>For our BFS routine, we keep a queue, <code>q</code> to maintain the queue of cells to be examined next.</li> \n   <li>We start by adding all the cells with <code>0</code>s to <code>q</code>.</li> \n   <li>Intially, distance for each <code>0</code> cell is <code>0</code> and distance for each <code>1</code> is <code>INT_MAX</code>, which is updated during the BFS.</li> \n   <li>Pop the cell from queue, and examine its neighbours. If the new calculated distance for neighbour <code>{i,j}</code> is smaller, we add <code>{i,j}</code> to <code>q</code> and update <code>dist[i][j]</code>.</li> \n  </ul> \n  <iframe src=\"https://leetcode.com/playground/abTJGHUf/shared\" frameborder=\"0\" name=\"abTJGHUf\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity analysis</strong></p> \n  <ul> \n   <li>Time complexity: <script type=\"math/tex; mode=display\">O(r \\cdot c)</script>.</li> \n   <li> <p>Since, the new cells are added to the queue only if their current distance is greater than the calculated distance, cells are not likely to be added multiple times.</p> </li> \n   <li> <p>Space complexity: <script type=\"math/tex; mode=display\">O(r \\cdot c)</script>. Additional <script type=\"math/tex; mode=display\">O(r \\cdot c)</script> for queue than in Approach #1</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-dp-approach-accepted\">Approach #3 DP Approach [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>The distance of a cell from <code>0</code> can be calculated if we know the nearest distance for all the neighbours, in which case the distance is minimum distance of any neightbour + 1. And, instantly, the word come to mind DP!!<br> For each <code>1</code>, the minimum path to <code>0</code> can be in any direction. So, we need to check all the 4 direction. In one iteration from top to bottom, we can check left and top directions, and we need another iteration from bottom to top to check for right and bottom direction.</p> \n  <p><strong>Algorithm</strong></p> \n  <ul> \n   <li>Iterate the matrix from top to bottom-left to right:</li> \n   <li>Update <script type=\"math/tex; mode=display\">\\text{dist}[i][j]=\\min(\\text{dist}[i][j],\\min(\\text{dist}[i][j-1],\\text{dist}[i-1][j])+1)</script> i.e., minimum of the current dist and distance from top or left neighbour +1, that would have been already calculated previously in the current iteration.</li> \n   <li>Now, we need to do the back iteration in the similar manner: from bottom to top-right to left:</li> \n   <li>Update <script type=\"math/tex; mode=display\">\\text{dist}[i][j]=\\min(\\text{dist}[i][j],\\min(\\text{dist}[i][j+1],\\text{dist}[i+1][j])+1)</script> i.e. minimum of current dist and distances calculated from bottom and right neighbours, that would be already available in current iteration.</li> \n  </ul> \n  <iframe src=\"https://leetcode.com/playground/ZLQD7VF7/shared\" frameborder=\"0\" name=\"ZLQD7VF7\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity analysis</strong></p> \n  <ul> \n   <li>Time complexity: <script type=\"math/tex; mode=display\">O(r \\cdot c)</script>. 2 passes of <script type=\"math/tex; mode=display\">r \\cdot c</script> each</li> \n   <li>Space complexity: <script type=\"math/tex; mode=display\">O(r \\cdot c)</script>. No additional space required than <code>dist vector&lt;vector&lt;int&gt; &gt;</code></li> \n  </ul> \n  <hr> \n  <p>Analysis written by <a href=\"https://leetcode.com/abhinavbansal0\">@abhinavbansal0</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 541,
    "article_live": true,
    "article_slug": "reverse-string-ii",
    "title": "Reverse String II",
    "title_slug": "reverse-string-ii",
    "content": "</p>\r\nGiven a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original.\r\n</p>\r\n\r\n<p><b>Example:</b><br />\r\n<pre>\r\n<b>Input:</b> s = \"abcdefg\", k = 2\r\n<b>Output:</b> \"bacdfeg\"\r\n</pre>\r\n</p>\r\n\r\n<b>Restrictions:</b> </b>\r\n<ol>\r\n<li> The string consists of lower English letters only.</li>\r\n<li> Length of the given string and k will in the range [1, 10000]</li>\r\n</ol>",
    "tags": "String",
    "difficulty": 1,
    "frontend_article_id": 541,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-direct-accepted\">Approach #1: Direct [Accepted]</a></li> \n   </ul> \n  </div> \n  <hr> \n  <h4 id=\"approach-1-direct-accepted\">Approach #1: Direct [Accepted]</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>We will reverse each block of <code>2k</code> characters directly.</p> \n  <p>Each block starts at a multiple of <code>2k</code>: for example, <code>0, 2k, 4k, 6k, ...</code>. One thing to be careful about is we may not reverse each block if there aren't enough characters.</p> \n  <p>To reverse a block of characters from <code>i</code> to <code>j</code>, we can swap characters in positions <code>i++</code> and <code>j--</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/2qnQN5xs/shared\" frameborder=\"0\" width=\"100%\" height=\"293\" name=\"2qnQN5xs\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the size of <code>s</code>. We build a helper array, plus reverse about half the characters in <code>s</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the size of <code>a</code>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 540,
    "article_live": false,
    "title": "Single Element in a Sorted Array",
    "title_slug": "single-element-in-a-sorted-array",
    "content": "<p>\r\nGiven a sorted array consisting of only integers where every element appears twice except for one element which appears once. Find this single element that appears only once. \r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [1,1,2,3,3,4,4,8,8]\r\n<b>Output:</b> 2\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> [3,3,7,7,10,11,11]\r\n<b>Output:</b> 10\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\nYour solution should run in O(log n) time and O(1) space.\r\n</p>\r\n",
    "tags": "",
    "difficulty": 2,
    "frontend_article_id": 540
},
{
    "frontend_question_id": 539,
    "article_live": false,
    "title": "Minimum Time Difference",
    "title_slug": "minimum-time-difference",
    "content": "Given a list of 24-hour clock time points in \"Hour:Minutes\" format, find the minimum <b>minutes</b> difference between any two time points in the list. \r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [\"23:59\",\"00:00\"]\r\n<b>Output:</b> 1\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The number of time points in the given list is at least 2 and won't exceed 20000.</li>\r\n<li>The input time is legal and ranges from 00:00 to 23:59.</li>\r\n</ol>\r\n</p>",
    "tags": "String",
    "difficulty": 2,
    "frontend_article_id": 539
},
{
    "frontend_question_id": 538,
    "article_live": true,
    "article_slug": "convert-bst-to-greater-tree",
    "title": "Convert BST to Greater Tree",
    "title_slug": "convert-bst-to-greater-tree",
    "content": "<p>Given a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST.</p>\r\n\r\n<p>\r\n<b>Example:</b>\r\n<pre>\r\n<b>Input:</b> The root of a Binary Search Tree like this:\r\n              5\r\n            /   \\\r\n           2     13\r\n\r\n<b>Output:</b> The root of a Greater Tree like this:\r\n             18\r\n            /   \\\r\n          20     13\r\n</pre>\r\n</p>",
    "tags": "Tree",
    "difficulty": 1,
    "frontend_article_id": 538,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#initial-thoughts\">Initial Thoughts</a></li> \n    <li><a href=\"#approach-1-recursion-accepted\">Approach #1 Recursion [Accepted]</a></li> \n    <li><a href=\"#approach-2-iteration-with-a-stack-accepted\">Approach #2 Iteration with a Stack [Accepted]</a></li> \n    <li><a href=\"#approach-3-reverse-morris-in-order-traversal-accepted\">Approach #3 Reverse Morris In-order Traversal [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"initial-thoughts\">Initial Thoughts</h4> \n  <p>This question asks us to modify an asymptotically linear number of nodes in a given binary search tree, so a very efficient solution will visit each node once. The key to such a solution would be a way to visit nodes in descending order, keeping a sum of all values that we have already visited and adding that sum to the node's values as we traverse the tree. This method for tree traversal is known as a <em>reverse in-order traversal</em>, and allows us to guarantee visitation of each node in the desired order. The basic idea of such a traversal is that before visiting any node in the tree, we must first visit all nodes with greater value. Where are all of these nodes conveniently located? In the right subtree.</p> \n  <h4 id=\"approach-1-recursion-accepted\">Approach #1 Recursion [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>One way to perform a reverse in-order traversal is via recursion. By using the call stack to return to previous nodes, we can easily visit the nodes in reverse order.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>For the recursive approach, we maintain some minor \"global\" state so each recursive call can access and modify the current total sum. Essentially, we ensure that the current node exists, recurse on the right subtree, visit the current node by updating its value and the total sum, and finally recurse on the left subtree. If we know that recursing on <code>root.right</code> properly updates the right subtree and that recursing on <code>root.left</code> properly updates the left subtree, then we are guaranteed to update all nodes with larger values before the current node and all nodes with smaller values after.</p> \n  <iframe src=\"https://leetcode.com/playground/izz2BZVf/shared\" frameborder=\"0\" width=\"100%\" height=\"276\" name=\"izz2BZVf\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script> </p> <p>A binary tree has no cycles by definition, so <code>convertBST</code> gets called on each node no more than once. Other than the recursive calls, <code>convertBST</code> does a constant amount of work, so a linear number of calls to <code>convertBST</code> will run in linear time.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script> </p> <p>Using the prior assertion that <code>convertBST</code> is called a linear number of times, we can also show that the entire algorithm has linear space complexity. Consider the worst case, a tree with only right (or only left) subtrees. The call stack will grow until the end of the longest path is reached, which in this case includes all <script type=\"math/tex; mode=display\">n</script> nodes.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-iteration-with-a-stack-accepted\">Approach #2 Iteration with a Stack [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>If we don't want to use recursion, we can also perform a reverse in-order traversal via iteration and a literal stack to emulate the call stack.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>One way to describe the iterative stack method is in terms of the intuitive recursive solution. First, we initialize an empty stack and set the current node to the root. Then, so long as there are unvisited nodes in the stack or <code>node</code> does not point to <code>null</code>, we push all of the nodes along the path to the rightmost leaf onto the stack. This is equivalent to always processing the right subtree first in the recursive solution, and is crucial for the guarantee of visiting nodes in order of decreasing value. Next, we visit the node on the top of our stack, and consider its left subtree. This is just like visiting the current node before recursing on the left subtree in the recursive solution. Eventually, our stack is empty and <code>node</code> points to the left <code>null</code> child of the tree's minimum value node, so the loop terminates.</p> \n  <iframe src=\"https://leetcode.com/playground/U56ntS8W/shared\" frameborder=\"0\" width=\"100%\" height=\"497\" name=\"U56ntS8W\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script> </p> <p>The key observation is that each node is pushed onto the stack exactly once. I will take for granted the assumption that a node will always be pushed <em>at least</em> once, as the alternative would imply that at least one node is disconnected from the root. Notice that nodes are only pushed onto the stack when they are pointed to by <code>node</code> at the beginning of the outer <code>while</code> loop, or when there is a path to them from such a node by using only <code>right</code> pointers. Then notice that at the end of each iteration of the loop, <code>node</code> points to the left child of a node that has been pushed onto (and subsequently popped from) the stack. Therefore, because the outer <code>while</code> loop always begins with <code>node</code> pointing to <code>None</code>, the root (which is not pointed to by any other node), or a left child of a visited node, we cannot revisit nodes.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script> </p> <p>If we assume that the above logic is sound, the assertion that each node is pushed onto the stack exactly once implies that the stack can contain (at most) <script type=\"math/tex; mode=display\">n</script> nodes. All other parts of the algorithm use constant space, so there is overall a linear memory footprint.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-reverse-morris-in-order-traversal-accepted\">Approach #3 Reverse Morris In-order Traversal [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>There is a clever way to perform an in-order traversal using only linear time and constant space, first described by J. H. Morris in his 1979 paper \"Traversing Binary Trees Simply and Cheaply\". In general, the recursive and iterative stack methods sacrifice linear space for the ability to return to a node after visiting its left subtree. The Morris traversal instead exploits the unused <code>null</code> pointer(s) of the tree's leaves to create a temporary link out of the left subtree, allowing the traversal to be performed using only constant additional memory. To apply it to this problem, we can simply swap all \"left\" and \"right\" references, which will reverse the traversal.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>First, we initialize <code>node</code>, which points to the root. Then, until <code>node</code> points to <code>null</code> (specifically, the left <code>null</code> of the tree's minimum-value node), we repeat the following. First, consider whether the current node has a right subtree. If it does not have a right subtree, then there is no unvisited node with a greater value, so we can visit this node and move into the left subtree. If it does have a right subtree, then there is at least one unvisited node with a greater value, and thus we must visit first go to the right subtree. To do so, we obtain a reference to the in-order successor (the smallest-value node larger than the current) via our helper function <code>getSuccessor</code>. This successor node is the node that must be visited immediately before the current node, so it by definition has a <code>null</code> <code>left</code> pointer (otherwise it would not be the successor). Therefore, when we first find a node's successor, we temporarily link it (via its <code>left</code> pointer) to the node and proceed to the node's right subtree. Then, when we finish visiting the right subtree, the leftmost <code>left</code> pointer in it will be our temporary link that we can use to escape the subtree. After following this link, we have returned to the original node that we previously passed through, but did not visit. This time, when we find that the successor's <code>left</code> pointer loops back to the current node, we know that we have visited the entire right subtree, so we can now erase the temporary link and move into the left subtree.</p> \n  <p align=\"center\"><img alt=\"Reverse Morris Traversal Example\" src=\"../Figures/543/morris.png\"></p> \n  <p>The figure above shows an example of the modified tree during a reverse Morris traversal. Left pointers are illustrated in blue and right pointers in red. Dashed edges indicate temporary links generated at some point during the algorithm (which will be erased before it terminates). Notice that blue edges can be dashed, as we always exploit the empty <code>left</code> pointer of successor nodes. Additionally, notice that every node with a right subtree has a link from its in-order successor.</p> \n  <iframe src=\"https://leetcode.com/playground/9fu9CDg3/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"9fu9CDg3\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script> </p> <p>Although the Morris traversal does slightly more work than the other approaches, it is only by a constant factor. To be specific, if we can show that each edge in the tree is traversed no more than <script type=\"math/tex; mode=display\">k</script> times (for some constant <script type=\"math/tex; mode=display\">k</script>), then the algorithm is shown to have linear time complexity. First, note that <code>getSuccessor</code> is called at most twice per node. On the first invocation, the temporary link back to the node in question is created, and on the second invocation, the temporary link is erased. Then, the algorithm steps into the left subtree with no way to return to the node. Therefore, each edge can only be traversed 3 times: once when we move the <code>node</code> pointer, and once for each of the two calls to <code>getSuccessor</code>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script> </p> <p>Because we only manipulate pointers that already exist, the Morris traversal uses constant space.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/emptyset/\">@emptyset</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 537,
    "article_live": true,
    "article_slug": "complex-number-multiplication",
    "title": "Complex Number Multiplication",
    "title_slug": "complex-number-multiplication",
    "content": "<p>\r\nGiven two strings representing two <a href = \"https://en.wikipedia.org/wiki/Complex_number\">complex numbers</a>.</p>\r\n\r\n<p>\r\nYou need to return a string representing their multiplication. Note i<sup>2</sup> = -1 according to the definition.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \"1+1i\", \"1+1i\"\r\n<b>Output:</b> \"0+2i\"\r\n<b>Explanation:</b> (1 + i) * (1 + i) = 1 + i<sup>2</sup> + 2 * i = 2i, and you need convert it to the form of 0+2i.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> \"1+-1i\", \"1+-1i\"\r\n<b>Output:</b> \"0+-2i\"\r\n<b>Explanation:</b> (1 - i) * (1 - i) = 1 + i<sup>2</sup> - 2 * i = -2i, and you need convert it to the form of 0+-2i.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\n<ol>\r\n<li>The input strings will not have extra blank.</li>\r\n<li>The input strings will be given in the form of <b>a+bi</b>, where the integer <b>a</b> and <b>b</b> will both belong to the range of [-100, 100]. And <b>the output should be also in this form</b>.</li>\r\n</ol>\r\n</p>",
    "tags": "Math, String",
    "difficulty": 2,
    "frontend_article_id": 537,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-simple-solutionaccepted\">Approach #1 Simple Solution[Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-simple-solutionaccepted\">Approach #1 Simple Solution[Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Multiplication of two complex numbers can be done as:</p> \n  <p> <script type=\"math/tex; mode=display\">\n(a+ib) \\times (x+iy)=ax+i^2by+i(bx+ay)=ax-by+i(bx+ay)\n</script> </p> \n  <p>We simply split up the real and the imaginary parts of the given complex strings based on the '+' and the 'i' symbols. We store the real parts of the two strings <script type=\"math/tex; mode=display\">a</script> and <script type=\"math/tex; mode=display\">b</script> as <script type=\"math/tex; mode=display\">x[0]</script> and <script type=\"math/tex; mode=display\">y[0]</script> respectively and the imaginary parts as <script type=\"math/tex; mode=display\">x[1]</script> and <script type=\"math/tex; mode=display\">y[1]</script> respectively. Then, we multiply the real and the imaginary parts as required after converting the extracted parts into integers. Then, we again form the return string in the required format and return the result.</p> \n  <iframe src=\"https://leetcode.com/playground/jgLSUzDc/shared\" frameborder=\"0\" name=\"jgLSUzDc\" width=\"100%\" height=\"309\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Here splitting takes constant time as length of the string is very small <script type=\"math/tex; mode=display\">(<20)</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant extra space is used.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 536,
    "article_live": false,
    "title": "Construct Binary Tree from String",
    "title_slug": "construct-binary-tree-from-string",
    "tags": "String, Tree",
    "difficulty": 2,
    "frontend_article_id": 536
},
{
    "frontend_question_id": 535,
    "article_live": true,
    "article_slug": "encode-and-decode-tinyurl",
    "title": "Encode and Decode TinyURL",
    "title_slug": "encode-and-decode-tinyurl",
    "content": "<blockquote>Note: This is a companion problem to the <a href=\"https://leetcode.com/discuss/interview-question/system-design/\" target=\"_blank\">System Design</a> problem: <a href=\"https://leetcode.com/discuss/interview-question/124658/Design-a-URL-Shortener-(-TinyURL-)-System/\" target=\"_blank\">Design TinyURL</a>.</blockquote>\r\n\r\n<p>TinyURL is a URL shortening service where you enter a URL such as <code>https://leetcode.com/problems/design-tinyurl</code> and it returns a short URL such as <code>http://tinyurl.com/4e9iAk</code>.</p>\r\n\r\n<p>Design the <code>encode</code> and <code>decode</code> methods for the TinyURL service. There is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL.</p>\r\n",
    "tags": "Hash Table, Math",
    "difficulty": 2,
    "frontend_article_id": 535,
    "article_content": ""
},
{
    "frontend_question_id": 533,
    "article_live": false,
    "title": "Lonely Pixel II",
    "title_slug": "lonely-pixel-ii",
    "tags": "Array, Depth-first Search",
    "difficulty": 2,
    "frontend_article_id": 533
},
{
    "frontend_question_id": 532,
    "article_live": false,
    "title": "K-diff Pairs in an Array",
    "title_slug": "k-diff-pairs-in-an-array",
    "content": "<p>\r\nGiven an array of integers and an integer <b>k</b>, you need to find the number of <b>unique</b> k-diff pairs in the array. Here a <b>k-diff</b> pair is defined as an integer pair (i, j), where <b>i</b> and <b>j</b> are both numbers in the array and their <a href = \"https://en.wikipedia.org/wiki/Absolute_difference\">absolute difference</a> is <b>k</b>.\r\n</p>\r\n\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [3, 1, 4, 1, 5], k = 2\r\n<b>Output:</b> 2\r\n<b>Explanation: </b>There are two 2-diff pairs in the array, (1, 3) and (3, 5).</br>Although we have two 1s in the input, we should only return the number of <b>unique</b> pairs.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b>[1, 2, 3, 4, 5], k = 1\r\n<b>Output: </b>4\r\n<b>Explanation:</b> There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 3:</b><br />\r\n<pre>\r\n<b>Input: </b>[1, 3, 1, 5, 4], k = 0\r\n<b>Output: </b>1\r\n<b>Explanation:</b> There is one 0-diff pair in the array, (1, 1).\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The pairs (i, j) and (j, i) count as the same pair.</li>\r\n<li>The length of the array won't exceed 10,000.</li>\r\n<li>All the integers in the given input belong to the range: [-1e7, 1e7].</li>\r\n</ol>\r\n</p>",
    "tags": "Array, Two Pointers",
    "difficulty": 1,
    "frontend_article_id": 532
},
{
    "frontend_question_id": 531,
    "article_live": false,
    "title": "Lonely Pixel I",
    "title_slug": "lonely-pixel-i",
    "tags": "Array, Depth-first Search",
    "difficulty": 2,
    "frontend_article_id": 531
},
{
    "frontend_question_id": 530,
    "article_live": false,
    "title": "Minimum Absolute Difference in BST",
    "title_slug": "minimum-absolute-difference-in-bst",
    "content": "<p>Given a binary search tree with non-negative values, find the minimum <a href=\"https://en.wikipedia.org/wiki/Absolute_difference\">absolute difference</a> between values of any two nodes.</p>\r\n\r\n<p><b>Example:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b>\r\n\r\n   1\r\n    \\\r\n     3\r\n    /\r\n   2\r\n\r\n<b>Output:</b>\r\n1\r\n\r\n<b>Explanation:</b>\r\nThe minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3).\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Note:</b> There are at least two nodes in this BST.</p>\r\n",
    "tags": "Binary Search Tree",
    "difficulty": 1,
    "frontend_article_id": 530
},
{
    "frontend_question_id": 529,
    "article_live": false,
    "title": "Minesweeper",
    "title_slug": "minesweeper",
    "content": "<p>Let&#39;s play the minesweeper game (<a href=\"https://en.wikipedia.org/wiki/Minesweeper_(video_game)\">Wikipedia</a>, <a href=\"http://minesweeperonline.com\">online game</a>)!</p>\r\n\r\n<p>You are given a 2D char matrix representing the game board. <b>&#39;M&#39;</b> represents an <b>unrevealed</b> mine, <b>&#39;E&#39;</b> represents an <b>unrevealed</b> empty square, <b>&#39;B&#39;</b> represents a <b>revealed</b> blank square that has no adjacent (above, below, left, right, and all 4 diagonals) mines, <b>digit</b> (&#39;1&#39; to &#39;8&#39;) represents how many mines are adjacent to this <b>revealed</b> square, and finally <b>&#39;X&#39;</b> represents a <b>revealed</b> mine.</p>\r\n\r\n<p>Now given the next click position (row and column indices) among all the <b>unrevealed</b> squares (&#39;M&#39; or &#39;E&#39;), return the board after revealing this position according to the following rules:</p>\r\n\r\n<ol>\r\n\t<li>If a mine (&#39;M&#39;) is revealed, then the game is over - change it to <b>&#39;X&#39;</b>.</li>\r\n\t<li>If an empty square (&#39;E&#39;) with <b>no adjacent mines</b> is revealed, then change it to revealed blank (&#39;B&#39;) and all of its adjacent <b>unrevealed</b> squares should be revealed recursively.</li>\r\n\t<li>If an empty square (&#39;E&#39;) with <b>at least one adjacent mine</b> is revealed, then change it to a digit (&#39;1&#39; to &#39;8&#39;) representing the number of adjacent mines.</li>\r\n\t<li>Return the board when no more squares will be revealed.</li>\r\n</ol>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> \r\n\r\n[[&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;],\r\n [&#39;E&#39;, &#39;E&#39;, &#39;M&#39;, &#39;E&#39;, &#39;E&#39;],\r\n [&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;],\r\n [&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;]]\r\n\r\nClick : [3,0]\r\n\r\n<b>Output:</b> \r\n\r\n[[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],\r\n [&#39;B&#39;, &#39;1&#39;, &#39;M&#39;, &#39;1&#39;, &#39;B&#39;],\r\n [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],\r\n [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]\r\n\r\n<b>Explanation:</b>\r\n<img src=\"https://assets.leetcode.com/uploads/2018/10/12/minesweeper_example_1.png\" style=\"width: 100%; max-width: 400px\" />\r\n</pre>\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> \r\n\r\n[[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],\r\n [&#39;B&#39;, &#39;1&#39;, &#39;M&#39;, &#39;1&#39;, &#39;B&#39;],\r\n [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],\r\n [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]\r\n\r\nClick : [1,2]\r\n\r\n<b>Output:</b> \r\n\r\n[[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],\r\n [&#39;B&#39;, &#39;1&#39;, &#39;X&#39;, &#39;1&#39;, &#39;B&#39;],\r\n [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],\r\n [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]\r\n\r\n<b>Explanation:</b>\r\n<img src=\"https://assets.leetcode.com/uploads/2018/10/12/minesweeper_example_2.png\" style=\"width: 100%; max-width: 400px\" />\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Note:</b></p>\r\n\r\n<ol>\r\n\t<li>The range of the input matrix&#39;s height and width is [1,50].</li>\r\n\t<li>The click position will only be an unrevealed square (&#39;M&#39; or &#39;E&#39;), which also means the input board contains at least one clickable square.</li>\r\n\t<li>The input board won&#39;t be a stage when game is over (some mines have been revealed).</li>\r\n\t<li>For simplicity, not mentioned rules should be ignored in this problem. For example, you <b>don&#39;t</b> need to reveal all the unrevealed mines when the game is over, consider any cases that you will win the game or flag any squares.</li>\r\n</ol>\r\n",
    "tags": "Depth-first Search, Breadth-first Search",
    "difficulty": 2,
    "frontend_article_id": 529
},
{
    "frontend_question_id": 527,
    "article_live": true,
    "article_slug": "word-abbreviation",
    "title": "Word Abbreviation",
    "title_slug": "word-abbreviation",
    "tags": "String, Sort",
    "difficulty": 3,
    "frontend_article_id": 527,
    "article_content": ""
},
{
    "frontend_question_id": 526,
    "article_live": true,
    "article_slug": "beautiful-arrangement",
    "title": "Beautiful Arrangement",
    "title_slug": "beautiful-arrangement",
    "content": "<p>\r\nSuppose you have <b>N</b> integers from 1 to N. We define a beautiful arrangement as an array that is constructed by these <b>N</b> numbers successfully if one of the following is true for the i<sub>th</sub> position (1 <= i <= N) in this array:\r\n<ol>\r\n<li>The number at the i<sub>th</sub> position is divisible by <b>i</b>.</li>\r\n<li><b>i</b> is divisible by the number at the i<sub>th</sub> position.</li>\r\n</ol>\r\n</p>\r\n\r\n<p>\r\nNow given N, how many beautiful arrangements can you construct?\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> 2\r\n<b>Output:</b> 2\r\n<b>Explanation:</b> \r\n<br/>The first beautiful arrangement is [1, 2]:\r\n<br/>Number at the 1st position (i=1) is 1, and 1 is divisible by i (i=1).\r\n<br/>Number at the 2nd position (i=2) is 2, and 2 is divisible by i (i=2).\r\n<br/>The second beautiful arrangement is [2, 1]:\r\n<br/>Number at the 1st position (i=1) is 2, and 2 is divisible by i (i=1).\r\n<br/>Number at the 2nd position (i=2) is 1, and i (i=2) is divisible by 1.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li><b>N</b> is a positive integer and will not exceed 15.</li>\r\n</ol>\r\n</p>",
    "tags": "Backtracking",
    "difficulty": 2,
    "frontend_article_id": 526,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-better-brute-force-accepted\">Approach #2 Better Brute Force [Accepted]</a></li> \n      <li><a href=\"#approach-3-backtracking-accepted\">Approach #3 Backtracking [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In the brute force method, we can find out all the arrays that can be formed using the numbers from 1 to N(by creating every possible permutation of the given elements). Then, we iterate over all the elements of every permutation generated and check for the required conditions of divisibility.</p> \n  <p>In order to generate all the possible pairings, we make use of a function <code>permute(nums, current_index)</code>. This function creates all the possible permutations of the elements of the given array.</p> \n  <p>To do so, <code>permute</code> takes the index of the current element <script type=\"math/tex; mode=display\">current_index</script> as one of the arguments. Then, it swaps the current element with every other element in the array, lying towards its right, so as to generate a new ordering of the array elements. After the swapping has been done, it makes another call to permute but this time with the index of the next element in the array. While returning back, we reverse the swapping done in the current function call.</p> \n  <p>Thus, when we reach the end of the array, a new ordering of the array's elements is generated. The following animation depicts the process of generating the permutations.</p> \n  <p>!?!../Documents/561_Array.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/PqSksc2S/shared\" frameborder=\"0\" name=\"PqSksc2S\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n!)</script>. A total of <script type=\"math/tex; mode=display\">n!</script> permutations will be generated for an array of length <script type=\"math/tex; mode=display\">n</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The depth of the recursion tree can go upto <script type=\"math/tex; mode=display\">n</script>. <script type=\"math/tex; mode=display\">nums</script> array of size <script type=\"math/tex; mode=display\">n</script> is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-better-brute-force-accepted\">Approach #2 Better Brute Force [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In the brute force approach, we create the full array for every permutation and then check the array for the given divisibilty conditions. But this method can be optimized to a great extent. To do so, we can keep checking the elements while being added to the permutation array at every step for the divisibility condition and can stop creating it any further as soon as we find out the element just added to the permutation violates the divisiblity condition. </p> \n  <iframe src=\"https://leetcode.com/playground/WQVaxmVy/shared\" frameborder=\"0\" name=\"WQVaxmVy\" width=\"100%\" height=\"513\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(k)</script>. <script type=\"math/tex; mode=display\">k</script> refers to the number of valid permutations.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The depth of recursion tree can go upto <script type=\"math/tex; mode=display\">n</script>. Further, <script type=\"math/tex; mode=display\">nums</script> array of size <script type=\"math/tex; mode=display\">n</script> is used, where, <script type=\"math/tex; mode=display\">n</script> is the given number.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-backtracking-accepted\">Approach #3 Backtracking [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>The idea behind this approach is simple. We try to create all the permutations of numbers from 1 to N. We can fix one number at a particular position and check for the divisibility criteria of that number at the particular position. But, we need to keep a track of the numbers which have already been considered earlier so that they aren't reconsidered while generating the permutations. If the current number doesn't satisfy the divisibility criteria, we can leave all the permutations that can be generated with that number at the particular position. This helps to prune the search space of the permutations to a great extent. We do so by trying to place each of the numbers at each position.</p> \n  <p>We make use of a visited array of size <script type=\"math/tex; mode=display\">N</script>. Here, <script type=\"math/tex; mode=display\">visited[i]</script> refers to the <script type=\"math/tex; mode=display\">i^{th}</script> number being already placed/not placed in the array being formed till now(True indicates that the number has already been placed).</p> \n  <p>We make use of a <code>calculate</code> function, which puts all the numbers pending numbers from 1 to N(i.e. not placed till now in the array), indicated by a <script type=\"math/tex; mode=display\">False</script> at the corresponding <script type=\"math/tex; mode=display\">visited[i]</script> position, and tries to create all the permutations with those numbers starting from the <script type=\"math/tex; mode=display\">pos</script> index onwards in the current array. While putting the <script type=\"math/tex; mode=display\">pos^{th}</script> number, we check whether the <script type=\"math/tex; mode=display\">i^{th}</script> number satisfies the divisibility criteria on the go i.e. we continue forward with creating the permutations with the number <script type=\"math/tex; mode=display\">i</script> at the <script type=\"math/tex; mode=display\">pos^{th}</script> position only if the number <script type=\"math/tex; mode=display\">i</script> and <script type=\"math/tex; mode=display\">pos</script> satisfy the given criteria. Otherwise, we continue with putting the next numbers at the same position and keep on generating the permutations.</p> \n  <p>Look at the animation below for a better understanding of the methodology:</p> \n  <p>!?!../Documents/526_Beautiful.json:1000,563!?!</p> \n  <p>Below code is inspired by <a href=\"https://leetcode.com/shawngao\">@shawngao</a></p> \n  <iframe src=\"https://leetcode.com/playground/cBVwozT4/shared\" frameborder=\"0\" name=\"cBVwozT4\" width=\"100%\" height=\"377\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(k)</script>. <script type=\"math/tex; mode=display\">k</script> refers to the number of valid permutations.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. <script type=\"math/tex; mode=display\">visited</script> array of size <script type=\"math/tex; mode=display\">n</script> is used. The depth of recursion tree will also go upto <script type=\"math/tex; mode=display\">n</script>. Here, <script type=\"math/tex; mode=display\">n</script> refers to the given integer <script type=\"math/tex; mode=display\">n</script>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 525,
    "article_live": true,
    "article_slug": "contiguous-array",
    "title": "Contiguous Array",
    "title_slug": "contiguous-array",
    "content": "<p>Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1. </p>\r\n\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [0,1]\r\n<b>Output:</b> 2\r\n<b>Explanation:</b> [0, 1] is the longest contiguous subarray with equal number of 0 and 1.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> [0,1,0]\r\n<b>Output:</b> 2\r\n<b>Explanation:</b> [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\nThe length of the given binary array will not exceed 50,000.\r\n</p>",
    "tags": "Hash Table",
    "difficulty": 2,
    "frontend_article_id": 525,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-using-extra-array-accepted\">Approach #2 Using Extra Array [Accepted]</a></li> \n      <li><a href=\"#approach-3-using-hashmap-accepted\">Approach #3 Using HashMap [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>The brute force approach is really simple. We consider every possible subarray within the given array and count the number of zeros and ones in each subarray. Then, we find out the maximum size subarray with equal no. of zeros and ones out of them.</p> \n  <iframe src=\"https://leetcode.com/playground/sPZqbexo/shared\" frameborder=\"0\" name=\"sPZqbexo\" width=\"100%\" height=\"428\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^2)</script>. We consider every possible subarray by traversing over the complete array for every start point possible.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Only two variables <script type=\"math/tex; mode=display\">zeroes</script> and <script type=\"math/tex; mode=display\">ones</script> are required.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-using-extra-array-accepted\">Approach #2 Using Extra Array [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In this approach, we make use of a <script type=\"math/tex; mode=display\">count</script> variable, which is used to store the relative number of ones and zeros encountered so far while traversing the array. The <script type=\"math/tex; mode=display\">count</script> variable is incremented by one for every <script type=\"math/tex; mode=display\">\\text{1}</script> encountered and the same is decremented by one for every <script type=\"math/tex; mode=display\">\\text{0}</script> encountered.</p> \n  <p>We start traversing the array from the beginning. If at any moment, the <script type=\"math/tex; mode=display\">count</script> becomes zero, it implies that we've encountered equal number of zeros and ones from the beginning till the current index of the array(<script type=\"math/tex; mode=display\">i</script>). Not only this, another point to be noted is that if we encounter the same <script type=\"math/tex; mode=display\">count</script> twice while traversing the array, it means that the number of zeros and ones are equal between the indices corresponding to the equal <script type=\"math/tex; mode=display\">count</script> values. The following figure illustrates the observation for the sequence <code>[0 0 1 0 0 0 1 1]</code>:</p> \n  <p><img alt=\"Contiguous_Array\" src=\"../Figures/535_Contiguous_Array.PNG\"></p> \n  <p>In the above figure, the subarrays between (A,B), (B,C) and (A,C) (lying between indices corresponing to <script type=\"math/tex; mode=display\">count = 2</script>) have equal number of zeros and ones.</p> \n  <p>Another point to be noted is that the largest subarray is the one between the points (A, C). Thus, if we keep a track of the indices corresponding to the same <script type=\"math/tex; mode=display\">count</script> values that lie farthest apart, we can determine the size of the largest subarray with equal no. of zeros and ones easily.</p> \n  <p>Now, the <script type=\"math/tex; mode=display\">count</script> values can range between <script type=\"math/tex; mode=display\">\\text{-n}</script> to <script type=\"math/tex; mode=display\">\\text{+n}</script>, with the extreme points corresponding to the complete array being filled with all 0's and all 1's respectively. Thus, we make use of an array <script type=\"math/tex; mode=display\">arr</script>(of size <script type=\"math/tex; mode=display\">\\text{2n+1}</script>to keep a track of the various <script type=\"math/tex; mode=display\">count</script>'s encountered so far. We make an entry containing the current element's index (<script type=\"math/tex; mode=display\">i</script>) in the <script type=\"math/tex; mode=display\">arr</script> for a new <script type=\"math/tex; mode=display\">count</script> encountered everytime. Whenever, we come across the same <script type=\"math/tex; mode=display\">count</script> value later while traversing the array, we determine the length of the subarray lying between the indices corresponding to the same <script type=\"math/tex; mode=display\">count</script> values.</p> \n  <iframe src=\"https://leetcode.com/playground/Nvw6WnPN/shared\" frameborder=\"0\" name=\"Nvw6WnPN\" width=\"100%\" height=\"411\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The complete array is traversed only once.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. <script type=\"math/tex; mode=display\">arr</script> array of size <script type=\"math/tex; mode=display\">\\text{2n+1}</script> is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-using-hashmap-accepted\">Approach #3 Using HashMap [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>This approach relies on the same premise as the previous approach. But, we need not use an array of size <script type=\"math/tex; mode=display\">\\text{2n+1}</script>, since it isn't necessary that we'll encounter all the <script type=\"math/tex; mode=display\">count</script> values possible. Thus, we make use of a HashMap <script type=\"math/tex; mode=display\">map</script> to store the entries in the form of <script type=\"math/tex; mode=display\">(index, count)</script>. We make an entry for a <script type=\"math/tex; mode=display\">count</script> in the <script type=\"math/tex; mode=display\">map</script> whenever the <script type=\"math/tex; mode=display\">count</script> is encountered first, and later on use the correspoding index to find the length of the largest subarray with equal no. of zeros and ones when the same <script type=\"math/tex; mode=display\">count</script> is encountered again.</p> \n  <p>The following animation depicts the process: \n   <!--<img alt=\"Contiguous_Array\" src=\"../Figures/525_Contiguous_Array.gif\" />--> !?!../Documents/525_Contiguous_Array.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/nG5CTUD8/shared\" frameborder=\"0\" name=\"nG5CTUD8\" width=\"100%\" height=\"360\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The entire array is traversed only once.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Maximum size of the HashMap <script type=\"math/tex; mode=display\">map</script> will be <script type=\"math/tex; mode=display\">\\text{n}</script>, if all the elements are either 1 or 0.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 524,
    "article_live": true,
    "article_slug": "longest-word-in-dictionary-through-deletion",
    "title": "Longest Word in Dictionary through Deleting",
    "title_slug": "longest-word-in-dictionary-through-deleting",
    "content": "<p>\r\nGiven a string and a string dictionary, find the longest string in the dictionary that can be formed by deleting some characters of the given string. If there are more than one possible results, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.\r\n</p>\r\n<p><b>Example 1:</b><br>\r\n<pre>\r\n<b>Input:</b>\r\ns = \"abpcplea\", d = [\"ale\",\"apple\",\"monkey\",\"plea\"]\r\n\r\n<b>Output:</b> \r\n\"apple\"\r\n</pre>\r\n</p>\r\n\r\n</p>\r\n<p><b>Example 2:</b><br>\r\n<pre>\r\n<b>Input:</b>\r\ns = \"abpcplea\", d = [\"a\",\"b\",\"c\"]\r\n\r\n<b>Output:</b> \r\n\"a\"\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>All the strings in the input will only contain lower-case letters.</li>\r\n<li>The size of the dictionary won't exceed 1,000.</li>\r\n<li>The length of all the strings in the input won't exceed 1,000.</li>\r\n</ol>\r\n</p>",
    "tags": "Two Pointers, Sort",
    "difficulty": 2,
    "frontend_article_id": 524,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#summary\">Summary</a></li> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-iterative-brute-force-time-limit-exceeded\">Approach #2 Iterative Brute Force [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-3-sorting-and-checking-subsequence-accepted\">Approach #3 Sorting and checking Subsequence [Accepted]</a></li> \n      <li><a href=\"#approach-4-without-sorting-accepted\">Approach #4 Without Sorting [Accepted]:</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"summary\">Summary</h2> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>The idea behind this approach is as follows. We create a list of all the possible strings that can be formed by deleting one or more characters from the given string <script type=\"math/tex; mode=display\">s</script>. In order to do so, we make use of a recursive function <code>generate(s, str, i, l)</code> which creates a string by adding and by removing the current character(<script type=\"math/tex; mode=display\">i^{th}</script>) from the string <script type=\"math/tex; mode=display\">s</script> to the string <script type=\"math/tex; mode=display\">str</script> formed till the index <script type=\"math/tex; mode=display\">i</script>. Thus, it adds the <script type=\"math/tex; mode=display\">i^{th}</script> character to <script type=\"math/tex; mode=display\">str</script> and calls itself as <code>generate(s, str + s.charAt(i), i + 1, l)</code>. It also omits the <script type=\"math/tex; mode=display\">i^{th}</script> character to <script type=\"math/tex; mode=display\">str</script> and calls itself as <code>generate(s, str, i + 1, l)</code>.</p> \n  <p>Thus, at the end the list <script type=\"math/tex; mode=display\">l</script> contains all the required strings that can be formed using <script type=\"math/tex; mode=display\">s</script>. Then, we look for the strings formed in <script type=\"math/tex; mode=display\">l</script> into the dictionary available to see if a match is available. Further, in case of a match, we check for the length of the matched string to maximize the length and we also take care to consider the lexicographically smallest string in case of length match as well.</p> \n  <iframe src=\"https://leetcode.com/playground/stinLqjy/shared\" frameborder=\"0\" name=\"stinLqjy\" width=\"100%\" height=\"445\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(2^n)</script>. <code>generate</code> calls itself <script type=\"math/tex; mode=display\">2^n</script> times. Here, <script type=\"math/tex; mode=display\">n</script> refers to the length of string <script type=\"math/tex; mode=display\">s</script>. </p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(2^n)</script>. List <script type=\"math/tex; mode=display\">l</script> contains <script type=\"math/tex; mode=display\">2^n</script> strings.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-iterative-brute-force-time-limit-exceeded\">Approach #2 Iterative Brute Force [Time Limit Exceeded]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Instead of using recursive <code>generate</code> to create the list of possible strings that can be formed using <script type=\"math/tex; mode=display\">s</script> by performing delete operations, we can also do the same process iteratively. To do so, we use the concept of binary number generation. </p> \n  <p>We can treat the given string <script type=\"math/tex; mode=display\">s</script> along with a binary represenation corresponding to the indices of <script type=\"math/tex; mode=display\">s</script>. The rule is that the character at the position <script type=\"math/tex; mode=display\">i</script> has to be added to the newly formed string <script type=\"math/tex; mode=display\">str</script> only if there is a boolean 1 at the corresponding index in the binary representation of a number currently considered.</p> \n  <p>We know a total of <script type=\"math/tex; mode=display\">2^n</script> such binary numbers are possible if there are <script type=\"math/tex; mode=display\">n</script> positions to be filled(<script type=\"math/tex; mode=display\">n</script> also corresponds to the number of characters in <script type=\"math/tex; mode=display\">s</script>). Thus, we consider all the numbers from <script type=\"math/tex; mode=display\">0</script> to <script type=\"math/tex; mode=display\">2^n</script> in their binary representation in a serial order and generate all the strings possible using the above rule.</p> \n  <p>The figure below shows an example of the strings generated for the given string <script type=\"math/tex; mode=display\">s</script>:\"sea\".</p> \n  <p><img alt=\"Longest_Word\" src=\"../Figures/524_Longest_Word_Binary.PNG\"></p> \n  <p>A problem with this method is that the maximum length of the string can be 32 only, since we make use of an integer and perform the shift operations on it to generate the binary numbers.</p> \n  <iframe src=\"https://leetcode.com/playground/cmWsEFGG/shared\" frameborder=\"0\" name=\"cmWsEFGG\" width=\"100%\" height=\"411\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(2^n)</script>. <script type=\"math/tex; mode=display\">2^n</script> strings are generated. </p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(2^n)</script>. List <script type=\"math/tex; mode=display\">l</script> contains <script type=\"math/tex; mode=display\">2^n</script> strings.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-sorting-and-checking-subsequence-accepted\">Approach #3 Sorting and checking Subsequence [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>The matching condition in the given problem requires that we need to consider the matching string in the dictionary with the longest length and in case of same length, the string which is smallest lexicographically. To ease the searching process, we can sort the given dictionary's strings based on the same criteria, such that the more favorable string appears earlier in the sorted dictionary.</p> \n  <p>Now, instead of performing the deletions in <script type=\"math/tex; mode=display\">s</script>, we can directly check if any of the words given in the dictionary(say <script type=\"math/tex; mode=display\">x</script>) is a subsequence of the given string <script type=\"math/tex; mode=display\">s</script>, starting from the beginning of the dictionary. This is because, if <script type=\"math/tex; mode=display\">x</script> is a subsequence of <script type=\"math/tex; mode=display\">s</script>, we can obtain <script type=\"math/tex; mode=display\">x</script> by performing delete operations on <script type=\"math/tex; mode=display\">s</script>. </p> \n  <p>If <script type=\"math/tex; mode=display\">x</script> is a subsequence of <script type=\"math/tex; mode=display\">s</script> every character of <script type=\"math/tex; mode=display\">x</script> will be present in <script type=\"math/tex; mode=display\">s</script>. The following figure shows the way the subsequence check is done for one example:</p> \n  <p>!?!../Documents/524_Longest_Word.json:1000,563!?!</p> \n  <p>As soon as we find any such <script type=\"math/tex; mode=display\">x</script>, we can stop the search immediately since we've already processed <script type=\"math/tex; mode=display\">d</script> to our advantage.</p> \n  <iframe src=\"https://leetcode.com/playground/bzaQxoMF/shared\" frameborder=\"0\" name=\"bzaQxoMF\" width=\"100%\" height=\"428\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n*x*logn + n*x)</script>. Here <script type=\"math/tex; mode=display\">n</script> refers to the number of strings in list <script type=\"math/tex; mode=display\">d</script> and <script type=\"math/tex; mode=display\">x</script> refers to average string length. Sorting takes <script type=\"math/tex; mode=display\">O(nlogn)</script> and <code>isSubsequence</code> takes <script type=\"math/tex; mode=display\">O(x)</script> to check whether a string is a subsequence of another string or not. </p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(logn)</script>. Sorting takes <script type=\"math/tex; mode=display\">O(logn)</script> space in average case.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-4-without-sorting-accepted\">Approach #4 Without Sorting [Accepted]:</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Since sorting the dictionary could lead to a huge amount of extra effort, we can skip the sorting and directly look for the strings <script type=\"math/tex; mode=display\">x</script> in the unsorted dictionary <script type=\"math/tex; mode=display\">d</script> such that <script type=\"math/tex; mode=display\">x</script> is a subsequence in <script type=\"math/tex; mode=display\">s</script>. If such a string <script type=\"math/tex; mode=display\">x</script> is found, we compare it with the other matching strings found till now based on the required length and lexicographic criteria. Thus, after considering every string in <script type=\"math/tex; mode=display\">d</script>, we can obtain the required result.</p> \n  <iframe src=\"https://leetcode.com/playground/qsSjNJwD/shared\" frameborder=\"0\" name=\"qsSjNJwD\" width=\"100%\" height=\"377\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n*x)</script>. One iteration over all strings is required. Here <script type=\"math/tex; mode=display\">n</script> refers to the number of strings in list <script type=\"math/tex; mode=display\">d</script> and <script type=\"math/tex; mode=display\">x</script> refers to average string length.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(x)</script>. <script type=\"math/tex; mode=display\">max\\_str</script> variable is used.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 523,
    "article_live": true,
    "article_slug": "continous-subarray-sum",
    "title": "Continuous Subarray Sum",
    "title_slug": "continuous-subarray-sum",
    "content": "<p>\r\nGiven a list of <b>non-negative</b> numbers and a target <b>integer</b> k, write a function to check if the array has a continuous subarray of size at least 2 that sums up to the multiple of <b>k</b>, that is, sums up to n*k where n is also an <b>integer</b>.\r\n</p>\r\n\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [23, 2, 4, 6, 7],  k=6\r\n<b>Output:</b> True\r\n<b>Explanation:</b> Because [2, 4] is a continuous subarray of size 2 and sums up to 6.\r\n</pre>\r\n</p>\r\n\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> [23, 2, 6, 4, 7],  k=6\r\n<b>Output:</b> True\r\n<b>Explanation:</b> Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The length of the array won't exceed 10,000.</li>\r\n<li>You may assume the sum of all the numbers is in the range of a signed 32-bit integer.</li>\r\n</ol>\r\n</p>",
    "tags": "Math, Dynamic Programming",
    "difficulty": 2,
    "frontend_article_id": 523,
    "article_content": ""
},
{
    "frontend_question_id": 522,
    "article_live": true,
    "article_slug": "longest-uncommon-subsequence-ii",
    "title": "Longest Uncommon Subsequence II",
    "title_slug": "longest-uncommon-subsequence-ii",
    "content": "<p>\r\nGiven a list of strings, you need to find the longest uncommon subsequence among them. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be <b>any</b> subsequence of the other strings.\r\n</p>\r\n\r\n<p>\r\nA <b>subsequence</b> is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string.\r\n</p>\r\n\r\n<p>\r\nThe input will be a list of strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn't exist, return -1.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \"aba\", \"cdc\", \"eae\"\r\n<b>Output:</b> 3\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\n<ol>\r\n<li>All the given strings' lengths will not exceed 10.</li>\r\n<li>The length of the given list will be in the range of [2, 50].</li>\r\n</ol>\r\n</p>",
    "tags": "String",
    "difficulty": 2,
    "frontend_article_id": 522,
    "article_content": ""
},
{
    "frontend_question_id": 521,
    "article_live": true,
    "article_slug": "longest-uncommon-subsequence-i",
    "title": "Longest Uncommon Subsequence I ",
    "title_slug": "longest-uncommon-subsequence-i",
    "content": "<p>\r\nGiven a group of two strings, you need to find the longest uncommon subsequence of this group of two strings.\r\nThe longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be <b>any</b> subsequence of the other strings.\r\n</p>\r\n\r\n<p>\r\nA <b>subsequence</b> is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string.\r\n</p>\r\n\r\n<p>\r\nThe input will be two strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn't exist, return -1.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \"aba\", \"cdc\"\r\n<b>Output:</b> 3\r\n<b>Explanation:</b> The longest uncommon subsequence is \"aba\" (or \"cdc\"), <br/>because \"aba\" is a subsequence of \"aba\", <br/>but not a subsequence of any other strings in the group of two strings. \r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\n<ol>\r\n<li>Both strings' lengths will not exceed 100.</li>\r\n<li>Only letters from a ~ z will appear in input strings. </li>\r\n</ol>\r\n</p>",
    "tags": "String",
    "difficulty": 1,
    "frontend_article_id": 521,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-simple-solutionaccepted\">Approach #2 Simple Solution[Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</h4> \n  <p>In the brute force approach we will generate all the possible <script type=\"math/tex; mode=display\">2^n</script> subsequences of both the strings and store their number of occurences in a hashmap. Longest subsequence whose frequency is equal to <script type=\"math/tex; mode=display\">1</script> will be the required subsequence. And, if it is not found we will return <script type=\"math/tex; mode=display\">-1</script>.</p> \n  <iframe src=\"https://leetcode.com/playground/tSXGPoqU/shared\" frameborder=\"0\" name=\"tSXGPoqU\" width=\"100%\" height=\"479\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time complexity : <script type=\"math/tex; mode=display\">O(2^x+2^y)</script>. where <script type=\"math/tex; mode=display\">x</script> and <script type=\"math/tex; mode=display\">y</script> are the lengths of strings <script type=\"math/tex; mode=display\">a</script> and <script type=\"math/tex; mode=display\">b</script> respectively . Number of subsequences will be <script type=\"math/tex; mode=display\">2^x+2^y</script>.</li> \n   <li>Space complexity : <script type=\"math/tex; mode=display\">O(2^x+2^y)</script>. <script type=\"math/tex; mode=display\">2^x+2^y</script> subsequences will be generated.</li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-simple-solutionaccepted\">Approach #2 Simple Solution[Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Simple analysis of this problem can lead to an easy solution.</p> \n  <p>These three cases are possible with string <script type=\"math/tex; mode=display\">a</script> and <script type=\"math/tex; mode=display\">b</script>:-</p> \n  <ul> \n   <li> <p> <script type=\"math/tex; mode=display\">a=b</script>. If both the strings are identical, it is obvious that no subsequence will be uncommon. Hence, return -1.</p> </li> \n   <li> <p> <script type=\"math/tex; mode=display\">length(a)=length(b)</script> and <script type=\"math/tex; mode=display\">a \\ne b</script>. Example: <script type=\"math/tex; mode=display\">abc</script> and <script type=\"math/tex; mode=display\">abd</script>. In this case we can consider any string i.e. <script type=\"math/tex; mode=display\">abc</script> or <script type=\"math/tex; mode=display\">abd</script> as a required subsequence, as out of these two strings one string will never be a subsequence of other string. Hence, return <script type=\"math/tex; mode=display\">length(a)</script> or <script type=\"math/tex; mode=display\">length(b)</script>.</p> </li> \n   <li> <p> <script type=\"math/tex; mode=display\">length(a) \\ne length(b)</script>. Example <script type=\"math/tex; mode=display\">abcd</script> and <script type=\"math/tex; mode=display\">abc</script>. In this case we can consider bigger string as a required subsequence because bigger string can't be a subsequence of smaller string. Hence, return <script type=\"math/tex; mode=display\">max(length(a),length(b))</script>.</p> </li> \n  </ul> \n  <iframe src=\"https://leetcode.com/playground/YdNcPgTE/shared\" frameborder=\"0\" name=\"YdNcPgTE\" width=\"100%\" height=\"173\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(min(x,y))</script>. where <script type=\"math/tex; mode=display\">x</script> and <script type=\"math/tex; mode=display\">y</script> are the lengths of strings <script type=\"math/tex; mode=display\">a</script> and <script type=\"math/tex; mode=display\">b</script> respectively. Here equals method will take <script type=\"math/tex; mode=display\">min(x,y)</script> time .</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. No extra space required.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 520,
    "article_live": false,
    "title": "Detect Capital",
    "title_slug": "detect-capital",
    "content": "<p>\r\nGiven a word, you need to judge whether the usage of capitals in it is right or not.\r\n</p>\r\n\r\n<p>\r\nWe define the usage of capitals in a word to be right when one of the following cases holds:\r\n<ol>\r\n<li>All letters in this word are capitals, like \"USA\".</li>\r\n<li>All letters in this word are not capitals, like \"leetcode\".</li>\r\n<li>Only the first letter in this word is capital if it has more than one letter, like \"Google\".</li>\r\n</ol>\r\nOtherwise, we define that this word doesn't use capitals in a right way.\r\n</p>\r\n\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \"USA\"\r\n<b>Output:</b> True\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> \"FlaG\"\r\n<b>Output:</b> False\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\nThe input will be a non-empty word consisting of uppercase and lowercase latin letters.\r\n</p>",
    "tags": "String",
    "difficulty": 1,
    "frontend_article_id": 520
},
{
    "frontend_question_id": 518,
    "article_live": false,
    "title": "Coin Change 2",
    "title_slug": "coin-change-2",
    "content": "<p>You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin.</p>\r\n\r\n<p><b>Note:</b> You can assume that</p>\r\n\r\n<ul>\r\n\t<li>0 &lt;= amount &lt;= 5000</li>\r\n\t<li>1 &lt;= coin &lt;= 5000</li>\r\n\t<li>the number of coins is less than 500</li>\r\n\t<li>the answer is guaranteed to fit into signed 32-bit integer</li>\r\n</ul>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> amount = 5, coins = [1, 2, 5]\r\n<b>Output:</b> 4\r\n<b>Explanation:</b> there are four ways to make up the amount:\r\n5=5\r\n5=2+2+1\r\n5=2+1+1+1\r\n5=1+1+1+1+1\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> amount = 3, coins = [2]\r\n<b>Output:</b> 0\r\n<b>Explanation:</b> the amount of 3 cannot be made up just with coins of 2.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Example 3:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> amount = 10, coins = [10] \r\n<b>Output:</b> 1\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n",
    "tags": "",
    "difficulty": 2,
    "frontend_article_id": 518
},
{
    "frontend_question_id": 517,
    "article_live": false,
    "title": "Super Washing Machines",
    "title_slug": "super-washing-machines",
    "content": "<p>You have <b>n</b> super washing machines on a line. Initially, each washing machine has some dresses or is empty. \r\n</p>\r\n\r\n<p>For each <b>move</b>, you could choose <b>any m</b> (1 &le; m &le; n) washing machines, and pass <b>one dress</b> of each washing machine to one of its adjacent washing machines <b> at the same time </b>.  </p>\r\n\r\n<p>Given an integer array representing the number of dresses in each washing machine from left to right on the line, you should find the <b>minimum number of moves</b> to make all the washing machines have the same number of dresses. If it is not possible to do it, return -1.</p>\r\n\r\n<p><b>Example1</b>\r\n<pre>\r\n<b>Input:</b> [1,0,5]\r\n\r\n<b>Output:</b> 3\r\n\r\n<b>Explanation:</b> \r\n1st move:    1     0 <-- 5    =>    1     1     4\r\n2nd move:    1 <-- 1 <-- 4    =>    2     1     3    \r\n3rd move:    2     1 <-- 3    =>    2     2     2   \r\n</pre>\r\n\r\n<p><b>Example2</b>\r\n<pre>\r\n<b>Input:</b> [0,3,0]\r\n\r\n<b>Output:</b> 2\r\n\r\n<b>Explanation:</b> \r\n1st move:    0 <-- 3     0    =>    1     2     0    \r\n2nd move:    1     2 --> 0    =>    1     1     1     \r\n</pre>\r\n\r\n<p><b>Example3</b>\r\n<pre>\r\n<b>Input:</b> [0,2,0]\r\n\r\n<b>Output:</b> -1\r\n\r\n<b>Explanation:</b> \r\nIt's impossible to make all the three washing machines have the same number of dresses. \r\n</pre>\r\n\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The range of n is [1, 10000].</li>\r\n<li>The range of dresses number in a super washing machine is [0, 1e5].</li>\r\n</ol>\r\n</p>",
    "tags": "Math, Dynamic Programming",
    "difficulty": 3,
    "frontend_article_id": 517
},
{
    "frontend_question_id": 516,
    "article_live": false,
    "title": "Longest Palindromic Subsequence",
    "title_slug": "longest-palindromic-subsequence",
    "content": "<p>\r\nGiven a string s, find the longest palindromic subsequence's length in s. You may assume that the maximum length of s is 1000.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br>\r\nInput: \r\n<pre>\r\n\"bbbab\"\r\n</pre>\r\nOutput: \r\n<pre>\r\n4\r\n</pre>\r\nOne possible longest palindromic subsequence is \"bbbb\".\r\n</p>\r\n\r\n<p><b>Example 2:</b><br>\r\nInput:\r\n<pre>\r\n\"cbbd\"\r\n</pre>\r\nOutput:\r\n<pre>\r\n2\r\n</pre>\r\nOne possible longest palindromic subsequence is \"bb\".\r\n</p>",
    "tags": "Dynamic Programming",
    "difficulty": 2,
    "frontend_article_id": 516
},
{
    "frontend_question_id": 515,
    "article_live": false,
    "title": "Find Largest Value in Each Tree Row",
    "title_slug": "find-largest-value-in-each-tree-row",
    "content": "<p>You need to find the largest value in each row of a binary tree.</p>\r\n\r\n<p><b>Example:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\n\r\n          1\r\n         / \\\r\n        3   2\r\n       / \\   \\  \r\n      5   3   9 \r\n\r\n<b>Output:</b> [1, 3, 9]\r\n</pre>\r\n</p>\r\n",
    "tags": "Tree, Depth-first Search, Breadth-first Search",
    "difficulty": 2,
    "frontend_article_id": 515
},
{
    "frontend_question_id": 514,
    "article_live": false,
    "title": "Freedom Trail",
    "title_slug": "freedom-trail",
    "content": "<p>In the video game Fallout 4, the quest &quot;Road to Freedom&quot; requires players to reach a metal dial called the &quot;Freedom Trail Ring&quot;, and use the dial to spell a specific keyword in order to open the door.</p>\r\n\r\n<p>Given a string <b>ring</b>, which represents the code engraved on the outer ring and another string <b>key</b>, which represents the keyword needs to be spelled. You need to find the <b>minimum</b> number of steps in order to spell all the characters in the keyword.</p>\r\n\r\n<p>Initially, the first character of the <b>ring</b> is aligned at 12:00 direction. You need to spell all the characters in the string <b>key</b> one by one by rotating the ring clockwise or anticlockwise to make each character of the string <b>key</b> aligned at 12:00 direction and then by pressing the center button.</p>\r\n\r\n<p>At the stage of rotating the ring to spell the key character <b>key[i]</b>:</p>\r\n\r\n<ol>\r\n\t<li>You can rotate the <b>ring</b> clockwise or anticlockwise <b>one place</b>, which counts as 1 step. The final purpose of the rotation is to align one of the string <b>ring&#39;s</b> characters at the 12:00 direction, where this character must equal to the character <b>key[i]</b>.</li>\r\n\t<li>If the character <b>key[i]</b> has been aligned at the 12:00 direction, you need to press the center button to spell, which also counts as 1 step. After the pressing, you could begin to spell the next character in the key (next stage), otherwise, you&#39;ve finished all the spelling.</li>\r\n</ol>\r\n\r\n<p><b>Example:</b></p>\r\n\r\n<center><img src=\"https://assets.leetcode.com/uploads/2018/10/22/ring.jpg\" style=\"width: 26%;\" /></center>\r\n&nbsp;\r\n\r\n<pre>\r\n<b>Input:</b> ring = &quot;godding&quot;, key = &quot;gd&quot;\r\n<b>Output:</b> 4\r\n<b>Explanation:</b>\r\nFor the first key character &#39;g&#39;, since it is already in place, we just need 1 step to spell this character. \r\nFor the second key character &#39;d&#39;, we need to rotate the ring &quot;godding&quot; anticlockwise by two steps to make it become &quot;ddinggo&quot;.\r\nAlso, we need 1 more step for spelling.\r\nSo the final output is 4.\r\n</pre>\r\n\r\n<p><b>Note:</b></p>\r\n\r\n<ol>\r\n\t<li>Length of both ring and <b>key</b> will be in range 1 to 100.</li>\r\n\t<li>There are only lowercase letters in both strings and might be some duplcate characters in both strings.</li>\r\n\t<li>It&#39;s guaranteed that string <b>key</b> could always be spelled by rotating the string <b>ring</b>.</li>\r\n</ol>\r\n",
    "tags": "Divide and Conquer, Dynamic Programming, Depth-first Search",
    "difficulty": 3,
    "frontend_article_id": 514
},
{
    "frontend_question_id": 513,
    "article_live": false,
    "title": "Find Bottom Left Tree Value",
    "title_slug": "find-bottom-left-tree-value",
    "content": "<p>\r\nGiven a binary tree, find the leftmost value in the last row of the tree. \r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\nInput:\r\n\r\n    2\r\n   / \\\r\n  1   3\r\n\r\nOutput:\r\n1\r\n</pre>\r\n</p>\r\n\r\n<p> <b> Example 2: </b><br>\r\n<pre>\r\nInput:\r\n\r\n        1\r\n       / \\\r\n      2   3\r\n     /   / \\\r\n    4   5   6\r\n       /\r\n      7\r\n\r\nOutput:\r\n7\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\nYou may assume the tree (i.e., the given root node) is not <b>NULL</b>.\r\n</p>",
    "tags": "Tree, Depth-first Search, Breadth-first Search",
    "difficulty": 2,
    "frontend_article_id": 513
},
{
    "frontend_question_id": 508,
    "article_live": false,
    "title": "Most Frequent Subtree Sum",
    "title_slug": "most-frequent-subtree-sum",
    "content": "<p>\r\nGiven the root of a tree, you are asked to find the most frequent subtree sum. The subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself). So what is the most frequent subtree sum value? If there is a tie, return all the values with the highest frequency in any order.\r\n</p>\r\n\r\n<p><b>Examples 1</b><br>\r\nInput:\r\n<pre>\r\n  5\r\n /  \\\r\n2   -3\r\n</pre>\r\nreturn [2, -3, 4], since all the values happen only once, return all of them in any order.\r\n</p>\r\n\r\n<p><b>Examples 2</b><br>\r\nInput:\r\n<pre>\r\n  5\r\n /  \\\r\n2   -5\r\n</pre>\r\nreturn [2], since 2 happens twice, however -5 only occur once.\r\n</p>\r\n\r\n<p><b>Note:</b>\r\nYou may assume the sum of values in any subtree is in the range of 32-bit signed integer.\r\n</p>",
    "tags": "Hash Table, Tree",
    "difficulty": 2,
    "frontend_article_id": 508
},
{
    "frontend_question_id": 507,
    "article_live": true,
    "article_slug": "perfect-number",
    "title": "Perfect Number",
    "title_slug": "perfect-number",
    "content": "<p>We define the Perfect Number is a <b>positive</b> integer that is equal to the sum of all its <b>positive</b> divisors except itself. \r\n</p>\r\nNow, given an <b>integer</b> n, write a function that returns true when it is a perfect number and false when it is not.\r\n</p>\r\n\r\n<p><b>Example:</b><br />\r\n<pre>\r\n<b>Input:</b> 28\r\n<b>Output:</b> True\r\n<b>Explanation:</b> 28 = 1 + 2 + 4 + 7 + 14\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\nThe input number <b>n</b> will not exceed 100,000,000. (1e8)\r\n</p>",
    "tags": "Math",
    "difficulty": 1,
    "frontend_article_id": 507,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-better-brute-force-time-limit-exceeded\">Approach #2 Better Brute Force [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-3-optimal-solution-accepted\">Approach #3 Optimal Solution [Accepted]</a></li> \n      <li><a href=\"#approach-4-euclid-euler-theorem-accepted\">Approach #4 Euclid-Euler Theorem [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In brute force approach, we consider every possible number to be a divisor of the given number <script type=\"math/tex; mode=display\">num</script>, by iterating over all the numbers lesser than <script type=\"math/tex; mode=display\">num</script>. Then, we add up all the factors to check if the given number satisfies the Perfect Number property. This approach obviously fails if the number <script type=\"math/tex; mode=display\">num</script> is very large.</p> \n  <iframe src=\"https://leetcode.com/playground/6Nzf7w9h/shared\" frameborder=\"0\" name=\"6Nzf7w9h\" width=\"100%\" height=\"343\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. We iterate over all the numbers lesser than <script type=\"math/tex; mode=display\">n</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant extra space is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-better-brute-force-time-limit-exceeded\">Approach #2 Better Brute Force [Time Limit Exceeded]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>We can little optimize the brute force by breaking the loop when the value of <script type=\"math/tex; mode=display\">sum</script> increase the value of <script type=\"math/tex; mode=display\">num</script>. In that case, we can directly return <script type=\"math/tex; mode=display\">false</script>.</p> \n  <iframe src=\"https://leetcode.com/playground/bGGFxpmt/shared\" frameborder=\"0\" name=\"bGGFxpmt\" width=\"100%\" height=\"377\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. In worst case, we iterate over all the numbers lesser than <script type=\"math/tex; mode=display\">n</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant extra space is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-optimal-solution-accepted\">Approach #3 Optimal Solution [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In this method, instead of iterating over all the integers to find the factors of <script type=\"math/tex; mode=display\">num</script>, we only iterate upto the <script type=\"math/tex; mode=display\">\\sqrt{n}</script>. The reasoning behind this can be understood as follows.</p> \n  <p>Consider the given number <script type=\"math/tex; mode=display\">num</script> which can have <script type=\"math/tex; mode=display\">m</script> distinct factors, namely <script type=\"math/tex; mode=display\">n_1, n_2,..., n_m</script>. Now, since the number <script type=\"math/tex; mode=display\">num</script> is divisible by <script type=\"math/tex; mode=display\">n_i</script>, it is also divisible by <script type=\"math/tex; mode=display\">n_j=num/n_1</script> i.e. <script type=\"math/tex; mode=display\">n_i*n_j=num</script>. Also, the largest number in such a pair can only be up to <script type=\"math/tex; mode=display\">\\sqrt{num}</script> (because <script type=\"math/tex; mode=display\">\\sqrt{num} \\times \\sqrt{num}=num</script>). Thus, we can get a significant reduction in the run-time by iterating only upto <script type=\"math/tex; mode=display\">\\sqrt{num}</script> and considering such <script type=\"math/tex; mode=display\">n_i</script>'s and <script type=\"math/tex; mode=display\">n_j</script>'s in a single pass directly.</p> \n  <p>Further, if <script type=\"math/tex; mode=display\">\\sqrt{num}</script> is also a factor, we have to consider the factor only once while checking for the perfect number property.</p> \n  <p>We sum up all such factors and check if the given number is a Perfect Number or not. Another point to be observed is that while considering 1 as such a factor, <script type=\"math/tex; mode=display\">num</script> will also be considered as the other factor. Thus, we need to subtract <script type=\"math/tex; mode=display\">num</script> from the <script type=\"math/tex; mode=display\">sum</script>.</p> \n  <iframe src=\"https://leetcode.com/playground/ZpHuGfHj/shared\" frameborder=\"0\" name=\"ZpHuGfHj\" width=\"100%\" height=\"377\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time complexity : <script type=\"math/tex; mode=display\">O(\\sqrt{n})</script>. We iterate only over the range <script type=\"math/tex; mode=display\">1 < i &leq; \\sqrt{num}</script>.</li> \n   <li>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant extra space is used.</li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-4-euclid-euler-theorem-accepted\">Approach #4 Euclid-Euler Theorem [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Euclid proved that <script type=\"math/tex; mode=display\">2^{p−1}(2^p − 1)</script> is an even perfect number whenever <script type=\"math/tex; mode=display\">2^p − 1</script> is prime, where <script type=\"math/tex; mode=display\">p</script> is prime.</p> \n  <p>For example, the first four perfect numbers are generated by the formula <script type=\"math/tex; mode=display\">2^{p−1}(2^p − 1)</script>, with <script type=\"math/tex; mode=display\">p</script> a prime number, as follows:</p> \n  <div class=\"codehilite\">\n   <pre><span></span>for p = 2:   21(22 − 1) = 6\nfor p = 3:   22(23 − 1) = 28\nfor p = 5:   24(25 − 1) = 496\nfor p = 7:   26(27 − 1) = 8128.\n</pre>\n  </div> \n  <p>Prime numbers of the form <script type=\"math/tex; mode=display\">2^p − 1</script> are known as Mersenne primes. For <script type=\"math/tex; mode=display\">2^p − 1</script> to be prime, it is necessary that <script type=\"math/tex; mode=display\">p</script> itself be prime. However, not all numbers of the form <script type=\"math/tex; mode=display\">2^p − 1</script> with a prime <script type=\"math/tex; mode=display\">p</script> are prime; for example, <script type=\"math/tex; mode=display\">2^{11} − 1 = 2047 = 23 × 89</script> is not a prime number.</p> \n  <p>You can see that for small value of <script type=\"math/tex; mode=display\">p</script>, its related perfect number goes very high. So, we need to evaluate perfect numbers for some primes <script type=\"math/tex; mode=display\">(2, 3, 5, 7, 13, 17, 19, 31)</script> only, as for bigger prime its perfect number will not fit in 64 bits.</p> \n  <iframe src=\"https://leetcode.com/playground/kBfJ6TtU/shared\" frameborder=\"0\" name=\"kBfJ6TtU\" width=\"100%\" height=\"292\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(\\log{n})</script>. Number of primes will be in order <script type=\"math/tex; mode=display\">\\log{num}</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(\\log{n})</script>. Space used to store primes.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 506,
    "article_live": false,
    "title": "Relative Ranks",
    "title_slug": "relative-ranks",
    "content": "<p>\r\nGiven scores of <b>N</b> athletes, find their relative ranks and the people with the top three highest scores, who will be awarded medals: \"Gold Medal\", \"Silver Medal\" and \"Bronze Medal\".</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [5, 4, 3, 2, 1]\r\n<b>Output:</b> [\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\", \"4\", \"5\"]\r\n<b>Explanation:</b> The first three athletes got the top three highest scores, so they got \"Gold Medal\", \"Silver Medal\" and \"Bronze Medal\". <br/>For the left two athletes, you just need to output their relative ranks according to their scores.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>N is a positive integer and won't exceed 10,000.</li>\r\n<li>All the scores of athletes are guaranteed to be unique.</li>\r\n</ol>\r\n</p>\r\n",
    "tags": "",
    "difficulty": 1,
    "frontend_article_id": 506
},
{
    "frontend_question_id": 505,
    "article_live": true,
    "article_slug": "the-maze-ii",
    "title": "The Maze II",
    "title_slug": "the-maze-ii",
    "tags": "Depth-first Search, Breadth-first Search",
    "difficulty": 2,
    "frontend_article_id": 505,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-depth-first-search-accepted\">Approach #1 Depth First Search [Accepted]</a></li> \n      <li><a href=\"#approach-2-using-breadth-first-search-accepted\">Approach #2 Using Breadth First Search [Accepted]</a></li> \n      <li><a href=\"#approach-3-using-dijkstra-algorithm-accepted\">Approach #3 Using Dijkstra Algorithm [Accepted]</a></li> \n      <li><a href=\"#approach-4-using-dijkstra-algorithm-and-priority-queueaccepted\">Approach #4 Using Dijkstra Algorithm and Priority Queue[Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-depth-first-search-accepted\">Approach #1 Depth First Search [Accepted]</h4> \n  <p>We can view the given search space in the form of a tree. The root node of the tree represents the starting position. Four different routes are possible from each position i.e. left, right, up or down. These four options can be represented by 4 branches of each node in the given tree. Thus, the new node reached from the root traversing over the branch represents the new position occupied by the ball after choosing the corresponding direction of travel.</p> \n  <p><img alt=\"Maze_Tree\" src=\"../Figures/490_Maze_Tree.PNG\"></p> \n  <p>In order to do this traversal, one of the simplest schemes is to undergo depth first search. We make use of a recursive function <code>dfs</code> for this. From every current position, we try to go as deep as possible into the levels of a tree taking a particular branch traversal direction as possible. When one of the deepest levels is exhausted, we continue the process by reaching the next deepest levels of the tree. In order to travel in the various directions from the current position, we make use of a <script type=\"math/tex; mode=display\">dirs</script> array. <script type=\"math/tex; mode=display\">dirs</script> is an array with 4 elements, where each of the elements represents a single step of a one-dimensional movement. For travelling in a particular direction, we keep on adding the appropriate <script type=\"math/tex; mode=display\">dirs</script> element in the current position till the ball hits a boundary or a wall.</p> \n  <p>We start with the given <script type=\"math/tex; mode=display\">start</script> position, and try to explore these directions represented by the <script type=\"math/tex; mode=display\">dirs</script> array one by one. For every element <script type=\"math/tex; mode=display\">dir</script> of the <script type=\"math/tex; mode=display\">dirs</script> chosen for the current travelling direction, we determine how far can the ball travel in this direction prior to hitting a wall or a boundary. We keep a track of the number of steps using <script type=\"math/tex; mode=display\">count</script> variable. </p> \n  <p>Apart from this, we also make use of a 2-D <script type=\"math/tex; mode=display\">distance</script> array. <script type=\"math/tex; mode=display\">distance[i][j]</script> represents the minimum number of steps required to reach the positon <script type=\"math/tex; mode=display\">(i, j)</script> starting from the <script type=\"math/tex; mode=display\">start</script> position. This array is initialized with largest integer values in the beginning. </p> \n  <p>When we reach any position next to a boundary or a wall during the traversal in a particular direction, as discussed earlier, we keep a track of the number of steps taken in the last direction in <script type=\"math/tex; mode=display\">count</script> variable. Suppose, we reach the position <script type=\"math/tex; mode=display\">(i,j)</script> starting from the last position <script type=\"math/tex; mode=display\">(k,l)</script>. Now, for this position, we need to determine the minimum number of steps taken to reach this position starting from the <script type=\"math/tex; mode=display\">start</script> position. For this, we check if the current path takes lesser steps to reach <script type=\"math/tex; mode=display\">(i,j)</script> than any other previous path taken to reach the same position i.e. we check if <script type=\"math/tex; mode=display\">distance[k][l] + count</script> is lesser than <script type=\"math/tex; mode=display\">distance[i][j]</script>. If not, we continue the process of traversal from the position <script type=\"math/tex; mode=display\">(k,l)</script> in the next direction.</p> \n  <p>If <script type=\"math/tex; mode=display\">distance[k][l] + count</script> is lesser than <script type=\"math/tex; mode=display\">distance[i][j]</script>, we can reach the position <script type=\"math/tex; mode=display\">(i,j)</script> from the current route in lesser number of steps. Thus, we need to update the value of <script type=\"math/tex; mode=display\">distance[i][j]</script> as <script type=\"math/tex; mode=display\">distance[k][l] + count</script>. Further, now we need to try to reach the destination, <script type=\"math/tex; mode=display\">dest</script>, from the end position <script type=\"math/tex; mode=display\">(i,j)</script>, since this could lead to a shorter path to <script type=\"math/tex; mode=display\">dest</script>. Thus, we again call the same function <code>dfs</code> but with the position <script type=\"math/tex; mode=display\">(i,j)</script> acting as the current position. </p> \n  <p>After this, we try to explore the routes possible by choosing all the other directions of travel from the current position <script type=\"math/tex; mode=display\">(k,l)</script> as well.</p> \n  <p>At the end, the entry in distance array corresponding to the destination, <script type=\"math/tex; mode=display\">dest</script>'s coordinates gives the required minimum distance to reach the destination. If the destination can't be reached, the corresponding entry will contain <script type=\"math/tex; mode=display\">\\text{Integer.MAX_VALUE}</script>.</p> \n  <p>The following animation depicts the process.</p> \n  <p>!?!../Documents/505_Maze2_DFS.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/9KoQFAmz/shared\" frameborder=\"0\" name=\"9KoQFAmz\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(m*n*\\text{max}(m,n))</script>. Complete traversal of maze will be done in the worst case. Here, <script type=\"math/tex; mode=display\">m</script> and <script type=\"math/tex; mode=display\">n</script> refers to the number of rows and columns of the maze. Further, for every current node chosen, we can travel upto a maximum depth of <script type=\"math/tex; mode=display\">\\text{max}(m,n)</script> in any direction.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(mn)</script>. <script type=\"math/tex; mode=display\">distance</script> array of size <script type=\"math/tex; mode=display\">m*n</script> is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-using-breadth-first-search-accepted\">Approach #2 Using Breadth First Search [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Instead of making use of Depth First Search for exploring the search space, we can make use of Breadth First Search as well. In this, instead of exploring the search space on a depth basis, we traverse the search space(tree) on a level by level basis i.e. we explore all the new positions that can be reached starting from the current position first, before moving onto the next positions that can be reached from these new positions. </p> \n  <p>In order to make a traversal in any direction, we again make use of <script type=\"math/tex; mode=display\">dirs</script> array as in the DFS approach. Again, whenever we make a traversal in any direction, we keep a track of the number of steps taken while moving in this direction in <script type=\"math/tex; mode=display\">count</script> variable as done in the last approach. We also make use of <script type=\"math/tex; mode=display\">distance</script> array initialized with very large values in the beginning. <script type=\"math/tex; mode=display\">distance[i][j]</script> again represents the minimum number of steps required to reach the position <script type=\"math/tex; mode=display\">(i,j)</script> from the <script type=\"math/tex; mode=display\">start</script> position. </p> \n  <p>This approach differs from the last approach only in the way the search space is explored. In order to reach the new positions in a Breadth First Search order, we make use of a <script type=\"math/tex; mode=display\">queue</script>, which contains the new positions to be explored in the future. We start from the current position <script type=\"math/tex; mode=display\">(k,l)</script>, try to traverse in a particular direction, obtain the corresponding <script type=\"math/tex; mode=display\">count</script> for that direction, reaching an end position of <script type=\"math/tex; mode=display\">(i,j)</script> just near the boundary or a wall. If the position <script type=\"math/tex; mode=display\">(i,j)</script> can be reached in a lesser number of steps from the current route than any other previous route checked, indicated by <script type=\"math/tex; mode=display\">distance[k][l] + count < distance[i][j]</script>, we need to update <script type=\"math/tex; mode=display\">distance[i][j]</script> as <script type=\"math/tex; mode=display\">distance[k][l] + count</script>. </p> \n  <p>After this, we add the new position obtained, <script type=\"math/tex; mode=display\">(i,j)</script> to the back of a <script type=\"math/tex; mode=display\">queue</script>, so that the various paths possible from this new position will be explored later on when all the directions possible from the current position <script type=\"math/tex; mode=display\">(k,l)</script> have been explored. After exploring all the directions from the current position, we remove an element from the front of the <script type=\"math/tex; mode=display\">queue</script> and continue checking the routes possible through all the directions now taking the new position(obtained from the <script type=\"math/tex; mode=display\">queue</script>) as the current position. </p> \n  <p>Again, the entry in distance array corresponding to the destination, <script type=\"math/tex; mode=display\">dest</script>'s coordinates gives the required minimum distance to reach the destination. If the destination can't be reached, the corresponding entry will contain <script type=\"math/tex; mode=display\">\\text{Integer.MAX_VALUE}</script>.</p> \n  <iframe src=\"https://leetcode.com/playground/58PgnMeA/shared\" frameborder=\"0\" name=\"58PgnMeA\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(m*n*max(m,n))</script>. Time complexity : <script type=\"math/tex; mode=display\">O(m*n*\\text{max}(m,n))</script>. Complete traversal of maze will be done in the worst case. Here, <script type=\"math/tex; mode=display\">m</script> and <script type=\"math/tex; mode=display\">n</script> refers to the number of rows and columns of the maze. Further, for every current node chosen, we can travel upto a maximum depth of <script type=\"math/tex; mode=display\">\\text{max}(m,n)</script> in any direction.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(mn)</script>. <script type=\"math/tex; mode=display\">queue</script> size can grow upto <script type=\"math/tex; mode=display\">m*n</script> in the worst case.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-using-dijkstra-algorithm-accepted\">Approach #3 Using Dijkstra Algorithm [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Before we look into this approach, we take a quick overview of Dijkstra's Algorithm. </p> \n  <p>Dijkstra's Algorithm is a very famous graph algorithm, which is used to find the shortest path from any <script type=\"math/tex; mode=display\">start</script> node to any <script type=\"math/tex; mode=display\">destination</script> node in the given weighted graph(the edges of the graph represent the distance between the nodes). </p> \n  <p>The algorithm consists of the following steps:</p> \n  <ol> \n   <li> <p>Assign a tentative distance value to every node: set it to zero for our <script type=\"math/tex; mode=display\">start</script> node and to infinity for all other nodes.</p> </li> \n   <li> <p>Set the <script type=\"math/tex; mode=display\">start</script> node as <script type=\"math/tex; mode=display\">current</script> node. Mark it as visited.</p> </li> \n   <li> <p>For the <script type=\"math/tex; mode=display\">current</script> node, consider all of its neighbors and calculate their tentative distances. Compare the newly calculated tentative distance to the current assigned value and assign the smaller one to all the neighbors. For example, if the current node A is marked with a distance of 6, and the edge connecting it with a neighbor B has length 2, then the distance to B (through A) will be 6 + 2 = 8. If B was previously marked with a distance greater than 8 then change it to 8. Otherwise, keep the current value.</p> </li> \n   <li> <p>When we are done considering all of the neighbors of the current node, mark the <script type=\"math/tex; mode=display\">current</script> node as visited. A visited node will never be checked again.</p> </li> \n   <li> <p>If the <script type=\"math/tex; mode=display\">destination</script> node has been marked visited or if the smallest tentative distance among all the nodes left is infinity(indicating that the <script type=\"math/tex; mode=display\">destination</script> can't be reached), then stop. The algorithm has finished.</p> </li> \n   <li> <p>Otherwise, select the unvisited node that is marked with the smallest tentative distance, set it as the new <script type=\"math/tex; mode=display\">current</script> node, and go back to step 3.</p> </li> \n  </ol> \n  <p>The working of this algorithm can be understood by taking two simple examples. Consider the first set of nodes as shown below. </p> \n  <p><img alt=\"Dijkstra_Graph\" src=\"../Figures/505_Maze2_1.PNG\"></p> \n  <p>Suppose that the node <script type=\"math/tex; mode=display\">b</script> is at a shorter distance from the <script type=\"math/tex; mode=display\">start</script> node <script type=\"math/tex; mode=display\">a</script> as compared to <script type=\"math/tex; mode=display\">c</script>, but the distance from <script type=\"math/tex; mode=display\">a</script> to the <script type=\"math/tex; mode=display\">destination</script> node, <script type=\"math/tex; mode=display\">e</script>, is shorter through the node <script type=\"math/tex; mode=display\">c</script> itself. In this case, we need to check if the Dijkstra's algorithm works correctly, since the node <script type=\"math/tex; mode=display\">b</script> is considered first while selecting the nodes being at a shorter distance from <script type=\"math/tex; mode=display\">a</script>. Let's look into this.</p> \n  <ol> \n   <li> <p>Firstly, we choose <script type=\"math/tex; mode=display\">a</script> as the <script type=\"math/tex; mode=display\">start</script> node, mark it as visited and update the <script type=\"math/tex; mode=display\">distance_b</script> and <script type=\"math/tex; mode=display\">distance_c</script> values. Here, <script type=\"math/tex; mode=display\">distance_i</script> represents the distance of node <script type=\"math/tex; mode=display\">i</script> from the <script type=\"math/tex; mode=display\">start</script> node.</p> </li> \n   <li> <p>Since <script type=\"math/tex; mode=display\">distance_b < distance_c</script>, <script type=\"math/tex; mode=display\">b</script> is chosen as the next node for calculating the distances. We mark <script type=\"math/tex; mode=display\">b</script> as visited. Now, we update the <script type=\"math/tex; mode=display\">distance_e</script> value as <script type=\"math/tex; mode=display\">distance_b + weight_{be}</script>. </p> </li> \n   <li> <p>Now, <script type=\"math/tex; mode=display\">c</script> is obviously the next node to be chosen as per the conditions of the assumptions taken above. (For path to <script type=\"math/tex; mode=display\">e</script> through <script type=\"math/tex; mode=display\">c</script> to be shorter than path to <script type=\"math/tex; mode=display\">e</script> through <script type=\"math/tex; mode=display\">c</script>, <script type=\"math/tex; mode=display\">distance_c < distance_b + weight_{be}</script>. From <script type=\"math/tex; mode=display\">c</script>, we determine the distance to node <script type=\"math/tex; mode=display\">e</script>. Since <script type=\"math/tex; mode=display\">distance_c + weight_{ce}</script> is shorter than the previous value of <script type=\"math/tex; mode=display\">distance_e</script>, we update <script type=\"math/tex; mode=display\">distance_e</script> with the correct shorter value.</p> </li> \n   <li> <p>We choose <script type=\"math/tex; mode=display\">e</script> as the current node. No other distances need to be updated. Thus, we mark <script type=\"math/tex; mode=display\">e</script> as visited. <script type=\"math/tex; mode=display\">distance_e</script> now gives the required shortest distance.</p> </li> \n  </ol> \n  <p>The above example proves that even if a locally closer node is chosen as the current node first, the ultimate shortest distance to any node is calculated correctly.</p> \n  <p>Let's take another example to demonstrate that the visited node needs not be chosen again as the current node. </p> \n  <p><img alt=\"Dijkstra_Graph\" src=\"../Figures/505_Maze2_2.PNG\"></p> \n  <p>Suppose <script type=\"math/tex; mode=display\">a</script> is the <script type=\"math/tex; mode=display\">start</script> node and <script type=\"math/tex; mode=display\">e</script> is the <script type=\"math/tex; mode=display\">destination</script> node. Now, suppose we visit <script type=\"math/tex; mode=display\">b</script> first and mark it as visited, but later on we find that another path exists through <script type=\"math/tex; mode=display\">c</script> to <script type=\"math/tex; mode=display\">b</script>, which makes the <script type=\"math/tex; mode=display\">distance_b</script> shorter than the previous value. But, because of this, we need to consider <script type=\"math/tex; mode=display\">b</script> as the current node again, since it would affect the value of <script type=\"math/tex; mode=display\">distance_e</script>. But, if we observe closely, such a situation would never occur, because for <script type=\"math/tex; mode=display\">weight_{ac} + weight_{cb}</script> to be lesser than <script type=\"math/tex; mode=display\">weight_{ab}</script>, <script type=\"math/tex; mode=display\">weight_{ac} < weight_{ab}</script> in the first place. Thus, <script type=\"math/tex; mode=display\">b</script> would never be marked <script type=\"math/tex; mode=display\">visited</script> before <script type=\"math/tex; mode=display\">c</script>, which contradicts the first assumption. This proves that the <script type=\"math/tex; mode=display\">visited</script> node needs not be chosen as the current node again.</p> \n  <p>The given problem is also a shortest distance finding problem with a slightly different set of rules. Thus, we can make use of Dijkstra's Algorithm to determine the minimum number of steps to reach the destination.</p> \n  <p>The methodology remains the same as the DFS or BFS Approach discussed above, except the order in which the current positions are chosen. We again make use of a <script type=\"math/tex; mode=display\">distance</script> array to keep a track of the minimum number of steps needed to reach every position from the <script type=\"math/tex; mode=display\">start</script> position. At every step, we choose a position which hasn't been marked as visited and which is at the shortest distance from the <script type=\"math/tex; mode=display\">start</script> position to be the current position. We mark this position as visited so that we don't consider this position as the current position again.</p> \n  <p>From the current position, we determine the number of steps required to reach all the positions possible travelling from the current position(in all the four directions possible till hitting a wall/boundary). If it is possible to reach any position through the current route with a lesser number of steps than the earlier routes considered, we update the corresponding <script type=\"math/tex; mode=display\">distance</script> entry. We continue the same process for the other directions as well for the current position. </p> \n  <p>In order to determine the current node, we make use of <code>minDistance</code> function, in which we traverse over the whole <script type=\"math/tex; mode=display\">distance</script> array and find out an unvisited node at the shortest distance from the <script type=\"math/tex; mode=display\">start</script> node.</p> \n  <p>At the end, the entry in <script type=\"math/tex; mode=display\">distance</script> array corresponding to the <script type=\"math/tex; mode=display\">destination</script> position gives the required minimum number of steps. If the destination can't be reached, the corresponding entry will contain <script type=\"math/tex; mode=display\">\\text{Integer.MAX_VALUE}</script>.</p> \n  <iframe src=\"https://leetcode.com/playground/L8dvTQnh/shared\" frameborder=\"0\" name=\"L8dvTQnh\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O((mn)^2)</script>. Complete traversal of maze will be done in the worst case and function <code>minDistance</code> takes <script type=\"math/tex; mode=display\">O(mn)</script> time.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(mn)</script>. <script type=\"math/tex; mode=display\">distance</script> array of size <script type=\"math/tex; mode=display\">m*n</script> is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-4-using-dijkstra-algorithm-and-priority-queueaccepted\">Approach #4 Using Dijkstra Algorithm and Priority Queue[Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In the last approach, in order to choose the current node, we traversed over the whole <script type=\"math/tex; mode=display\">distance</script> array and found out an unvisited node at the shortest distance from the <script type=\"math/tex; mode=display\">start</script> node. Rather than doing this, we can do the same task much efficiently by making use of a Priority Queue, <script type=\"math/tex; mode=display\">queue</script>. This priority queue is implemented internally in the form of a heap. The criteria used for heapifying is that the node which is unvisited and at the smallest distance from the <script type=\"math/tex; mode=display\">start</script> node, is always present on the top of the heap. Thus, the node to be chosen as the current node, is always present at the front of the <script type=\"math/tex; mode=display\">queue</script>. </p> \n  <p>For every current node, we again try to traverse in all the possible directions. We determine the minimum number of steps(till now) required to reach all the end points possible from the current node. If any such end point can be reached in a lesser number of steps through the current path than the paths previously considered, we need to update its <script type=\"math/tex; mode=display\">distance</script> entry. </p> \n  <p>Further, we add an entry corresponding to this node in the <script type=\"math/tex; mode=display\">queue</script>, since its <script type=\"math/tex; mode=display\">distance</script> entry has been updated and we need to consider this node as the competitors for the next current node choice. Thus, the process remains the same as the last approach, except the way in which the pick out the current node(which is the unvisited node at the shortest distance from the <script type=\"math/tex; mode=display\">start</script> node).</p> \n  <iframe src=\"https://leetcode.com/playground/iyiLhqSD/shared\" frameborder=\"0\" name=\"iyiLhqSD\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O\\big(mn*log(mn)\\big)</script>. Complete traversal of maze will be done in the worst case giving a factor of <script type=\"math/tex; mode=display\">mn</script>. Further, <code>poll</code> method is a combination of heapifying(<script type=\"math/tex; mode=display\">O\\big(log(n)\\big)</script>) and removing the top element(<script type=\"math/tex; mode=display\">O(1)</script>) from the priority queue, and it takes <script type=\"math/tex; mode=display\">O(n)</script> time for <script type=\"math/tex; mode=display\">n</script> elements. In the current case, <code>poll</code> introduces a factor of <script type=\"math/tex; mode=display\">log(mn)</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(mn)</script>. <script type=\"math/tex; mode=display\">distance</script> array of size <script type=\"math/tex; mode=display\">m*n</script> is used and <script type=\"math/tex; mode=display\">queue</script> size can grow upto <script type=\"math/tex; mode=display\">m*n</script> in worst case.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 504,
    "article_live": false,
    "title": "Base 7",
    "title_slug": "base-7",
    "content": "<p>Given an integer, return its base 7 string representation.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> 100\r\n<b>Output:</b> \"202\"\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> -7\r\n<b>Output:</b> \"-10\"\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\nThe input will be in range of [-1e7, 1e7].\r\n</p>",
    "tags": "",
    "difficulty": 1,
    "frontend_article_id": 504
},
{
    "frontend_question_id": 503,
    "article_live": true,
    "article_slug": "next-greater-element-ii",
    "title": "Next Greater Element II",
    "title_slug": "next-greater-element-ii",
    "content": "<p>\r\nGiven a circular array (the next element of the last element is the first element of the array), print the Next Greater Number for every element. The Next Greater Number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn't exist, output -1 for this number.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [1,2,1]\r\n<b>Output:</b> [2,-1,2]\r\n<b>Explanation:</b> The first 1's next greater number is 2; </br>The number 2 can't find next greater number; </br>The second 1's next greater number needs to search circularly, which is also 2.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\nThe length of given array won't exceed 10000.\r\n</p>",
    "tags": "Stack",
    "difficulty": 2,
    "frontend_article_id": 503,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-using-double-length-array-time-limit-exceeded\">Approach #1 Brute Force (using Double Length Array) [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-better-brute-force-accepted\">Approach #2 Better Brute Force [Accepted]</a></li> \n      <li><a href=\"#approach-3-using-stack-accepted\">Approach #3 Using Stack [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-using-double-length-array-time-limit-exceeded\">Approach #1 Brute Force (using Double Length Array) [Time Limit Exceeded]</h4> \n  <p>In this method, we make use of an array <script type=\"math/tex; mode=display\">doublenums</script> which is formed by concatenating two copies of the given <script type=\"math/tex; mode=display\">nums</script> array one after the other. Now, when we need to find out the next greater element for <script type=\"math/tex; mode=display\">nums[i]</script>, we can simply scan all the elements <script type=\"math/tex; mode=display\">doublenums[j]</script>, such that <script type=\"math/tex; mode=display\">i < j < length(doublenums)</script>. The first element found satisfying the given condition is the required result for <script type=\"math/tex; mode=display\">nums[i]</script>. If no such element is found, we put a <script type=\"math/tex; mode=display\">\\text{-1}</script> at the appropriate position in the <script type=\"math/tex; mode=display\">res</script> array.</p> \n  <iframe src=\"https://leetcode.com/playground/tRcR8Lx3/shared\" frameborder=\"0\" name=\"tRcR8Lx3\" width=\"100%\" height=\"377\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^2)</script>. The complete <script type=\"math/tex; mode=display\">doublenums</script> array(of size <script type=\"math/tex; mode=display\">\\text{2n}</script>) is scanned for all the elements of <script type=\"math/tex; mode=display\">nums</script> in the worst case.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. <script type=\"math/tex; mode=display\">doublenums</script> array of size <script type=\"math/tex; mode=display\">\\text{2n}</script> is used. <script type=\"math/tex; mode=display\">res</script> array of size <script type=\"math/tex; mode=display\">\\text{n}</script> is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-better-brute-force-accepted\">Approach #2 Better Brute Force [Accepted]</h4> \n  <p>Instead of making a double length copy of <script type=\"math/tex; mode=display\">nums</script> array , we can traverse circularly in the <script type=\"math/tex; mode=display\">nums</script> array by making use of the <script type=\"math/tex; mode=display\">\\text{%(modulus)}</script> operator. For every element <script type=\"math/tex; mode=display\">nums[i]</script>, we start searching in the <script type=\"math/tex; mode=display\">nums</script> array(of length <script type=\"math/tex; mode=display\">n</script>) from the index <script type=\"math/tex; mode=display\">(i+1)%n</script> and look at the next(cicularly) <script type=\"math/tex; mode=display\">n-1</script> elements. For <script type=\"math/tex; mode=display\">nums[i]</script> we do so by scanning over <script type=\"math/tex; mode=display\">nums[j]</script>, such that <script type=\"math/tex; mode=display\">(i+1)%n &leq; j &leq; (i+(n-1))%n</script>, and we look for the first greater element found. If no such element is found, we put a <script type=\"math/tex; mode=display\">\\text{-1}</script> at the appropriate position in the <script type=\"math/tex; mode=display\">res</script> array.</p> \n  <iframe src=\"https://leetcode.com/playground/LCG759JD/shared\" frameborder=\"0\" name=\"LCG759JD\" width=\"100%\" height=\"309\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^2)</script>. The complete <script type=\"math/tex; mode=display\">nums</script> array of size <script type=\"math/tex; mode=display\">n</script> is scanned for all the elements of <script type=\"math/tex; mode=display\">nums</script> in the worst case.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. <script type=\"math/tex; mode=display\">res</script> array of size <script type=\"math/tex; mode=display\">n</script> is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-using-stack-accepted\">Approach #3 Using Stack [Accepted]</h4> \n  <p>This approach makes use of a stack. This stack stores the indices of the appropriate elements from <script type=\"math/tex; mode=display\">nums</script> array. The top of the stack refers to the index of the Next Greater Element found so far. We store the indices instead of the elements since there could be duplicates in the <script type=\"math/tex; mode=display\">nums</script> array. The description of the method will make the above statement clearer.</p> \n  <p>We start traversing the <script type=\"math/tex; mode=display\">nums</script> array from right towards the left. For an element <script type=\"math/tex; mode=display\">nums[i]</script> encountered, we pop all the elements <script type=\"math/tex; mode=display\">stack[top]</script> from the stack such that <script type=\"math/tex; mode=display\">nums\\big[stack[top]\\big] &le; nums[i]</script>. We continue the popping till we encounter a <script type=\"math/tex; mode=display\">stack[top]</script> satisfying <script type=\"math/tex; mode=display\">nums\\big[stack[top]\\big] > nums[i]</script>. Now, it is obvious that the current <script type=\"math/tex; mode=display\">stack[top]</script> only can act as the Next Greater Element for <script type=\"math/tex; mode=display\">nums[i]</script>(right now, considering only the elements lying to the right of <script type=\"math/tex; mode=display\">nums[i]</script>).</p> \n  <p>If no element remains on the top of the stack, it means no larger element than <script type=\"math/tex; mode=display\">nums[i]</script> exists to its right. Along with this, we also push the index of the element just encountered(<script type=\"math/tex; mode=display\">nums[i]</script>), i.e. <script type=\"math/tex; mode=display\">i</script> over the top of the stack, so that <script type=\"math/tex; mode=display\">nums[i]</script>(or <script type=\"math/tex; mode=display\">stack[top</script>) now acts as the Next Greater Element for the elements lying to its left.</p> \n  <p>We go through two such passes over the complete <script type=\"math/tex; mode=display\">nums</script> array. This is done so as to complete a circular traversal over the <script type=\"math/tex; mode=display\">nums</script> array. The first pass could make some wrong entries in the <script type=\"math/tex; mode=display\">res</script> array since it considers only the elements lying to the right of <script type=\"math/tex; mode=display\">nums[i]</script>, without a circular traversal. But, these entries are corrected in the second pass. </p> \n  <p>Further, to ensure the correctness of the method, let's look at the following cases.</p> \n  <p>Assume that <script type=\"math/tex; mode=display\">nums[j]</script> is the correct Next Greater Element for <script type=\"math/tex; mode=display\">nums[i]</script>, such that <script type=\"math/tex; mode=display\">i < j &le; stack[top]</script>. Now, whenever we encounter <script type=\"math/tex; mode=display\">nums[j]</script>, if <script type=\"math/tex; mode=display\">nums[j] > nums\\big[stack[top]\\big]</script>, it would have already popped the previous <script type=\"math/tex; mode=display\">stack[top]</script> and <script type=\"math/tex; mode=display\">j</script> would have become the topmost element. On the other hand, if <script type=\"math/tex; mode=display\">nums[j] < nums\\big[stack[top]\\big]</script>, it would have become the topmost element by being pushed above the previous <script type=\"math/tex; mode=display\">stack[top]</script>. In both the cases, if <script type=\"math/tex; mode=display\">nums[j] > nums[i]</script>, it will be correctly determined to be the Next Greater Element.</p> \n  <p>The following example makes the procedure clear:</p> \n  <!--![Next_Greater_Element_II](../Figures/503_Next_Greater_Element_II.gif)--> \n  <p>!?!../Documents/503_Next_Greater2.json:1000,563!?!</p> \n  <p>As the animation above depicts, after the first pass, there are a number of wrong entries(marked as <script type=\"math/tex; mode=display\">\\text{-1}</script>) in the <script type=\"math/tex; mode=display\">res</script> array, because only the elements lying to the corresponding right(non-circular) have been considered till now. But, after the second pass, the correct values are substituted.</p> \n  <iframe src=\"https://leetcode.com/playground/in37fqRd/shared\" frameborder=\"0\" name=\"in37fqRd\" width=\"100%\" height=\"309\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Only two traversals of the <script type=\"math/tex; mode=display\">nums</script> array are done. Further, atmost <script type=\"math/tex; mode=display\">\\text{2n}</script> elements are pushed and popped from the stack.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. A stack of size <script type=\"math/tex; mode=display\">n</script> is used. <script type=\"math/tex; mode=display\">res</script> array of size <script type=\"math/tex; mode=display\">n</script> is used.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 502,
    "article_live": false,
    "title": "IPO",
    "title_slug": "ipo",
    "content": "<p>\r\nSuppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most <b>k</b> distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most <b>k</b> distinct projects. \r\n</p>\r\n\r\n<p>\r\nYou are given several projects. For each project <b>i</b>, it has a pure profit <b>P<sub>i</sub></b> and a minimum capital of <b>C<sub>i</sub></b> is needed to start the corresponding project. Initially, you have <b>W</b> capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.\r\n</p>\r\n\r\n<p>\r\nTo sum up, pick a list of at most <b>k</b> distinct projects from given projects to maximize your final capital, and output your final maximized capital.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> k=2, W=0, Profits=[1,2,3], Capital=[0,1,1].\r\n\r\n<b>Output:</b> 4\r\n\r\n<b>Explanation:</b> Since your initial capital is 0, you can only start the project indexed 0.\r\n             After finishing it you will obtain profit 1 and your capital becomes 1.\r\n             With capital 1, you can either start the project indexed 1 or the project indexed 2.\r\n             Since you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.\r\n             Therefore, output the final maximized capital, which is 0 + 1 + 3 = 4.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>You may assume all numbers in the input are non-negative integers.</li>\r\n<li>The length of Profits array and Capital array will not exceed 50,000.</li>\r\n<li>The answer is guaranteed to fit in a 32-bit signed integer.</li>\r\n</ol>\r\n</p>",
    "tags": "Heap, Greedy",
    "difficulty": 3,
    "frontend_article_id": 502
},
{
    "frontend_question_id": 501,
    "article_live": false,
    "title": "Find Mode in Binary Search Tree",
    "title_slug": "find-mode-in-binary-search-tree",
    "content": "<p>Given a binary search tree (BST) with duplicates, find all the <a href=\"https://en.wikipedia.org/wiki/Mode_(statistics)\" target=\"_blank\">mode(s)</a> (the most frequently occurred element) in the given BST.</p>\r\n\r\n<p>Assume a BST is defined as follows:</p>\r\n\r\n<ul>\r\n\t<li>The left subtree of a node contains only nodes with keys <b>less than or equal to</b> the node&#39;s key.</li>\r\n\t<li>The right subtree of a node contains only nodes with keys <b>greater than or equal to</b> the node&#39;s key.</li>\r\n\t<li>Both the left and right subtrees must also be binary search trees.</li>\r\n</ul>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>For example:<br />\r\nGiven BST <code>[1,null,2,2]</code>,</p>\r\n\r\n<pre>\r\n   1\r\n    \\\r\n     2\r\n    /\r\n   2\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>return <code>[2]</code>.</p>\r\n\r\n<p><b>Note:</b> If a tree has more than one mode, you can return them in any order.</p>\r\n\r\n<p><b>Follow up:</b> Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).</p>\r\n",
    "tags": "Tree",
    "difficulty": 1,
    "frontend_article_id": 501
},
{
    "frontend_question_id": 500,
    "article_live": false,
    "title": "Keyboard Row",
    "title_slug": "keyboard-row",
    "content": "<p>Given a List of words, return the words that can be typed using letters of <b>alphabet</b> on only one row&#39;s of American keyboard like the image below.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/10/12/keyboard.png\" style=\"width: 100%; max-width: 600px\" /></p>\r\n&nbsp;\r\n\r\n<p><b>Example:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> [&quot;Hello&quot;, &quot;Alaska&quot;, &quot;Dad&quot;, &quot;Peace&quot;]\r\n<b>Output:</b> [&quot;Alaska&quot;, &quot;Dad&quot;]\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Note:</b></p>\r\n\r\n<ol>\r\n\t<li>You may use one character in the keyboard more than once.</li>\r\n\t<li>You may assume the input string will only contain letters of alphabet.</li>\r\n</ol>\r\n",
    "tags": "Hash Table",
    "difficulty": 1,
    "frontend_article_id": 500
},
{
    "frontend_question_id": 499,
    "article_live": false,
    "title": "The Maze III",
    "title_slug": "the-maze-iii",
    "tags": "Depth-first Search, Breadth-first Search",
    "difficulty": 3,
    "frontend_article_id": 499
},
{
    "frontend_question_id": 498,
    "article_live": false,
    "title": "Diagonal Traverse",
    "title_slug": "diagonal-traverse",
    "content": "<p>Given a matrix of M x N elements (M rows, N columns), return all elements of the matrix in diagonal order as shown in the below image.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Example:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b>\r\n[\r\n [ 1, 2, 3 ],\r\n [ 4, 5, 6 ],\r\n [ 7, 8, 9 ]\r\n]\r\n\r\n<b>Output:</b>  [1,2,4,7,5,3,6,8,9]\r\n\r\n<b>Explanation:</b>\r\n<img src=\"https://assets.leetcode.com/uploads/2018/10/12/diagonal_traverse.png\" style=\"width: 220px;\" />\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Note:</b></p>\r\n\r\n<p>The total number of elements of the given matrix will not exceed 10,000.</p>\r\n",
    "tags": "",
    "difficulty": 2,
    "frontend_article_id": 498
},
{
    "frontend_question_id": 496,
    "article_live": true,
    "article_slug": "greater-element-i",
    "title": "Next Greater Element I",
    "title_slug": "next-greater-element-i",
    "content": "<p>\r\nYou are given two arrays <b>(without duplicates)</b> <code>nums1</code> and <code>nums2</code> where <code>nums1</code>’s elements are subset of <code>nums2</code>. Find all the next greater numbers for <code>nums1</code>'s elements in the corresponding places of <code>nums2</code>. \r\n</p>\r\n\r\n<p>\r\nThe Next Greater Number of a number <b>x</b> in <code>nums1</code> is the first greater number to its right in <code>nums2</code>. If it does not exist, output -1 for this number.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> <b>nums1</b> = [4,1,2], <b>nums2</b> = [1,3,4,2].\r\n<b>Output:</b> [-1,3,-1]\r\n<b>Explanation:</b>\r\n    For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.\r\n    For number 1 in the first array, the next greater number for it in the second array is 3.\r\n    For number 2 in the first array, there is no next greater number for it in the second array, so output -1.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> <b>nums1</b> = [2,4], <b>nums2</b> = [1,2,3,4].\r\n<b>Output:</b> [3,-1]\r\n<b>Explanation:</b>\r\n    For number 2 in the first array, the next greater number for it in the second array is 3.\r\n    For number 4 in the first array, there is no next greater number for it in the second array, so output -1.\r\n</pre>\r\n</p>\r\n\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>All elements in <code>nums1</code> and <code>nums2</code> are unique.</li>\r\n<li>The length of both <code>nums1</code> and <code>nums2</code> would not exceed 1000.</li>\r\n</ol>\r\n</p>",
    "tags": "Stack",
    "difficulty": 1,
    "frontend_article_id": 496,
    "article_content": ""
},
{
    "frontend_question_id": 495,
    "article_live": false,
    "title": "Teemo Attacking",
    "title_slug": "teemo-attacking",
    "content": "<p>\r\nIn LOL world, there is a hero called Teemo and his attacking can make his enemy Ashe be in poisoned condition. Now, given the Teemo's attacking <b>ascending</b> time series towards Ashe and the poisoning time duration per Teemo's attacking, you need to output the total time that Ashe is in poisoned condition.\r\n</p>\r\n\r\n<p>You may assume that Teemo attacks at the very beginning of a specific time point, and makes Ashe be in poisoned condition immediately.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [1,4], 2\r\n<b>Output:</b> 4\r\n<b>Explanation:</b> At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned immediately. <br />This poisoned status will last 2 seconds until the end of time point 2. <br />And at time point 4, Teemo attacks Ashe again, and causes Ashe to be in poisoned status for another 2 seconds. <br />So you finally need to output 4.\r\n</pre>\r\n</p>\r\n\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> [1,2], 2\r\n<b>Output:</b> 3\r\n<b>Explanation:</b> At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned. <br />This poisoned status will last 2 seconds until the end of time point 2. <br/>However, at the beginning of time point 2, Teemo attacks Ashe again who is already in poisoned status. <br/>Since the poisoned status won't add up together, though the second poisoning attack will still work at time point 2, it will stop at the end of time point 3. <br/>So you finally need to output 3.\r\n</pre>\r\n</p>\r\n\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>You may assume the length of given time series array won't exceed 10000.</li>\r\n<li>You may assume the numbers in the Teemo's attacking time series and his poisoning time duration per attacking are non-negative integers, which won't exceed 10,000,000.</li>\r\n</ol>\r\n</p>",
    "tags": "Array",
    "difficulty": 2,
    "frontend_article_id": 495
},
{
    "frontend_question_id": 494,
    "article_live": true,
    "article_slug": "target-sum",
    "title": "Target Sum",
    "title_slug": "target-sum",
    "content": "<p>\r\nYou are given a list of non-negative integers, a1, a2, ..., an, and a target, S. Now you have 2 symbols <code>+</code> and <code>-</code>. For each integer, you should choose one from <code>+</code> and <code>-</code> as its new symbol.\r\n</p> \r\n\r\n<p>Find out how many ways to assign symbols to make sum of integers equal to target S.  \r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> nums is [1, 1, 1, 1, 1], S is 3. \r\n<b>Output:</b> 5\r\n<b>Explanation:</b> \r\n\r\n-1+1+1+1+1 = 3\r\n+1-1+1+1+1 = 3\r\n+1+1-1+1+1 = 3\r\n+1+1+1-1+1 = 3\r\n+1+1+1+1-1 = 3\r\n\r\nThere are 5 ways to assign symbols to make the sum of nums be target 3.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The length of the given array is positive and will not exceed 20. </li>\r\n<li>The sum of elements in the given array will not exceed 1000.</li>\r\n<li>Your output answer is guaranteed to be fitted in a 32-bit integer.</li>\r\n</ol>\r\n</p>",
    "tags": "Dynamic Programming, Depth-first Search",
    "difficulty": 2,
    "frontend_article_id": 494,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-accepted\">Approach #1 Brute Force [Accepted]</a></li> \n      <li><a href=\"#approach-2-recursion-with-memoization-accepted\">Approach #2 Recursion with memoization [Accepted]</a></li> \n      <li><a href=\"#approach-3-2d-dynamic-programming-accepted\">Approach #3 2D Dynamic Programming [Accepted]</a></li> \n      <li><a href=\"#approach-4-1d-dynamic-programming-accepted\">Approach #4 1D Dynamic Programming [Accepted]:</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-accepted\">Approach #1 Brute Force [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>The brute force approach is based on recursion. We need to try to put both the <code>+</code> and <code>-</code> symbols at every location in the given <script type=\"math/tex; mode=display\">nums</script> array and find out the assignments which lead to the required result <script type=\"math/tex; mode=display\">S</script>.</p> \n  <p>For this, we make use of a recursive function <code>calculate(nums, i, sum, S)</code>, which returns the assignments leading to the sum <script type=\"math/tex; mode=display\">S</script>, starting from the <script type=\"math/tex; mode=display\">i^{th}</script> index onwards, provided the sum of elements upto the <script type=\"math/tex; mode=display\">i^{th}</script> element is <script type=\"math/tex; mode=display\">sum</script>. This function appends a <code>+</code> sign and a <code>-</code> sign both to the element at the current index and calls itself with the updated <script type=\"math/tex; mode=display\">sum</script> as <script type=\"math/tex; mode=display\">sum + nums[i]</script> and <script type=\"math/tex; mode=display\">sum - nums[i]</script> repectively along with the updated current index as <script type=\"math/tex; mode=display\">i+1</script>. Whenver, we reach the end of the array, we compare the sum obtained with <script type=\"math/tex; mode=display\">S</script>. If they are equal, we increment the <script type=\"math/tex; mode=display\">count</script> value to be returned.</p> \n  <p>Thus, the function call <code>calculate(nums, 0, 0, S)</code> retuns the required no. of assignments.</p> \n  <iframe src=\"https://leetcode.com/playground/zHJSM65m/shared\" frameborder=\"0\" name=\"zHJSM65m\" width=\"100%\" height=\"326\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(2^n)</script>. Size of recursion tree will be <script type=\"math/tex; mode=display\">2^n</script>. <script type=\"math/tex; mode=display\">n</script> refers to the size of <script type=\"math/tex; mode=display\">nums</script> array.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The depth of the recursion tree can go upto <script type=\"math/tex; mode=display\">n</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-recursion-with-memoization-accepted\">Approach #2 Recursion with memoization [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>It can be easily observed that in the last approach, a lot of redundant function calls could be made with the same value of <script type=\"math/tex; mode=display\">i</script> as the current index and the same value of <script type=\"math/tex; mode=display\">sum</script> as the current sum, since the same values could be obtained through multiple paths in the recursion tree. In order to remove this redundancy, we make use of memoization as well to store the results which have been calculated earlier.</p> \n  <p>Thus, for every call to <code>calculate(nums, i, sum, S)</code>, we store the result obtained in <script type=\"math/tex; mode=display\">memo[i][sum + 1000]</script>. The factor of 1000 has been added as an offset to the <script type=\"math/tex; mode=display\">sum</script> value to map all the <script type=\"math/tex; mode=display\">sum</script>s possible to positive integer range. By making use of memoization, we can prune the search space to a good extent.</p> \n  <iframe src=\"https://leetcode.com/playground/jAQP4A3v/shared\" frameborder=\"0\" name=\"jAQP4A3v\" width=\"100%\" height=\"496\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(l*n)</script>. The <script type=\"math/tex; mode=display\">memo</script> array of size <script type=\"math/tex; mode=display\">l*n</script> has been filled just once. Here, <script type=\"math/tex; mode=display\">l</script> refers to the range of <script type=\"math/tex; mode=display\">sum</script> and <script type=\"math/tex; mode=display\">n</script> refers to the size of <script type=\"math/tex; mode=display\">nums</script> array.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The depth of recursion tree can go upto <script type=\"math/tex; mode=display\">n</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-2d-dynamic-programming-accepted\">Approach #3 2D Dynamic Programming [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>The idea behind this approach is as follows. Suppose we can find out the number of times a particular sum, say <script type=\"math/tex; mode=display\">sum_i</script> is possible upto a particular index, say <script type=\"math/tex; mode=display\">i</script>, in the given <script type=\"math/tex; mode=display\">nums</script> array, which is given by say <script type=\"math/tex; mode=display\">count_i</script>. Now, we can find out the number of times the sum <script type=\"math/tex; mode=display\">sum_i + nums[i]</script> can occur easily as <script type=\"math/tex; mode=display\">count_i</script>. Similarly, the number of times the sum <script type=\"math/tex; mode=display\">sum_i - nums[i]</script> occurs is also given by <script type=\"math/tex; mode=display\">count_i</script>. </p> \n  <p>Thus, if we know all the sums <script type=\"math/tex; mode=display\">sum_j</script>'s which are possible upto the <script type=\"math/tex; mode=display\">j^{th}</script> index by using various assignments, along with the corresponding count of assignments, <script type=\"math/tex; mode=display\">count_j</script>, leading to the same sum, we can determine all the sums possible upto the <script type=\"math/tex; mode=display\">(j+1)^{th}</script> index along with the corresponding count of assignments leading to the new sums.</p> \n  <p>Based on this idea, we make use of a <script type=\"math/tex; mode=display\">dp</script> to determine the number of assignments which can lead to the given sum. <script type=\"math/tex; mode=display\">dp[i][j]</script> refers to the number of assignments which can lead to a sum of <script type=\"math/tex; mode=display\">j</script> upto the <script type=\"math/tex; mode=display\">i^{th}</script> index. To determine the number of assignments which can lead to a sum of <script type=\"math/tex; mode=display\">sum + nums[i]</script> upto the <script type=\"math/tex; mode=display\">(i+1)^{th}</script> index, we can use <script type=\"math/tex; mode=display\">dp[i][sum + nums[i]] = dp[i][sum + nums[i]] + dp[i-1][sum]</script>. Similarly, <script type=\"math/tex; mode=display\">dp[i][sum - nums[i]] = dp[i][sum + nums[i]] + dp[i-1][sum]</script>. We iterate over the <script type=\"math/tex; mode=display\">dp</script> array in a rowwise fashion i.e. Firstly we obtain all the sums which are possible upto a particular index along with the corresponding count of assignments and then proceed for the next element(index) in the <script type=\"math/tex; mode=display\">nums</script> array.</p> \n  <p>But, since the $$sum can range from -1000 to +1000, we need to add an offset of 1000 to the sum indices (column number) to map all the sums obtained to positive range only. </p> \n  <p>At the end, the value of <script type=\"math/tex; mode=display\">dp[n-1][S+1000]</script> gives us the required number of assignments. Here, <script type=\"math/tex; mode=display\">n</script> refers to the number of elements in the <script type=\"math/tex; mode=display\">nums</script> array.</p> \n  <p>The animation below shows the way various sums are generated along with the corresponding indices. The example assumes <script type=\"math/tex; mode=display\">sum</script> values to lie in the range of -6 to +6 just for the purpose of illustration. This animation is inspired by <a href=\"https://leetcode.com/Chidong\">@Chidong</a></p> \n  <p>!?!../Documents/494_Target_Sum.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/PfZkp9b3/shared\" frameborder=\"0\" name=\"PfZkp9b3\" width=\"100%\" height=\"326\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(l*n)</script>. The entire <script type=\"math/tex; mode=display\">nums</script> array is travesed 2001(constant no.: <script type=\"math/tex; mode=display\">l</script>) times. <script type=\"math/tex; mode=display\">n</script> refers to the size of <script type=\"math/tex; mode=display\">nums</script> array. <script type=\"math/tex; mode=display\">l</script> refers to the range of <script type=\"math/tex; mode=display\">sum</script> possible.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(l*n)</script>. <script type=\"math/tex; mode=display\">dp</script> array of size <script type=\"math/tex; mode=display\">l*n</script> is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-4-1d-dynamic-programming-accepted\">Approach #4 1D Dynamic Programming [Accepted]:</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>If we look closely at the last solution, we can observe that for the evaluation of the current row of <script type=\"math/tex; mode=display\">dp</script>, only the values of the last row of <script type=\"math/tex; mode=display\">dp</script> are needed. Thus, we can save some space by using a 1D DP array instead of a 2-D DP array. The only difference that needs to be made is that now the same <script type=\"math/tex; mode=display\">dp</script> array will be updated for every row traversed. </p> \n  <p>Below code is inspired by <a href=\"https://leetcode.com/Chidong\">@Chidong</a></p> \n  <iframe src=\"https://leetcode.com/playground/YJzJ5KpW/shared\" frameborder=\"0\" name=\"YJzJ5KpW\" width=\"100%\" height=\"360\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(l.n)</script>. The entire <script type=\"math/tex; mode=display\">nums</script> array is traversed <script type=\"math/tex; mode=display\">l</script> times. <script type=\"math/tex; mode=display\">n</script> refers to the size of <script type=\"math/tex; mode=display\">nums</script> array. <script type=\"math/tex; mode=display\">l</script> refers to the range of <script type=\"math/tex; mode=display\">sum</script> possible.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. <script type=\"math/tex; mode=display\">dp</script> array of size <script type=\"math/tex; mode=display\">n</script> is used.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 493,
    "article_live": true,
    "article_slug": "reverse-pairs",
    "title": "Reverse Pairs",
    "title_slug": "reverse-pairs",
    "content": "<p>Given an array <code>nums</code>, we call <code>(i, j)</code> an <b><i>important reverse pair</i></b> if <code>i &lt; j</code> and <code>nums[i] &gt; 2*nums[j]</code>.</p>\r\n\r\n<p>You need to return the number of important reverse pairs in the given array.</p>\r\n\r\n<p><b>Example1:</b>\r\n<pre>\r\n<b>Input</b>: [1,3,2,3,1]\r\n<b>Output</b>: 2\r\n</pre></p>\r\n\r\n<p><b>Example2:</b>\r\n<pre>\r\n<b>Input</b>: [2,4,3,5,1]\r\n<b>Output</b>: 3\r\n</pre></p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The length of the given array will not exceed <code>50,000</code>.</li>\r\n<li>All the numbers in the input array are in the range of 32-bit integer.</li>\r\n</ol>\r\n</p>",
    "tags": "Divide and Conquer, Binary Indexed Tree, Segment Tree, Binary Search Tree",
    "difficulty": 3,
    "frontend_article_id": 493,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute force [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-binary-search-tree-accepted\">Approach #2 Binary Search Tree [Accepted]</a></li> \n      <li><a href=\"#approach-3-bit-accepted\">Approach #3 BIT [Accepted]</a></li> \n      <li><a href=\"#approach-4-modified-merge-sort-accepted\">Approach #4 Modified Merge Sort [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute force [Time Limit Exceeded]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Do as directed in the question. We can simply check all the pairs if they are important reverse pairs or not.</p> \n  <p><strong>Algorithm</strong></p> \n  <ul> \n   <li>Iterate over <script type=\"math/tex; mode=display\">i</script> from <script type=\"math/tex; mode=display\">0</script> to <script type=\"math/tex; mode=display\">\\text{size} - 1</script> \n    <ul> \n     <li>Iterate over <script type=\"math/tex; mode=display\">j</script> from <script type=\"math/tex; mode=display\">0</script> to <script type=\"math/tex; mode=display\">i - 1</script> \n      <ul> \n       <li>If <script type=\"math/tex; mode=display\">\\text{nums[j]} > 2 * \\text{nums[i]}</script>, increment <script type=\"math/tex; mode=display\">\\text{count}</script> </li> \n      </ul> </li> \n    </ul> </li> \n  </ul> \n  <iframe src=\"https://leetcode.com/playground/uASZfEgx/shared\" frameborder=\"0\" name=\"uASZfEgx\" width=\"100%\" height=\"258\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time complexity: <script type=\"math/tex; mode=display\">O(n^2)</script> \n    <ul> \n     <li>We iterate over all the possible pairs wherein (<script type=\"math/tex; mode=display\">i<j</script>) in the array which is <script type=\"math/tex; mode=display\">O(n^2)</script> </li> \n    </ul> </li> \n   <li>Space complexity: <script type=\"math/tex; mode=display\">O(1)</script> only constant extra space is required for <script type=\"math/tex; mode=display\">n</script>, <script type=\"math/tex; mode=display\">count</script> etc.</li> \n  </ul> \n  <p><strong>Trivia</strong></p> \n  <p>The above code can be expressed as one-liner in Python:</p> \n  <p><em>Python</em></p> \n  <iframe src=\"https://leetcode.com/playground/s5b8yGJS/shared\" frameborder=\"0\" name=\"s5b8yGJS\" width=\"100%\" height=\"88\"></iframe> \n  <p>Herein, we iterate over all the pairs and store the boolean values for <script type=\"math/tex; mode=display\">\\text{nums[i]}>2*\\text{nums[j]}</script>. Finally, we count the number of <script type=\"math/tex; mode=display\">\\text{true}</script> in the array and return the result.</p> \n  <hr> \n  <h4 id=\"approach-2-binary-search-tree-accepted\">Approach #2 Binary Search Tree [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>In Approach #1, for each element <script type=\"math/tex; mode=display\">i</script>, we searched the subarray <script type=\"math/tex; mode=display\">[0,i)</script> for elements such that their value is greater than <script type=\"math/tex; mode=display\">2*\\text{nums[i]}</script>. In the previous approach, the search is linear. However, we need to make the process efficient. Maybe, memoization can help, but since, we need to compare the elements, we cannot find a linear DP solution.</p> \n  <p>Observe that the indices of the elements in subarray <script type=\"math/tex; mode=display\">[0,i)</script> don't matter as we only require the count. So, we can sort the elements and perform binary search on the subarray. But, since the subarray keeps growing as we iterate to the next element, we need a data structure to store the previous result as well as to allow efficient searching(preferably <script type=\"math/tex; mode=display\">O(log(n))</script>) - Binary Search Tree(BST) could be a good bet. </p> \n  <p><em>Refreshing BST</em></p> \n  <p>BST is a rooted binary tree, wherein each node is associated with a value and has 2 distinguishable sub-trees namely <script type=\"math/tex; mode=display\">left</script> and <script type=\"math/tex; mode=display\">right</script> subtree. The left subtree contains only the nodes with lower values than the parent's value, while the right subtree conatins only the nodes with greater values than the parent's value.</p> \n  <p><em>Voila!</em></p> \n  <p>This is exactly what is required. So, if we store our elements in BST, then we can search the larger elements thus eliminating the search on smaller elements altogether.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Define the <script type=\"math/tex; mode=display\">\\text{Node}</script> of BST that stores the <script type=\"math/tex; mode=display\">\\text{val}</script> and pointers to the <script type=\"math/tex; mode=display\">\\text{left}</script> and <script type=\"math/tex; mode=display\">\\text{right}</script>. We also need a count of elements(say <script type=\"math/tex; mode=display\">\\text{count_ge}</script>) in the subtree rooted at the current node that are greater than or equal to the current node's <script type=\"math/tex; mode=display\">\\text{val}</script>. <script type=\"math/tex; mode=display\">\\text{count_ge}</script> is initialized to 1 for each node and <script type=\"math/tex; mode=display\">\\text{left}</script>, <script type=\"math/tex; mode=display\">\\text{right}</script> pointers are set to <script type=\"math/tex; mode=display\">\\text{NULL}</script>.</p> \n  <p>We define the <script type=\"math/tex; mode=display\">\\text{insert}</script> routine that recursively adds the given <script type=\"math/tex; mode=display\">\\text{val}</script> as an appropriate leaf node based on comparisons with the <script type=\"math/tex; mode=display\">Node.val</script>. Each time, the given <script type=\"math/tex; mode=display\">val</script> is smaller than <script type=\"math/tex; mode=display\">Node.val</script>, we increment the <script type=\"math/tex; mode=display\">\\text{count_ge}</script> and move the <script type=\"math/tex; mode=display\">val</script> to the right subtree. While, if the <script type=\"math/tex; mode=display\">val</script> is equal to the current <script type=\"math/tex; mode=display\">Node</script>, we simply increment the <script type=\"math/tex; mode=display\">\\text{count_ge}</script> and exit. While, we move to the left subtree in case <script type=\"math/tex; mode=display\">(\\text{val}<\\text{Node.val})</script>.</p> \n  <p>We also require the <script type=\"math/tex; mode=display\">search</script> routine that gives the count of number of elements greater than or equal to the <script type=\"math/tex; mode=display\">\\text{target}</script>. In the <script type=\"math/tex; mode=display\">\\text{search}</script> routine, if the <script type=\"math/tex; mode=display\">head</script> is NULL, return 0. Otherwise, if <script type=\"math/tex; mode=display\">\\text{target}==\\text{head.val}</script>, we know the count of values greater than or equal to the <script type=\"math/tex; mode=display\">\\text{target}</script>, hence simply return <script type=\"math/tex; mode=display\">\\text{head.count_ge}</script>. In case, <script type=\"math/tex; mode=display\">\\text{target}<\\text{head.val}</script>, the ans is calculated by adding <script type=\"math/tex; mode=display\">\\text{Node.count_ge}</script> and recursively calling the <script type=\"math/tex; mode=display\">\\text{search}</script> routine with <script type=\"math/tex; mode=display\">\\text{head.left}</script>. And if <script type=\"math/tex; mode=display\">\\text{target}>\\text{head.val}</script>, ans is obtained by recursively calling the <script type=\"math/tex; mode=display\">\\text{search}</script> routine with <script type=\"math/tex; mode=display\">\\text{head.right}</script>.</p> \n  <p>Now, we can get to our main logic:</p> \n  <ul> \n   <li>Iterate over <script type=\"math/tex; mode=display\">i</script> from <script type=\"math/tex; mode=display\">0</script> to <script type=\"math/tex; mode=display\">(size-1)</script> of <script type=\"math/tex; mode=display\">\\text{nums}</script> :\n    <ul> \n     <li>Search the existing BST for <script type=\"math/tex; mode=display\">\\text{nums[i]} * 2 + 1</script> and add the result to <script type=\"math/tex; mode=display\">\\text{count}</script> </li> \n     <li>Insert <script type=\"math/tex; mode=display\">\\text{nums[i]}</script> to the BST, hence updating the <script type=\"math/tex; mode=display\">\\text{count_ge}</script> of the previous nodes</li> \n    </ul> </li> \n  </ul> \n  <p>The algorithm can be better understood using the example below: !?!../Documents/493_reverse_pairs.json:1000,662!?!</p> \n  <iframe src=\"https://leetcode.com/playground/5xoZwFd2/shared\" frameborder=\"0\" name=\"5xoZwFd2\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity analysis</strong></p> \n  <ul> \n   <li>Time complexity: <script type=\"math/tex; mode=display\">O(n^2)</script> \n    <ul> \n     <li>The best case complexity for BST is <script type=\"math/tex; mode=display\">O(log(n))</script> for search as well as insertion, wherein, the tree formed is complete binary tree</li> \n     <li>Whereas, in case like [1,2,3,4,5,6,7,8,...], insertion as well as search for an element becomes <script type=\"math/tex; mode=display\">O(n)</script> in time, since, the tree is skewed in only one direction, and hence, is no better than the array</li> \n     <li>So, in worst case, for searching and insertion over n items, the complexity is <script type=\"math/tex; mode=display\">O(n*n)</script> </li> \n    </ul> </li> \n   <li>Space complexity: <script type=\"math/tex; mode=display\">O(n)</script> extra space for storing the BST in <script type=\"math/tex; mode=display\">\\text{Node}</script> class.</li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-bit-accepted\">Approach #3 BIT [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>The problem with BST is that the tree can be skewed hence, making it <script type=\"math/tex; mode=display\">O(n^2)</script> in complexity. So, need a data structure that remains balanced. We could either use a Red-black or AVL tree to make a balanced BST, but the implementation would be an overkill for the solution. We can use BIT (Binary Indexed Tree, also called Fenwick Tree) to ensure that the complexity is <script type=\"math/tex; mode=display\">O(nlog(n))</script> with only 12-15 lines of code.</p> \n  <p><em>BIT Overview:</em></p> \n  <p>Fenwick Tree or BIT provides a way to represent an array of numbers in an array(can be visualized as tree), allowing prefix/suffix sums to be calculated efficiently(<script type=\"math/tex; mode=display\">O(log(n))</script>). BIT allows to update an element in <script type=\"math/tex; mode=display\">O(log(n))</script> time.</p> \n  <p>We recommend having a look at BIT from the following links before getting into details:</p> \n  <ul> \n   <li><a href=\"https://www.youtube.com/watch?v=CWDQJGaN1gY\">https://www.youtube.com/watch?v=CWDQJGaN1gY</a></li> \n   <li><a href=\"https://www.topcoder.com/community/data-science/data-science-tutorials/binary-indexed-trees/\">https://www.topcoder.com/community/data-science/data-science-tutorials/binary-indexed-trees/</a></li> \n  </ul> \n  <p>So, BIT is very useful to accumulate information from front/back and hence, we can use it in the same way we used BST to get the count of elements that are greater than or equal to <script type=\"math/tex; mode=display\">2 * \\text{nums[i]} + 1</script> in the existing tree and then adding the current element to the tree.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>First, lets review the BIT <script type=\"math/tex; mode=display\">\\text{query}</script> and <script type=\"math/tex; mode=display\">\\text{update}</script> routines of BIT. According to the convention, <script type=\"math/tex; mode=display\">\\text{query}</script> routine goes from <script type=\"math/tex; mode=display\">\\text{index}</script> to <script type=\"math/tex; mode=display\">0</script>, i.e., <script type=\"math/tex; mode=display\">\\text{BIT[i]}</script> gives the sum for the range <script type=\"math/tex; mode=display\">[0,index]</script>, and <script type=\"math/tex; mode=display\">\\text{update}</script> updates the values from current <script type=\"math/tex; mode=display\">\\text{index}</script> to the end of array. But, since, we require to find the numbers greater than the given index, as and when we update an index, we update all the ancestors of the node in the tree, and for <script type=\"math/tex; mode=display\">\\text{search}</script>, we go from the node to the end. </p> \n  <p>The modified <script type=\"math/tex; mode=display\">\\text{update}</script> algorithm is:</p> \n  <div class=\"codehilite\">\n   <pre><span></span>update(BIT,index, val):\n  while(index&lt;0):\n    BIT[index]+=val\n    index-=(index&amp;(-index))\n</pre>\n  </div> \n  <p>Herein, we find get the next index using: <script type=\"math/tex; mode=display\">\\text{index-=index&(-index)}</script>, which is essentially subtracting the rightmost 1 from the <script type=\"math/tex; mode=display\">\\text{index}</script> binary representation. We update the previous indices since, if an element is greater than the index</p> \n  <p>And the modified <script type=\"math/tex; mode=display\">\\text{query}</script> algorithm is:</p> \n  <div class=\"codehilite\">\n   <pre><span></span>query(BIT,index):\n  sum=0\n  while(index&lt;BIT.size):\n    sum+=BIT[index]\n    index+=(index&amp;(-index))\n</pre>\n  </div> \n  <p>Herein, we find get the next index using: <script type=\"math/tex; mode=display\">\\text{index+=index&(-index)}</script>. This gives the suffix sum from <script type=\"math/tex; mode=display\">index</script> to the end.</p> \n  <p>So, the main idea is to count the number of elements greater than <script type=\"math/tex; mode=display\">2*\\text{nums[i]}</script> in range <script type=\"math/tex; mode=display\">[0,i)</script> as we iterate from <script type=\"math/tex; mode=display\">0</script> to <script type=\"math/tex; mode=display\">\\text{size-1}</script>. The steps are as follows:</p> \n  <ul> \n   <li>Create a copy of <script type=\"math/tex; mode=display\">\\text{nums}</script>, say <script type=\"math/tex; mode=display\">\\text{nums_copy}</script> ans sort <script type=\"math/tex; mode=display\">\\text{nums_copy}</script>. This array is actually used for creating the Binary indexed tree</li> \n   <li>Initialize <script type=\"math/tex; mode=display\">\\text{count}=0</script> and <script type=\"math/tex; mode=display\">\\text{BIT}</script> array of size <script type=\"math/tex; mode=display\">\\text{size(nums)} + 1</script> to store the BIT</li> \n   <li>Iterate over <script type=\"math/tex; mode=display\">i</script> from <script type=\"math/tex; mode=display\">0</script> to <script type=\"math/tex; mode=display\">\\text{size(nums)}-1</script> :\n    <ul> \n     <li>Search the index of element not less than <script type=\"math/tex; mode=display\">2*\\text{nums[i]}+1</script> in <script type=\"math/tex; mode=display\">\\text{nums_copy}</script> array. <script type=\"math/tex; mode=display\">\\text{query}</script> the obtained index+1 in the <script type=\"math/tex; mode=display\">\\text{BIT}</script>, and add the result to <script type=\"math/tex; mode=display\">\\text{count}</script> </li> \n     <li>Search for the index of element not less than <script type=\"math/tex; mode=display\">nums[i]</script> in <script type=\"math/tex; mode=display\">\\text{nums_copy}</script>. We need to <script type=\"math/tex; mode=display\">\\text{update}</script> the BIT for this index by 1. This essentially means that 1 is added to this index(or number of elements greater than this index is incremented). The effect of adding <script type=\"math/tex; mode=display\">1</script> to the index is passed to the ancestors as shown in <script type=\"math/tex; mode=display\">\\text{update}</script> algorithm</li> \n    </ul> </li> \n  </ul> \n  <iframe src=\"https://leetcode.com/playground/ckjEGCCm/shared\" frameborder=\"0\" name=\"ckjEGCCm\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity analysis</strong></p> \n  <ul> \n   <li>Time complexity: <script type=\"math/tex; mode=display\">O(nlog(n))</script> \n    <ul> \n     <li>In <script type=\"math/tex; mode=display\">\\text{query}</script> and <script type=\"math/tex; mode=display\">\\text{update}</script> operations, we see that the loop iterates at most the number of bits in <script type=\"math/tex; mode=display\">\\text{index}</script> which can be at most <script type=\"math/tex; mode=display\">n</script>. Hence, the complexity of both the operations is <script type=\"math/tex; mode=display\">O(log(n))</script>(Number of bits in <script type=\"math/tex; mode=display\">n</script> is <script type=\"math/tex; mode=display\">log(n)</script>)</li> \n     <li>The in-built operation <script type=\"math/tex; mode=display\">\\text{lower_bound}</script> is binary search hence <script type=\"math/tex; mode=display\">O(log(n))</script> </li> \n     <li>We perform the operations for <script type=\"math/tex; mode=display\">n</script> elements, hence the total complexity is <script type=\"math/tex; mode=display\">O(nlog(n))</script> </li> \n    </ul> </li> \n   <li>Space complexity: <script type=\"math/tex; mode=display\">O(n)</script>. Additional space for <script type=\"math/tex; mode=display\">\\text{BITS}</script> array</li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-4-modified-merge-sort-accepted\">Approach #4 Modified Merge Sort [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>In BIT and BST, we iterate over the array, dividing the array into 3 sections: already visited and hence added to the tree, current node and section to be visited. Another approach could be divide the problem into smaller subproblems, solving them and combining these problems to get the final result - Divide and conquer. We see that the problem has a great resemblance to the merge sort routine. The question is to find the inversions such that <script type=\"math/tex; mode=display\">\\text{nums[i]}>2 * \\text{nums[j]}</script> and <script type=\"math/tex; mode=display\">i<j</script>. So, we can easily modify the merge sort to count the inversions as required.</p> \n  <p><em>Mergesort</em></p> \n  <p>Mergesort is a divide-and-conquer based sorting technique that operates in <script type=\"math/tex; mode=display\">O(nlog(n))</script> time. The basic idea to divide the array into several sub-arrays until each sub-array is single element long and merging these sublists recursively that results in the final sorted array.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>We define <script type=\"math/tex; mode=display\">\\text{mergesort_and_count}</script> routine that takes parameters an array say <script type=\"math/tex; mode=display\">A</script> and <script type=\"math/tex; mode=display\">\\text{start}</script> and <script type=\"math/tex; mode=display\">\\text{end}</script> indices:</p> \n  <ul> \n   <li>If <script type=\"math/tex; mode=display\">\\text{start}</script>&gt;=<script type=\"math/tex; mode=display\">\\text{end}</script> this implies that elements can no longer be broken further and hence we return 0</li> \n   <li>Otherwise, set <script type=\"math/tex; mode=display\">\\text{mid}=(\\text{start} + \\text{end})/2</script> </li> \n   <li>Store <script type=\"math/tex; mode=display\">count</script> by recursively calling <script type=\"math/tex; mode=display\">\\text{mergesort_and_count}</script> on range <script type=\"math/tex; mode=display\">\\text{[start,mid]}</script> and <script type=\"math/tex; mode=display\">\\text{[mid+1,end]}</script> and adding the results. This is the divide step on our routine, breaking it into the 2 ranges, and finding the results for each range separately</li> \n   <li>Now, we that we have separately calculated the results for ranges <script type=\"math/tex; mode=display\">\\text{[start,mid]}</script> and <script type=\"math/tex; mode=display\">\\text{[mid+1,end]}</script>, but we still have to count the elements in <script type=\"math/tex; mode=display\">\\text{[start,mid]}</script> that are greater than 2 * elements in <script type=\"math/tex; mode=display\">\\text{[mid+1,end]}</script>. Count all such elements and add the result to <script type=\"math/tex; mode=display\">\\text{count}</script> </li> \n   <li>Finally, <script type=\"math/tex; mode=display\">\\text{merge}</script> the array from <script type=\"math/tex; mode=display\">\\text{start}</script> to <script type=\"math/tex; mode=display\">\\text{end}</script> \n    <ul> \n     <li>Make 2 array : <script type=\"math/tex; mode=display\">L</script> from elements in range <script type=\"math/tex; mode=display\">\\text{[start,mid]}</script> and <script type=\"math/tex; mode=display\">R</script> from elements in range <script type=\"math/tex; mode=display\">\\text{R[mid+1,end]}</script> </li> \n     <li>Keep pointers <script type=\"math/tex; mode=display\">i</script> and <script type=\"math/tex; mode=display\">j</script> to <script type=\"math/tex; mode=display\">L</script> and <script type=\"math/tex; mode=display\">R</script> respectively both initialized to start to the arrays</li> \n     <li>Iterate over <script type=\"math/tex; mode=display\">k</script> from <script type=\"math/tex; mode=display\">\\text{start}</script> to <script type=\"math/tex; mode=display\">\\text{end}</script> and set <script type=\"math/tex; mode=display\">\\text{A[k]}</script> to the smaller of <script type=\"math/tex; mode=display\">\\text{L[i]}</script> or <script type=\"math/tex; mode=display\">\\text{R[j]}</script> and increment the respective index</li> \n    </ul> </li> \n  </ul> \n  <iframe src=\"https://leetcode.com/playground/PVpymxwQ/shared\" frameborder=\"0\" name=\"PVpymxwQ\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity analysis</strong></p> \n  <ul> \n   <li>Time complexity: <script type=\"math/tex; mode=display\">O(nlog(n))</script> \n    <ul> \n     <li>In each step we divide the array into 2 sub-arrays, and hence, the maximum times we need to divide is equal to <script type=\"math/tex; mode=display\">O(log(n))</script> </li> \n     <li>Additional <script type=\"math/tex; mode=display\">O(n)</script> work needs to be done to count the inversions and to merge the 2 sub-arrays after sorting. Hence total time complexity is <script type=\"math/tex; mode=display\">O(n * log(n))</script> </li> \n    </ul> </li> \n   <li>Space complexity: <script type=\"math/tex; mode=display\">O(n)</script>. Additional space for storing <script type=\"math/tex; mode=display\">L</script> and <script type=\"math/tex; mode=display\">R</script> arrays</li> \n  </ul> \n  <hr> \n  <p>Analysis written by <a href=\"https://leetcode.com/abhinavbansal0\">@abhinavbansal0</a>.</p> \n  <p>Shoutout to <a href=\"https://discuss.leetcode.com/user/fun4leetcode\">@FUN4LEETCODE</a> for the brilliant post!</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 492,
    "article_live": false,
    "title": "Construct the Rectangle",
    "title_slug": "construct-the-rectangle",
    "content": "<p>\r\nFor a web developer, it is very important to know how to design a web page's size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:<pre>\r\n1. The area of the rectangular web page you designed must equal to the given target area.\r\n<br>2. The width W should not be larger than the length L, which means L >= W.\r\n<br>3. The difference between length L and width W should be as small as possible.\r\n</pre>\r\nYou need to output the length L and the width W of the web page you designed in sequence.\r\n</p>\r\n\r\n\r\n<p><b>Example:</b><br />\r\n<pre>\r\n<b>Input:</b> 4\r\n<b>Output:</b> [2, 2]\r\n<b>Explanation:</b> The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1]. \r\nBut according to requirement 2, [1,4] is illegal; according to requirement 3,  [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The given area won't exceed 10,000,000 and is a positive integer</li>\r\n<li>The web page's width and length you designed must be positive integers.</li>\r\n</ol>\r\n</p>",
    "tags": "",
    "difficulty": 1,
    "frontend_article_id": 492
},
{
    "frontend_question_id": 491,
    "article_live": false,
    "title": "Increasing Subsequences",
    "title_slug": "increasing-subsequences",
    "content": "<p>\r\nGiven an integer array, your task is to find all the different possible increasing subsequences of the given array, and the length of an increasing subsequence should be at least 2 .\r\n</p>\r\n\r\n<p><b>Example:</b><br />\r\n<pre>\r\n<b>Input:</b> [4, 6, 7, 7]\r\n<b>Output:</b> [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The length of the given array will not exceed 15.</li>\r\n<li>The range of integer in the given array is [-100,100].</li>\r\n<li>The given array may contain duplicates, and two equal integers should also be considered as a special case of increasing sequence.</li>\r\n</ol>\r\n</p>",
    "tags": "Depth-first Search",
    "difficulty": 2,
    "frontend_article_id": 491
},
{
    "frontend_question_id": 490,
    "article_live": true,
    "article_slug": "the-maze",
    "title": "The Maze",
    "title_slug": "the-maze",
    "tags": "Depth-first Search, Breadth-first Search",
    "difficulty": 2,
    "frontend_article_id": 490,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-depth-first-search-time-limit-exceeded\">Approach #1 Depth First Search [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-breadth-first-search-accepted\">Approach #2 Breadth First Search [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-depth-first-search-time-limit-exceeded\">Approach #1 Depth First Search [Time Limit Exceeded]</h4> \n  <p>We can view the given search space in the form of a tree. The root node of the tree represents the starting position. Four different routes are possible from each position i.e. left, right, up or down. These four options can be represented by 4 branches of each node in the given tree. Thus, the new node reached from the root traversing over the branch represents the new position occupied by the ball after choosing the corresponding direction of travel.</p> \n  <p><img alt=\"Maze_Tree\" src=\"../Figures/490_Maze_Tree.PNG\"></p> \n  <p>In order to do this traversal, one of the simplest schemes is to undergo depth first search. In this case, we choose one path at a time and try to go as deep as possible into the levels of the tree before going for the next path. In order to implement this, we make use of a recursive function <code>dfs(maze, start, desination, visited)</code>. This function takes the given <script type=\"math/tex; mode=display\">maze</script> array, the <script type=\"math/tex; mode=display\">start</script> position and the <script type=\"math/tex; mode=display\">destination</script> position as its arguments along with a <script type=\"math/tex; mode=display\">visited</script> array. <script type=\"math/tex; mode=display\">visited</script> array is a 2-D boolean array of the same size as that of <script type=\"math/tex; mode=display\">maze</script>. A True value at <script type=\"math/tex; mode=display\">visited[i][j]</script> represents that the current position has already been reached earlier during the path traversal. We make use of this array so as to keep track of the same paths being repeated over and over. We mark a True at the current position in the <script type=\"math/tex; mode=display\">visited</script> array once we reach that particular positon in the <script type=\"math/tex; mode=display\">maze</script>.</p> \n  <p>From every <script type=\"math/tex; mode=display\">start</script> position, we can move continuously in either left, right, upward or downward direction till we reach the boundary or a wall. Thus, from the <script type=\"math/tex; mode=display\">start</script> position, we determine all the end points which can be reached by choosing the four directions. For each of the cases, the new endpoint will now act as the new start point for the traversals. The destination, obviously remains unchanged. Thus, now we call the same function four times for the four directions, each time with a new start point obtained previously. </p> \n  <p>If any of the function call returns a True value, it means we can reach the desination. </p> \n  <p>The following animation depicts the process:</p> \n  <p>!?!../Documents/490_Maze_DFS.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/mNXpP4ZF/shared\" frameborder=\"0\" name=\"mNXpP4ZF\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(mn)</script>. Complete traversal of maze will be done in the worst case. Here, <script type=\"math/tex; mode=display\">m</script> and <script type=\"math/tex; mode=display\">n</script> refers to the number of rows and coloumns of the maze.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(mn)</script>. <script type=\"math/tex; mode=display\">visited</script> array of size <script type=\"math/tex; mode=display\">m*n</script> is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-breadth-first-search-accepted\">Approach #2 Breadth First Search [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>The same search space tree can also be explored in a Depth First Search manner. In this case, we try to explore the search space on a level by level basis. i.e. We try to move in all the directions at every step. When all the directions have been explored and we still don't reach the destination, then only we proceed to the new set of traversals from the new positions obtained. </p> \n  <p>In order to implement this, we make use of a <script type=\"math/tex; mode=display\">queue</script>. We start with the ball at the <script type=\"math/tex; mode=display\">start</script> position. For every current position, we add all the new positions possible by traversing in all the four directions(till reaching the wall or boundary) into the <script type=\"math/tex; mode=display\">queue</script> to act as the new start positions and mark these positions as True in the <script type=\"math/tex; mode=display\">visited</script> array. When all the directions have been covered up, we remove a position value, <script type=\"math/tex; mode=display\">s</script>, from the front of the <script type=\"math/tex; mode=display\">queue</script> and again continue the same process with <script type=\"math/tex; mode=display\">s</script> acting as the new <script type=\"math/tex; mode=display\">start</script> position. </p> \n  <p>Further, in order to choose the direction of travel, we make use of a <script type=\"math/tex; mode=display\">dir</script> array, which contains 4 entries. Each entry represents a one-dimensional direction of travel. To travel in a particular direction, we keep on adding the particular entry of the <script type=\"math/tex; mode=display\">dirs</script> array till we hit a wall or a boundary. For a particular start position, we do this process of <script type=\"math/tex; mode=display\">dir</script> addition for all all the four directions possible.</p> \n  <p>If we hit the destination position at any moment, we return a True directly indicating that the <script type=\"math/tex; mode=display\">destination</script> position can be reached starting from the <script type=\"math/tex; mode=display\">start</script> position. </p> \n  <p>The following animation depicts the process:</p> \n  <p>!?!../Documents/490_Maze_BFS.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/5jvdfXTK/shared\" frameborder=\"0\" name=\"5jvdfXTK\" width=\"100%\" height=\"513\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(mn)</script>. Complete traversal of maze will be done in the worst case. Here, <script type=\"math/tex; mode=display\">m</script> and <script type=\"math/tex; mode=display\">n</script> refers to the number of rows and coloumns of the maze.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(mn)</script>. <script type=\"math/tex; mode=display\">visited</script> array of size <script type=\"math/tex; mode=display\">m*n</script> is used and <script type=\"math/tex; mode=display\">queue</script> size can grow upto <script type=\"math/tex; mode=display\">m*n</script> in worst case.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 488,
    "article_live": false,
    "title": "Zuma Game",
    "title_slug": "zuma-game",
    "content": "<p>Think about Zuma Game. You have a row of balls on the table, colored red(R), yellow(Y), blue(B), green(G), and white(W). You also have several balls in your hand.</p>\r\n<p>\r\nEach time, you may choose a ball in your hand, and insert it into the row (including the leftmost place and rightmost place). Then, if there is a group of 3 or more balls in the same color touching, remove these balls. Keep doing this until no more balls can be removed.</p>\r\n<p>\r\nFind the minimal balls you have to insert to remove all the balls on the table. If you cannot remove all the balls, output -1.\r\n</p>\r\n<pre>\r\n<p><b>Examples:</b><br />\r\n<b>Input:</b> \"WRRBBW\", \"RB\"\r\n<b>Output:</b> -1\r\n<b>Explanation:</b> WRRBBW -> WRR[R]BBW -> WBBW -> WBB[B]W -> WW\r\n\r\n<b>Input:</b> \"WWRRBBWW\", \"WRBRW\"\r\n<b>Output:</b> 2\r\n<b>Explanation:</b> WWRRBBWW -> WWRR[R]BBWW -> WWBBWW -> WWBB[B]WW -> WWWW -> empty\r\n\r\n<b>Input:</b>\"G\", \"GGGGG\"\r\n<b>Output:</b> 2\r\n<b>Explanation:</b> G -> G[G] -> GG[G] -> empty \r\n\r\n<b>Input:</b> \"RBYYBBRRB\", \"YRBGB\"\r\n<b>Output:</b> 3\r\n<b>Explanation:</b> RBYYBBRRB -> RBYY[Y]BBRRB -> RBBBRRB -> RRRB -> B -> B[B] -> BB[B] -> empty \r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>You may assume that the initial row of balls on the table won’t have any 3 or more consecutive balls with the same color.</li>\r\n<li>The number of balls on the table won't exceed 20, and the string represents these balls is called \"board\" in the input.</li>\r\n<li>The number of balls in your hand won't exceed 5, and the string represents these balls is called \"hand\" in the input.</li>\r\n<li>Both input strings will be non-empty and only contain characters 'R','Y','B','G','W'.</li>\r\n</ol>\r\n</p>",
    "tags": "Depth-first Search",
    "difficulty": 3,
    "frontend_article_id": 488
},
{
    "frontend_question_id": 487,
    "article_live": false,
    "title": "Max Consecutive Ones II",
    "title_slug": "max-consecutive-ones-ii",
    "tags": "Two Pointers",
    "difficulty": 2,
    "frontend_article_id": 487
},
{
    "frontend_question_id": 486,
    "article_live": true,
    "article_slug": "predict-the-winner",
    "title": "Predict the Winner",
    "title_slug": "predict-the-winner",
    "content": "<p>Given an array of scores that are non-negative integers. Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on. Each time a player picks a number, that number will not be available for the next player. This continues until all the scores have been chosen. The player with the maximum score wins. </p>\r\n\r\n<p>Given an array of scores, predict whether player 1 is the winner. You can assume each player plays to maximize his score. </p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [1, 5, 2]\r\n<b>Output:</b> False\r\n<b>Explanation:</b> Initially, player 1 can choose between 1 and 2. <br/>If he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). <br/>So, final score of player 1 is 1 + 2 = 3, and player 2 is 5. <br/>Hence, player 1 will never be the winner and you need to return False.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> [1, 5, 233, 7]\r\n<b>Output:</b> True\r\n<b>Explanation:</b> Player 1 first chooses 1. Then player 2 have to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.<br />Finally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>1 <= length of the array <= 20. </li>\r\n<li>Any scores in the given array are non-negative integers and will not exceed 10,000,000.</li>\r\n<li>If the scores of both players are equal, then player 1 is still the winner.</li>\r\n</ol>\r\n</p>",
    "tags": "Dynamic Programming, Minimax",
    "difficulty": 2,
    "frontend_article_id": 486,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-using-recursion-accepted\">Approach #1 Using Recursion [Accepted]</a></li> \n      <li><a href=\"#approach-2-similar-approach-accepted\">Approach #2 Similar Approach [Accepted]</a></li> \n      <li><a href=\"#approach-3-dynamic-programming-accepted\">Approach #3 Dynamic Programming [Accepted]:</a></li> \n      <li><a href=\"#approach-4-1-d-dynamic-programming-accepted\">Approach #4 1-D Dynamic Programming [Accepted]:</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-using-recursion-accepted\">Approach #1 Using Recursion [Accepted]</h4> \n  <p>The idea behind the recursive approach is simple. The two players Player 1 and Player 2 will be taking turns alternately. For the Player 1 to be the winner, we need <script type=\"math/tex; mode=display\">score_{Player\\_1} &geq; score_{Player\\_2}</script>. Or in other terms, <script type=\"math/tex; mode=display\">score_{Player\\_1} - score_{Player\\_2} &geq; 0</script>. </p> \n  <p>Thus, for the turn of Player 1, we can add its score obtained to the total score and for Player 2's turn, we can substract its score from the total score. At the end, we can check if the total score is greater than or equal to zero(equal score of both players), to predict that Player 1 will be the winner.</p> \n  <p>Thus, by making use of a recursive function <code>winner(nums,s,e,turn)</code> which predicts the winner for the <script type=\"math/tex; mode=display\">nums</script> array as the score array with the elements in the range of indices <script type=\"math/tex; mode=display\">[s,e]</script> currently being considered, given a particular player's turn, indicated by <script type=\"math/tex; mode=display\">turn=1</script> being Player 1's turn and <script type=\"math/tex; mode=display\">turn=-1</script> being the Player 2's turn, we can predict the winner of the given problem by making the function call <code>winner(nums,0,n-1,1)</code>. Here, <script type=\"math/tex; mode=display\">n</script> refers to the length of <script type=\"math/tex; mode=display\">nums</script> array.</p> \n  <p>In every turn, we can either pick up the first(<script type=\"math/tex; mode=display\">nums[s]</script>) or the last(<script type=\"math/tex; mode=display\">nums[e]</script>) element of the current subarray. Since both the players are assumed to be playing smartly and making the best move at every step, both will tend to maximize their scores. Thus, we can make use of the same function <code>winner</code> to determine the maximum score possible for any of the players. </p> \n  <p>Now, at every step of the recursive process, we determine the maximum score possible for the current player. It will be the maximum one possible out of the scores obtained by picking the first or the last element of the current subarray. </p> \n  <p>To obtain the score possible from the remaining subarray, we can again make use of the same <code>winner</code> function and add the score corresponding to the point picked in the current function call. But, we need to take care of whether to add or subtract this score to the total score available. If it is Player 1's turn, we add the current number's score to the total score, otherwise, we need to subtract the same. </p> \n  <p>Thus, at every step, we need update the search space appropriately based on the element chosen and also invert the <script type=\"math/tex; mode=display\">turn</script>'s value to indicate the turn change among the players and either add or subtract the current player's score from the total score available to determine the end result.</p> \n  <p>Further, note that the value returned at every step is given by <script type=\"math/tex; mode=display\">turn *\\text{max}(turn * a, turn * b)</script>. This is equivalent to the statement <script type=\"math/tex; mode=display\">max(a,b)</script> for Player 1's turn and <script type=\"math/tex; mode=display\">min(a,b)</script> for Player 2's turn. </p> \n  <p>This is done because, looking from Player 1's perspective, for any move made by Player 1, it tends to leave the remaining subarray in a situation which minimizes the best score possible for Player 2, even if it plays in the best possible manner. But, when the turn passes to Player 1 again, for Player 1 to win, the remaining subarray should be left in a state such that the score obtained from this subarrray is maximum(for Player 1). </p> \n  <p>This is a general criteria for any arbitrary two player game and is commonly known as the <a href=\"https://en.wikipedia.org/wiki/Minimax\">Min-Max algorithm</a>.</p> \n  <p>The following image shows how the scores are passed to determine the end result for a simple example.</p> \n  <p align=\"center\"><img alt=\"Recursive_Tree\" src=\"../Figures/486/486_Predict_the_winner_new.PNG\"></p> \n  <iframe src=\"https://leetcode.com/playground/3SDSCR7V/shared\" frameborder=\"0\" name=\"3SDSCR7V\" width=\"100%\" height=\"275\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(2^n)</script>. Size of recursion tree will be <script type=\"math/tex; mode=display\">2^n</script>. Here, <script type=\"math/tex; mode=display\">n</script> refers to the length of <script type=\"math/tex; mode=display\">nums</script> array.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The depth of the recursion tree can go upto <script type=\"math/tex; mode=display\">n</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-similar-approach-accepted\">Approach #2 Similar Approach [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>We can omit the use of <script type=\"math/tex; mode=display\">turn</script> to keep a track of the player for the current turn. To do so, we can make use of a simple observation. If the current turn belongs to, say Player 1, we pick up an element, say <script type=\"math/tex; mode=display\">x</script>, from either end, and give the turn to Player 2. Thus, if we obtain the score for the remaining elements(leaving <script type=\"math/tex; mode=display\">x</script>), this score, now belongs to Player 2. Thus, since Player 2 is competing against Player 1, this score should be subtracted from Player 1's current(local) score(<script type=\"math/tex; mode=display\">x</script>) to obtain the effective score of Player 1 at the current instant.</p> \n  <p>Similar argument holds true for Player 2's turn as well i.e. we can subtract Player 1's score for the remaining subarray from Player 2's current score to obtain its effective score. By making use of this observation, we can omit the use of <script type=\"math/tex; mode=display\">turn</script> from <code>winner</code> to find the required result by making the slight change discussed above in the <code>winner</code>'s implementation.</p> \n  <p>While returning the result from <code>winner</code> for the current function call, we return the larger of the effective scores possible by choosing either the first or the last element from the currently available subarray. Rest of the process remains the same as the last approach.</p> \n  <p>Now, in order to remove the duplicate function calls, we can make use of a 2-D memoization array, <script type=\"math/tex; mode=display\">memo</script>, such that we can store the result obtained for the function call <code>winner</code> for a subarray with starting and ending indices being <script type=\"math/tex; mode=display\">s</script> and <script type=\"math/tex; mode=display\">e</script> ] at <script type=\"math/tex; mode=display\">memo[s][e]</script>. This helps to prune the search space to a great extent.</p> \n  <p>This approach is inspired by <a href=\"https://leetcode.com/chidong\">@chidong</a></p> \n  <iframe src=\"https://leetcode.com/playground/RGPbqsDC/shared\" frameborder=\"0\" name=\"RGPbqsDC\" width=\"100%\" height=\"326\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^2)</script>. The entire <script type=\"math/tex; mode=display\">memo</script> array of size <script type=\"math/tex; mode=display\">n</script>x<script type=\"math/tex; mode=display\">n</script> is filled only once. Here, <script type=\"math/tex; mode=display\">n</script> refers to the size of <script type=\"math/tex; mode=display\">nums</script> array.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n^2)</script>. <script type=\"math/tex; mode=display\">memo</script> array of size <script type=\"math/tex; mode=display\">n</script>x<script type=\"math/tex; mode=display\">n</script> is used for memoization.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-dynamic-programming-accepted\">Approach #3 Dynamic Programming [Accepted]:</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>We can observe that the effective score for the current player for any given subarray <script type=\"math/tex; mode=display\">nums[x:y]</script> only depends on the elements within the range <script type=\"math/tex; mode=display\">[x,y]</script> in the array <script type=\"math/tex; mode=display\">nums</script>. It mainly depends on whether the element <script type=\"math/tex; mode=display\">nums[x]</script> or <script type=\"math/tex; mode=display\">nums[y]</script> is chosen in the current turn and also on the maximum score possible for the other player from the remaining subarray left after choosing the current element. Thus, it is certain that the current effective score isn't dependent on the elements outside the range <script type=\"math/tex; mode=display\">[x,y]</script>. </p> \n  <p>Based on the above observation, we can say that if know the maximum effective score possible for the subarray <script type=\"math/tex; mode=display\">nums[x+1,y]</script> and <script type=\"math/tex; mode=display\">nums[x,y-1]</script>, we can easily determine the maximum effective score possible for the subarray <script type=\"math/tex; mode=display\">nums[x,y]</script> as <script type=\"math/tex; mode=display\">\\text{max}(nums[x]-score_{[x+1,y]}, nums[y]-score_{[x,y-1]})</script>. These equations are deduced based on the last approach. </p> \n  <p>From this, we conclude that we can make use of Dynamic Programming to determine the required maximum effective score for the array <script type=\"math/tex; mode=display\">nums</script>. We can make use of a 2-D <script type=\"math/tex; mode=display\">dp</script> array, such that <script type=\"math/tex; mode=display\">dp[i][j]</script> is used to store the maximum effective score possible for the subarray <script type=\"math/tex; mode=display\">nums[i,j]</script>. The <script type=\"math/tex; mode=display\">dp</script> updation equation becomes: </p> \n  <p> <script type=\"math/tex; mode=display\">dp[i,j] = nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]</script>.</p> \n  <p>We can fill in the <script type=\"math/tex; mode=display\">dp</script> array starting from the last row. At the end, the value for <script type=\"math/tex; mode=display\">dp[0][n-1]</script> gives the required result. Here, <script type=\"math/tex; mode=display\">n</script> refers to the length of <script type=\"math/tex; mode=display\">nums</script> array.</p> \n  <p>Look at the animation below to clearly understand the <script type=\"math/tex; mode=display\">dp</script> filling process.</p> \n  <p>!?!../Documents/486_Predict_the_winner.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/EFGjsVXp/shared\" frameborder=\"0\" name=\"EFGjsVXp\" width=\"100%\" height=\"275\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^2)</script>. <script type=\"math/tex; mode=display\">((n+1)</script>x<script type=\"math/tex; mode=display\">n)/2</script> entries in <script type=\"math/tex; mode=display\">dp</script> array of size <script type=\"math/tex; mode=display\">(n+1)</script>x<script type=\"math/tex; mode=display\">n</script> is filled once. Here, <script type=\"math/tex; mode=display\">n</script> refers to the length of <script type=\"math/tex; mode=display\">nums</script> array.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n^2)</script>. <script type=\"math/tex; mode=display\">dp</script> array of size <script type=\"math/tex; mode=display\">(n+1)</script>x<script type=\"math/tex; mode=display\">n</script> is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-4-1-d-dynamic-programming-accepted\">Approach #4 1-D Dynamic Programming [Accepted]:</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>From the last approach, we see that the <script type=\"math/tex; mode=display\">dp</script> updation equation is: </p> \n  <p> <script type=\"math/tex; mode=display\">dp[i,j] = nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]</script>. </p> \n  <p>Thus, for filling in any entry in <script type=\"math/tex; mode=display\">dp</script> array, only the entries in the next row(same column) and the previous column(same row) are needed.</p> \n  <p>Instead of making use of a new row in <script type=\"math/tex; mode=display\">dp</script> array for the current <script type=\"math/tex; mode=display\">dp</script> row's updations, we can overwrite the values in the previous row itself and consider the values as belonging to the new row's entries, since the older values won't be needed ever in the future again. Thus, instead of making use of a 2-D <script type=\"math/tex; mode=display\">dp</script> array, we can make use of a 1-D <script type=\"math/tex; mode=display\">dp</script> array and make the updations appropriately.</p> \n  <iframe src=\"https://leetcode.com/playground/k9vrYN2X/shared\" frameborder=\"0\" name=\"k9vrYN2X\" width=\"100%\" height=\"292\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^2)</script>. The elements of <script type=\"math/tex; mode=display\">dp</script> array are updated <script type=\"math/tex; mode=display\">1+2+3+...+n</script> times. Here, <script type=\"math/tex; mode=display\">n</script> refers to the length of <script type=\"math/tex; mode=display\">nums</script> array.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. 1-D <script type=\"math/tex; mode=display\">dp</script> array of size <script type=\"math/tex; mode=display\">n</script> is used.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 485,
    "article_live": false,
    "title": "Max Consecutive Ones",
    "title_slug": "max-consecutive-ones",
    "content": "<p>Given a binary array, find the maximum number of consecutive 1s in this array.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [1,1,0,1,1,1]\r\n<b>Output:</b> 3\r\n<b>Explanation:</b> The first two digits or the last three digits are consecutive 1s.\r\n    The maximum number of consecutive 1s is 3.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\n<ul>\r\n<li>The input array will only contain <code>0</code> and <code>1</code>.</li>\r\n<li>The length of input array is a positive integer and will not exceed 10,000</li>\r\n</ul>\r\n</p>",
    "tags": "Array",
    "difficulty": 1,
    "frontend_article_id": 485
},
{
    "frontend_question_id": 484,
    "article_live": true,
    "article_slug": "find-permutation",
    "title": "Find Permutation",
    "title_slug": "find-permutation",
    "tags": "Greedy",
    "difficulty": 2,
    "frontend_article_id": 484,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-using-stack-accepted\">Approach #1 Using Stack [Accepted]</a></li> \n      <li><a href=\"#approach-2-reversing-the-subarray-accepted\">Approach #2 Reversing the subarray [Accepted]</a></li> \n      <li><a href=\"#approach-3-two-pointers-accepted\">Approach #3 Two pointers [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-using-stack-accepted\">Approach #1 Using Stack [Accepted]</h4> \n  <p>Let's revisit the important points of the given problem statement. For a given <script type=\"math/tex; mode=display\">n</script>, we need to use all the integers in the range <script type=\"math/tex; mode=display\">(1,n)</script> to generate a lexicographically smallest permutation of these <script type=\"math/tex; mode=display\">n</script> numbers which satsfies the pattern given in the string <script type=\"math/tex; mode=display\">s</script>.</p> \n  <p>Firstly, we note that the lexicographically smallest permutation that can be generated(irrelevant of the given pattern <script type=\"math/tex; mode=display\">s</script>) using the <script type=\"math/tex; mode=display\">n</script> integers from <script type=\"math/tex; mode=display\">(1,n)</script> is <script type=\"math/tex; mode=display\">[1, 2, 3,.., n]</script>(say <script type=\"math/tex; mode=display\">min</script>). Thus, while generating the required permutation, we can surely say that the permutation generated should be as close as possible to <script type=\"math/tex; mode=display\">min</script>.</p> \n  <p>Now, we can also note that the number generated will be the smallest possible only if the digits lying towards the most significant positions are as small as possible while satisfying the given pattern. Now, to understand how these observations help in providing the solution of the given problem, we'll look at a simple example.</p> \n  <p>Say, the given pattern <script type=\"math/tex; mode=display\">s</script> is <code>\"DDIIIID\"</code>. This corresponds to <script type=\"math/tex; mode=display\">n=8</script>. Thus, the <script type=\"math/tex; mode=display\">min</script> permutation possible will be <code>[1, 2, 3, 4, 5, 6, 7, 8]</code>. Now, to satisfy the first two <code>\"DD\"</code> pattern, we can observe that the best course of action to generate the smallest arrangement will be to rearrange only <code>1, 2, 3</code>, because these are the smallest numbers that can be placed at the three most significant positions to generate the smallest arrangement satisfying the given pattern till now, leading to the formation of <code>[3, 2, 1, 4, 5, 6, 7, 8]</code> till now. We can note that placing any number larger than 3 at any of these positions will lead to the generation of a lexicographically larger arrangement as discussed above.</p> \n  <p>We can also note that irrespective of how we rearrange the first three <code>1, 2, 3</code>, the relationship of the last number among them with the next number always satisfies the criteria required for satisfying the first <code>I</code> in <script type=\"math/tex; mode=display\">s</script>. Further, note that, the pattern generated till now already satisfies the subpattern <code>\"IIII\"</code> in <script type=\"math/tex; mode=display\">s</script>. This will always be satisfied since the <script type=\"math/tex; mode=display\">min</script> number considered originally always satisfies the increasing criteria.</p> \n  <p>Now, when we find the last <code>\"D\"</code> in the pattern <script type=\"math/tex; mode=display\">s</script>, we again need to make rearrangements in the last two positions only and we need to use only the numbers <code>7, 8</code> in such rearrangements at those positions. This is because, again, we would like to keep the larger number towards the least significant possible as much as possible to generate the lexicographically smallest arrangement. Thus, to satisfy the last <code>\"D\"</code> the best arrangement of the last two numbers is <code>8, 7</code> leading to the generation of <code>[3, 2, 1, 4, 5, 6, 8, 7]</code> as the required output.</p> \n  <p>Based on the above example, we can summarize that, to generate the required arrangement, we can start off with the <script type=\"math/tex; mode=display\">min</script> number that can be formed for the given <script type=\"math/tex; mode=display\">n</script>. Then, to satisfy the given pattern <script type=\"math/tex; mode=display\">s</script>, we need to reverse only those subsections of the <script type=\"math/tex; mode=display\">min</script> array which have a <code>D</code> in the pattern at their corresponding positions.</p> \n  <p>To perform these operations, we need not necessarily create the <script type=\"math/tex; mode=display\">min</script> array first, because it simply consists of numbers from <script type=\"math/tex; mode=display\">1</script> to <script type=\"math/tex; mode=display\">n</script> in ascending order. </p> \n  <p>To perform the operations discussed above, we can make use of a <script type=\"math/tex; mode=display\">stack</script>. We can start considering the numbers <script type=\"math/tex; mode=display\">i</script> from <script type=\"math/tex; mode=display\">1</script> to <script type=\"math/tex; mode=display\">n</script>. For every current number, whenver we find a <code>D</code> in the pattern <script type=\"math/tex; mode=display\">s</script>, we just push that number onto the <script type=\"math/tex; mode=display\">stack</script>. This is done so that, later on, when we find the next <code>I</code>, we can pop off these numbers from the stack leading to the formation of a reversed (descending) subpattern of those numbers corrresponding to the <code>D</code>'s in <script type=\"math/tex; mode=display\">s</script>(as discussed above). </p> \n  <p>When we encounter an <code>I</code> in the pattern, as discussed above, we push the current number as well onto the <script type=\"math/tex; mode=display\">stack</script> and then pop-off all the numbers on the <script type=\"math/tex; mode=display\">stack</script> and append these numbers to the resultant pattern formed till now.</p> \n  <p>Now, we could reach the end of the pattern <script type=\"math/tex; mode=display\">s</script> with a trail of <code>D</code>'s at the end. In this case, we won't find an ending <code>I</code> to pop-off the numbers on the <script type=\"math/tex; mode=display\">stack</script>. Thus, at the end, we push the value <script type=\"math/tex; mode=display\">n</script> on the stack and then pop all the values on the <script type=\"math/tex; mode=display\">stack</script> and append them to the resultant pattern formed till now. Now, if the second last character in <script type=\"math/tex; mode=display\">s</script> was an <code>I</code>, <script type=\"math/tex; mode=display\">n</script> will be appended at the end of the resultant arrangement correctly. If the second last character was a <code>D</code>, the reversed pattern appended at the end of the resultant arrangement will be reversed including the last number <script type=\"math/tex; mode=display\">n</script>. In both the cases, the resultant arrangement turns out to be correct. </p> \n  <p>The following animation better illustrates the process.</p> \n  <p>!?!../Documents/484_Find_Permutation_1.json:1000,563!?!</p> \n  <p>Below code is inpired by <a href=\"https://leetcode.com/horseno\">@horseno</a></p> \n  <iframe src=\"https://leetcode.com/playground/oQngSEVg/shared\" frameborder=\"0\" name=\"oQngSEVg\" width=\"100%\" height=\"394\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. <script type=\"math/tex; mode=display\">n</script> numbers will be pushed and popped from the <script type=\"math/tex; mode=display\">stack</script>. Here, <script type=\"math/tex; mode=display\">n</script> refers to the number of elements in the resultant arrangement.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The <script type=\"math/tex; mode=display\">stack</script> can grow upto a depth of <script type=\"math/tex; mode=display\">n</script> in the worst case.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-reversing-the-subarray-accepted\">Approach #2 Reversing the subarray [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In order to reverse the subsections of the <script type=\"math/tex; mode=display\">min</script> array, as discussed in the last approach, we can also start by initializing the resultant arrangement <script type=\"math/tex; mode=display\">res</script> with the <script type=\"math/tex; mode=display\">min</script> array i.e. by filling with elements <script type=\"math/tex; mode=display\">(1,n)</script> in ascending order. Then, while traversing the pattern <script type=\"math/tex; mode=display\">s</script>, we can keep a track of the starting and ending indices in <script type=\"math/tex; mode=display\">res</script> corresponding to the <code>D</code>'s in the pattern <script type=\"math/tex; mode=display\">s</script>, and reverse the portions of the sub-arrays in <script type=\"math/tex; mode=display\">res</script> corresponding to these indices. The reasoning behind this remains the same as discussed in the last approach.</p> \n  <p>The following animation illustrates the process.</p> \n  <p>!?!../Documents/484_Find_Permutation_Reverse.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/JWJKE7wc/shared\" frameborder=\"0\" name=\"JWJKE7wc\" width=\"100%\" height=\"462\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The resultant array of size <script type=\"math/tex; mode=display\">n</script> is traversed atmost three times, in the worst case e.g. \"DDDDDD\"</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant extra space is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-two-pointers-accepted\">Approach #3 Two pointers [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Instead of initializing the <script type=\"math/tex; mode=display\">res</script> array once with ascending numbers, we can save one iteration over <script type=\"math/tex; mode=display\">res</script> if we fill it on the fly. To do this, we can keep on filling the numbers in ascending order in <script type=\"math/tex; mode=display\">res</script> for <code>I</code>'s found in the pattern <script type=\"math/tex; mode=display\">s</script>. Whenever we find a <code>D</code> in the pattern <script type=\"math/tex; mode=display\">s</script>, we can store the current position(counting from 1) being filled in the <script type=\"math/tex; mode=display\">res</script> array in a pointer <script type=\"math/tex; mode=display\">j</script>. Now, whenever we find the first <code>I</code> following this last consecutive set of <code>D</code>'s, say at the <script type=\"math/tex; mode=display\">i^{th}</script> position(counting from 1) in <script type=\"math/tex; mode=display\">res</script>, we know, that the elements from <script type=\"math/tex; mode=display\">j^{th}</script> position to the <script type=\"math/tex; mode=display\">i^{th}</script> position in <script type=\"math/tex; mode=display\">res</script> need to be filled with the numbers from <script type=\"math/tex; mode=display\">j</script> to <script type=\"math/tex; mode=display\">i</script> in reverse order. Thus, we can fill the numbers in <script type=\"math/tex; mode=display\">res</script> array starting from the <script type=\"math/tex; mode=display\">j^{th}</script> position, with <script type=\"math/tex; mode=display\">i</script> being the number filled at that position and continue the filling in descending order till reaching the <script type=\"math/tex; mode=display\">i^{th}</script> position. In this way, we can generate the required arrangement without initializing <script type=\"math/tex; mode=display\">res</script>.</p> \n  <iframe src=\"https://leetcode.com/playground/XWhYV6uZ/shared\" frameborder=\"0\" name=\"XWhYV6uZ\" width=\"100%\" height=\"428\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The resultant array of size <script type=\"math/tex; mode=display\">n</script> is traversed atmost two times, in the worst case e.g. \"DDDDDD\"</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant extra space is used.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 483,
    "article_live": false,
    "title": "Smallest Good Base",
    "title_slug": "smallest-good-base",
    "content": "<p>For an integer n, we call k>=2 a <i><b>good base</b></i> of n, if all digits of n base k are 1.</p>\r\n<p>Now given a string representing n, you should return the smallest good base of n in string format. <br/></p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \"13\"\r\n<b>Output:</b> \"3\"\r\n<b>Explanation:</b> 13 base 3 is 111.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> \"4681\"\r\n<b>Output:</b> \"8\"\r\n<b>Explanation:</b> 4681 base 8 is 11111.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 3:</b><br />\r\n<pre>\r\n<b>Input:</b> \"1000000000000000000\"\r\n<b>Output:</b> \"999999999999999999\"\r\n<b>Explanation:</b> 1000000000000000000 base 999999999999999999 is 11.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The range of n is [3, 10^18].</li>\r\n<li>The string representing n is always valid and will not have leading zeros.</li>\r\n</ol>\r\n</p>",
    "tags": "Math, Binary Search",
    "difficulty": 3,
    "frontend_article_id": 483
},
{
    "frontend_question_id": 482,
    "article_live": false,
    "title": "License Key Formatting",
    "title_slug": "license-key-formatting",
    "content": "<p>You are given a license key represented as a string S which consists only alphanumeric character and dashes. The string is separated into N+1 groups by N dashes.</p>\r\n\r\n<p>Given a number K, we would want to reformat the strings such that each group contains <i>exactly</i> K characters, except for the first group which could be shorter than K, but still must contain at least one character. Furthermore, there must be a dash inserted between two groups and all lowercase letters should be converted to uppercase.</p>\r\n\r\n<p>Given a non-empty string S and a number K, format the string according to the rules described above.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> S = \"5F3Z-2e-9-w\", K = 4\r\n\r\n<b>Output:</b> \"5F3Z-2E9W\"\r\n\r\n<b>Explanation:</b> The string S has been split into two parts, each part has 4 characters.\r\nNote that the two extra dashes are not needed and can be removed.\r\n</pre>\r\n</p>\r\n\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> S = \"2-5g-3-J\", K = 2\r\n\r\n<b>Output:</b> \"2-5G-3J\"\r\n\r\n<b>Explanation:</b> The string S has been split into three parts, each part has 2 characters except the first part as it could be shorter as mentioned above.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The length of string S will not exceed 12,000, and K is a positive integer.</li>\r\n<li>String S consists only of alphanumerical characters (a-z and/or A-Z and/or 0-9) and dashes(-).</li>\r\n<li>String S is non-empty.</li>\r\n</ol>\r\n</p>",
    "tags": "",
    "difficulty": 1,
    "frontend_article_id": 482
},
{
    "frontend_question_id": 481,
    "article_live": false,
    "title": "Magical String",
    "title_slug": "magical-string",
    "content": "<p>\r\nA magical string <b>S</b> consists of only '1' and '2' and obeys the following rules:\r\n</p>\r\n<p>\r\nThe string <b>S</b> is magical because concatenating the number of contiguous occurrences of characters '1' and '2' generates the string <b>S</b> itself.\r\n</p>\r\n\r\n<p>\r\nThe first few elements of string <b>S</b> is the following:\r\n<b>S</b> = \"1221121221221121122……\"\r\n</p>\r\n\r\n<p>\r\nIf we group the consecutive '1's and '2's in <b>S</b>, it will be:\r\n</p>\r\n<p>\r\n1   22  11  2  1  22  1  22  11  2  11  22 ......\r\n</p>\r\n<p>\r\nand the occurrences of '1's or '2's in each group are:\r\n</p>\r\n<p>\r\n1   2\t   2    1   1    2     1    2     2    1    2    2 ......\r\n</p>\r\n\r\n<p>\r\nYou can see that the occurrence sequence above is the <b>S</b> itself. \r\n</p>\r\n\r\n<p>\r\nGiven an integer N as input, return the number of '1's in the first N number in the magical string <b>S</b>.\r\n</p>\r\n\r\n<p><b>Note:</b>\r\nN will not exceed 100,000.\r\n</p>\r\n\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> 6\r\n<b>Output:</b> 3\r\n<b>Explanation:</b> The first 6 elements of magical string S is \"12211\" and it contains three 1's, so return 3.\r\n</pre>\r\n</p>",
    "tags": "",
    "difficulty": 2,
    "frontend_article_id": 481
},
{
    "frontend_question_id": 480,
    "article_live": true,
    "article_slug": "sliding-window-median",
    "title": "Sliding Window Median",
    "title_slug": "sliding-window-median",
    "content": "<p>Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.</p>\r\nExamples: <br />\r\n<p><code>[2,3,4]</code> , the median is <code>3</code></p>\r\n<p><code>[2,3]</code>, the median is <code>(2 + 3) / 2 = 2.5</code> </p>\r\n\r\n<p>Given an array <i>nums</i>, there is a sliding window of size <i>k</i> which is moving from the very left of the array to the very right. You can only see the <i>k</i> numbers in the window. Each time the sliding window moves right by one position. Your job is to output the median array for each window in the original array.</p>\r\n\r\n<p>For example,<br>\r\nGiven <i>nums</i> = <code>[1,3,-1,-3,5,3,6,7]</code>, and <i>k</i> = 3.</p>\r\n\r\n<pre>\r\nWindow position                Median\r\n---------------               -----\r\n[1  3  -1] -3  5  3  6  7       1\r\n 1 [3  -1  -3] 5  3  6  7       -1\r\n 1  3 [-1  -3  5] 3  6  7       -1\r\n 1  3  -1 [-3  5  3] 6  7       3\r\n 1  3  -1  -3 [5  3  6] 7       5\r\n 1  3  -1  -3  5 [3  6  7]      6\r\n</pre>\r\n\r\n<p>Therefore, return the median sliding window as <code>[1,-1,-1,3,5,6]</code>.</p>\r\n\r\n<p><b>Note: </b><br>\r\nYou may assume <code>k</code> is always valid, ie: <code>k</code> is always smaller than input array's size for non-empty array.</p>",
    "tags": "",
    "difficulty": 3,
    "frontend_article_id": 480,
    "article_content": ""
},
{
    "frontend_question_id": 479,
    "article_live": false,
    "title": "Largest Palindrome Product",
    "title_slug": "largest-palindrome-product",
    "content": "<p>Find the largest palindrome made from the product of two n-digit numbers.</p>\r\n<p> Since the result could be very large, you should return the largest palindrome mod 1337.</p>\r\n\r\n<p><b>Example:</b>\r\n<p>Input: 2</p>\r\n<p>Output: 987</p>\r\n<p>Explanation: 99 x 91 = 9009, 9009 % 1337 = 987\r\n</p>\r\n</p>\r\n\r\n\r\n<p><b>Note:</b>\r\n<p>The range of n is [1,8].</p>\r\n</p>\r\n",
    "tags": "",
    "difficulty": 1,
    "frontend_article_id": 479
},
{
    "frontend_question_id": 477,
    "article_live": true,
    "article_slug": "total-hamming-distance",
    "title": "Total Hamming Distance",
    "title_slug": "total-hamming-distance",
    "content": "<p>The <a href=\"https://en.wikipedia.org/wiki/Hamming_distance\" target=\"_blank\">Hamming distance</a> between two integers is the number of positions at which the corresponding bits are different.</p>\r\n\r\n<p>Now your job is to find the total Hamming distance between all pairs of the given numbers.</p\u0010\u0010\u0010\u0010>\r\n\r\n\r\n<p><b>Example:</b><br />\r\n<pre>\r\n<b>Input:</b> 4, 14, 2\r\n\r\n<b>Output:</b> 6\r\n\r\n<b>Explanation:</b> In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just\r\nshowing the four bits relevant in this case). So the answer will be:\r\nHammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>Elements of the given array are in the range of <code>0 </code> to <code>10^9</code>\r\n<li>Length of the array will not exceed <code>10^4</code>. </li>\r\n</ol>\r\n</p>",
    "tags": "Bit Manipulation",
    "difficulty": 2,
    "frontend_article_id": 477,
    "article_content": ""
},
{
    "frontend_question_id": 476,
    "article_live": false,
    "title": "Number Complement",
    "title_slug": "number-complement",
    "content": "<p>Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The given integer is guaranteed to fit within the range of a 32-bit signed integer.</li>\r\n<li>You could assume no leading zero bit in the integer’s binary representation.</li>\r\n</ol>\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> 5\r\n<b>Output:</b> 2\r\n<b>Explanation:</b> The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> 1\r\n<b>Output:</b> 0\r\n<b>Explanation:</b> The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.\r\n</pre>\r\n</p>",
    "tags": "Bit Manipulation",
    "difficulty": 1,
    "frontend_article_id": 476
},
{
    "frontend_question_id": 475,
    "article_live": false,
    "title": "Heaters",
    "title_slug": "heaters",
    "content": "<p>Winter is coming! Your first job during the contest is to design a standard heater with fixed warm radius to warm all the houses.</p>\r\n\r\n<p>Now, you are given positions of houses and heaters on a horizontal line, find out minimum radius of heaters so that all houses could be covered by those heaters.</p>\r\n\r\n<p>So, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters.</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>Numbers of houses and heaters you are given are non-negative and will not exceed 25000.</li>\r\n<li>Positions of houses and heaters you are given are non-negative and will not exceed 10^9.</li>\r\n<li>As long as a house is in the heaters' warm radius range, it can be warmed.</li>\r\n<li>All the heaters follow your radius standard and the warm radius will the same.</li>\r\n</ol>\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [1,2,3],[2]\r\n<b>Output:</b> 1\r\n<b>Explanation:</b> The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> [1,2,3,4],[1,4]\r\n<b>Output:</b> 1\r\n<b>Explanation:</b> The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.\r\n</pre>\r\n</p>",
    "tags": "Binary Search",
    "difficulty": 1,
    "frontend_article_id": 475
},
{
    "frontend_question_id": 474,
    "article_live": true,
    "article_slug": "ones-and-zeroes",
    "title": "Ones and Zeroes",
    "title_slug": "ones-and-zeroes",
    "content": "<p>In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue.</p>\r\n<p>For now, suppose you are a dominator of <b>m</b> <code>0s</code> and <b>n</b> <code>1s</code> respectively. On the other hand, there is an array with strings consisting of only <code>0s</code> and <code>1s</code>.</p>\r\n\r\n<p>\r\nNow your task is to find the maximum number of strings that you can form with given <b>m</b> <code>0s</code> and <b>n</b> <code>1s</code>. Each <code>0</code> and <code>1</code> can be used at most <b>once</b>.\r\n</p>\r\n\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The given numbers of <code>0s</code> and <code>1s</code> will both not exceed <code>100</code></li>\r\n<li>The size of given string array won't exceed <code>600</code>.</li>\r\n</ol>\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> Array = {\"10\", \"0001\", \"111001\", \"1\", \"0\"}, m = 5, n = 3\r\n<b>Output:</b> 4\r\n\r\n<b>Explanation:</b> This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are “10,”0001”,”1”,”0”\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> Array = {\"10\", \"0\", \"1\"}, m = 1, n = 1\r\n<b>Output:</b> 2\r\n\r\n<b>Explanation:</b> You could form \"10\", but then you'd have nothing left. Better form \"0\" and \"1\".\r\n</pre>\r\n</p>",
    "tags": "Dynamic Programming",
    "difficulty": 2,
    "frontend_article_id": 474,
    "article_content": ""
},
{
    "frontend_question_id": 473,
    "article_live": true,
    "article_slug": "matchsticks-to-square",
    "title": "Matchsticks to Square",
    "title_slug": "matchsticks-to-square",
    "content": "<p>Remember the story of Little Match Girl? By now, you know exactly what matchsticks the little match girl has, please find out a way you can make one square by using up all those matchsticks. You should not break any stick, but you can link them up, and each matchstick must be used <b>exactly</b> one time.</P>\r\n\r\n<p> Your input will be several matchsticks the girl has, represented with their stick length. Your output will either be true or false, to represent whether you could make one square using all the matchsticks the little match girl has.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [1,1,2,2,2]\r\n<b>Output:</b> true\r\n\r\n<b>Explanation:</b> You can form a square with length 2, one side of the square came two sticks with length 1.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> [3,3,3,3,4]\r\n<b>Output:</b> false\r\n\r\n<b>Explanation:</b> You cannot find a way to form a square with all the matchsticks.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The length sum of the given matchsticks is in the range of <code>0</code> to <code>10^9</code>.\r\n<li>The length of the given matchstick array will not exceed <code>15</code>.</li>\r\n</ol>\r\n</p>",
    "tags": "Depth-first Search",
    "difficulty": 2,
    "frontend_article_id": 473,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-depth-first-search\">Approach 1: Depth First Search</a></li> \n      <li><a href=\"#approach-2-dynamic-programming\">Approach 2: Dynamic Programming</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <p><br> <strong>Intuition</strong></p> \n  <p>Suppose we have <code>1,1,1,1,2,2,2,2,3,3,3,3</code> as our set of matchsticks. In this case a square of side <script type=\"math/tex; mode=display\">6</script> can be formed and we have 4 matchsticks each of 1, 2 and 3 and so we can have each square side formed by <code>3 + 2 + 1 = 6</code>.</p> \n  <p></p>\n  <center> \n   <img src=\"../Figures/473/473_Matchsticks-In-Square-Diag-1.png\" height=\"400\">\n  </center>\n  <p></p> \n  <p>We can clearly see in the diagram above that the 3 matchsticks of sizes <code>1</code>, <code>2</code> and <code>3</code> combine to give one side of our resulting square.</p> \n  <p>This problem boils down to splitting an array of integers into <script type=\"math/tex; mode=display\">4</script> subsets where all of these subsets are: <em> mutually exclusive i.e. no specific element of the array is shared by any two of these subsets, and </em> have the same sum which is equal to the side of our square.</p> \n  <p>We know that we will have <script type=\"math/tex; mode=display\">4</script> different subsets. The sum of elements of these subsets would be <script type=\"math/tex; mode=display\">\\frac{1}{4}\\sum_{}^{} arr</script>. If the sum if not divisible by <script type=\"math/tex; mode=display\">4</script>, that implies that <script type=\"math/tex; mode=display\">4</script> subsets of equal value are not possible and we don't need to do any further processing on this.</p> \n  <p>The only question that remains now for us to solve is:</p> \n  <blockquote> \n   <p>what subset a particular element belongs to?</p> \n  </blockquote> \n  <p>If we are able to figure that out, then there's nothing else left to do. But, since we can't say which of the <script type=\"math/tex; mode=display\">4</script> subsets would contain a particular element, we try out all the options. <br> <br></p> \n  <hr> \n  <h4 id=\"approach-1-depth-first-search\">Approach 1: Depth First Search</h4> \n  <p>It is possible that a matchstick <strong><em>can</em></strong> be a part of any of the 4 sides of the resulting square, but which one of these choices leads to an actual square is something we don't know.</p> \n  <p>This means that for every matchstick in our given array, we have <script type=\"math/tex; mode=display\">4</script> different options each representing the side of the square or subset that this matchstick can be a part of.</p> \n  <p>We try out all of them and keep on doing this recursively until we exhaust all of the possibilities or until we find an arrangement of our matchsticks such that they form the square.</p> \n  <p><strong>Algorithm</strong></p> \n  <ol> \n   <li> <p>As discussed previously, we will follow a recursive, depth first approach to solve this problem. So, we have a function that takes the current matchstick index we are to process and also the number of sides of the square that are completely formed till now.</p> </li> \n   <li> <p>If all of the matchsticks have been used up and 4 sides have been completely formed, that implies our square is completely formed. This is the base case for the recursion.</p> </li> \n   <li> <p>For the current matchstick we have 4 different options. This matchstick at <script type=\"math/tex; mode=display\">index</script> can be a part of any of the sides of the square. We try out the 4 options by recursing on them.</p> \n    <ul> \n     <li>If any of these recursive calls returns <script type=\"math/tex; mode=display\">True</script>, then we return from there, else we return <script type=\"math/tex; mode=display\">False</script> </li> \n    </ul> </li> \n  </ol> \n  <iframe src=\"https://leetcode.com/playground/PcFBb5tW/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"PcFBb5tW\"></iframe> \n  <p><strong>Implementation Details</strong></p> \n  <p>This solution is very slow as is. However, we can speed it up considerably by a small trick and that is to <code>sort our matchsticks sizes in reverse order before processing them recursively</code>.</p> \n  <p>The reason for this is that if there is no solution, trying a longer matchstick first will get to negative conclusion earlier.</p> \n  <p>e.g. <script type=\"math/tex; mode=display\">[8,4,4,4]</script>. In this case we can have a square of size 5 but the largest side 8 doesn't fit in anywhere i.e. cannot be a part of any of the sides (because we can't break matchsticks according to the question) and hence we can simply return <script type=\"math/tex; mode=display\">False</script> without even considering the remaining matchsticks.</p> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity : <script type=\"math/tex; mode=display\">O(4^N)</script> because we have a total of <script type=\"math/tex; mode=display\">N</script> sticks and for each one of those matchsticks, we have <script type=\"math/tex; mode=display\">4</script> different possibilities for the subsets they might belong to or the side of the square they might be a part of.</p> </li> \n   <li> <p>Space Complexity : <script type=\"math/tex; mode=display\">O(N)</script>. For recursive solutions, the space complexity is the stack space occupied by all the recursive calls. The deepest recursive call here would be of size <script type=\"math/tex; mode=display\">N</script> and hence the space complexity is <script type=\"math/tex; mode=display\">O(N)</script>. There is no additional space other than the recursion stack in this solution. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-dynamic-programming\">Approach 2: Dynamic Programming</h4> \n  <p>In any dynamic programming problem, what's important is that our problem must be breakable into smaller subproblems and also, these subproblems show some sort of overlap which we can save upon by caching or memoization.</p> \n  <p>Suppose we have <code>3,3,4,4,5,5</code> as our matchsticks that have been used already to construct some of the sides of our square (<strong>Note:</strong> not all the sides may be completely constructed at all times.)</p> \n  <p>If the square side is <script type=\"math/tex; mode=display\">8</script>, then there are many possibilities for how the sides can be constructed using the matchsticks above. We can have</p> \n  <pre>  (4, 4), (3, 5), (3, 5) -----------&gt; 3 sides fully constructed.\n  (3, 4), (3, 5), (4), (5) ---------&gt; 0 sides completely constructed.\n  (3, 3), (4, 4), (5), (5) ---------&gt; 1 side completely constructed.\n</pre> \n  <p>As we can see above, there are multiple ways to use the same set of matchsticks and land up in completely different recursion states.</p> \n  <p>This means that if we just keep track of what all matchsticks have been used and which all are remaining, it won't properly define the state of recursion we are in or what subproblem we are solving.</p> \n  <p>A single set of used matchsticks can represent multiple different unrelated subproblems and that is just not right.</p> \n  <p>We also need to keep track of number of sides of the square that have been <strong>completely</strong> formed till now.</p> \n  <p>Also, an important thing to note in the example we just considered was that if the matchsticks being used are <script type=\"math/tex; mode=display\">[3,3,4,4,5,5]</script> and the side of the square is <code>8</code>, then we will always consider that arrangement that forms the most number of complete sides over that arrangement that leads to incomplete sides. Hence, the optimal arrangement here is <script type=\"math/tex; mode=display\">(4, 4), (3, 5), (3, 5)</script> with 3 complete sides of the square.</p> \n  <p>Let us take a look at the following recursion tree to see if in-fact we can get overlapping subproblems.</p> \n  <p></p>\n  <center> \n   <img src=\"../Figures/473/473_Matchsticks-In-Square-Diag-2.png\" width=\"500\">\n  </center>\n  <p></p> \n  <p><strong>Note:</strong> Not all subproblems have been shown in this figure. The thing we wanted to point out was overlapping subproblems.</p> \n  <p>We know that the overall sum of these matchsticks can be split equally into 4 halves. The only thing we don't know is if 4 <strong>equal</strong> halves can be carved out of the given set of matchsticks. For that also we need to keep track of the number of sides completely formed at any point in time. <strong><em>If we end up forming 4 equal sides successfully then naturally we would have used up all of the matchsticks each being used exactly once and we would have formed a square</em></strong>.</p> \n  <p>Let us first look at the pseudo-code for this problem before looking at the exact implementation details for the same.</p> \n  <pre>let square_side = sum(matchsticks) / 4\nfunc recurse(matchsticks_used, sides_formed) {\n    if sides_formed == 4, then {\n        Square Formed!!\n    }\n    for match in matchsticks available, do {\n          add match to matchsticks_used\n          let result = recurse(matchsticks_used, sides_formed)\n          if result == True, then {\n              return True\n          }\n          remove match from matchsticks_used\n    }\n    return False\n}\n</pre> \n  <p>This is the overall structure of our dynamic programming solution. Of-course, a lot of implementation details are missing here that we will address now.</p> \n  <p><br></p> \n  <p><strong>Implementation Details</strong></p> \n  <p>It is very clear from the pseudo-code above that the state of a recursion is defined by two variables <code>matchsticks_used</code> and <code>sides_formed</code>. Hence, these are the two variables that will be used to <strong>memoize</strong> or cache the results for that specific subproblem.</p> \n  <p>The question however is how do we actually store all the matchsticks that have been used? We want a memory efficient solution for this.</p> \n  <p>If we look at the question's constraints, we find that the max number of matchsticks we can have are <script type=\"math/tex; mode=display\">15</script>. That's a pretty small number and we can make use of this constraint.</p> \n  <p>All we need to store is which of the matchsticks from the original list have been used. <code>We can use a Bit-Map for this</code></p> \n  <p>We will use <script type=\"math/tex; mode=display\">N</script> number of bits, one for each of the matchsticks (<script type=\"math/tex; mode=display\">N</script> is at max 15 according to the question's constraints). Initially we will start with a bit mask of <code>all 1s</code> and then as we keep on using the matchsticks, we will keep on setting their corresponding bits to <code>0</code>.</p> \n  <p>This way, we just have to hash an integer value which represents our bit-map and the max value for this mask would be <script type=\"math/tex; mode=display\">2^{15}</script>.</p> \n  <p><br></p> \n  <p><strong>Do we really need to see if all 4 sides have been completely formed ?</strong></p> \n  <p>Another implementation trick that helps optimize this solution is that we don't really need to see if 4 sides have been completely formed.</p> \n  <p>This is because, we already know that the sum of all the matchsticks is divisible by 4. So, <em>if 3 equal sides have been formed by using some of the matchsticks, then the remaining matchsticks would definitely form the remaining side of our square.</em></p> \n  <p>Hence, we only need to check if 3 sides of our square can be formed or not.</p> \n  <iframe src=\"https://leetcode.com/playground/yNytHY5x/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"yNytHY5x\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity : <script type=\"math/tex; mode=display\">O(N \\times 2^N)</script>. At max <script type=\"math/tex; mode=display\">2^N</script> unique bit masks are possible and during every recursive call, we iterate our original matchsticks array to sum up the values of matchsticks used to update the <code>sides_formed</code> variable.</p> </li> \n   <li> <p>Space Complexity : <script type=\"math/tex; mode=display\">O(N + 2^N)</script> because <script type=\"math/tex; mode=display\">N</script> is the stack space taken up by recursion and <script type=\"math/tex; mode=display\">4 \\times 2^N</script> = <script type=\"math/tex; mode=display\">O(2^N)</script> is the max possible size of our cache for memoization.</p> \n    <ul> \n     <li>The size of the cache is defined by the two variables <code>sides_formed</code> and <code>mask</code>. The number of different values that <code>sides_formed</code> can take = 4 and number of unique values of <code>mask</code> = <script type=\"math/tex; mode=display\">2^N</script>.</li> \n    </ul> </li> \n  </ul> \n  <p><br> <br></p> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/sachinmalhotra1993\">@sachinmalhotra1993</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 472,
    "article_live": false,
    "title": "Concatenated Words",
    "title_slug": "concatenated-words",
    "content": "Given a list of words (<b>without duplicates</b>), please write a program that returns all concatenated words in the given list of words.\r\n<p>A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.</p>\r\n\r\n<p><b>Example:</b><br />\r\n<pre>\r\n<b>Input:</b> [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]\r\n\r\n<b>Output:</b> [\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]\r\n\r\n<b>Explanation:</b> \"catsdogcats\" can be concatenated by \"cats\", \"dog\" and \"cats\"; <br> \"dogcatsdog\" can be concatenated by \"dog\", \"cats\" and \"dog\"; <br>\"ratcatdogcat\" can be concatenated by \"rat\", \"cat\", \"dog\" and \"cat\".\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The number of elements of the given array will not exceed <code>10,000 </code>\r\n<li>The length sum of elements in the given array will not exceed <code>600,000</code>. </li>\r\n<li>All the input string will only include lower case letters.</li>\r\n<li>The returned elements order does not matter. </li>\r\n</ol>\r\n</p>",
    "tags": "Dynamic Programming, Depth-first Search, Trie",
    "difficulty": 3,
    "frontend_article_id": 472
},
{
    "frontend_question_id": 471,
    "article_live": false,
    "title": "Encode String with Shortest Length",
    "title_slug": "encode-string-with-shortest-length",
    "tags": "Dynamic Programming",
    "difficulty": 3,
    "frontend_article_id": 471
},
{
    "frontend_question_id": 469,
    "article_live": false,
    "title": "Convex Polygon",
    "title_slug": "convex-polygon",
    "tags": "Math",
    "difficulty": 2,
    "frontend_article_id": 469
},
{
    "frontend_question_id": 468,
    "article_live": false,
    "title": "Validate IP Address",
    "title_slug": "validate-ip-address",
    "content": "<p>\r\nWrite a function to check whether an input string is a valid IPv4 address or IPv6 address or neither.\r\n</p>\r\n\r\n<p>\r\n<b>IPv4</b> addresses are canonically represented in dot-decimal notation, which consists of four decimal numbers, each ranging from 0 to 255, separated by dots (\".\"), e.g.,<code>172.16.254.1</code>;\r\n</p>\r\n\r\n<p>\r\nBesides, leading zeros in the IPv4 is invalid. For example, the address <code>172.16.254.01</code> is invalid.\r\n</p>\r\n\r\n<p>\r\n<b>IPv6</b> addresses are represented as eight groups of four hexadecimal digits, each group representing 16 bits. The groups are separated by colons (\":\"). For example, the address <code>2001:0db8:85a3:0000:0000:8a2e:0370:7334</code> is a valid one. Also, we could omit some leading zeros among four hexadecimal digits and some low-case characters in the address to upper-case ones, so <code>2001:db8:85a3:0:0:8A2E:0370:7334</code> is also a valid IPv6 address(Omit leading zeros and using upper cases).\r\n</p>\r\n\r\n\r\n<p>\r\nHowever, we don't replace a consecutive group of zero value with a single empty group using two consecutive colons (::) to pursue simplicity. For example, <code>2001:0db8:85a3::8A2E:0370:7334</code> is an invalid IPv6 address.\r\n</p>\r\n\r\n<p>\r\nBesides, extra leading zeros in the IPv6 is also invalid. For example, the address <code>02001:0db8:85a3:0000:0000:8a2e:0370:7334</code> is invalid.\r\n</p>\r\n\r\n\r\n<p><b>Note:</b>\r\nYou may assume there is no extra space or special characters in the input string.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \"172.16.254.1\"\r\n\r\n<b>Output:</b> \"IPv4\"\r\n\r\n<b>Explanation:</b> This is a valid IPv4 address, return \"IPv4\".\r\n</pre>\r\n</p>\r\n\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> \"2001:0db8:85a3:0:0:8A2E:0370:7334\"\r\n\r\n<b>Output:</b> \"IPv6\"\r\n\r\n<b>Explanation:</b> This is a valid IPv6 address, return \"IPv6\".\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 3:</b><br />\r\n<pre>\r\n<b>Input:</b> \"256.256.256.256\"\r\n\r\n<b>Output:</b> \"Neither\"\r\n\r\n<b>Explanation:</b> This is neither a IPv4 address nor a IPv6 address.\r\n</pre>\r\n</p>",
    "tags": "String",
    "difficulty": 2,
    "frontend_article_id": 468
},
{
    "frontend_question_id": 467,
    "article_live": false,
    "title": "Unique Substrings in Wraparound String",
    "title_slug": "unique-substrings-in-wraparound-string",
    "content": "<p>Consider the string <code>s</code> to be the infinite wraparound string of \"abcdefghijklmnopqrstuvwxyz\", so <code>s</code> will look like this: \"...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....\".</p>\r\n\r\n<p>Now we have another string <code>p</code>. Your job is to find out how many unique non-empty substrings of <code>p</code> are present in <code>s</code>. In particular, your input is the string <code>p</code> and you need to output the number of different non-empty substrings of <code>p</code> in the string <code>s</code>.</p>\r\n\r\n<p><b>Note:</b> <code>p</code> consists of only lowercase English letters and the size of p might be over 10000.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \"a\"\r\n<b>Output:</b> 1\r\n\r\n<b>Explanation:</b> Only the substring \"a\" of string \"a\" is in the string \u0010s.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> \"cac\"\r\n<b>Output:</b> 2\r\n<b>Explanation:</b> There are two substrings \"a\", \"c\" of string \"cac\" in the string s.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 3:</b><br />\r\n<pre>\r\n<b>Input:</b> \"zab\"\r\n<b>Output:</b> 6\r\n<b>Explanation:</b> There are six substrings \"z\", \"a\", \"b\", \"za\", \"ab\", \"zab\" of string \"zab\" in the string s.\r\n</pre>\r\n</p>",
    "tags": "Dynamic Programming",
    "difficulty": 2,
    "frontend_article_id": 467
},
{
    "frontend_question_id": 466,
    "article_live": true,
    "article_slug": "count-the-repetitions",
    "title": "Count The Repetitions",
    "title_slug": "count-the-repetitions",
    "content": "<p>Define <code>S = [s,n]</code> as the string S which consists of n connected strings s. For example, <code>[\"abc\", 3]</code> =\"abcabcabc\". </p>\r\n<p>On the other hand, we define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1. For example, “abc”  can be obtained from “abdbec” based on our definition, but it can not be obtained from “acbbe”.</p>\r\n<p>You are given two non-empty strings s1 and s2 (each at most 100 characters long) and two integers 0 &le; n1 &le; 10<sup>6</sup> and 1 &le; n2 &le; 10<sup>6</sup>. Now consider the strings S1 and S2, where <code>S1=[s1,n1]</code> and <code>S2=[s2,n2]</code>. Find the maximum integer M such that <code>[S2,M]</code> can be obtained from <code>S1</code>.</p>\r\n\r\n<p><b>Example:</b>\r\n<pre>\r\nInput:\r\ns1=\"acb\", n1=4\r\ns2=\"ab\", n2=2\r\n\r\nReturn:\r\n2\r\n</pre>\r\n</p>",
    "tags": "Dynamic Programming",
    "difficulty": 3,
    "frontend_article_id": 466,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute force [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-a-better-brute-force-accepted\">Approach #2 A better brute force [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute force [Time Limit Exceeded]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>According to the question, we need to find <script type=\"math/tex; mode=display\">m</script> such that <script type=\"math/tex; mode=display\">[S2,m]</script> is the largest subsequence that can be found in <script type=\"math/tex; mode=display\">S1</script>. <script type=\"math/tex; mode=display\">S2</script> is essentially <script type=\"math/tex; mode=display\">[s2,n2]</script> and <script type=\"math/tex; mode=display\">S1</script> is <script type=\"math/tex; mode=display\">[s1,n1]</script> and so, we can find the number of times <script type=\"math/tex; mode=display\">s2</script> repeats in <script type=\"math/tex; mode=display\">[s1,n1]</script>, say <script type=\"math/tex; mode=display\">\\text{repeat_count}</script>. And the number of times <script type=\"math/tex; mode=display\">S2</script> repeats in <script type=\"math/tex; mode=display\">S1</script> is therefore <script type=\"math/tex; mode=display\">\\text{(repeat_count/n2)}</script>. Simple.</p> \n  <p><strong>Algorithm</strong></p> \n  <ul> \n   <li>Initialize <script type=\"math/tex; mode=display\">\\text{index=0}</script> and <script type=\"math/tex; mode=display\">\\text{repeat_count=0}</script>. <script type=\"math/tex; mode=display\">\\text{index}</script> represents the current index in <script type=\"math/tex; mode=display\">s2</script> to be checked against <script type=\"math/tex; mode=display\">s1</script> and <script type=\"math/tex; mode=display\">\\text{repeat_count}</script> represents the number of times <script type=\"math/tex; mode=display\">s2</script> repeats in <script type=\"math/tex; mode=display\">S1</script>.</li> \n   <li>Iterate over the variable <script type=\"math/tex; mode=display\">i</script> from <script type=\"math/tex; mode=display\">0</script> to <script type=\"math/tex; mode=display\">n1-1</script>:\n    <ul> \n     <li>Iterate over the variable <script type=\"math/tex; mode=display\">j</script> from <script type=\"math/tex; mode=display\">0</script> to <script type=\"math/tex; mode=display\">\\text{size(s1)}-1</script>: \n      <ul> \n       <li>If <script type=\"math/tex; mode=display\">\\text{s1[j] }</script> is equal to <script type=\"math/tex; mode=display\">\\text{s2[index]}</script>, increment <script type=\"math/tex; mode=display\">\\text{index}</script>.</li> \n       <li>If <script type=\"math/tex; mode=display\">index</script> is equal to <script type=\"math/tex; mode=display\">size(s2)</script>, this implies that <script type=\"math/tex; mode=display\">s2</script> has completed one repartition and hence set <script type=\"math/tex; mode=display\">\\text{index=0}</script> and increment the <script type=\"math/tex; mode=display\">\\text{repeat_count}</script>.</li> \n      </ul> </li> \n    </ul> </li> \n   <li>Return <script type=\"math/tex; mode=display\">\\text{(repeat_count / n2)}</script> since, <script type=\"math/tex; mode=display\">S2</script> is <script type=\"math/tex; mode=display\">\\text{[s2,n2]}</script>.</li> \n  </ul> \n  <iframe src=\"https://leetcode.com/playground/y5jtZgJj/shared\" frameborder=\"0\" name=\"y5jtZgJj\" width=\"100%\" height=\"326\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity: <script type=\"math/tex; mode=display\">O(n1*size(s1))</script>.</p> \n    <ul> \n     <li>We iterate over the entire length of string <script type=\"math/tex; mode=display\">s1</script> for <script type=\"math/tex; mode=display\">n1</script> times.</li> \n    </ul> </li> \n   <li> <p>Space complexity: <script type=\"math/tex; mode=display\">O(1)</script> extra space for <script type=\"math/tex; mode=display\">\\text{index}</script> and <script type=\"math/tex; mode=display\">\\text{repeat_count}</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-a-better-brute-force-accepted\">Approach #2 A better brute force [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>In Approach #1, we simply checked for repetition over the entire <script type=\"math/tex; mode=display\">[s1,n1]</script>. However, <script type=\"math/tex; mode=display\">n1</script> could be quiet large and thus, is inefficient to iterate over complete <script type=\"math/tex; mode=display\">S1</script>. We can take advantage of the fact that <script type=\"math/tex; mode=display\">s1</script> is repeating and hence, we could find a pattern of repetition of <script type=\"math/tex; mode=display\">s2</script> in <script type=\"math/tex; mode=display\">S1</script>. Once, we get the repetition pattern, we can easy calculate how many times the pattern repeats in <script type=\"math/tex; mode=display\">n2</script> in <script type=\"math/tex; mode=display\">O(1)</script>.</p> \n  <p><em>But what's the pattern!</em></p> \n  <p>In approach #1, we kept <script type=\"math/tex; mode=display\">\\text{index}</script> which tells the index to search in <script type=\"math/tex; mode=display\">s2</script>. We try to see in the below illustration if this <script type=\"math/tex; mode=display\">\\text{index}</script> repeats itself after some fixed iterations of <script type=\"math/tex; mode=display\">s1</script> or not and if so, then how can we leverage it.</p> \n  <p align=\"center\"><img alt=\"Count the repitition\" src=\"../Figures/466/count_the_repititions.png\" width=\"700px\"></p> \n  <p>After finding the repitition pattern, we can calculate the sum of repeating pattern, part before repitition and part left after repitition as the result in <script type=\"math/tex; mode=display\">O(1)</script>. </p> \n  <p><em>But will this repitition always take place?</em></p> \n  <p>Yes! By <strong>Pigeonhole principle</strong>, which states that if <script type=\"math/tex; mode=display\">n</script> items are put into <script type=\"math/tex; mode=display\">m</script> containers, with <script type=\"math/tex; mode=display\">n > m</script>, then at least one container must contain more than one item. So, according to this, we are sure to find 2 same <script type=\"math/tex; mode=display\">index</script> after scanning at max <script type=\"math/tex; mode=display\">\\text{size(s2)}</script> blocks of <script type=\"math/tex; mode=display\">s1</script>.</p> \n  <p><strong>Algorithm</strong></p> \n  <ul> \n   <li>Intialize <script type=\"math/tex; mode=display\">count=0</script> nd <script type=\"math/tex; mode=display\">index=0</script>, which are same as in Approach #1.</li> \n   <li>Initialize 2 arrays, say <script type=\"math/tex; mode=display\">\\text{indexr}</script> and <script type=\"math/tex; mode=display\">\\text{countr}</script> of size <script type=\"math/tex; mode=display\">(\\text{size(s2)}+1)</script>, initialized with 0. The size <script type=\"math/tex; mode=display\">(\\text{size(s2)}+1)</script> is based on the Pigeonhole principle as discussed above. The 2 arrays specifies the <script type=\"math/tex; mode=display\">\\text{index}</script> and <script type=\"math/tex; mode=display\">\\text{count}</script> at the start of each <script type=\"math/tex; mode=display\">s1</script> block.</li> \n   <li>Iterate over <script type=\"math/tex; mode=display\">i</script> from <script type=\"math/tex; mode=display\">0</script> to <script type=\"math/tex; mode=display\">n1-1</script>:\n    <ul> \n     <li>Iterate over <script type=\"math/tex; mode=display\">j</script> from <script type=\"math/tex; mode=display\">0</script> to <script type=\"math/tex; mode=display\">\\text{size(s1)}-1</script>:\n      <ul> \n       <li>If <script type=\"math/tex; mode=display\">\\text{s1[j]} == \\text{s2[index]}</script>, increment <script type=\"math/tex; mode=display\">\\text{index}</script>.</li> \n       <li>If <script type=\"math/tex; mode=display\">\\text{index}</script> is equal to <script type=\"math/tex; mode=display\">\\text{size(s2)}</script>, set <script type=\"math/tex; mode=display\">\\text{index} = 0</script> and increment <script type=\"math/tex; mode=display\">\\text{count}</script>.</li> \n      </ul> </li> \n     <li>Set <script type=\"math/tex; mode=display\">\\text{countr[i]}=\\text{count}</script> and <script type=\"math/tex; mode=display\">\\text{indexr[i]}=\\text{index}</script> </li> \n     <li> <p>Iterate over <script type=\"math/tex; mode=display\">k</script> from <script type=\"math/tex; mode=display\">0</script> to <script type=\"math/tex; mode=display\">i-1</script>:</p> \n      <ul> \n       <li>If we find the repitition, i.e. current <script type=\"math/tex; mode=display\">\\text{index} = \\text{indexr[k]}</script>, we calculate the count for block before the repitition starts, the repeating block and the block left after repitition pattern, which can be calculated as:</li> \n      </ul> <p> <script type=\"math/tex; mode=display\">\n\\begin{align}\n\\text{prev_count} &= \\text{countr}[k] \\\\\n\\text{pattern_count} &= (\\text{countr}[i] - \\text{countr}[k]) * \\frac{n1 - 1 - k}{i - k} \\\\\n\\text{remain_count} &= \\text{countr}\\left[k + \\left(n1 - 1 - k\\right) \\% \\left(i - k \\right)\\right] - \\text{countr}[k]\n\\end{align}\n</script> </p> \n      <ul> \n       <li>Sum the 3 counts and return the sum divided by <script type=\"math/tex; mode=display\">n2</script>, since <script type=\"math/tex; mode=display\">\\text{S2 = [s2,n2]}</script> </li> \n       <li>If no repetition is found, return <script type=\"math/tex; mode=display\">\\text{countr[n1-1]/n2}</script>.</li> \n      </ul> </li> \n    </ul> </li> \n  </ul> \n  <iframe src=\"https://leetcode.com/playground/2UJEXG8V/shared\" frameborder=\"0\" name=\"2UJEXG8V\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity: <script type=\"math/tex; mode=display\">\\text{O(size(s1)*size(s2))}</script>.</p> \n    <ul> \n     <li>According to the Pigeonhole principle, we need to iterate over <script type=\"math/tex; mode=display\">s1</script> only <script type=\"math/tex; mode=display\">(\\text{size(s2)+1})</script> times at max.</li> \n    </ul> </li> \n   <li> <p>Space complexity: <script type=\"math/tex; mode=display\">O(\\text{size(s2)})</script> extra space for <script type=\"math/tex; mode=display\">\\text{indexr}</script> and <script type=\"math/tex; mode=display\">\\text{countr}</script> string.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by <a href=\"https://leetcode.com/abhinavbansal0\">@abhinavbansal0</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 465,
    "article_live": false,
    "title": "Optimal Account Balancing",
    "title_slug": "optimal-account-balancing",
    "tags": "",
    "difficulty": 3,
    "frontend_article_id": 465
},
{
    "frontend_question_id": 464,
    "article_live": false,
    "title": "Can I Win",
    "title_slug": "can-i-win",
    "content": "<p>In the \"100 game,\" two players take turns adding, to a running total, any integer from 1..10. The player who first causes the running total to reach or exceed 100 wins. </p>\r\n\r\n<p>What if we change the game so that players cannot re-use integers? </p>\r\n\r\n<p>For example, two players might take turns drawing from a common pool of numbers of 1..15 without replacement until they reach a total >= 100.</p>\r\n\r\n<p>Given an integer <code>maxChoosableInteger</code> and another integer <code>desiredTotal</code>, determine if the first player to move can force a win, assuming both players play optimally. </p>\r\n\r\n<p>You can always assume that <code>maxChoosableInteger</code> will not be larger than 20 and <code>desiredTotal</code> will not be larger than 300.\r\n</p>\r\n\r\n<p><b>Example</b>\r\n<pre>\r\n<b>Input:</b>\r\nmaxChoosableInteger = 10\r\ndesiredTotal = 11\r\n\r\n<b>Output:</b>\r\nfalse\r\n\r\n<b>Explanation:</b>\r\nNo matter which integer the first player choose, the first player will lose.\r\nThe first player can choose an integer from 1 up to 10.\r\nIf the first player choose 1, the second player can only choose integers from 2 up to 10.\r\nThe second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.\r\nSame with other integers chosen by the first player, the second player will always win.\r\n</pre>\r\n</p>",
    "tags": "Dynamic Programming, Minimax",
    "difficulty": 2,
    "frontend_article_id": 464
},
{
    "frontend_question_id": 463,
    "article_live": false,
    "title": "Island Perimeter",
    "title_slug": "island-perimeter",
    "content": "<p>You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water.</p>\r\n\r\n<p>Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).</p>\r\n\r\n<p>The island doesn&#39;t have &quot;lakes&quot; (water inside that isn&#39;t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don&#39;t exceed 100. Determine the perimeter of the island.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Example:</b></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>\r\n[[0,1,0,0],\r\n [1,1,1,0],\r\n [0,1,0,0],\r\n [1,1,0,0]]\r\n\r\n<strong>Output:</strong> 16\r\n\r\n<strong>Explanation:</strong> The perimeter is the 16 yellow stripes in the image below:\r\n\r\n<img src=\"https://assets.leetcode.com/uploads/2018/10/12/island.png\" style=\"width: 221px; height: 213px;\" />\r\n</pre>\r\n",
    "tags": "Hash Table",
    "difficulty": 1,
    "frontend_article_id": 463
},
{
    "frontend_question_id": 462,
    "article_live": true,
    "article_slug": "minimum-moves-to-equal-array-elements-ii",
    "title": "Minimum Moves to Equal Array Elements II",
    "title_slug": "minimum-moves-to-equal-array-elements-ii",
    "content": "<p><p>Given a <b>non-empty</b> integer array, find the minimum number of moves required to make all array elements equal, where a move is incrementing a selected element by 1 or decrementing a selected element by 1.</p>\r\n\r\n<p>You may assume the array's length is at most 10,000.</p>\r\n\r\n<p><b>Example:</b>\r\n<pre>\r\n<b>Input:</b>\r\n[1,2,3]\r\n\r\n<b>Output:</b>\r\n2\r\n\r\n<b>Explanation:</b>\r\nOnly two moves are needed (remember each move increments or decrements one element):\r\n\r\n[1,2,3]  =>  [2,2,3]  =>  [2,2,2]\r\n</pre>\r\n</p></p>",
    "tags": "Math",
    "difficulty": 2,
    "frontend_article_id": 462,
    "article_content": ""
},
{
    "frontend_question_id": 461,
    "article_live": false,
    "title": "Hamming Distance",
    "title_slug": "hamming-distance",
    "content": "<p>The <a href=\"https://en.wikipedia.org/wiki/Hamming_distance\" target=\"_blank\">Hamming distance</a> between two integers is the number of positions at which the corresponding bits are different.</p>\r\n\r\n<p>Given two integers <code>x</code> and <code>y</code>, calculate the Hamming distance.</p>\r\n\r\n<p><b>Note:</b><br />\r\n0 &le; <code>x</code>, <code>y</code> &lt; 2<sup>31</sup>.\r\n</p>\r\n\r\n<p><b>Example:</b>\r\n<pre>\r\n<b>Input:</b> x = 1, y = 4\r\n\r\n<b>Output:</b> 2\r\n\r\n<b>Explanation:</b>\r\n1   (0 0 0 1)\r\n4   (0 1 0 0)\r\n       &uarr;   &uarr;\r\n\r\nThe above arrows point to positions where the corresponding bits are different.\r\n</pre>\r\n</p>",
    "tags": "Bit Manipulation",
    "difficulty": 1,
    "frontend_article_id": 461
},
{
    "frontend_question_id": 460,
    "article_live": false,
    "title": "LFU Cache",
    "title_slug": "lfu-cache",
    "content": "<p>Design and implement a data structure for <a href=\"https://en.wikipedia.org/wiki/Least_frequently_used\" target=\"_blank\">Least Frequently Used (LFU)</a> cache. It should support the following operations: <code>get</code> and <code>put</code>.\r\n</p>\r\n\r\n<p>\r\n<code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br>\r\n<code>put(key, value)</code> - Set or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least frequently used item before inserting a new item. For the purpose of this problem, when there is a tie (i.e., two or more keys that have the same frequency), the least <b>recently</b> used key would be evicted.\r\n</p>\r\n\r\n<p><b>Follow up:</b><br />\r\nCould you do both operations in <b>O(1)</b> time complexity?</p>\r\n\r\n<p><b>Example:</b>\r\n<pre>\r\nLFUCache cache = new LFUCache( 2 /* capacity */ );\r\n\r\ncache.put(1, 1);\r\ncache.put(2, 2);\r\ncache.get(1);       // returns 1\r\ncache.put(3, 3);    // evicts key 2\r\ncache.get(2);       // returns -1 (not found)\r\ncache.get(3);       // returns 3.\r\ncache.put(4, 4);    // evicts key 1.\r\ncache.get(1);       // returns -1 (not found)\r\ncache.get(3);       // returns 3\r\ncache.get(4);       // returns 4\r\n</pre>\r\n</p>",
    "tags": "Design",
    "difficulty": 3,
    "frontend_article_id": 460
},
{
    "frontend_question_id": 459,
    "article_live": false,
    "title": "Repeated Substring Pattern",
    "title_slug": "repeated-substring-pattern",
    "content": "<p>Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> &quot;abab&quot;\r\n<b>Output:</b> True\r\n<b>Explanation:</b> It&#39;s the substring &quot;ab&quot; twice.\r\n</pre>\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> &quot;aba&quot;\r\n<b>Output:</b> False\r\n</pre>\r\n\r\n<p><b>Example 3:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> &quot;abcabcabcabc&quot;\r\n<b>Output:</b> True\r\n<b>Explanation:</b> It&#39;s the substring &quot;abc&quot; four times. (And the substring &quot;abcabc&quot; twice.)\r\n</pre>\r\n",
    "tags": "String",
    "difficulty": 1,
    "frontend_article_id": 459
},
{
    "frontend_question_id": 458,
    "article_live": false,
    "title": "Poor Pigs",
    "title_slug": "poor-pigs",
    "content": "<p>There are 1000 buckets, one and only one of them contains poison, the rest are filled with water. They all look the same. If a pig drinks that poison it will die within 15 minutes. What is the minimum amount of pigs you need to figure out which bucket contains the poison within one hour.</p>\r\n\r\n<p>Answer this question, and write an algorithm for the follow-up general case.</p>\r\n\r\n<p><b>Follow-up: </b></p>\r\n\r\n<p>If there are n buckets and a pig drinking poison will die within m minutes, how many pigs (x) you need to figure out the &quot;poison&quot; bucket within p minutes? There is exact one bucket with poison.</p>\r\n",
    "tags": "",
    "difficulty": 1,
    "frontend_article_id": 458
},
{
    "frontend_question_id": 457,
    "article_live": false,
    "title": "Circular Array Loop",
    "title_slug": "circular-array-loop",
    "content": "<p>You are given an array of positive and negative integers. If a number n at an index is positive, then move forward n steps. Conversely, if it&#39;s negative (-n), move backward n steps. Assume the first element of the array is forward next to the last element, and the last element is backward next to the first element. Determine if there is a loop in this array. A loop starts and ends at a particular index with more than 1 element along the loop. The loop must be &quot;forward&quot; or &quot;backward&#39;.</p>\r\n\r\n<p><b>Example 1:</b> Given the array [2, -1, 1, 2, 2], there is a loop, from index 0 -&gt; 2 -&gt; 3 -&gt; 0.</p>\r\n\r\n<p><b>Example 2:</b> Given the array [-1, 2], there is no loop.</p>\r\n\r\n<p><b>Note:</b> The given array is guaranteed to contain no element &quot;0&quot;.</p>\r\n\r\n<p>Can you do it in <b>O(n)</b> time complexity and <b>O(1)</b> space complexity?</p>\r\n",
    "tags": "",
    "difficulty": 2,
    "frontend_article_id": 457
},
{
    "frontend_question_id": 456,
    "article_live": true,
    "article_slug": "132-pattern",
    "title": "132 Pattern",
    "title_slug": "132-pattern",
    "content": "<p>\r\nGiven a sequence of n integers a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub>, a 132 pattern is a subsequence a<sub><b>i</b></sub>, a<sub><b>j</b></sub>, a<sub><b>k</b></sub> such\r\nthat <b>i</b> < <b>j</b> < <b>k</b> and a<sub><b>i</b></sub> < a<sub><b>k</b></sub> < a<sub><b>j</b></sub>. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list.</p>\r\n\r\n<p><b>Note:</b> n will be less than 15,000.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [1, 2, 3, 4]\r\n\r\n<b>Output:</b> False\r\n\r\n<b>Explanation:</b> There is no 132 pattern in the sequence.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> [3, 1, 4, 2]\r\n\r\n<b>Output:</b> True\r\n\r\n<b>Explanation:</b> There is a 132 pattern in the sequence: [1, 4, 2].\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 3:</b><br />\r\n<pre>\r\n<b>Input:</b> [-1, 3, 2, 0]\r\n\r\n<b>Output:</b> True\r\n\r\n<b>Explanation:</b> There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].\r\n</pre>\r\n</p>",
    "tags": "Stack",
    "difficulty": 2,
    "frontend_article_id": 456,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-better-brute-force-accepted\">Approach #2 Better Brute Force [Accepted]</a></li> \n      <li><a href=\"#approach-3-searching-intervals-accepted\">Approach #3 Searching Intervals [Accepted]</a></li> \n      <li><a href=\"#approach-4-using-stack-accepted\">Approach #4 Using Stack [Accepted]:</a></li> \n      <li><a href=\"#approach-5-using-binary-search-accepted\">Approach #5 Using Binary Search [Accepted]:</a></li> \n      <li><a href=\"#approach-6-using-array-as-a-stackaccepted\">Approach #6 Using Array as a stack[Accepted]:</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</h4> \n  <p>The simplest solution is to consider every triplet <script type=\"math/tex; mode=display\">(i, j, k)</script> and check if the corresponding numbers satisfy the 132 criteria. If any such triplet is found, we can return a True value. If no such triplet is found, we need to return a False value.</p> \n  <iframe src=\"https://leetcode.com/playground/WxSeh6mX/shared\" frameborder=\"0\" name=\"WxSeh6mX\" width=\"100%\" height=\"292\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^3)</script>. Three loops are used to consider every possible triplet. Here, <script type=\"math/tex; mode=display\">n</script> refers to the size of <script type=\"math/tex; mode=display\">nums</script> array.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant extra space is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-better-brute-force-accepted\">Approach #2 Better Brute Force [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>We can improve the last approach to some extent, if we make use of some observations. We can note that for a particular number <script type=\"math/tex; mode=display\">nums[j]</script> chosen as 2nd element in the 132 pattern, if we don't consider <script type=\"math/tex; mode=display\">nums[k]</script>(the 3rd element) for the time being, our job is to find out the first element, <script type=\"math/tex; mode=display\">nums[i]</script>(<script type=\"math/tex; mode=display\">i<j</script>) which is lesser than <script type=\"math/tex; mode=display\">nums[j]</script>. </p> \n  <p>Now, assume that we have somehow found a <script type=\"math/tex; mode=display\">nums[i],nums[j]</script> pair. Our task now reduces to finding out a <script type=\"math/tex; mode=display\">nums[k]</script>(<script type=\"math/tex; mode=display\">Kk>j>i)</script>, which falls in the range <script type=\"math/tex; mode=display\">(nums[i], nums[j])</script>. Now, to maximize the likelihood of a <script type=\"math/tex; mode=display\">nums[k]</script> falling in this range, we need to increase this range as much as possible. </p> \n  <p>Since, we started off by fixing a <script type=\"math/tex; mode=display\">nums[j]</script>, the only option in our hand is to choose a minimum value of <script type=\"math/tex; mode=display\">nums[i]</script> given a particular <script type=\"math/tex; mode=display\">nums[j]</script>. Once, this pair <script type=\"math/tex; mode=display\">nums[i],nums[j]</script>, has been found out, we simply need to traverse beyond the index <script type=\"math/tex; mode=display\">j</script> to find if a <script type=\"math/tex; mode=display\">nums[k]</script> exists for this pair satisfying the 132 criteria.</p> \n  <p>Based on the above observations, while traversing over the <script type=\"math/tex; mode=display\">nums</script> array choosing various values of <script type=\"math/tex; mode=display\">nums[j]</script>, we simultaneously keep a track of the minimum element found so far(excluding <script type=\"math/tex; mode=display\">nums[j]</script>). This minimum element always serves as the <script type=\"math/tex; mode=display\">nums[i]</script> for the current <script type=\"math/tex; mode=display\">nums[j]</script>. Thus, we only need to traverse beyond the <script type=\"math/tex; mode=display\">j^{th}</script> index to check the <script type=\"math/tex; mode=display\">nums[k]</script>'s to determine if any of them satisfies the 132 criteria.</p> \n  <iframe src=\"https://leetcode.com/playground/otcaotVk/shared\" frameborder=\"0\" name=\"otcaotVk\" width=\"100%\" height=\"292\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^2)</script>. Two loops are used to find the <script type=\"math/tex; mode=display\">nums[j],nums[k]</script> pairs. Here, <script type=\"math/tex; mode=display\">n</script> refers to the size of <script type=\"math/tex; mode=display\">nums</script> array.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant extra space is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-searching-intervals-accepted\">Approach #3 Searching Intervals [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>As discussed in the last approach, once we've fixed a <script type=\"math/tex; mode=display\">nums[i],nums[j]</script> pair, we just need to determine a <script type=\"math/tex; mode=display\">nums[k]</script> which falls in the range <script type=\"math/tex; mode=display\">(nums[i],nums[j])</script>. Further, to maximize the likelihood of any arbitrary <script type=\"math/tex; mode=display\">nums[k]</script> falling in this range, we need to try to keep this range as much as possible. But, in the last approach, we tried to work only on <script type=\"math/tex; mode=display\">nums[i]</script>. But, it'll be a better choice, if we can somehow work out on <script type=\"math/tex; mode=display\">nums[j]</script> as well.</p> \n  <p>To do so, we can look at the given <script type=\"math/tex; mode=display\">nums</script> array in the form of a graph, as shown below:</p> \n  <p align=\"center\"><img alt=\"Graph\" src=\"../Figures/456/456_132_Pattern.PNG\"></p> \n  <p>From the above graph, which consists of rising and falling slopes, we know, the best qualifiers to act as the <script type=\"math/tex; mode=display\">nums[i],nums[j]</script> pair, as discussed above, to maximize the range <script type=\"math/tex; mode=display\">nums[i], nums[j]</script>, at any instant, while traversing the <script type=\"math/tex; mode=display\">nums</script> array, will be the points at the endpoints of a local rising slope. Thus, once we've found such points, we can traverse over the <script type=\"math/tex; mode=display\">nums</script> array to find a <script type=\"math/tex; mode=display\">nums[k]</script> satisfying the given 132 criteria. </p> \n  <p>To find these points at the ends of a local rising slope, we can traverse over the given <script type=\"math/tex; mode=display\">nums</script> array. While traversing, we can keep a track of the minimum point found after the last peak(<script type=\"math/tex; mode=display\">nums[s]</script>). </p> \n  <p>Now, whenever we encounter a falling slope, say, at index <script type=\"math/tex; mode=display\">i</script>, we know, that <script type=\"math/tex; mode=display\">nums[i-1]</script> was the endpoint of the last rising slope found. Thus, we can scan over the <script type=\"math/tex; mode=display\">k</script> indices(k&gt;i), to find a 132 pattern.</p> \n  <p>But, instead of traversing over <script type=\"math/tex; mode=display\">nums</script> to find a <script type=\"math/tex; mode=display\">k</script> satisfying the 132 pattern for every such rising slope, we can store this range <script type=\"math/tex; mode=display\">(nums[s], nums[i-1])</script>(acting as <script type=\"math/tex; mode=display\">(nums[i], nums[j])</script>) in, say an <script type=\"math/tex; mode=display\">intervals</script> array. </p> \n  <p>While traversing over the <script type=\"math/tex; mode=display\">nums</script> array to check the rising/falling slopes, whenever we find any rising slope, we can keep adding the endpoint pairs to this <script type=\"math/tex; mode=display\">intervals</script> array. At the same time, we can also check if the current element falls in any of the ranges found so far. If so, this element satisfies the 132 criteria for that range. </p> \n  <p>If no such element is found till the end, we need to return a False value.</p> \n  <iframe src=\"https://leetcode.com/playground/7sk67PQp/shared\" frameborder=\"0\" name=\"7sk67PQp\" width=\"100%\" height=\"360\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^2)</script>. We traverse over the <script type=\"math/tex; mode=display\">nums</script> array of size <script type=\"math/tex; mode=display\">n</script> once to find the slopes. But for every element, we also need to traverse over the <script type=\"math/tex; mode=display\">intervals</script> to check if any element falls in any range found so far. This array can contain atmost <script type=\"math/tex; mode=display\">(n/2)</script> pairs, in the case of an alternate increasing-decreasing sequence(worst case e.g.<code>[5 6 4 7 3 8 2 9]</code>). </p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. <script type=\"math/tex; mode=display\">intervals</script> array can contain atmost <script type=\"math/tex; mode=display\">n/2</script> pairs, in the worst case(alternate increasing-decreasing sequence).</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-4-using-stack-accepted\">Approach #4 Using Stack [Accepted]:</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In Approach 2, we found out <script type=\"math/tex; mode=display\">nums[i]</script> corresponding to a particular <script type=\"math/tex; mode=display\">nums[j]</script> directly without having to consider every pair possible in <script type=\"math/tex; mode=display\">nums</script> to find this <script type=\"math/tex; mode=display\">nums[i],nums[j]</script> pair. If we do some preprocessing, we can make the process of finding a <script type=\"math/tex; mode=display\">nums[k]</script> corresponding to this <script type=\"math/tex; mode=display\">nums[i],nums[j]</script> pair also easy.</p> \n  <p>The preprocessing required is to just find the best <script type=\"math/tex; mode=display\">nums[i]</script> value corresponding to every <script type=\"math/tex; mode=display\">nums[j]</script> value. This is done in the same manner as in the second approach i.e. we find the minimum element found till the <script type=\"math/tex; mode=display\">j^{th}</script> element which acts as the <script type=\"math/tex; mode=display\">nums[i]</script> for the current <script type=\"math/tex; mode=display\">nums[j]</script>. We maintain thes values in a <script type=\"math/tex; mode=display\">min</script> array. Thus, <script type=\"math/tex; mode=display\">min[j]</script> now refers to the best <script type=\"math/tex; mode=display\">nums[i]</script> value for a particular <script type=\"math/tex; mode=display\">nums[j]</script>. </p> \n  <p>Now, we traverse back from the end of the <script type=\"math/tex; mode=display\">nums</script> array to find the <script type=\"math/tex; mode=display\">nums[k]</script>'s. Suppose, we keep a track of the <script type=\"math/tex; mode=display\">nums[k]</script> values which can potentially satisfy the 132 criteria for the current <script type=\"math/tex; mode=display\">nums[j]</script>. We know, one of the conditions to be satisfied by such a <script type=\"math/tex; mode=display\">nums[k]</script> is that it must be greater than <script type=\"math/tex; mode=display\">nums[i]</script>. Or in other words, we can also say that it must be greater than <script type=\"math/tex; mode=display\">min[j]</script> for a particular <script type=\"math/tex; mode=display\">nums[j]</script> chosen. </p> \n  <p>Once it is ensured that the elements left for competing for the <script type=\"math/tex; mode=display\">nums[k]</script> are all greater than <script type=\"math/tex; mode=display\">min[j]</script>(or <script type=\"math/tex; mode=display\">nums[i]</script>), our only task is to ensure that it should be lesser than <script type=\"math/tex; mode=display\">nums[j]</script>. Now, the best element from among the competitors, for satisfying this condition will be the minimum one from out of these elements. </p> \n  <p>If this element, <script type=\"math/tex; mode=display\">nums[min]</script> satisfies <script type=\"math/tex; mode=display\">nums[min] < nums[j]</script>, we've found a 132 pattern. If not, no other element will satisfy this criteria, since they are all greater than or equal to <script type=\"math/tex; mode=display\">nums[min]</script>$ and thus greater than or equal to <script type=\"math/tex; mode=display\">nums[j]</script> as well.</p> \n  <p>To keep a track of these potential <script type=\"math/tex; mode=display\">nums[k]</script> values for a particular <script type=\"math/tex; mode=display\">nums[i],nums[j]</script> considered currently, we maintain a <script type=\"math/tex; mode=display\">stack</script> on which these potential <script type=\"math/tex; mode=display\">nums[k]</script>'s satisfying the 132 criteria lie in a descending order(minimum element on the top). We need not sort these elements on the <script type=\"math/tex; mode=display\">stack</script>, but they'll be sorted automatically as we'll discuss along with the process.</p> \n  <p>After creating a <script type=\"math/tex; mode=display\">min</script> array, we start traversing the <script type=\"math/tex; mode=display\">nums[j]</script> array in a backward manner. Let's say, we are currently at the <script type=\"math/tex; mode=display\">j^{th}</script> element and let's also assume that the <script type=\"math/tex; mode=display\">stack</script> is sorted right now. Now, firstly, we check if <script type=\"math/tex; mode=display\">nums[j] > min[j]</script>. If not, we continue with the <script type=\"math/tex; mode=display\">(j-1)^{th}</script> element and the <script type=\"math/tex; mode=display\">stack</script> remains sorted. If not, we keep on popping the elements from the top of the <script type=\"math/tex; mode=display\">stack</script> till we find an element, <script type=\"math/tex; mode=display\">stack[top]</script> such that, <script type=\"math/tex; mode=display\">stack[top] > min[j]</script>(or <script type=\"math/tex; mode=display\">stack[top] > nums[i]</script>). </p> \n  <p>Once the popping is done, we're sure that all the elements pending on the <script type=\"math/tex; mode=display\">stack</script> are greater than <script type=\"math/tex; mode=display\">nums[i]</script> and are thus, the potential candidates for <script type=\"math/tex; mode=display\">nums[k]</script> satisfying the 132 criteria. We can also note that the elements which have been popped from the <script type=\"math/tex; mode=display\">stack</script>, all satisfy <script type=\"math/tex; mode=display\">stack[top] &leq; min[j]</script>. </p> \n  <p>Since, in the <script type=\"math/tex; mode=display\">min</script> array, <script type=\"math/tex; mode=display\">min[p] &leq; min[q]</script>, for every <script type=\"math/tex; mode=display\">p > q</script>, these popped elements also satisfy <script type=\"math/tex; mode=display\">stack[top] &leq; min[k]</script>, for all <script type=\"math/tex; mode=display\">0 &leq; k < j</script>. Thus, they are not the potential <script type=\"math/tex; mode=display\">nums[k]</script> candidates for even the preceding elements. Even after doing the popping, the <script type=\"math/tex; mode=display\">stack</script> remains sorted.</p> \n  <p>After the popping is done, we've got the minimum element from amongst all the potential <script type=\"math/tex; mode=display\">nums[k]</script>'s on the top of the <script type=\"math/tex; mode=display\">stack</script>(as per the assumption). We can check if it is greater than <script type=\"math/tex; mode=display\">nums[j]</script> to satisfy the 132 criteria(we've already checked <script type=\"math/tex; mode=display\">stack[top] > nums[i]</script>). If this element satisfies the 132 criteria, we can return a True value. If not, we know that for the current <script type=\"math/tex; mode=display\">j</script>, <script type=\"math/tex; mode=display\">nums[j] > min[j]</script>. Thus, the element <script type=\"math/tex; mode=display\">nums[j]</script> could be a potential <script type=\"math/tex; mode=display\">nums[k]</script> value, for the preceding <script type=\"math/tex; mode=display\">nums[i]'s</script>. </p> \n  <p>Thus, we push it over the <script type=\"math/tex; mode=display\">stack</script>. We can note that, we need to push this element <script type=\"math/tex; mode=display\">nums[j]</script> on the <script type=\"math/tex; mode=display\">stack</script> only when it didn't satisfy <script type=\"math/tex; mode=display\">stack[top]<nums[j]</script>. Thus, <script type=\"math/tex; mode=display\">nums[j] &leq; stack[top]</script>. Thus, even after pushing this element on the <script type=\"math/tex; mode=display\">stack</script>, the <script type=\"math/tex; mode=display\">stack</script> remains sorted. Thus, we've seen by induction, that the <script type=\"math/tex; mode=display\">stack</script> always remains sorted.</p> \n  <p>Also, note that in case <script type=\"math/tex; mode=display\">nums[j] &leq; min[j]</script>, we don't push <script type=\"math/tex; mode=display\">nums[j]</script> onto the <script type=\"math/tex; mode=display\">stack</script>. This is because this <script type=\"math/tex; mode=display\">nums[j]</script> isn't greater than even the minimum element lying towards its left and thus can't act as <script type=\"math/tex; mode=display\">nums[k]</script> in the future.</p> \n  <p>If no element is found satisfying the 132 criteria till reaching the first element, we return a False value.</p> \n  <p>The following animation better illustrates the process.</p> \n  <p>!?!../Documents/456_132_Pattern.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/mhTQ2qWz/shared\" frameborder=\"0\" name=\"mhTQ2qWz\" width=\"100%\" height=\"411\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. We travesre over the <script type=\"math/tex; mode=display\">nums</script> array of size <script type=\"math/tex; mode=display\">n</script> once to fill the <script type=\"math/tex; mode=display\">min</script> array. After this, we traverse over <script type=\"math/tex; mode=display\">nums</script> to find the <script type=\"math/tex; mode=display\">nums[k]</script>. During this process, we also push and pop the elements on the <script type=\"math/tex; mode=display\">stack</script>. But, we can note that atmost <script type=\"math/tex; mode=display\">n</script> elements can be pushed and popped off the <script type=\"math/tex; mode=display\">stack</script> in total. Thus, the second traversal requires only <script type=\"math/tex; mode=display\">O(n)</script> time.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The <script type=\"math/tex; mode=display\">stack</script> can grow upto a maximum depth of <script type=\"math/tex; mode=display\">n</script>. Furhter, <script type=\"math/tex; mode=display\">min</script> array of size <script type=\"math/tex; mode=display\">n</script> is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-5-using-binary-search-accepted\">Approach #5 Using Binary Search [Accepted]:</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In the last approach, we've made use of a separate <script type=\"math/tex; mode=display\">stack</script> to push and pop the <script type=\"math/tex; mode=display\">nums[k]</script>'s. But, we can also note that when we reach the index <script type=\"math/tex; mode=display\">j</script> while scanning backwards for finding <script type=\"math/tex; mode=display\">nums[k]</script>, the <script type=\"math/tex; mode=display\">stack</script> can contain atmost <script type=\"math/tex; mode=display\">n-j-1</script> elements. Here, <script type=\"math/tex; mode=display\">n</script> refers to the number of elements in <script type=\"math/tex; mode=display\">nums</script> array. </p> \n  <p>We can also note that this is the same number of elements which lie beyond the <script type=\"math/tex; mode=display\">j^{th}</script> index in <script type=\"math/tex; mode=display\">nums</script> array. We also know that these elements lying beyond the <script type=\"math/tex; mode=display\">j^{th}</script> index won't be needed in the future ever again. Thus, we can make use of this space in <script type=\"math/tex; mode=display\">nums</script> array instead of using a separate <script type=\"math/tex; mode=display\">stack</script>. The rest of the process can be carried on in the same manner as discussed in the last approach.</p> \n  <p>We can try to go for another optimization here. Since, we've got an array for storing the potential <script type=\"math/tex; mode=display\">nums[k]</script> values now, we need not do the popping process for a <script type=\"math/tex; mode=display\">min[j]</script> to find an element just larger than <script type=\"math/tex; mode=display\">min[j]</script> from amongst these potential values. </p> \n  <p>Instead, we can make use of Binary Search to directly find an element, which is just larger than <script type=\"math/tex; mode=display\">min[j]</script> in the required interval, if it exists. If such an element is found, we can compare it with <script type=\"math/tex; mode=display\">nums[j]</script> to check the 132 criteria. Otherwise, we continue the process as in the last approach.</p> \n  <iframe src=\"https://leetcode.com/playground/RBDptaN7/shared\" frameborder=\"0\" name=\"RBDptaN7\" width=\"100%\" height=\"411\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O\\big(nlog(n)\\big)</script>. Filling <script type=\"math/tex; mode=display\">min</script> array requires <script type=\"math/tex; mode=display\">O(n)</script> time. The second traversal is done over the whole <script type=\"math/tex; mode=display\">nums</script> array of length <script type=\"math/tex; mode=display\">n</script>. For every current <script type=\"math/tex; mode=display\">nums[j]</script> we need to do the Binary Search, which requires <script type=\"math/tex; mode=display\">O\\big(log(n)\\big)</script>. In the worst case, this Binary Search will be done for all the <script type=\"math/tex; mode=display\">n</script> elements, and the required element won't be found in any case, leading to a complexity of <script type=\"math/tex; mode=display\">O\\big(nlog(n)\\big)</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. <script type=\"math/tex; mode=display\">min</script> array of size <script type=\"math/tex; mode=display\">n</script> is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-6-using-array-as-a-stackaccepted\">Approach #6 Using Array as a stack[Accepted]:</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In the last approach, we've seen that in the worst case, the required element won't be found for all the <script type=\"math/tex; mode=display\">n</script> elements and thus Binary Search is done at every step increasing the time complexity. </p> \n  <p>To remove this problem, we can follow the same steps as in Approach 4 i.e. We can remove those elements(update the index <script type=\"math/tex; mode=display\">k</script>) which aren't greater than <script type=\"math/tex; mode=display\">nums[i]</script>(<script type=\"math/tex; mode=display\">min[j]</script>). Thus, in case no element is larger than <script type=\"math/tex; mode=display\">min[j]</script> the index <script type=\"math/tex; mode=display\">k</script> reaches the last element. </p> \n  <p>Now, at every step, only <script type=\"math/tex; mode=display\">nums[j]</script> will be added and removed from consideration in the next step, improving the time complexity in the worst case. The rest of the method remains the same as in Approach 4.</p> \n  <p>This approach is inspired by <a href=\"https://leetcode.com/fun4leetcode/\">@fun4leetcode</a></p> \n  <iframe src=\"https://leetcode.com/playground/oPrsY93V/shared\" frameborder=\"0\" name=\"oPrsY93V\" width=\"100%\" height=\"411\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. We travesre over the <script type=\"math/tex; mode=display\">nums</script> array of size <script type=\"math/tex; mode=display\">n</script> once to fill the <script type=\"math/tex; mode=display\">min</script> array. After this, we traverse over <script type=\"math/tex; mode=display\">nums</script> to find the <script type=\"math/tex; mode=display\">nums[k]</script>. Atmost <script type=\"math/tex; mode=display\">n</script> elements can be put in and out of the <script type=\"math/tex; mode=display\">nums</script> array in total. Thus, the second traversal requires only <script type=\"math/tex; mode=display\">O(n)</script> time.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. <script type=\"math/tex; mode=display\">min</script> array of size <script type=\"math/tex; mode=display\">n</script> is used.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 455,
    "article_live": false,
    "title": "Assign Cookies",
    "title_slug": "assign-cookies",
    "content": "<p>\r\nAssume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor g<sub>i</sub>, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s<sub>j</sub>. If s<sub>j</sub> >= g<sub>i</sub>, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.\r\n</p>\r\n\r\n<p><b>Note:</b><br />\r\nYou may assume the greed factor is always positive. <br />\r\nYou cannot assign more than one cookie to one child.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [1,2,3], [1,1]\r\n\r\n<b>Output:</b> 1\r\n\r\n<b>Explanation:</b> You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. \r\nAnd even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.\r\nYou need to output 1.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> [1,2], [1,2,3]\r\n\r\n<b>Output:</b> 2\r\n\r\n<b>Explanation:</b> You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. \r\nYou have 3 cookies and their sizes are big enough to gratify all of the children, \r\nYou need to output 2.\r\n</pre>\r\n</p>",
    "tags": "Greedy",
    "difficulty": 1,
    "frontend_article_id": 455
},
{
    "frontend_question_id": 454,
    "article_live": false,
    "title": "4Sum II",
    "title_slug": "4sum-ii",
    "content": "<p>Given four lists A, B, C, D of integer values, compute how many tuples <code>(i, j, k, l)</code> there are such that <code>A[i] + B[j] + C[k] + D[l]</code> is zero.</p>\r\n\r\n<p>To make problem a bit easier, all A, B, C, D have same length of N where 0 &le; N &le; 500. All integers are in the range of -2<sup>28</sup> to 2<sup>28</sup> - 1 and the result is guaranteed to be at most 2<sup>31</sup> - 1.</p>\r\n\r\n<p><b>Example:</b>\r\n<pre>\r\n<b>Input:</b>\r\nA = [ 1, 2]\r\nB = [-2,-1]\r\nC = [-1, 2]\r\nD = [ 0, 2]\r\n\r\n<b>Output:</b>\r\n2\r\n\r\n<b>Explanation:</b>\r\nThe two tuples are:\r\n1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0\r\n2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0\r\n</pre>\r\n</p>",
    "tags": "Hash Table, Binary Search",
    "difficulty": 2,
    "frontend_article_id": 454
},
{
    "frontend_question_id": 453,
    "article_live": true,
    "article_slug": "minimum-moves-to-equal-array-elements",
    "title": "Minimum Moves to Equal Array Elements",
    "title_slug": "minimum-moves-to-equal-array-elements",
    "content": "<p>Given a <b>non-empty</b> integer array of size <i>n</i>, find the minimum number of moves required to make all array elements equal, where a move is incrementing <i>n</i> - 1 elements by 1.</p>\r\n\r\n<p><b>Example:</b>\r\n<pre>\r\n<b>Input:</b>\r\n[1,2,3]\r\n\r\n<b>Output:</b>\r\n3\r\n\r\n<b>Explanation:</b>\r\nOnly three moves are needed (remember each move increments two elements):\r\n\r\n[1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]\r\n</pre>\r\n</p>",
    "tags": "Math",
    "difficulty": 1,
    "frontend_article_id": 453,
    "article_content": ""
},
{
    "frontend_question_id": 452,
    "article_live": false,
    "title": "Minimum Number of Arrows to Burst Balloons",
    "title_slug": "minimum-number-of-arrows-to-burst-balloons",
    "content": "<p>There are a number of spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it's horizontal, y-coordinates don't matter and hence the x-coordinates of start and end of the diameter suffice. Start is always smaller than end. There will be at most 10<sup>4</sup> balloons.</p>\r\n\r\n<p>An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with x<sub>start</sub> and x<sub>end</sub> bursts by an arrow shot at x if x<sub>start</sub> &le; x &le; x<sub>end</sub>. There is no limit to the number of arrows that can be shot. An arrow once shot keeps travelling up infinitely. The problem is to find the minimum number of arrows that must be shot to burst all balloons. </p>\r\n\r\n<p><b>Example:</b>\r\n<pre>\r\n<b>Input:</b>\r\n[[10,16], [2,8], [1,6], [7,12]]\r\n\r\n<b>Output:</b>\r\n2\r\n\r\n<b>Explanation:</b>\r\nOne way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons).\r\n</pre>\r\n</p>",
    "tags": "Greedy",
    "difficulty": 2,
    "frontend_article_id": 452
},
{
    "frontend_question_id": 451,
    "article_live": false,
    "title": "Sort Characters By Frequency",
    "title_slug": "sort-characters-by-frequency",
    "content": "<p>Given a string, sort it in decreasing order based on the frequency of characters.</p>\r\n\r\n<p><b>Example 1:</b>\r\n<pre>\r\n<b>Input:</b>\r\n\"tree\"\r\n\r\n<b>Output:</b>\r\n\"eert\"\r\n\r\n<b>Explanation:</b>\r\n'e' appears twice while 'r' and 't' both appear once.\r\nSo 'e' must appear before both 'r' and 't'. Therefore \"eetr\" is also a valid answer.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b>\r\n<pre>\r\n<b>Input:</b>\r\n\"cccaaa\"\r\n\r\n<b>Output:</b>\r\n\"cccaaa\"\r\n\r\n<b>Explanation:</b>\r\nBoth 'c' and 'a' appear three times, so \"aaaccc\" is also a valid answer.\r\nNote that \"cacaca\" is incorrect, as the same characters must be together.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 3:</b>\r\n<pre>\r\n<b>Input:</b>\r\n\"Aabb\"\r\n\r\n<b>Output:</b>\r\n\"bbAa\"\r\n\r\n<b>Explanation:</b>\r\n\"bbaA\" is also a valid answer, but \"Aabb\" is incorrect.\r\nNote that 'A' and 'a' are treated as two different characters.\r\n</pre>\r\n</p>",
    "tags": "Hash Table, Heap",
    "difficulty": 2,
    "frontend_article_id": 451
},
{
    "frontend_question_id": 450,
    "article_live": false,
    "title": "Delete Node in a BST",
    "title_slug": "delete-node-in-a-bst",
    "content": "<p>Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.</p>\r\n\r\n<p>Basically, the deletion can be divided into two stages:\r\n<ol>\r\n<li>Search for a node to remove.</li>\r\n<li>If the node is found, delete the node.</li>\r\n</ol>\r\n</p>\r\n\r\n<p><b>Note:</b> Time complexity should be O(height of tree).</p>\r\n\r\n<p><b>Example:</b>\r\n<pre>\r\nroot = [5,3,6,2,4,null,7]\r\nkey = 3\r\n\r\n    5\r\n   / \\\r\n  3   6\r\n / \\   \\\r\n2   4   7\r\n\r\nGiven key to delete is 3. So we find the node with value 3 and delete it.\r\n\r\nOne valid answer is [5,4,6,2,null,null,7], shown in the following BST.\r\n\r\n    5\r\n   / \\\r\n  4   6\r\n /     \\\r\n2       7\r\n\r\nAnother valid answer is [5,2,6,null,4,null,7].\r\n\r\n    5\r\n   / \\\r\n  2   6\r\n   \\   \\\r\n    4   7\r\n</pre>\r\n</p>",
    "tags": "Tree",
    "difficulty": 2,
    "frontend_article_id": 450
},
{
    "frontend_question_id": 449,
    "article_live": false,
    "title": "Serialize and Deserialize BST",
    "title_slug": "serialize-and-deserialize-bst",
    "content": "<p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. </p>\r\n\r\n<p>Design an algorithm to serialize and deserialize a <b>binary search tree</b>. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>\r\n\r\n<p>\r\n<b>The encoded string should be as compact as possible.</b>\r\n</p>\r\n\r\n<p>\r\n<b>Note:</b> Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.\r\n</p>",
    "tags": "Tree",
    "difficulty": 2,
    "frontend_article_id": 449
},
{
    "frontend_question_id": 448,
    "article_live": false,
    "title": "Find All Numbers Disappeared in an Array",
    "title_slug": "find-all-numbers-disappeared-in-an-array",
    "content": "<p>Given an array of integers where 1 &le; a[i] &le; <i>n</i> (<i>n</i> = size of array), some elements appear twice and others appear once.</p>\r\n\r\n<p>Find all the elements of [1, <i>n</i>] inclusive that do not appear in this array.</p>\r\n\r\n<p>Could you do it without extra space and in O(<i>n</i>) runtime? You may assume the returned list does not count as extra space.</p>\r\n\r\n<p><b>Example:</b>\r\n<pre>\r\n<b>Input:</b>\r\n[4,3,2,7,8,2,3,1]\r\n\r\n<b>Output:</b>\r\n[5,6]\r\n</pre>\r\n</p>",
    "tags": "Array",
    "difficulty": 1,
    "frontend_article_id": 448
},
{
    "frontend_question_id": 447,
    "article_live": false,
    "title": "Number of Boomerangs",
    "title_slug": "number-of-boomerangs",
    "content": "<p>Given <i>n</i> points in the plane that are all pairwise distinct, a \"boomerang\" is a tuple of points <code>(i, j, k)</code> such that the distance between <code>i</code> and <code>j</code> equals the distance between <code>i</code> and <code>k</code> (<b>the order of the tuple matters</b>).</p>\r\n\r\n<p>Find the number of boomerangs. You may assume that <i>n</i> will be at most <b>500</b> and coordinates of points are all in the range <b>[-10000, 10000]</b> (inclusive).</p>\r\n\r\n<p><b>Example:</b><br />\r\n<pre>\r\n<b>Input:</b>\r\n[[0,0],[1,0],[2,0]]\r\n\r\n<b>Output:</b>\r\n2\r\n\r\n<b>Explanation:</b>\r\nThe two boomerangs are <b>[[1,0],[0,0],[2,0]]</b> and <b>[[1,0],[2,0],[0,0]]</b>\r\n</pre>\r\n</p>",
    "tags": "Hash Table",
    "difficulty": 1,
    "frontend_article_id": 447
},
{
    "frontend_question_id": 446,
    "article_live": true,
    "article_slug": "arithmetic-slices-ii-subsequence",
    "title": "Arithmetic Slices II - Subsequence",
    "title_slug": "arithmetic-slices-ii-subsequence",
    "content": "<p>A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.</p>\r\n\r\n<p>For example, these are arithmetic sequences:</p>\r\n<pre>1, 3, 5, 7, 9\r\n7, 7, 7, 7\r\n3, -1, -5, -9</pre>\r\n\r\n<p>The following sequence is not arithmetic.</p> <pre>1, 1, 2, 5, 7</pre> \r\n<br/>\r\n\r\n<p>A zero-indexed array A consisting of N numbers is given. A <b>subsequence</b> slice of that array is any sequence of integers (P<sub>0</sub>, P<sub>1</sub>, ..., P<sub>k</sub>) such that 0 &le; P<sub>0</sub> < P<sub>1</sub> < ... < P<sub>k</sub> < N.</p>\r\n\r\n<p>A <b>subsequence</b> slice (P<sub>0</sub>, P<sub>1</sub>, ..., P<sub>k</sub>) of array A is called arithmetic if the sequence A[P<sub>0</sub>], A[P<sub>1</sub>], ..., A[P<sub>k-1</sub>], A[P<sub>k</sub>] is arithmetic. In particular, this means that k &ge; 2.</p>\r\n\r\n<p>The function should return the number of arithmetic subsequence slices in the array A. </p>\r\n\r\n<p>The input contains N integers. Every integer is in the range of -2<sup>31</sup> and 2<sup>31</sup>-1 and 0 &le; N &le; 1000. The output is guaranteed to be less than 2<sup>31</sup>-1.</p>\r\n<br/>\r\n\r\n<p><b>Example:</b>\r\n<pre>\r\n<b>Input:</b> [2, 4, 6, 8, 10]\r\n\r\n<b>Output:</b> 7\r\n\r\n<b>Explanation:</b>\r\nAll arithmetic subsequence slices are:\r\n[2,4,6]\r\n[4,6,8]\r\n[6,8,10]\r\n[2,4,6,8]\r\n[4,6,8,10]\r\n[2,4,6,8,10]\r\n[2,6,10]\r\n</pre>\r\n</p>",
    "tags": "Dynamic Programming",
    "difficulty": 3,
    "frontend_article_id": 446,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</a></li> \n    <li><a href=\"#approach-2-dynamic-programming-accepted\">Approach #2 Dynamic Programming [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Enumerate all possible subsequences to see if they are arithmetic sequences.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>We can use depth-first search to generate all subsequences. We can check a Subsequence is arithmetic or not by its definition.</p> \n  <iframe src=\"https://leetcode.com/playground/yNoZjyFt/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"yNoZjyFt\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(2^n)</script>. For each element in the array, it can be in or outside the subsequence. So the time complexity is <script type=\"math/tex; mode=display\">O(2^n)</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. We only need the space to store the array.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-dynamic-programming-accepted\">Approach #2 Dynamic Programming [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>To determine an arithmetic sequence, we need at least two parameters: the first (or last) element of the sequence, and the common difference.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Starting from this point, we can easily figure out that one state representation that may work:</p> \n  <blockquote> \n   <p><code>f[i][d]</code> denotes the number of arithmetic subsequences that ends with <code>A[i]</code> and its common difference is <code>d</code>.</p> \n  </blockquote> \n  <p>Let's try to find the state transitions based on the representation above. Assume we want to append a new element <code>A[i]</code> to existing arithmetic subsequences to form new subsequences. We can append <code>A[i]</code> to an existing arithmetic subsequence, only if the difference between the sequence's last element and <code>A[i]</code> is equal to the sequence's common difference.</p> \n  <p>Thus, we can define the state transitions for the element <code>A[i]</code> intuitively :</p> \n  <blockquote> \n   <p>for all <code>j &lt; i</code>, f[i][A[i] - A[j]] += f[j][A[i] - A[j]].</p> \n  </blockquote> \n  <p>This demonstrates the appending process above to form new arithmetic subsequences.</p> \n  <p>But here comes the problem. Initially all <code>f[i][d]</code> are set to be <code>0</code>, but how can we form a new arithmetic subsequence if there are no existing subsequences before?</p> \n  <p>In the original definition of arithmetic subsequences, the length of the subsequence must be at least <code>3</code>. This makes it hard to form new subsequences if only two indices <code>i</code> and <code>j</code> are given. How about taking the subsequences of length <code>2</code> into account?</p> \n  <p>We can define <code>weak arithmetic subsequences</code> as follows:</p> \n  <blockquote> \n   <p><strong>Weak arithmetic subsequences</strong> are subsequences that consist of at least two elements and if the difference between any two consecutive elements is the same.</p> \n  </blockquote> \n  <p>There are two properties of weak arithmetic subsequences that are very useful:</p> \n  <ul> \n   <li> <p>For any pair <code>i, j (i != j)</code>, <code>A[i]</code> and <code>A[j]</code> can always form a weak arithmetic subsequence.</p> </li> \n   <li> <p>If we can append a new element to a weak arithmetic subsequence and keep it arithmetic, then the new subsequence must be an arithmetic subsequence.</p> </li> \n  </ul> \n  <p>The second property is quite trival, because the only difference between arithmetic subsequences and weak arithmetic subsequences is their length.</p> \n  <p>Thus we can change the state representations accordingly:</p> \n  <blockquote> \n   <p><code>f[i][d]</code> denotes the number of weak arithmetic subsequences that ends with <code>A[i]</code> and its common difference is <code>d</code>.</p> \n  </blockquote> \n  <p>Now the state transitions are quite straightforward:</p> \n  <blockquote> \n   <p>for all <code>j &lt; i</code>, f[i][A[i] - A[j]] += (f[j][A[i] - A[j]] + 1).</p> \n  </blockquote> \n  <p>The <code>1</code> appears here because of the property one, we can form a new weak arithmetic subsequence for the pair <code>(i, j)</code>.</p> \n  <p>Now the number of all weak arithmetic subsequences is the sum of all <code>f[i][d]</code>. But how can we get the number of arithmetic subsequences that are not <code>weak</code>?</p> \n  <p>There are two ways:</p> \n  <ul> \n   <li> <p>First, we can count the number of <code>pure weak</code> arithmetic subsequences directly. The <code>pure weak</code> arithmetic subsequences are the arithmetic subsequences of length <code>2</code>, so the number of <code>pure weak</code> arithmetic subsequences should be equal to the number of pairs <code>(i, j)</code>, which is <script type=\"math/tex; mode=display\">\\binom{n}{2} = \\frac{n * (n - 1)}{2}.</script> </p> </li> \n   <li> <p>Second, for the summation <code>f[i][A[i] - A[j]] += (f[j][A[i] - A[j]] + 1)</code>, <code>f[j][A[i] - A[j]]</code> is the number of existing weak arithmetic subsequences, while <code>1</code> is the new subsequence built with <code>A[i]</code> and <code>A[j]</code>. Based on property two, when we are appending new elements to existing weak arithmetic subsequences, we are forming arithmetic subsequences. So the first part, <code>f[j][A[i] - A[j]]</code> is the number of new formed arithmetic subsequences, and can be added to the answer.</p> </li> \n  </ul> \n  <p>We can use the following example to illustrate the process:</p> \n  <blockquote> \n   <p>[1, 1, 2, 3, 4, 5]</p> \n  </blockquote> \n  <p>We need to count the answer for the above sequence.</p> \n  <ul> \n   <li> <p>For the first element <code>1</code>, there is no element in front of it, the answer remains <code>0</code>.</p> </li> \n   <li> <p>For the second element <code>1</code>, the element itself with the previous <code>1</code> can form a pure weak arithmetic subsequence with common difference <code>0</code> : <code>[1, 1]</code>.</p> </li> \n   <li> <p>For the third element <code>2</code>, it cannot be appended to the only weak arithmetic subsequence <code>[1, 1]</code>, so the answer remains <code>0</code>. Similar to the second element, it can form new weak arithmetic subsequences <code>[1, 2]</code> and <code>[1, 2]</code>.</p> </li> \n   <li> <p>For the forth element <code>3</code>, if we append it to some arithmetic subsequences ending with <code>2</code>, these subsequences must have a common difference of <code>3 - 2 = 1</code>. Indeed there are two: <code>[1, 2]</code> and <code>[1, 2]</code>. So we can append <code>3</code> to the end of these subsequences, and the answer is added by <code>2</code>. Similar to above, it can form new weak arithmetic subsequences <code>[1, 3], [1, 3]</code> and <code>[2, 3]</code>.</p> </li> \n   <li> <p>The other elements are the same, we can view the process in the figure below. The red bracket indicates the weak arithmetic subsequence of length <code>2</code>, and the black bracket indicates the arithmetic subsequence. The answer should be the total number of black brackets.</p> </li> \n  </ul> \n  <p><img src=\"../Figures/446_Arithmetic_Slices_II_Subsequence.png\" width=\"80%\" height=\"80%\"></p> \n  <iframe src=\"https://leetcode.com/playground/MVagoidb/shared\" frameborder=\"0\" width=\"100%\" height=\"446\" name=\"MVagoidb\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n ^ 2)</script>. We can use double loop to enumerate all possible states.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n ^ 2)</script>. For each <code>i</code>, we need to store at most <code>n</code> distinct common differences, so the total space complexity is <script type=\"math/tex; mode=display\">O(n ^ 2)</script>.</p> </li> \n  </ul> \n </div> \n</div>"
},
{
    "frontend_question_id": 445,
    "article_live": false,
    "title": "Add Two Numbers II",
    "title_slug": "add-two-numbers-ii",
    "content": "<p>You are given two <b>non-empty</b> linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>\r\n\r\n<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>\r\n\r\n<p><b>Follow up:</b><br />\r\nWhat if you cannot modify the input lists? In other words, reversing the lists is not allowed.\r\n</p>\r\n\r\n<p>\r\n<b>Example:</b>\r\n<pre>\r\n<b>Input:</b> (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)\r\n<b>Output:</b> 7 -> 8 -> 0 -> 7\r\n</pre>\r\n</p>",
    "tags": "Linked List",
    "difficulty": 2,
    "frontend_article_id": 445
},
{
    "frontend_question_id": 444,
    "article_live": false,
    "title": "Sequence Reconstruction",
    "title_slug": "sequence-reconstruction",
    "tags": "Graph, Topological Sort",
    "difficulty": 2,
    "frontend_article_id": 444
},
{
    "frontend_question_id": 443,
    "article_live": true,
    "article_slug": "string-compression",
    "title": "String Compression",
    "title_slug": "string-compression",
    "content": "<p>Given an array of characters, compress it <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\"><b>in-place</b></a>.</p>\r\n\r\n<p>The length after compression must always be smaller than or equal to the original array.</p>\r\n\r\n<p>Every element of the array should be a <b>character</b> (not int) of length 1.</p>\r\n\r\n<p>After you are done <b>modifying the input array <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\">in-place</a></b>, return the new length of the array.</p>\r\n&nbsp;\r\n\r\n<p><b>Follow up:</b><br />\r\nCould you solve it using only O(1) extra space?</p>\r\n&nbsp;\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b>\r\n[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;c&quot;,&quot;c&quot;,&quot;c&quot;]\r\n\r\n<b>Output:</b>\r\nReturn 6, and the first 6 characters of the input array should be: [&quot;a&quot;,&quot;2&quot;,&quot;b&quot;,&quot;2&quot;,&quot;c&quot;,&quot;3&quot;]\r\n\r\n<b>Explanation:</b>\r\n&quot;aa&quot; is replaced by &quot;a2&quot;. &quot;bb&quot; is replaced by &quot;b2&quot;. &quot;ccc&quot; is replaced by &quot;c3&quot;.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b>\r\n[&quot;a&quot;]\r\n\r\n<b>Output:</b>\r\nReturn 1, and the first 1 characters of the input array should be: [&quot;a&quot;]\r\n\r\n<b>Explanation:</b>\r\nNothing is replaced.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Example 3:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b>\r\n[&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;]\r\n\r\n<b>Output:</b>\r\nReturn 4, and the first 4 characters of the input array should be: [&quot;a&quot;,&quot;b&quot;,&quot;1&quot;,&quot;2&quot;].\r\n\r\n<b>Explanation:</b>\r\nSince the character &quot;a&quot; does not repeat, it is not compressed. &quot;bbbbbbbbbbbb&quot; is replaced by &quot;b12&quot;.\r\nNotice each digit has it&#39;s own entry in the array.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Note:</b></p>\r\n\r\n<ol>\r\n\t<li>All characters have an ASCII value in <code>[35, 126]</code>.</li>\r\n\t<li><code>1 &lt;= len(chars) &lt;= 1000</code>.</li>\r\n</ol>\r\n",
    "tags": "String",
    "difficulty": 1,
    "frontend_article_id": 443,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-read-and-write-heads-accepted\">Approach #1: Read and Write Heads [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-read-and-write-heads-accepted\">Approach #1: Read and Write Heads [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>We will use separate pointers <code>read</code> and <code>write</code> to mark where we are reading and writing from. Both operations will be done left to right alternately: we will read a contiguous group of characters, then write the compressed version to the array. At the end, the position of the <code>write</code> head will be the length of the answer that was written.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Let's maintain <code>anchor</code>, the start position of the contiguous group of characters we are currently reading.</p> \n  <p>Now, let's read from left to right. We know that we must be at the end of the block when we are at the last character, or when the next character is different from the current character.</p> \n  <p>When we are at the end of a group, we will write the result of that group down using our <code>write</code> head. <code>chars[anchor]</code> will be the correct character, and the length (if greater than 1) will be <code>read - anchor + 1</code>. We will write the digits of that number to the array.</p> \n  <p><strong>Python</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">compress</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">chars</span><span class=\"p\">):</span>\n        <span class=\"n\">anchor</span> <span class=\"o\">=</span> <span class=\"n\">write</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n        <span class=\"k\">for</span> <span class=\"n\">read</span><span class=\"p\">,</span> <span class=\"n\">c</span> <span class=\"ow\">in</span> <span class=\"nb\">enumerate</span><span class=\"p\">(</span><span class=\"n\">chars</span><span class=\"p\">):</span>\n            <span class=\"k\">if</span> <span class=\"n\">read</span> <span class=\"o\">+</span> <span class=\"mi\">1</span> <span class=\"o\">==</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">chars</span><span class=\"p\">)</span> <span class=\"ow\">or</span> <span class=\"n\">chars</span><span class=\"p\">[</span><span class=\"n\">read</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">!=</span> <span class=\"n\">c</span><span class=\"p\">:</span>\n                <span class=\"n\">chars</span><span class=\"p\">[</span><span class=\"n\">write</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">chars</span><span class=\"p\">[</span><span class=\"n\">anchor</span><span class=\"p\">]</span>\n                <span class=\"n\">write</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n                <span class=\"k\">if</span> <span class=\"n\">read</span> <span class=\"o\">&gt;</span> <span class=\"n\">anchor</span><span class=\"p\">:</span>\n                    <span class=\"k\">for</span> <span class=\"n\">digit</span> <span class=\"ow\">in</span> <span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">read</span> <span class=\"o\">-</span> <span class=\"n\">anchor</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">):</span>\n                        <span class=\"n\">chars</span><span class=\"p\">[</span><span class=\"n\">write</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">digit</span>\n                        <span class=\"n\">write</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n                <span class=\"n\">anchor</span> <span class=\"o\">=</span> <span class=\"n\">read</span> <span class=\"o\">+</span> <span class=\"mi\">1</span>\n        <span class=\"k\">return</span> <span class=\"n\">write</span>\n</pre>\n  </div> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">compress</span><span class=\"o\">(</span><span class=\"kt\">char</span><span class=\"o\">[]</span> <span class=\"n\">chars</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">anchor</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">write</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">read</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">read</span> <span class=\"o\">&lt;</span> <span class=\"n\">chars</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">read</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">read</span> <span class=\"o\">+</span> <span class=\"mi\">1</span> <span class=\"o\">==</span> <span class=\"n\">chars</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">||</span> <span class=\"n\">chars</span><span class=\"o\">[</span><span class=\"n\">read</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"o\">!=</span> <span class=\"n\">chars</span><span class=\"o\">[</span><span class=\"n\">read</span><span class=\"o\">])</span> <span class=\"o\">{</span>\n                <span class=\"n\">chars</span><span class=\"o\">[</span><span class=\"n\">write</span><span class=\"o\">++]</span> <span class=\"o\">=</span> <span class=\"n\">chars</span><span class=\"o\">[</span><span class=\"n\">anchor</span><span class=\"o\">];</span>\n                <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">read</span> <span class=\"o\">&gt;</span> <span class=\"n\">anchor</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">char</span> <span class=\"n\">c</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"s\">\"\"</span> <span class=\"o\">+</span> <span class=\"o\">(</span><span class=\"n\">read</span> <span class=\"o\">-</span> <span class=\"n\">anchor</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">)).</span><span class=\"na\">toCharArray</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n                        <span class=\"n\">chars</span><span class=\"o\">[</span><span class=\"n\">write</span><span class=\"o\">++]</span> <span class=\"o\">=</span> <span class=\"n\">c</span><span class=\"o\">;</span>\n                    <span class=\"o\">}</span>\n                <span class=\"o\">}</span>\n                <span class=\"n\">anchor</span> <span class=\"o\">=</span> <span class=\"n\">read</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">write</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>chars</code>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>, the space used by <code>read</code>, <code>write</code>, and <code>anchor</code>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 442,
    "article_live": false,
    "title": "Find All Duplicates in an Array",
    "title_slug": "find-all-duplicates-in-an-array",
    "content": "<p>Given an array of integers, 1 &le; a[i] &le; <i>n</i> (<i>n</i> = size of array), some elements appear <b>twice</b> and others appear <b>once</b>.</p>\r\n\r\n<p>Find all the elements that appear <b>twice</b> in this array.</p>\r\n\r\n<p>Could you do it without extra space and in O(<i>n</i>) runtime?</p>\r\n</p>\r\n<p><b>Example:</b><br/>\r\n<pre>\r\n<b>Input:</b>\r\n[4,3,2,7,8,2,3,1]\r\n\r\n<b>Output:</b>\r\n[2,3]\r\n</pre>",
    "tags": "Array",
    "difficulty": 2,
    "frontend_article_id": 442
},
{
    "frontend_question_id": 441,
    "article_live": false,
    "title": "Arranging Coins",
    "title_slug": "arranging-coins",
    "content": "<p>You have a total of <i>n</i> coins that you want to form in a staircase shape, where every <i>k</i>-th row must have exactly <i>k</i> coins.</p>\r\n \r\n<p>Given <i>n</i>, find the total number of <b>full</b> staircase rows that can be formed.</p>\r\n\r\n<p><i>n</i> is a non-negative integer and fits within the range of a 32-bit signed integer.</p>\r\n\r\n<p><b>Example 1:</b>\r\n<pre>\r\nn = 5\r\n\r\nThe coins can form the following rows:\r\n¤\r\n¤ ¤\r\n¤ ¤\r\n\r\nBecause the 3rd row is incomplete, we return 2.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b>\r\n<pre>\r\nn = 8\r\n\r\nThe coins can form the following rows:\r\n¤\r\n¤ ¤\r\n¤ ¤ ¤\r\n¤ ¤\r\n\r\nBecause the 4th row is incomplete, we return 3.\r\n</pre>\r\n</p>",
    "tags": "Math, Binary Search",
    "difficulty": 1,
    "frontend_article_id": 441
},
{
    "frontend_question_id": 440,
    "article_live": false,
    "title": "K-th Smallest in Lexicographical Order",
    "title_slug": "k-th-smallest-in-lexicographical-order",
    "content": "<p>Given integers <code>n</code> and <code>k</code>, find the lexicographically k-th smallest integer in the range from <code>1</code> to <code>n</code>.</p>\r\n\r\n<p>Note: 1 &le; k &le; n &le; 10<sup>9</sup>.</p>\r\n\r\n<p><b>Example:</b>\r\n<pre>\r\n<b>Input:</b>\r\nn: 13   k: 2\r\n\r\n<b>Output:</b>\r\n10\r\n\r\n<b>Explanation:</b>\r\nThe lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10.\r\n</pre>\r\n</p>\r\n",
    "tags": "",
    "difficulty": 3,
    "frontend_article_id": 440
},
{
    "frontend_question_id": 439,
    "article_live": false,
    "title": "Ternary Expression Parser",
    "title_slug": "ternary-expression-parser",
    "tags": "Stack, Depth-first Search",
    "difficulty": 2,
    "frontend_article_id": 439
},
{
    "frontend_question_id": 438,
    "article_live": false,
    "title": "Find All Anagrams in a String",
    "title_slug": "find-all-anagrams-in-a-string",
    "content": "<p>Given a string <b>s</b> and a <b>non-empty</b> string <b>p</b>, find all the start indices of <b>p</b>'s anagrams in <b>s</b>.</p>\r\n\r\n<p>Strings consists of lowercase English letters only and the length of both strings <b>s</b> and <b>p</b> will not be larger than 20,100.</p>\r\n\r\n<p>The order of output does not matter.</p>\r\n\r\n<p><b>Example 1:</b>\r\n<pre>\r\n<b>Input:</b>\r\ns: \"cbaebabacd\" p: \"abc\"\r\n\r\n<b>Output:</b>\r\n[0, 6]\r\n\r\n<b>Explanation:</b>\r\nThe substring with start index = 0 is \"cba\", which is an anagram of \"abc\".\r\nThe substring with start index = 6 is \"bac\", which is an anagram of \"abc\".\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b>\r\n<pre>\r\n<b>Input:</b>\r\ns: \"abab\" p: \"ab\"\r\n\r\n<b>Output:</b>\r\n[0, 1, 2]\r\n\r\n<b>Explanation:</b>\r\nThe substring with start index = 0 is \"ab\", which is an anagram of \"ab\".\r\nThe substring with start index = 1 is \"ba\", which is an anagram of \"ab\".\r\nThe substring with start index = 2 is \"ab\", which is an anagram of \"ab\".\r\n</pre>\r\n</p>",
    "tags": "Hash Table",
    "difficulty": 1,
    "frontend_article_id": 438
},
{
    "frontend_question_id": 437,
    "article_live": false,
    "title": "Path Sum III",
    "title_slug": "path-sum-iii",
    "content": "<p>You are given a binary tree in which each node contains an integer value.</p>\r\n\r\n<p>Find the number of paths that sum to a given value.</p>\r\n\r\n<p>The path does not need to start or end at the root or a leaf, but it must go downwards\r\n(traveling only from parent nodes to child nodes).</p>\r\n\r\n<p>The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.\r\n\r\n<p><b>Example:</b>\r\n<pre>\r\nroot = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8\r\n\r\n      10\r\n     /  \\\r\n    <b>5</b>   <b>-3</b>\r\n   <b>/</b> <b>\\</b>    <b>\\</b>\r\n  <b>3</b>   <b>2</b>   <b>11</b>\r\n / \\   <b>\\</b>\r\n3  -2   <b>1</b>\r\n\r\nReturn 3. The paths that sum to 8 are:\r\n\r\n1.  5 -> 3\r\n2.  5 -> 2 -> 1\r\n3. -3 -> 11\r\n</pre>\r\n</p>",
    "tags": "Tree",
    "difficulty": 1,
    "frontend_article_id": 437
},
{
    "frontend_question_id": 436,
    "article_live": true,
    "article_slug": "find-right-interval",
    "title": "Find Right Interval",
    "title_slug": "find-right-interval",
    "content": "<p>\r\nGiven a set of intervals, for each of the interval i, check if there exists an interval j whose start point is bigger than or equal to the end point of the interval i, which can be called that j is on the \"right\" of i.\r\n</p>\r\n\r\n<p>\r\nFor any interval i, you need to store the minimum interval j's index, which means that the interval j has the minimum start point to build the \"right\" relationship for interval i. If the interval j doesn't exist, store -1 for the interval i. Finally, you need output the stored value of each interval as an array.\r\n</p>\r\n\r\n<p><b>Note:</b><br />\r\n<ol>\r\n<li>You may assume the interval's end point is always bigger than its start point.</li>\r\n<li>You may assume none of these intervals have the same start point.</li>\r\n</ol>\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [ [1,2] ]\r\n\r\n<b>Output:</b> [-1]\r\n\r\n<b>Explanation:</b> There is only one interval in the collection, so it outputs -1.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> [ [3,4], [2,3], [1,2] ]\r\n\r\n<b>Output:</b> [-1, 0, 1]\r\n\r\n<b>Explanation:</b> There is no satisfied \"right\" interval for [3,4].\r\nFor [2,3], the interval [3,4] has minimum-\"right\" start point;\r\nFor [1,2], the interval [2,3] has minimum-\"right\" start point.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 3:</b><br />\r\n<pre>\r\n<b>Input:</b> [ [1,4], [2,3], [3,4] ]\r\n\r\n<b>Output:</b> [-1, 2, -1]\r\n\r\n<b>Explanation:</b> There is no satisfied \"right\" interval for [1,4] and [3,4].\r\nFor [2,3], the interval [3,4] has minimum-\"right\" start point.\r\n</pre>\r\n</p>",
    "tags": "Binary Search",
    "difficulty": 2,
    "frontend_article_id": 436,
    "article_content": ""
},
{
    "frontend_question_id": 435,
    "article_live": true,
    "article_slug": "non-overlapping-intervals",
    "title": "Non-overlapping Intervals",
    "title_slug": "non-overlapping-intervals",
    "content": "<p>\r\nGiven a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.\r\n</p>\r\n\r\n<p><b>Note:</b><br />\r\n<ol>\r\n<li>You may assume the interval's end point is always bigger than its start point.</li>\r\n<li>Intervals like [1,2] and [2,3] have borders \"touching\" but they don't overlap each other.</li>\r\n</ol>\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [ [1,2], [2,3], [3,4], [1,3] ]\r\n\r\n<b>Output:</b> 1\r\n\r\n<b>Explanation:</b> [1,3] can be removed and the rest of intervals are non-overlapping.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> [ [1,2], [1,2], [1,2] ]\r\n\r\n<b>Output:</b> 2\r\n\r\n<b>Explanation:</b> You need to remove two [1,2] to make the rest of intervals non-overlapping.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 3:</b><br />\r\n<pre>\r\n<b>Input:</b> [ [1,2], [2,3] ]\r\n\r\n<b>Output:</b> 0\r\n\r\n<b>Explanation:</b> You don't need to remove any of the intervals since they're already non-overlapping.\r\n</pre>\r\n</p>",
    "tags": "Greedy",
    "difficulty": 2,
    "frontend_article_id": 435,
    "article_content": ""
},
{
    "frontend_question_id": 434,
    "article_live": true,
    "article_slug": "number-of-segments-in-a-string",
    "title": "Number of Segments in a String",
    "title_slug": "number-of-segments-in-a-string",
    "content": "<p>Count the number of segments in a string, where a segment is defined to be a contiguous sequence of non-space characters.</p>\r\n\r\n<p>Please note that the string does not contain any <b>non-printable</b> characters.</p>\r\n\r\n<p><b>Example:</b></p>\r\n<pre>\r\n<b>Input:</b> \"Hello, my name is John\"\r\n<b>Output:</b> 5\r\n</pre>\r\n</p>",
    "tags": "String",
    "difficulty": 1,
    "frontend_article_id": 434,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-using-language-builtins-accepted\">Approach #1 Using Language Builtins [Accepted]</a></li> \n    <li><a href=\"#approach-2-in-place-accepted\">Approach #2 In-place [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-using-language-builtins-accepted\">Approach #1 Using Language Builtins [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>In a situation where raw efficiency is less important than code legibility, it is likely better to use language-idiomatic builtin functions to solve this problem.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>There are a few corner cases that you can get snagged on in this problem, at least in Java. First, one or more leading spaces will cause <code>split</code> to deduce an erroneous <code>\"\"</code> token at the beginning of the string, so we use the builtin <code>trim</code> method to remove leading and trailing spaces. Then, if the resulting string is the empty string, then we can simply output <code>0</code>. This is necessary due to the following behavior of the <code>split</code> method:</p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">tokens</span> <span class=\"o\">=</span> <span class=\"s\">\"\"</span><span class=\"o\">.</span><span class=\"na\">split</span><span class=\"o\">(</span><span class=\"s\">\"\\\\s++\"</span><span class=\"o\">);</span>\n<span class=\"n\">tokens</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"c1\">// 1</span>\n<span class=\"n\">tokens</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">];</span> <span class=\"c1\">// \"\"</span>\n</pre>\n  </div> \n  <p>If we reach the final return statement, we <code>split</code> the trimmed string on sequences of one or more whitespace characters (<code>split</code> can take a regular expression) and return the length of the resulting array.</p> \n  <p>The Python solution is trivially short because Python's <code>split</code> has a lot of default behavior that makes it perfect for this sort of problem. Notably, it returns an empty list when <code>split</code>ting an empty string, it splits on whitespace by default, and it implicitly <code>trim</code>s (<code>strip</code>s, in Python lingo) the string beforehand.</p> \n  <iframe src=\"https://leetcode.com/playground/FdCZomTr/shared\" frameborder=\"0\" width=\"100%\" height=\"208\" name=\"FdCZomTr\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script> </p> <p>All builtin language functionality used here (in both the Java and Python examples) runs in either <script type=\"math/tex; mode=display\">O(n)</script> or <script type=\"math/tex; mode=display\">O(1)</script> time, so the entire algorithm runs in linear time.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script> </p> <p><code>split</code> (in both languages) returns an array/list of <script type=\"math/tex; mode=display\">O(n)</script> length, so the algorithm uses linear additional space.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-in-place-accepted\">Approach #2 In-place [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>If we cannot afford to allocate linear additional space, a fairly simple algorithm can deduce the number of segments in linear time and constant space.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>To count the number of segments, it is equivalent to count the number of string indices at which a segment begins. Therefore, by formally defining the characteristics of such an index, we can simply iterate over the string and test each index in turn. Such a definition is as follows: a string index begins a segment if it is preceded by whitespace (or is the first index) and is not whitespace itself, which can be checked in constant time. Finally, we simply return the number of indices for which the condition is satisfied.</p> \n  <iframe src=\"https://leetcode.com/playground/XX7WFxaA/shared\" frameborder=\"0\" width=\"100%\" height=\"276\" name=\"XX7WFxaA\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script> </p> <p>We do a constant time check for each of the string's <script type=\"math/tex; mode=display\">n</script> indices, so the runtime is overall linear.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script> </p> <p>There are only a few integers allocated, so the memory footprint is constant.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/emptyset\">@emptyset</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 433,
    "article_live": false,
    "title": "Minimum Genetic Mutation",
    "title_slug": "minimum-genetic-mutation",
    "content": "<p>A gene string can be represented by an 8-character long string, with choices from <code>&quot;A&quot;</code>, <code>&quot;C&quot;</code>, <code>&quot;G&quot;</code>, <code>&quot;T&quot;</code>.</p>\r\n\r\n<p>Suppose we need to investigate about a mutation (mutation from &quot;start&quot; to &quot;end&quot;), where ONE mutation is defined as ONE single character changed in the gene string.</p>\r\n\r\n<p>For example, <code>&quot;AACCGGTT&quot;</code> -&gt; <code>&quot;AACCGGTA&quot;</code> is 1 mutation.</p>\r\n\r\n<p>Also, there is a given gene &quot;bank&quot;, which records all the valid gene mutations. A gene must be in the bank to make it a valid gene string.</p>\r\n\r\n<p>Now, given 3 things - start, end, bank, your task is to determine what is the minimum number of mutations needed to mutate from &quot;start&quot; to &quot;end&quot;. If there is no such a mutation, return -1.</p>\r\n\r\n<p><b>Note:</b></p>\r\n\r\n<ol>\r\n\t<li>Starting point is assumed to be valid, so it might not be included in the bank.</li>\r\n\t<li>If multiple mutations are needed, all mutations during in the sequence must be valid.</li>\r\n\t<li>You may assume start and end string is not the same.</li>\r\n</ol>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\nstart: &quot;AACCGGTT&quot;\r\nend:   &quot;AACCGGTA&quot;\r\nbank: [&quot;AACCGGTA&quot;]\r\n\r\nreturn: 1\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\nstart: &quot;AACCGGTT&quot;\r\nend:   &quot;AAACGGTA&quot;\r\nbank: [&quot;AACCGGTA&quot;, &quot;AACCGCTA&quot;, &quot;AAACGGTA&quot;]\r\n\r\nreturn: 2\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Example 3:</b></p>\r\n\r\n<pre>\r\nstart: &quot;AAAAACCC&quot;\r\nend:   &quot;AACCCCCC&quot;\r\nbank: [&quot;AAAACCCC&quot;, &quot;AAACCCCC&quot;, &quot;AACCCCCC&quot;]\r\n\r\nreturn: 3\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n",
    "tags": "",
    "difficulty": 2,
    "frontend_article_id": 433
},
{
    "frontend_question_id": 432,
    "article_live": false,
    "title": "All O`one Data Structure",
    "title_slug": "all-oone-data-structure",
    "content": "<p>Implement a data structure supporting the following operations:</p>\r\n\r\n<p>\r\n<ol>\r\n<li>Inc(Key) - Inserts a new key <Key> with value 1. Or increments an existing key by 1. Key is guaranteed to be a <b>non-empty</b> string.</li>\r\n<li>Dec(Key) - If Key's value is 1, remove it from the data structure. Otherwise decrements an existing key by 1. If the key does not exist, this function does nothing. Key is guaranteed to be a <b>non-empty</b> string.</li>\r\n<li>GetMaxKey() - Returns one of the keys with maximal value. If no element exists, return an empty string <code>\"\"</code>.</li>\r\n<li>GetMinKey() - Returns one of the keys with minimal value. If no element exists, return an empty string <code>\"\"</code>.</li>\r\n</ol>\r\n</p>\r\n\r\n<p>\r\nChallenge: Perform all these in O(1) time complexity.\r\n</p>",
    "tags": "Design",
    "difficulty": 3,
    "frontend_article_id": 432
},
{
    "frontend_question_id": 425,
    "article_live": false,
    "title": "Word Squares",
    "title_slug": "word-squares",
    "tags": "Backtracking, Trie",
    "difficulty": 3,
    "frontend_article_id": 425
},
{
    "frontend_question_id": 424,
    "article_live": false,
    "title": "Longest Repeating Character Replacement",
    "title_slug": "longest-repeating-character-replacement",
    "content": "<p>Given a string that consists of only uppercase English letters, you can replace any letter in the string with another letter at most <i>k</i> times. Find the length of a longest substring containing all repeating letters you can get after performing the above operations.</p>\r\n\r\n<p><b>Note:</b><br />\r\nBoth the string's length and <i>k</i> will not exceed 10<sup>4</sup>.\r\n</p>\r\n\r\n<p>\r\n<b>Example 1:</b>\r\n<pre>\r\n<b>Input:</b>\r\ns = \"ABAB\", k = 2\r\n\r\n<b>Output:</b>\r\n4\r\n\r\n<b>Explanation:</b>\r\nReplace the two 'A's with two 'B's or vice versa.\r\n</pre>\r\n</p>\r\n\r\n<p>\r\n<b>Example 2:</b>\r\n<pre>\r\n<b>Input:</b>\r\ns = \"AABABBA\", k = 1\r\n\r\n<b>Output:</b>\r\n4\r\n\r\n<b>Explanation:</b>\r\nReplace the one 'A' in the middle with 'B' and form \"AABBBBA\".\r\nThe substring \"BBBB\" has the longest repeating letters, which is 4.\r\n</pre>\r\n</p>",
    "tags": "",
    "difficulty": 2,
    "frontend_article_id": 424
},
{
    "frontend_question_id": 423,
    "article_live": false,
    "title": "Reconstruct Original Digits from English",
    "title_slug": "reconstruct-original-digits-from-english",
    "content": "<p>Given a <b>non-empty</b> string containing an out-of-order English representation of digits <code>0-9</code>, output the digits in ascending order.</p>\r\n\r\n<p><b>Note:</b><br />\r\n<ol>\r\n<li>Input contains only lowercase English letters.</li>\r\n<li>Input is guaranteed to be valid and can be transformed to its original digits. That means invalid inputs such as \"abc\" or \"zerone\" are not permitted.</li>\r\n<li>Input length is less than 50,000.</li>\r\n</ol>\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\nInput: \"owoztneoer\"\r\n\r\nOutput: \"012\"\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\nInput: \"fviefuro\"\r\n\r\nOutput: \"45\"\r\n</pre>\r\n</p>",
    "tags": "Math",
    "difficulty": 2,
    "frontend_article_id": 423
},
{
    "frontend_question_id": 422,
    "article_live": false,
    "title": "Valid Word Square",
    "title_slug": "valid-word-square",
    "tags": "",
    "difficulty": 1,
    "frontend_article_id": 422
},
{
    "frontend_question_id": 421,
    "article_live": false,
    "title": "Maximum XOR of Two Numbers in an Array",
    "title_slug": "maximum-xor-of-two-numbers-in-an-array",
    "content": "<p>Given a <b>non-empty</b> array of numbers, a<sub>0</sub>, a<sub>1</sub>, a<sub>2</sub>, … , a<sub>n-1</sub>, where 0 &le; a<sub>i</sub> < 2<sup>31</sup>.</p>\r\n\r\n<p>Find the maximum result of a<sub>i</sub> XOR a<sub>j</sub>, where 0 &le; <i>i</i>, <i>j</i> &lt; <i>n</i>.</p>\r\n\r\n<p>Could you do this in O(<i>n</i>) runtime?</p>\r\n\r\n<p><b>Example:</b>\r\n<pre>\r\n<b>Input:</b> [3, 10, 5, 25, 2, 8]\r\n\r\n<b>Output:</b> 28\r\n\r\n<b>Explanation:</b> The maximum result is <b>5</b> ^ <b>25</b> = 28.\r\n</pre>\r\n</p>",
    "tags": "Bit Manipulation, Trie",
    "difficulty": 2,
    "frontend_article_id": 421
},
{
    "frontend_question_id": 420,
    "article_live": false,
    "title": "Strong Password Checker",
    "title_slug": "strong-password-checker",
    "content": "<p>A password is considered strong if below conditions are all met:</p>\r\n\r\n<ol>\r\n<li> It has at least 6 characters and at most 20 characters. </li>\r\n<li> It must contain at least one lowercase letter, at least one uppercase letter, and at least one digit. </li>\r\n<li> It must NOT contain three repeating characters in a row (\"...aaa...\" is weak, but \"...aa...a...\" is strong, assuming other conditions are met). </li>\r\n</ol>\r\n\r\n<p>Write a function strongPasswordChecker(s), that takes a string s as input, and return the <b>MINIMUM</b> change required to make s a strong password. If s is already strong, return 0.</p>\r\n\r\n<p>Insertion, deletion or replace of any one character are all considered as one change.</p>",
    "tags": "",
    "difficulty": 3,
    "frontend_article_id": 420
},
{
    "frontend_question_id": 419,
    "article_live": false,
    "title": "Battleships in a Board",
    "title_slug": "battleships-in-a-board",
    "content": "Given an 2D board, count how many battleships are in it. The battleships are represented with <code>'X'</code>s, empty slots are represented with <code>'.'</code>s. You may assume the following rules:\r\n\r\n<ul>\r\n<li>You receive a valid board, made of only battleships or empty slots.</li>\r\n<li>Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape <code>1xN</code> (1 row, N columns) or <code>Nx1</code> (N rows, 1 column), where N can be of any size.</li>\r\n<li>At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.</li>\r\n</ul>\r\n\r\n<p><b>Example:</b><br />\r\n<pre>X..X\r\n...X\r\n...X\r\n</pre>\r\nIn the above board there are 2 battleships.\r\n\r\n<p><b>Invalid Example:</b><br />\r\n<pre>...X\r\nXXXX\r\n...X\r\n</pre>\r\nThis is an invalid board that you will not receive - as battleships will always have a cell separating between them.\r\n<p></p>\r\n<p><b>Follow up:</b><br>Could you do it in <b>one-pass</b>, using only <b>O(1) extra memory</b> and <b>without modifying</b> the value of the board?</p>",
    "tags": "",
    "difficulty": 2,
    "frontend_article_id": 419
},
{
    "frontend_question_id": 418,
    "article_live": false,
    "title": "Sentence Screen Fitting",
    "title_slug": "sentence-screen-fitting",
    "tags": "Dynamic Programming",
    "difficulty": 2,
    "frontend_article_id": 418
},
{
    "frontend_question_id": 417,
    "article_live": false,
    "title": "Pacific Atlantic Water Flow",
    "title_slug": "pacific-atlantic-water-flow",
    "content": "<p>Given an <code>m x n</code> matrix of non-negative integers representing the height of each unit cell in a continent, the \"Pacific ocean\" touches the left and top edges of the matrix and the \"Atlantic ocean\" touches the right and bottom edges.</p>\r\n\r\n<p>Water can only flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower.</p>\r\n\r\n<p>Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.</p>\r\n\r\n<p><b>Note:</b><br />\r\n<ol>\r\n<li>The order of returned grid coordinates does not matter.</li>\r\n<li>Both <i>m</i> and <i>n</i> are less than 150.</li>\r\n</ol>\r\n</p>\r\n<p><b>Example:</b>\r\n<pre>\r\nGiven the following 5x5 matrix:\r\n\r\n  Pacific ~   ~   ~   ~   ~ \r\n       ~  1   2   2   3  (5) *\r\n       ~  3   2   3  (4) (4) *\r\n       ~  2   4  (5)  3   1  *\r\n       ~ (6) (7)  1   4   5  *\r\n       ~ (5)  1   1   2   4  *\r\n          *   *   *   *   * Atlantic\r\n\r\nReturn:\r\n\r\n[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).\r\n</pre>\r\n</p>",
    "tags": "Depth-first Search, Breadth-first Search",
    "difficulty": 2,
    "frontend_article_id": 417
},
{
    "frontend_question_id": 416,
    "article_live": false,
    "title": "Partition Equal Subset Sum",
    "title_slug": "partition-equal-subset-sum",
    "content": "<p>Given a <b>non-empty</b> array containing <b>only positive integers</b>, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.\r\n</p>\r\n\r\n<p><b>Note:</b><br />\r\n<ol>\r\n<li>Each of the array element will not exceed 100.</li>\r\n<li>The array size will not exceed 200.</li>\r\n</ol>\r\n</p>\r\n\r\n<p><b>Example 1:</b>\r\n<pre>\r\nInput: [1, 5, 11, 5]\r\n\r\nOutput: true\r\n\r\nExplanation: The array can be partitioned as [1, 5, 5] and [11].\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b>\r\n<pre>\r\nInput: [1, 2, 3, 5]\r\n\r\nOutput: false\r\n\r\nExplanation: The array cannot be partitioned into equal sum subsets.\r\n</pre>\r\n</p>",
    "tags": "Dynamic Programming",
    "difficulty": 2,
    "frontend_article_id": 416
},
{
    "frontend_question_id": 415,
    "article_live": false,
    "title": "Add Strings",
    "title_slug": "add-strings",
    "content": "<p>Given two non-negative integers <code>num1</code> and <code>num2</code> represented as string, return the sum of <code>num1</code> and <code>num2</code>.</p>\r\n\r\n<p><b>Note:</b>\r\n<ol>\r\n<li>The length of both <code>num1</code> and <code>num2</code> is < 5100.</li>\r\n<li>Both <code>num1</code> and <code>num2</code> contains only digits <code>0-9</code>.</li>\r\n<li>Both <code>num1</code> and <code>num2</code> does not contain any leading zero.</li>\r\n<li>You <b>must not use any built-in BigInteger library</b> or <b>convert the inputs to integer</b> directly.</li>\r\n</ol>\r\n</p>",
    "tags": "Math",
    "difficulty": 1,
    "frontend_article_id": 415
},
{
    "frontend_question_id": 414,
    "article_live": false,
    "title": "Third Maximum Number",
    "title_slug": "third-maximum-number",
    "content": "<p>Given a <b>non-empty</b> array of integers, return the <b>third</b> maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n).</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [3, 2, 1]\r\n\r\n<b>Output:</b> 1\r\n\r\n<b>Explanation:</b> The third maximum is 1.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> [1, 2]\r\n\r\n<b>Output:</b> 2\r\n\r\n<b>Explanation:</b> The third maximum does not exist, so the maximum (2) is returned instead.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 3:</b><br />\r\n<pre>\r\n<b>Input:</b> [2, 2, 3, 1]\r\n\r\n<b>Output:</b> 1\r\n\r\n<b>Explanation:</b> Note that the third maximum here means the third maximum distinct number.\r\nBoth numbers with value 2 are both considered as second maximum.\r\n</pre>\r\n</p>",
    "tags": "Array",
    "difficulty": 1,
    "frontend_article_id": 414
},
{
    "frontend_question_id": 413,
    "article_live": true,
    "article_slug": "arithmetic-slices",
    "title": "Arithmetic Slices",
    "title_slug": "arithmetic-slices",
    "content": "<p>A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.</p>\r\n\r\n<p>For example, these are arithmetic sequence:</p>\r\n<pre>1, 3, 5, 7, 9\r\n7, 7, 7, 7\r\n3, -1, -5, -9</pre>\r\n\r\n<p>The following sequence is not arithmetic.</p> <pre>1, 1, 2, 5, 7</pre> \r\n<br/>\r\n\r\n<p>A zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 <= P < Q < N.</p>\r\n\r\n<p>A slice (P, Q) of array A is called arithmetic if the sequence:<br/>\r\n    A[P], A[p + 1], ..., A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 < Q.</p>\r\n\r\n<p>The function should return the number of arithmetic slices in the array A. </p>\r\n<br/>\r\n\r\n<p><b>Example:</b>\r\n<pre>\r\nA = [1, 2, 3, 4]\r\n\r\nreturn: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself.\r\n</pre>",
    "tags": "Math, Dynamic Programming",
    "difficulty": 2,
    "frontend_article_id": 413,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-accepted\">Approach #1 Brute Force [Accepted]</a></li> \n      <li><a href=\"#approach-2-better-brute-force-accepted\">Approach #2 Better Brute Force [Accepted]</a></li> \n      <li><a href=\"#approach-3-using-recursion-accepted\">Approach #3 Using Recursion [Accepted]</a></li> \n      <li><a href=\"#approach-5-dynamic-programming-accepted\">Approach #5 Dynamic Programming [Accepted]:</a></li> \n      <li><a href=\"#approach-5-constant-space-dynamic-programming-accepted\">Approach #5 Constant Space Dynamic Programming [Accepted]:</a></li> \n      <li><a href=\"#approach-6-using-formula-accepted\">Approach #6 Using Formula [Accepted]:</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-accepted\">Approach #1 Brute Force [Accepted]</h4> \n  <p>The most naive solution is to consider every pair of elements(with atleast 1 element between them), so that the range of elements lying between these two elements acts as a slice. Then, we can iterate over every such slice(range) to check if all the consecutive elements within this range have the same difference. For every such range found, we can increment the <script type=\"math/tex; mode=display\">count</script> that is used to keep a track of the required result.</p> \n  <iframe src=\"https://leetcode.com/playground/HT3WjgGf/shared\" frameborder=\"0\" name=\"HT3WjgGf\" width=\"100%\" height=\"343\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^3)</script>. We iterate over the range formed by every pair of elements. Here, <script type=\"math/tex; mode=display\">n</script> refers to the number of elements in the given array <script type=\"math/tex; mode=display\">A</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant extra space is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-better-brute-force-accepted\">Approach #2 Better Brute Force [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In the last approach, we considered every possible range and then iterated over the range to check if the difference between every consercutive element in this range is the same. We can optimize this approach to some extent, by making a small observation. </p> \n  <p>We can see, that if we are currently considering the range bound by the elements, let's say, <script type=\"math/tex; mode=display\">A[s]</script>(start) and <script type=\"math/tex; mode=display\">A[e]</script>(end), we have checked the consecutive elements in this range to have the same difference. Now, when we move on to the next range between the indices <script type=\"math/tex; mode=display\">s</script> and <script type=\"math/tex; mode=display\">e+1</script>, we again perform a check on all the elements in the range <script type=\"math/tex; mode=display\">s:e</script>, along with one additional pair <script type=\"math/tex; mode=display\">A[e+1]</script> and <script type=\"math/tex; mode=display\">A[e]</script>. We can remove this redundant check in the range <script type=\"math/tex; mode=display\">s:e</script> and just check the last pair to have the same difference as the one used for the previous range(same <script type=\"math/tex; mode=display\">s</script>, incremented <script type=\"math/tex; mode=display\">e</script>).</p> \n  <p>Note that if the last range didn't constitute an arithmetic slice, the same elements will be a part of the updated range as well. Thus, we can omit the rest of the ranges consisting of the same starting index. The rest of the process remains the same as in the last approach.</p> \n  <iframe src=\"https://leetcode.com/playground/NPDEAgTz/shared\" frameborder=\"0\" name=\"NPDEAgTz\" width=\"100%\" height=\"309\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^2)</script>. Two for loops are used.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant extra space is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-using-recursion-accepted\">Approach #3 Using Recursion [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>By making use of the observation discussed in the last approach, we know, that if a range of elements between the indices <script type=\"math/tex; mode=display\">(i,j)</script> constitute an Arithmetic Slice, and another element <script type=\"math/tex; mode=display\">A[j+1]</script> is included such that <script type=\"math/tex; mode=display\">A[j+1]</script> and <script type=\"math/tex; mode=display\">A[j]</script> have the same difference as that of the previous common difference, the ranges between <script type=\"math/tex; mode=display\">(i,j+1)</script> will constitutes an arithmetic slice. Further, if the original range <script type=\"math/tex; mode=display\">(i,j)</script> doesn't form an arithmetic slice, adding new elements to this range won't do us any good. Thus, no more arithmetic slices can be obtained by adding new elements to it.</p> \n  <p>By making use of this observation, we can develop a recursive solution for the given problem as well. Assume that a <script type=\"math/tex; mode=display\">sum</script> variable is used to store the total number of arithmetic slices in the given array <script type=\"math/tex; mode=display\">A</script>. We make use of a recursive function <code>slices(A,i)</code> which returns the number of Arithmetic Slices in the range <script type=\"math/tex; mode=display\">(k,i)</script>, but which are not a part of any range <script type=\"math/tex; mode=display\">(k,j)</script> such that <script type=\"math/tex; mode=display\">j<i</script>. It also updates <script type=\"math/tex; mode=display\">sum</script> with the number of arithmetic slices(total) in the current range. Thus, <script type=\"math/tex; mode=display\">k</script> refers to the minimum index such that the range <script type=\"math/tex; mode=display\">(k,i)</script> constitutes a valid arithmetic slice.</p> \n  <p>Now, suppose we know the number of arithmetic slices in the range <script type=\"math/tex; mode=display\">(0,i-1)</script> constituted by the elements <script type=\"math/tex; mode=display\">[a_0,a_1,a_2,...a_(i-1)]</script>, to be say <script type=\"math/tex; mode=display\">x</script>. If this range itself is an arithmetic slice, all the consecutive elements have the same difference(equal to say, <script type=\"math/tex; mode=display\">a_(i-1)-a_(i-2)</script>). Now, adding a new element <script type=\"math/tex; mode=display\">a_i</script> to it to extend the range to <script type=\"math/tex; mode=display\">(0,i)</script> will constitute an arithmetic slice only if this new element satisfies <script type=\"math/tex; mode=display\">a_i-a_(i-1)=a_(i-1)-a_(i-2)</script>. Thus, now, the addition of this new element, will lead to an addition of <script type=\"math/tex; mode=display\">ap</script> number of arithmetic slices to the ones obtained in the range <script type=\"math/tex; mode=display\">(0,i-1)</script>. The new arithmetic slices will be the ones constituting the ranges <script type=\"math/tex; mode=display\">(0,i), (1,i), ... (i-2,i)</script>, which are a total of <script type=\"math/tex; mode=display\">x+1</script> additional arithmetic slices. This is because, apart from the range <script type=\"math/tex; mode=display\">(0,i)</script> the rest of the ranges <script type=\"math/tex; mode=display\">(1,i), (2,i),...(i-2,i)</script> can be mapped to <script type=\"math/tex; mode=display\">(0,i-1), (1,i-1),...(i-3,i-1)</script>, with count equal to <script type=\"math/tex; mode=display\">x</script>. </p> \n  <p>Thus, in every call to <code>slices</code>, if the <script type=\"math/tex; mode=display\">i^{th}</script> element has the same common difference with the last element as the previous common difference, we can find the number of new arithmetic slices added by the use of this element, <script type=\"math/tex; mode=display\">ap</script> and also update the <script type=\"math/tex; mode=display\">sum</script> to include this <script type=\"math/tex; mode=display\">ap</script> into it, apart from the count obtained by the smaller ranges. But, if the new element doesn't have the same common difference, extra arithmetic slices can't be contributed by it and hence, no addition is done to <script type=\"math/tex; mode=display\">sum</script> for the current element. But, of course <script type=\"math/tex; mode=display\">sum</script> will be updated as per the count obtained from the smaller ranges.</p> \n  <iframe src=\"https://leetcode.com/playground/WGzuREMw/shared\" frameborder=\"0\" name=\"WGzuREMw\" width=\"100%\" height=\"360\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The recursive function is called at most <script type=\"math/tex; mode=display\">n-2</script> times.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The depth of the recursion tree goes upto <script type=\"math/tex; mode=display\">n-2</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-5-dynamic-programming-accepted\">Approach #5 Dynamic Programming [Accepted]:</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In the last approach, we start with the full range <script type=\"math/tex; mode=display\">(0,n-1)</script>, where <script type=\"math/tex; mode=display\">n</script> is the number of elements in the given <script type=\"math/tex; mode=display\">A</script> array. We can observe that the result for the range <script type=\"math/tex; mode=display\">(0,i)</script> only depends on the elements in the range <script type=\"math/tex; mode=display\">(0,i)</script> and not on any element beyond this range. Thus, we can make use of Dynamic Programming to solve the given problem.</p> \n  <p>We can make use of a 1-D <script type=\"math/tex; mode=display\">dp</script> with number of elements equal to <script type=\"math/tex; mode=display\">n</script>. <script type=\"math/tex; mode=display\">dp[i]</script> is used to store the number of arithmetic slices possible in the range <script type=\"math/tex; mode=display\">(k,i)</script> and not in any range <script type=\"math/tex; mode=display\">(k,j)</script> such that <script type=\"math/tex; mode=display\">j<i</script>. Again, <script type=\"math/tex; mode=display\">k</script> refers to the minimum index possible such that <script type=\"math/tex; mode=display\">(k,j)</script> constitutes a valid Arithmetic Slice.</p> \n  <p>Instead of going in the reverse order as in the recursive approach, we can start filling the <script type=\"math/tex; mode=display\">dp</script> in a forward manner. The intuition remains the same as in the last approach. For the <script type=\"math/tex; mode=display\">i^{th}</script> element being considered, we check if this element satsfies the common difference criteria with the previous element. If so, we know the number of new arithmetic slices added will be <script type=\"math/tex; mode=display\">1+dp[i-1]</script> as discussed in the last approach. The <script type=\"math/tex; mode=display\">sum</script> is also updated by the same count to reflect the new arithmetic slices added. </p> \n  <p>The following animation illustrates the <script type=\"math/tex; mode=display\">dp</script> filling process.</p> \n  <p>!?!../Documents/413_Arithmetic_Slices.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/w8UZ2q6u/shared\" frameborder=\"0\" name=\"w8UZ2q6u\" width=\"100%\" height=\"292\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. We traverse over the given <script type=\"math/tex; mode=display\">A</script> array with <script type=\"math/tex; mode=display\">n</script> elements once only.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. 1-D <script type=\"math/tex; mode=display\">dp</script> of size <script type=\"math/tex; mode=display\">n</script> is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-5-constant-space-dynamic-programming-accepted\">Approach #5 Constant Space Dynamic Programming [Accepted]:</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In the last approach, we can observe that we only require the element <script type=\"math/tex; mode=display\">dp[i-1]</script> to determine the value to be entered at <script type=\"math/tex; mode=display\">dp[i]</script>. Thus, instead of making use of a 1-D array to store the required data, we can simply keep a track of just the last element. </p> \n  <iframe src=\"https://leetcode.com/playground/mGEcWWi3/shared\" frameborder=\"0\" name=\"mGEcWWi3\" width=\"100%\" height=\"292\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. We traverse over the given <script type=\"math/tex; mode=display\">A</script> array with <script type=\"math/tex; mode=display\">n</script> elements once only.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant extra space is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-6-using-formula-accepted\">Approach #6 Using Formula [Accepted]:</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>From the <script type=\"math/tex; mode=display\">dp</script> solution, we can observe that for <script type=\"math/tex; mode=display\">k</script> consecutive elements sastisfying the common difference criteria, we update the <script type=\"math/tex; mode=display\">sum</script> for each such element by <script type=\"math/tex; mode=display\">1, 2, 3, ..., k</script> counts in that order. Thus, instead of updating the <script type=\"math/tex; mode=display\">sum</script> at the same time, we can just keep a track of the number of consecutive elements satisfying the common differnce criteria in a <script type=\"math/tex; mode=display\">count</script> variable and just update the <script type=\"math/tex; mode=display\">sum</script> directly as <script type=\"math/tex; mode=display\">count*(count+1)/2</script> whenver an element not satisfying this criteria is found. At the same time, we also need to reset the <script type=\"math/tex; mode=display\">count</script> value. </p> \n  <iframe src=\"https://leetcode.com/playground/fQULWrDF/shared\" frameborder=\"0\" name=\"fQULWrDF\" width=\"100%\" height=\"309\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. We iterate over <script type=\"math/tex; mode=display\">A</script> with <script type=\"math/tex; mode=display\">n</script> elements exactly once.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant extra space is used.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 412,
    "article_live": true,
    "article_slug": "fizz-buzz",
    "title": "Fizz Buzz",
    "title_slug": "fizz-buzz",
    "content": "<p>Write a program that outputs the string representation of numbers from 1 to <i>n</i>.</p>\r\n\r\n<p>But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.</p>\r\n\r\n<p><b>Example:</b>\r\n<pre>\r\nn = 15,\r\n\r\nReturn:\r\n[\r\n    \"1\",\r\n    \"2\",\r\n    \"Fizz\",\r\n    \"4\",\r\n    \"Buzz\",\r\n    \"Fizz\",\r\n    \"7\",\r\n    \"8\",\r\n    \"Fizz\",\r\n    \"Buzz\",\r\n    \"11\",\r\n    \"Fizz\",\r\n    \"13\",\r\n    \"14\",\r\n    \"FizzBuzz\"\r\n]\r\n</pre>\r\n</p>",
    "tags": "",
    "difficulty": 1,
    "frontend_article_id": 412,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-naive-approach\">Approach 1: Naive Approach</a></li> \n      <li><a href=\"#approach-2-string-concatenation\">Approach 2: String Concatenation</a></li> \n      <li><a href=\"#approach-3-hash-it\">Approach 3: Hash it!</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <p>You must have played FizzBuzz as kids. FizzBuzz charm never gets old. And so here we are looking at how you can take on one step at a time and impress your interviewer with a better and neat approach to solve this problem.</p> \n  <h4 id=\"approach-1-naive-approach\">Approach 1: Naive Approach</h4> \n  <p><strong>Intuition</strong></p> \n  <p>The moment you hear of FizzBuzz you think whether the number is divisible by <code>3</code>, <code>5</code> or both.</p> \n  <p><strong>Algorithm</strong></p> \n  <ol> \n   <li>Initialize an empty answer list.</li> \n   <li>Iterate on the numbers from <script type=\"math/tex; mode=display\">1 ... N</script>.</li> \n   <li>For every number, if it is divisible by both 3 and 5, add FizzBuzz to the answer list.</li> \n   <li>Else, Check if the number is divisible by 3, add Fizz.</li> \n   <li>Else, Check if the number is divisible by 5, add Buzz.</li> \n   <li>Else, add the number. </li> \n  </ol> \n  <p><br></p> \n  <iframe src=\"https://leetcode.com/playground/kohPDrYw/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"kohPDrYw\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script> </li> \n   <li>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script> <br> <br></li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-string-concatenation\">Approach 2: String Concatenation</h4> \n  <p><strong>Intuition</strong></p> \n  <p>This approach won't reduce the asymptotic complexity, but proves to be a neater solution when <code>FizzBuzz</code> comes with a twist. What if <code>FizzBuzz</code> is now <code>FizzBuzzJazz</code> i.e. </p>\n  <pre>3 ---&gt; \"Fizz\" , 5 ---&gt; \"Buzz\", 7 ---&gt; \"Jazz\"\n</pre>\n  <p></p> \n  <p>If you try to solve this with the previous approach the program would have too many conditions to check:</p> \n  <ol> \n   <li>Divisible by 3</li> \n   <li>Divisible by 5</li> \n   <li>Divisible by 7</li> \n   <li>Divisible by 3 and 5</li> \n   <li>Divisible by 3 and 7</li> \n   <li>Divisible by 7 and 3</li> \n   <li>Divisible by 3 and 5 and 7</li> \n   <li>Not divisible by 3 or 5 or 7.</li> \n  </ol> \n  <p>This way if the <code>FizzBuzz</code> mappings increase, the conditions would grow exponentially in your program. </p> \n  <p><strong>Algorithm</strong></p> \n  <p>Instead of checking for every combination of these conditions, check for divisibility by given numbers i.e. 3, 5 as given in the problem. If the number is divisible, concatenate the corresponding string mapping <code>Fizz</code> or <code>Buzz</code> to the current answer string.</p> \n  <p>For eg. If we are checking for the number 15, the steps would be: </p>\n  <pre>Condition 1: 15 % 3 == 0 , num_ans_str = \"Fizz\"\nCondition 2: 15 % 5 == 0 , num_ans_str += \"Buzz\"\n=&gt; num_ans_str = \"FizzBuzz\"\n</pre>\n  <p></p> \n  <p>So for <code>FizzBuzz</code> we just check for two conditions instead of three conditions as in the first approach.</p> \n  <p>Similarly, for <code>FizzBuzzJazz</code> now we would just have three conditions to check for divisibility.</p> \n  <iframe src=\"https://leetcode.com/playground/kpRjpMFa/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"kpRjpMFa\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script> </li> \n   <li>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script> <br> <br></li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-hash-it\">Approach 3: Hash it!</h4> \n  <p><strong>Intuition</strong></p> \n  <p>This approach is an optimization over approach 2. When the number of mappings are limited, approach 2 looks good. But what if you face a tricky interviewer and he decides to add too many mappings?</p> \n  <p>Having a condition for every mapping is not feasible or may be we can say the code might get ugly and tough to maintain.</p> \n  <p>What if tomorrow we have to change a mapping or may be delete a mapping? Are we going to change the code every time we have a modification in the mappings?</p> \n  <p>We don't have to. We can put all these mappings in a <code>Hash Table</code>.</p> \n  <p><strong>Algorithm</strong></p> \n  <ol> \n   <li>Put all the mappings in a hash table. The hash table <code>fizzBuzzHash</code> would look something like <code>{ 3: 'Fizz', 5: 'Buzz' }</code></li> \n   <li>Iterate on the numbers from <script type=\"math/tex; mode=display\">1 ... N</script>.</li> \n   <li>For every number, iterate over the <code>fizzBuzzHash</code> keys and check for divisibility.</li> \n   <li>If the number is divisible by the key, concatenate the corresponding hash value to the answer string for current number. We do this for every entry in the hash table.</li> \n   <li>Add the answer string to the answer list.</li> \n  </ol> \n  <blockquote> \n   <p>This way you can add/delete mappings to/from to the hash table and not worry about changing the code.</p> \n  </blockquote> \n  <p>So, for <code>FizzBuzzJazz</code> the hash table would look something like <code>{ 3: 'Fizz', 5: 'Buzz', 7: 'Jazz' }</code></p> \n  <iframe src=\"https://leetcode.com/playground/yRV2JDsz/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"yRV2JDsz\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time Complexity : <script type=\"math/tex; mode=display\">O(N)</script> </li> \n   <li>Space Complexity : <script type=\"math/tex; mode=display\">O(1)</script> <br><br></li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/godayaldivya/\">@godayaldivya</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 411,
    "article_live": false,
    "title": "Minimum Unique Word Abbreviation",
    "title_slug": "minimum-unique-word-abbreviation",
    "tags": "Backtracking, Bit Manipulation",
    "difficulty": 3,
    "frontend_article_id": 411
},
{
    "frontend_question_id": 410,
    "article_live": true,
    "article_slug": "split-array-largest-sum",
    "title": "Split Array Largest Sum",
    "title_slug": "split-array-largest-sum",
    "content": "<p>Given an array which consists of non-negative integers and an integer <i>m</i>, you can split the array into <i>m</i> non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these <i>m</i> subarrays.\r\n</p>\r\n\r\n<p><b>Note:</b><br />\r\nIf <i>n</i> is the length of array, assume the following constraints are satisfied:\r\n<ul>\r\n<li>1 &le; <i>n</i> &le; 1000</li>\r\n<li>1 &le; <i>m</i> &le; min(50, <i>n</i>)</li>\r\n</ul>\r\n</p>\r\n\r\n<p><b>Examples: </b>\r\n<pre>\r\nInput:\r\n<b>nums</b> = [7,2,5,10,8]\r\n<b>m</b> = 2\r\n\r\nOutput:\r\n18\r\n\r\nExplanation:\r\nThere are four ways to split <b>nums</b> into two subarrays.\r\nThe best way is to split it into <b>[7,2,5]</b> and <b>[10,8]</b>,\r\nwhere the largest sum among the two subarrays is only 18.\r\n</pre>\r\n</p>",
    "tags": "Binary Search, Dynamic Programming",
    "difficulty": 3,
    "frontend_article_id": 410,
    "article_content": ""
},
{
    "frontend_question_id": 409,
    "article_live": true,
    "article_slug": "longest-palindrome",
    "title": "Longest Palindrome",
    "title_slug": "longest-palindrome",
    "content": "<p>Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.</p>\r\n\r\n<p>This is case sensitive, for example <code>\"Aa\"</code> is not considered a palindrome here.</p>\r\n\r\n<p><b>Note:</b><br />\r\nAssume the length of given string will not exceed 1,010.\r\n</p>\r\n\r\n<p><b>Example: </b>\r\n<pre>\r\nInput:\r\n\"abccccdd\"\r\n\r\nOutput:\r\n7\r\n\r\nExplanation:\r\nOne longest palindrome that can be built is \"dccaccd\", whose length is 7.\r\n</pre>\r\n</p>",
    "tags": "Hash Table",
    "difficulty": 1,
    "frontend_article_id": 409,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-greedy-accepted\">Approach #1: Greedy [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-greedy-accepted\">Approach #1: Greedy [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>A palindrome consists of letters with equal partners, plus possibly a unique center (without a partner). The letter <code>i</code> from the left has its partner <code>i</code> from the right. For example in <code>'abcba'</code>, <code>'aa'</code> and <code>'bb'</code> are partners, and <code>'c'</code> is a unique center.</p> \n  <p>Imagine we built our palindrome. It consists of as many partnered letters as possible, plus a unique center if possible. This motivates a greedy approach.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>For each letter, say it occurs <code>v</code> times. We know we have <code>v // 2 * 2</code> letters that can be partnered for sure. For example, if we have <code>'aaaaa'</code>, then we could have <code>'aaaa'</code> partnered, which is <code>5 // 2 * 2 = 4</code> letters partnered.</p> \n  <p>At the end, if there was any <code>v % 2 == 1</code>, then that letter could have been a unique center. Otherwise, every letter was partnered. To perform this check, we will check for <code>v % 2 == 1</code> and <code>ans % 2 == 0</code>, the latter meaning we haven't yet added a unique center to the answer.</p> \n  <iframe src=\"https://leetcode.com/playground/ZnPVAdHR/shared\" frameborder=\"0\" width=\"100%\" height=\"310\" name=\"ZnPVAdHR\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>s</code>. We need to count each letter.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>, the space for our count, as the alphabet size of <code>s</code> is fixed. We should also consider that in a bit complexity model, technically we need <script type=\"math/tex; mode=display\">O(\\log N)</script> bits to store the count values.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/awice\">@awice</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 408,
    "article_live": false,
    "title": "Valid Word Abbreviation",
    "title_slug": "valid-word-abbreviation",
    "tags": "String",
    "difficulty": 1,
    "frontend_article_id": 408
},
{
    "frontend_question_id": 407,
    "article_live": false,
    "title": "Trapping Rain Water II",
    "title_slug": "trapping-rain-water-ii",
    "content": "<p>Given an <code>m x n</code> matrix of positive integers representing the height of each unit cell in a 2D elevation map, compute the volume of water it is able to trap after raining.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Note:</b></p>\r\n\r\n<p>Both <i>m</i> and <i>n</i> are less than 110. The height of each unit cell is greater than 0 and is less than 20,000.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Example:</b></p>\r\n\r\n<pre>\r\nGiven the following 3x6 height map:\r\n[\r\n  [1,4,3,1,3,2],\r\n  [3,2,1,3,2,4],\r\n  [2,3,3,2,3,1]\r\n]\r\n\r\nReturn 4.\r\n</pre>\r\n\r\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/13/rainwater_empty.png\" style=\"width: 100%; max-width: 500px;\" /></p>\r\n\r\n<p>The above image represents the elevation map <code>[[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]</code> before the rain.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/13/rainwater_fill.png\" style=\"width: 100%; max-width: 500px;\" /></p>\r\n\r\n<p>After the rain, water is trapped between the blocks. The total volume of water trapped is 4.</p>\r\n",
    "tags": "Heap, Breadth-first Search",
    "difficulty": 3,
    "frontend_article_id": 407
},
{
    "frontend_question_id": 406,
    "article_live": false,
    "title": "Queue Reconstruction by Height",
    "title_slug": "queue-reconstruction-by-height",
    "content": "<p>Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers <code>(h, k)</code>, where <code>h</code> is the height of the person and <code>k</code> is the number of people in front of this person who have a height greater than or equal to <code>h</code>. Write an algorithm to reconstruct the queue.\r\n</p>\r\n\r\n<p><b>Note:</b><br />\r\nThe number of people is less than 1,100.\r\n</p>\r\n\r\n<br />\r\n\r\n<p><b>Example</b>\r\n<pre>\r\nInput:\r\n[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]\r\n\r\nOutput:\r\n[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]\r\n</pre>\r\n</p>",
    "tags": "Greedy",
    "difficulty": 2,
    "frontend_article_id": 406
},
{
    "frontend_question_id": 405,
    "article_live": false,
    "title": "Convert a Number to Hexadecimal",
    "title_slug": "convert-a-number-to-hexadecimal",
    "content": "<p>\r\nGiven an integer, write an algorithm to convert it to hexadecimal. For negative integer, <a href=\"https://en.wikipedia.org/wiki/Two%27s_complement\" target=\"_blank\">two’s complement</a> method is used.\r\n</p>\r\n\r\n<p><b>Note:</b>\r\n<ol>\r\n<li>All letters in hexadecimal (<code>a-f</code>) must be in lowercase.</li>\r\n<li>The hexadecimal string must not contain extra leading <code>0</code>s. If the number is zero, it is represented by a single zero character <code>'0'</code>; otherwise, the first character in the hexadecimal string will not be the zero character.</li>\r\n<li>The given number is guaranteed to fit within the range of a 32-bit signed integer.</li>\r\n<li>You <b>must not use <i>any</i> method provided by the library</b> which converts/formats the number to hex directly.</li>\r\n</ol>\r\n</p>\r\n\r\n<p><b>Example 1:</b>\r\n<pre>\r\nInput:\r\n26\r\n\r\nOutput:\r\n\"1a\"\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b>\r\n<pre>\r\nInput:\r\n-1\r\n\r\nOutput:\r\n\"ffffffff\"\r\n</pre>\r\n</p>",
    "tags": "Bit Manipulation",
    "difficulty": 1,
    "frontend_article_id": 405
},
{
    "frontend_question_id": 404,
    "article_live": false,
    "title": "Sum of Left Leaves",
    "title_slug": "sum-of-left-leaves",
    "content": "<p>Find the sum of all left leaves in a given binary tree.</p>\r\n\r\n<p><b>Example:</b>\r\n<pre>\r\n    3\r\n   / \\\r\n  9  20\r\n    /  \\\r\n   15   7\r\n\r\nThere are two left leaves in the binary tree, with values <b>9</b> and <b>15</b> respectively. Return <b>24</b>.\r\n</pre>\r\n</p>",
    "tags": "Tree",
    "difficulty": 1,
    "frontend_article_id": 404
},
{
    "frontend_question_id": 403,
    "article_live": true,
    "article_slug": "frog-jump",
    "title": "Frog Jump",
    "title_slug": "frog-jump",
    "content": "<p>A frog is crossing a river. The river is divided into x units and at each unit there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.</p>\r\n\r\n<p>Given a list of stones' positions (in units) in sorted ascending order, determine if the frog is able to cross the river by landing on the last stone. Initially, the frog is on the first stone and assume the first jump must be 1 unit.\r\n</p>\r\n\r\n<p>If the frog's last jump was <i>k</i> units, then its next jump must be either <i>k</i> - 1, <i>k</i>, or <i>k</i> + 1 units. Note that the frog can only jump in the forward direction.</p>\r\n\r\n<p><b>Note:</b>\r\n<ul>\r\n<li>The number of stones is &ge; 2 and is < 1,100.</li>\r\n<li>Each stone's position will be a non-negative integer < 2<sup>31</sup>.</li>\r\n<li>The first stone's position is always 0.</li>\r\n</ul>\r\n</p>\r\n\r\n<p><b>Example 1:</b>\r\n<pre>\r\n<b>[0,1,3,5,6,8,12,17]</b>\r\n\r\nThere are a total of 8 stones.\r\nThe first stone at the 0th unit, second stone at the 1st unit,\r\nthird stone at the 3rd unit, and so on...\r\nThe last stone at the 17th unit.\r\n\r\n<b>Return true</b>. The frog can jump to the last stone by jumping \r\n1 unit to the 2nd stone, then 2 units to the 3rd stone, then \r\n2 units to the 4th stone, then 3 units to the 6th stone, \r\n4 units to the 7th stone, and 5 units to the 8th stone.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b>\r\n<pre>\r\n<b>[0,1,2,3,4,8,9,11]</b>\r\n\r\n<b>Return false</b>. There is no way to jump to the last stone as \r\nthe gap between the 5th and 6th stone is too large.\r\n</pre>\r\n</p>",
    "tags": "Dynamic Programming",
    "difficulty": 3,
    "frontend_article_id": 403,
    "article_content": ""
},
{
    "frontend_question_id": 402,
    "article_live": false,
    "title": "Remove K Digits",
    "title_slug": "remove-k-digits",
    "content": "<p>Given a non-negative integer <i>num</i> represented as a string, remove <i>k</i> digits from the number so that the new number is the smallest possible.\r\n</p>\r\n\r\n<p><b>Note:</b><br />\r\n<ul>\r\n<li>The length of <i>num</i> is less than 10002 and will be &ge; <i>k</i>.</li>\r\n<li>The given <i>num</i> does not contain any leading zero.</li>\r\n</ul>\r\n</b>\r\n</p>\r\n\r\n<p><b>Example 1:</b>\r\n<pre>\r\nInput: num = \"1432219\", k = 3\r\nOutput: \"1219\"\r\nExplanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b>\r\n<pre>\r\nInput: num = \"10200\", k = 1\r\nOutput: \"200\"\r\nExplanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 3:</b>\r\n<pre>\r\nInput: num = \"10\", k = 2\r\nOutput: \"0\"\r\nExplanation: Remove all the digits from the number and it is left with nothing which is 0.\r\n</pre>\r\n</p>",
    "tags": "Stack, Greedy",
    "difficulty": 2,
    "frontend_article_id": 402
},
{
    "frontend_question_id": 401,
    "article_live": false,
    "title": "Binary Watch",
    "title_slug": "binary-watch",
    "content": "<p>A binary watch has 4 LEDs on the top which represent the <b>hours</b> (<b>0-11</b>), and the 6 LEDs on the bottom represent the <b>minutes</b> (<b>0-59</b>).</p>\r\n<p>Each LED represents a zero or one, with the least significant bit on the right.</p>\r\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/8/8b/Binary_clock_samui_moon.jpg\" height=\"300\" />\r\n<p>For example, the above binary watch reads \"3:25\".</p>\r\n\r\n<p>Given a non-negative integer <i>n</i> which represents the number of LEDs that are currently on, return all possible times the watch could represent.</p>\r\n\r\n<p><b>Example:</b>\r\n<pre>Input: n = 1<br>Return: [\"1:00\", \"2:00\", \"4:00\", \"8:00\", \"0:01\", \"0:02\", \"0:04\", \"0:08\", \"0:16\", \"0:32\"]</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br />\r\n<ul>\r\n<li>The order of output does not matter.</li>\r\n<li>The hour must not contain a leading zero, for example \"01:00\" is not valid, it should be \"1:00\".</li>\r\n<li>The minute must be consist of two digits and may contain a leading zero, for example \"10:2\" is not valid, it should be \"10:02\".</li>\r\n</ul>\r\n</p>",
    "tags": "Backtracking, Bit Manipulation",
    "difficulty": 1,
    "frontend_article_id": 401
},
{
    "frontend_question_id": 400,
    "article_live": false,
    "title": "Nth Digit",
    "title_slug": "nth-digit",
    "content": "<p>Find the <i>n</i><sup>th</sup> digit of the infinite integer sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... </p>\r\n\r\n<p><b>Note:</b><br />\r\n<i>n</i> is positive and will fit within the range of a 32-bit signed integer (<i>n</i> < 2<sup>31</sup>).\r\n</p>\r\n\r\n<p><b>Example 1:</b>\r\n<pre>\r\n<b>Input:</b>\r\n3\r\n\r\n<b>Output:</b>\r\n3\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b>\r\n<pre>\r\n<b>Input:</b>\r\n11\r\n\r\n<b>Output:</b>\r\n0\r\n\r\n<b>Explanation:</b>\r\nThe 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10.\r\n</pre>\r\n</p>",
    "tags": "Math",
    "difficulty": 1,
    "frontend_article_id": 400
},
{
    "frontend_question_id": 399,
    "article_live": false,
    "title": "Evaluate Division",
    "title_slug": "evaluate-division",
    "content": "<p>\r\nEquations are given in the format <code>A / B = k</code>, where  <code>A</code> and <code>B</code> are variables represented as strings, and <code>k</code> is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return <code>-1.0</code>.\r\n</p>\r\n<p><b>Example:</b><br/>\r\nGiven <code> a / b = 2.0, b / c = 3.0.</code> <br/>queries are: <code> a / c = ?,  b / a = ?, a / e = ?,  a / a = ?, x / x = ? .</code> <br/>return <code> [6.0, 0.5, -1.0, 1.0, -1.0 ].</code>\r\n</p>\r\n<p>\r\nThe input is: <code> vector&lt;pair&lt;string, string&gt;&gt; equations, vector&lt;double&gt;&amp; values, vector&lt;pair&lt;string, string&gt;&gt; queries </code>, where <code>equations.size() == values.size()</code>, and the values are positive. This represents the equations. Return <code> vector&lt;double&gt;</code>.\r\n</p>\r\n\r\n<p>According to the example above:\r\n<pre>equations = [ [\"a\", \"b\"], [\"b\", \"c\"] ],\r\nvalues = [2.0, 3.0],\r\nqueries = [ [\"a\", \"c\"], [\"b\", \"a\"], [\"a\", \"e\"], [\"a\", \"a\"], [\"x\", \"x\"] ]. </pre>\r\n</p>\r\n\r\n<p>\r\nThe input is always valid. You may assume that evaluating the queries will result in no division by zero and there is no contradiction.\r\n</p>",
    "tags": "Graph",
    "difficulty": 2,
    "frontend_article_id": 399
},
{
    "frontend_question_id": 398,
    "article_live": false,
    "title": "Random Pick Index",
    "title_slug": "random-pick-index",
    "content": "<p>Given an array of integers with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array.</p>\r\n\r\n<p><b>Note:</b><br />\r\nThe array size can be very large. Solution that uses too much extra space will not pass the judge.</p>\r\n\r\n<p><b>Example:</b></p>\r\n\r\n<pre>\r\nint[] nums = new int[] {1,2,3,3,3};\r\nSolution solution = new Solution(nums);\r\n\r\n// pick(3) should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.\r\nsolution.pick(3);\r\n\r\n// pick(1) should return 0. Since in the array only nums[0] is equal to 1.\r\nsolution.pick(1);\r\n</pre>\r\n",
    "tags": "Reservoir Sampling",
    "difficulty": 2,
    "frontend_article_id": 398
},
{
    "frontend_question_id": 397,
    "article_live": false,
    "title": "Integer Replacement",
    "title_slug": "integer-replacement",
    "content": "<p>\r\nGiven a positive integer <i>n</i> and you can do operations as follow:\r\n</p>\r\n\r\n<p>\r\n<ol>\r\n<li>If <i>n</i> is even, replace <i>n</i> with <code><i>n</i>/2</code>.</li>\r\n<li>If <i>n</i> is odd, you can replace <i>n</i> with either <code><i>n</i> + 1</code> or <code><i>n</i> - 1</code>.</li>\r\n</ol>\r\n</p>\r\n\r\n<p>\r\nWhat is the minimum number of replacements needed for <i>n</i> to become 1?\r\n</p>\r\n\r\n</p>\r\n\r\n<p><b>Example 1:</b>\r\n<pre>\r\n<b>Input:</b>\r\n8\r\n\r\n<b>Output:</b>\r\n3\r\n\r\n<b>Explanation:</b>\r\n8 -> 4 -> 2 -> 1\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b>\r\n<pre>\r\n<b>Input:</b>\r\n7\r\n\r\n<b>Output:</b>\r\n4\r\n\r\n<b>Explanation:</b>\r\n7 -> 8 -> 4 -> 2 -> 1\r\nor\r\n7 -> 6 -> 3 -> 2 -> 1\r\n</pre>\r\n</p>",
    "tags": "Math, Bit Manipulation",
    "difficulty": 2,
    "frontend_article_id": 397
},
{
    "frontend_question_id": 396,
    "article_live": false,
    "title": "Rotate Function",
    "title_slug": "rotate-function",
    "content": "<p>\r\nGiven an array of integers <code>A</code> and let <i>n</i> to be its length.\r\n</p>\r\n\r\n<p>\r\nAssume <code>B<sub>k</sub></code> to be an array obtained by rotating the array <code>A</code> <i>k</i> positions clock-wise, we define a \"rotation function\" <code>F</code> on <code>A</code> as follow:\r\n</p>\r\n\r\n<p>\r\n<code>F(k) = 0 * B<sub>k</sub>[0] + 1 * B<sub>k</sub>[1] + ... + (n-1) * B<sub>k</sub>[n-1]</code>.</p>\r\n\r\n<p>Calculate the maximum value of <code>F(0), F(1), ..., F(n-1)</code>. \r\n</p>\r\n\r\n<p><b>Note:</b><br />\r\n<i>n</i> is guaranteed to be less than 10<sup>5</sup>.\r\n</p>\r\n\r\n<p><b>Example:</b>\r\n<pre>\r\nA = [4, 3, 2, 6]\r\n\r\nF(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25\r\nF(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16\r\nF(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23\r\nF(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26\r\n\r\nSo the maximum value of F(0), F(1), F(2), F(3) is F(3) = 26.\r\n</pre>\r\n</p>",
    "tags": "Math",
    "difficulty": 2,
    "frontend_article_id": 396
},
{
    "frontend_question_id": 395,
    "article_live": false,
    "title": "Longest Substring with At Least K Repeating Characters",
    "title_slug": "longest-substring-with-at-least-k-repeating-characters",
    "content": "<p>\r\nFind the length of the longest substring <b><i>T</i></b> of a given string (consists of lowercase letters only) such that every character in <b><i>T</i></b> appears no less than <i>k</i> times.\r\n</p>\r\n\r\n<p><b>Example 1:</b>\r\n<pre>\r\nInput:\r\ns = \"aaabb\", k = 3\r\n\r\nOutput:\r\n3\r\n\r\nThe longest substring is \"aaa\", as 'a' is repeated 3 times.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b>\r\n<pre>\r\nInput:\r\ns = \"ababbc\", k = 2\r\n\r\nOutput:\r\n5\r\n\r\nThe longest substring is \"ababb\", as 'a' is repeated 2 times and 'b' is repeated 3 times.\r\n</pre>\r\n</p>",
    "tags": "",
    "difficulty": 2,
    "frontend_article_id": 395
},
{
    "frontend_question_id": 394,
    "article_live": false,
    "title": "Decode String",
    "title_slug": "decode-string",
    "content": "<p>\r\nGiven an encoded string, return it's decoded string.\r\n</p>\r\n<p>\r\nThe encoding rule is: <code>k[encoded_string]</code>, where the <i>encoded_string</i> inside the square brackets is being repeated exactly <i>k</i> times. Note that <i>k</i> is guaranteed to be a positive integer.</p>\r\n\r\n<p>\r\nYou may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.</p>\r\n\r\n<p>Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, <i>k</i>. For example, there won't be input like <code>3a</code> or <code>2[4]</code>.\r\n</p>\r\n\r\n<p><b>Examples:</b>\r\n<pre>\r\ns = \"3[a]2[bc]\", return \"aaabcbc\".\r\ns = \"3[a2[c]]\", return \"accaccacc\".\r\ns = \"2[abc]3[cd]ef\", return \"abcabccdcdcdef\".\r\n</pre>\r\n</p>",
    "tags": "Stack, Depth-first Search",
    "difficulty": 2,
    "frontend_article_id": 394
},
{
    "frontend_question_id": 393,
    "article_live": true,
    "article_slug": "utf-8-validation",
    "title": "UTF-8 Validation",
    "title_slug": "utf-8-validation",
    "content": "<p>A character in UTF8 can be from <b>1 to 4 bytes</b> long, subjected to the following rules:</p>\r\n<ol>\r\n<li>For 1-byte character, the first bit is a 0, followed by its unicode code.</li>\r\n<li>For n-bytes character, the first n-bits are all one's, the n+1 bit is 0, followed by n-1 bytes with most significant 2 bits being 10.</li>\r\n</ol>\r\n<p>This is how the UTF-8 encoding would work:</p>\r\n\r\n<pre><code>   Char. number range  |        UTF-8 octet sequence\r\n      (hexadecimal)    |              (binary)\r\n   --------------------+---------------------------------------------\r\n   0000 0000-0000 007F | 0xxxxxxx\r\n   0000 0080-0000 07FF | 110xxxxx 10xxxxxx\r\n   0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx\r\n   0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\r\n</code></pre>\r\n<p>\r\nGiven an array of integers representing the data, return whether it is a valid utf-8 encoding.\r\n</p>\r\n<p>\r\n<b>Note:</b><br />\r\nThe input is an array of integers. Only the <b>least significant 8 bits</b> of each integer is used to store the data. This means each integer represents only 1 byte of data.\r\n</p>\r\n\r\n<p>\r\n<b>Example 1:</b>\r\n<pre>\r\ndata = [197, 130, 1], which represents the octet sequence: <b>11000101 10000010 00000001</b>.\r\n\r\nReturn <b>true</b>.\r\nIt is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character.\r\n</pre>\r\n</p>\r\n\r\n<p>\r\n<b>Example 2:</b>\r\n<pre>\r\ndata = [235, 140, 4], which represented the octet sequence: <b>11101011 10001100 00000100</b>.\r\n\r\nReturn <b>false</b>.\r\nThe first 3 bits are all one's and the 4th bit is 0 means it is a 3-bytes character.\r\nThe next byte is a continuation byte which starts with 10 and that's correct.\r\nBut the second continuation byte does not start with 10, so it is invalid.\r\n</pre>\r\n</p>",
    "tags": "Bit Manipulation",
    "difficulty": 2,
    "frontend_article_id": 393,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-string-manipulation\">Approach 1: String Manipulation.</a></li> \n      <li><a href=\"#approach-2-bit-manipulation\">Approach 2: Bit Manipulation</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <p><strong>Intuition</strong></p> \n  <p>This is an interesting problem to work with especially because it is not really hard to code up a solution for, but, you really need to pay attention to the details of the problem. A lot of people trying to solve the problem tend to miss out on small details that are mentioned and end up getting 1 or 2 test cases wrong.</p> \n  <p><strong>Note:</strong> The following section provides 3 different examples for the problem and explains them. If the test cases and the rules are clear to you, you can skip over the <code>Approach 1</code>.</p> \n  <p>The problem statement provides 2 different examples for you to understand the rules to define a valid UTF-8 charset. That might not be enough for a lot of people and so the first thing we would do is try to understand all the rules given in the problem statement and in the meantime look at a few examples in detail that will help clarify the problem. Here are the rules in the question statement:</p> \n  <ul> \n   <li>A valid UTF-8 character can be <code>1 - 4</code> bytes long.</li> \n   <li>For a <code>1-byte</code> character, the first bit is a <code>0</code>, followed by its unicode.</li> \n   <li>For an <code>n-bytes</code> character, the first <code>n-bits</code> are all ones, the <code>n+1</code> bit is 0, followed by <code>n-1</code> bytes with most significant 2 bits being <code>10</code>.</li> \n   <li>The input given would be an array of integers containing the data. We have to return if the data in the array represents a valid UTF-8 encoding. The important thing to note here is that the array doesn't contain data for <strong>just a single character</strong>. As can be seen from the first example, the array can contain data for multiple characters all of which can be valid UTF-8 characters and hence the charset represented by the array is valid.</li> \n   <li>Another important thing to note is that the integers in the array can be larger than 255 as well. The highest number that can be represented by 8 bits is 255. So, what do we do if an integer in the array is say, 476? According to the Note in the problem before the examples, we only have to consider the <strong>8 least significant bits</strong> of each integer in the array.</li> \n  </ul> \n  <p>Now that we have our rules defined for us, let us first look at the examples in the question and then some other examples from the discussion section that seem to cause a lot of confusion.</p> \n  <p><strong>Example 1</strong></p> \n  <pre>data = [197, 130, 1]\n</pre> \n  <p>Let us look at the octet sequence represented by the integers in this array. So, the octet sequence would be as follows:</p> \n  <pre>11000101 10000010 00000001\n</pre> \n  <blockquote> \n   <p>Remember, for an n-bytes UTF-8 character, the first n-bits would be 1 followed by a 0 in the n+1 bit. Then, the next n - 1 bytes would all have 10 as their most significant bits.</p> \n  </blockquote> \n  <pre>[1 1 0] 0 0 1 0 1\n ↑   ↑\n</pre> \n  <p>Clearly, we can see that the 2 most significant bits of this byte are 1s and they are followed by a 0. This implies the start of a valid UTF-8 character. The information that we can gather from this byte is that this is a 2-byte UTF-8 character. This means that the next byte in the sequence must follow the pattern <code>10xxxxxx</code>. Let's see if it does.</p> \n  <pre>[1 1 0] 0 0 1 0 1    [1 0] 0 0 0 0 1 0\n ↑   ↑                ↑ ↑\n</pre> \n  <p>Yes, it does follow the intended sequence and hence the first two integers in the array i.e. <code>197 130</code> combine to form a valid 2-byte UTF-8 character. Since there are more elements left in the array, we move on and check them in a similar fashion as we did with the numbers above. The next integer in the array is <code>1</code>. Let's look at the binary representation for this integer.</p> \n  <pre>00000001\n</pre> \n  <p>Since the most significant bit itself of this number is a <code>0</code>, the only rule it satisfies is the 1-byte UTF-8 character rule. Let's re-iterate the rule:</p> \n  <blockquote> \n   <p>For 1-byte character, the first bit or the most significant but is a 0, followed by its unicode code.</p> \n  </blockquote> \n  <pre>[0] 0 0 0 0 0 0 1\n ↑\n</pre> \n  <p>Clearly, the integer <code>1</code> is a valid 1-byte UTF-8 character in itself. Since there are no more elements left in the array to process, we will return <code>True</code> since there were two characters present in the array and both of them were valid UTF-8 encoded characters.</p> \n  <p><strong>Example 2</strong></p> \n  <pre>[235, 140, 4]\n</pre> \n  <p>This is the second example that's mentioned in the problem statement. As before, let us look at the binary representation of the integers in the array.</p> \n  <pre>11101011 10001100 00000100\n</pre> \n  <p>Let's start with the first integer in our array. The first byte will tell us the length of the UTF-8 character and hence the number of bytes we have to process in all in order to completely process a single UTF-8 character in the array before moving on to another one.</p> \n  <pre>[1 1 1 0] 1 0 1 1\n ↑     ↑\n</pre> \n  <p>So, the first few bits of the byte above are <code>1110</code>. This means that our UTF-8 character is of <code>3 bytes</code> in all. Remember the rule that helps us identify the size of a potential UTF-8 character from it's first byte.</p> \n  <blockquote> \n   <p>For an <code>n-bytes</code> character, the first <code>n-bits</code> are all one's, the <code>n+1</code> bit is 0.</p> \n  </blockquote> \n  <p>Following this rule we determined that the first UTF-8 character is of 3 bytes. Since we are done processing one byte of data, we are left with 2 other bytes of data to process before starting with another UTF-8 character. Let's look at the remaining two bytes of the array.</p> \n  <pre>[1 0] 0 0 1 1 0 0       0 0 0 0 0 1 0 0\n ↑ ↑                    ↑ (WRONG!)\n</pre> \n  <p>The first byte above follows our pattern of <code>10xxxxxx</code> but the second byte does not. We had to verify a UTF-8 encoded 3-byte character as we saw from the first byte of the sequence <code>11101011</code>. The final byte is something that doesn't adhere to our rules mentioned before. Since we found an invalid byte, we can simply return <code>False</code> and we don't need to process any data further.</p> \n  <p><strong>Example 3</strong></p> \n  <p>We will look at one final example before moving onto the solution for this problem. This example has caused a lot of confusion as can be seen from multiple posts on the discussion forum:</p> \n  <ul> \n   <li><a href=\"https://leetcode.com/problems/utf-8-validation/discuss/87451/The-problem-description-is-super-vague-to-me.\">Discussion Post - 1</a></li> \n   <li><a href=\"https://leetcode.com/problems/utf-8-validation/discuss/147353/250145145145145-seems-valid-yet-the-testcase-flags-that-as-invalid\">Discussion Post - 2</a></li> \n   <li><a href=\"https://leetcode.com/problems/utf-8-validation/discuss/87452/2749-pass-Python-easy-to-understand-don't-understand-why-case-250-145-145-145-145-need-return-false\">Discussion Post - 3</a></li> \n  </ul> \n  <p>So, the example is:</p> \n  <pre>[250,145,145,145,145]\n</pre> \n  <p>Let us look at the binary representation of all the integers in the array.</p> \n  <pre>11111010 10010001 10010001 10010001 10010001\n</pre> \n  <p>As we have been doing in the previous two examples, let us look at the first byte of data to determine how many number of bytes our UTF-8 encoded character will have. Looking at the first byte of data we can see that our first UTF-8 encoded character in the sequence of data given, is of <code>5 bytes</code>.</p> \n  <pre>[1 1 1 1 1 0] 1 0\n ↑         ↑  \n</pre> \n  <p>If this is a valid UTF-8 encoded character, the following four bytes of data should be in accordance with the pattern <code>10xxxxxx</code>. Let's look at the next 4 bytes of data one on each line.</p> \n  <pre>1. [1 0] 0 1 0 0 0 1\n2. [1 0] 0 1 0 0 0 1\n3. [1 0] 0 1 0 0 0 1\n4. [1 0] 0 1 0 0 0 1\n</pre> \n  <p>As we can see above, all the 4 bytes are in accordance with the rules specified in the problem. Why then the result for this specific test case, <code>False</code>? People tend to miss out on one of the rules mentioned in the problem.</p> \n  <blockquote> \n   <p>This is the first rule in the problem statement and it clearly says that \"A valid UTF-8 character can be 1 - 4 bytes long.\"</p> \n  </blockquote> \n  <p>The first byte of data indicates that the UTF-8 encoded character contains <code>5 bytes</code> of data which cannot be true. This is why the answer for this specific test case is <code>False</code>.</p> \n  <p>Hopefully, most of your doubts would have been cleared by the three examples that we looked at above. Let us now move on to the solution(s) for this problem. <br> <br></p> \n  <hr> \n  <h4 id=\"approach-1-string-manipulation\">Approach 1: String Manipulation.</h4> \n  <p>The problem itself is not that complicated. As long as we adhere to the rules specified in the problem, we should be fine. So, let's jump straight in and look at the algorithm.</p> \n  <p><strong>Algorithm</strong></p> \n  <ol> \n   <li>Start processing the integers in the given array one by one.</li> \n   <li>For every integer, obtain the binary representation in the <code>string format</code>. Since integers can be very large, we should only keep/consider the <code>8 least significant bits</code> of data and discard the rest as mentioned in the problem statement. After this step, you should have 8-bits or 1-byte string representation for the integer. Let the string we get here be called <code>bin_rep</code>.</li> \n   <li>There are two scenarios that we need to consider here in the next step.\n    <ol> \n     <li>One is that we are in the middle of processing some UTF-8 encoded character. In this case we simply need to check the first two bits of the string and see if they are <code>10</code> i.e. the 2 most significant bits of the integer being <code>1 and 0</code>. <code>bin_rep[:2] == \"10\"</code></li> \n     <li>The other case is that we already processed some valid UTF-8 characters and we have to start processing a new UTF-8 character. In that case we have to look at a prefix of the string representation and look at the number of <code>1</code>s that we encounter before encountering a <code>0</code>. This will tell us the size of the next UTF-8 character.</li> \n    </ol> </li> \n   <li>We keep on processing the integers of the array in this way until we either end up processing all of them or we find an invalid scenario.</li> \n  </ol> \n  <p>Let us move on to the implementation of this algorithm.</p> \n  <iframe src=\"https://leetcode.com/playground/8N3Akduu/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"8N3Akduu\"></iframe> \n  <p><strong>Complexity analysis</strong></p> \n  <ul> \n   <li>Time Complexity : <script type=\"math/tex; mode=display\">O(N)</script> since we process each integer of the array and for each integer we obtain an 8 character string which we then use for further processing. Overall the complexity is <script type=\"math/tex; mode=display\">O(N)</script> considering <script type=\"math/tex; mode=display\">N</script> is the number of integers in the array.</li> \n   <li>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script> since for every integer we create a new string that we play around with. <br> <br></li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-bit-manipulation\">Approach 2: Bit Manipulation</h4> \n  <p>The previous solution is exactly what the problem asks us to do except that the string conversion and manipulation takes a lot of time and that is something unnecessary. We can make use of bit manipulation to perform the same task.</p> \n  <p>Let us look at what parts of a byte corresponding to an integer do we need to process.</p> \n  <ol> \n   <li>If it is the starting byte for a UTF-8 character, then we need to process the first <script type=\"math/tex; mode=display\">N</script> bits where <script type=\"math/tex; mode=display\">N</script> will be at max 4. Anything more than that and we would have an invalid character.</li> \n   <li>In case the byte is a part of a UTF-8 character, then we simply need to check the first two bits or the most significant bits. The most significant bit needs to be a <code>1</code> and the second most significant bit needs to be a <code>0</code>.</li> \n  </ol> \n  <p>Let's see how we can make use of bit manipulation to perform both of these tasks.</p> \n  <pre>mask = 1 &lt;&lt; 7\nwhile mask &amp; num:\n    n_bytes += 1\n    mask = mask &gt;&gt; 1\n</pre> \n  <p>So, we have taken a mask = <code>1 &lt;&lt; 7</code> which is basically <code>10000000</code>. We will make use of this mask and <code>logically and</code> it with the number to see if the bit at a particular position is set of not. We do this iteratively to check how many bits are set starting from the most significant bit (Remember, the integer might be too large but we should only process the 8 least significant bits of data.)</p> \n  <p>To check if the most significant bit is a <code>1</code> and the second most significant bit is a <code>0</code>, we can make use of the following two masks</p> \n  <pre>mask1 = 1 &lt;&lt; 7\nmask2 = 1 &lt;&lt; 6\n\nif not (num &amp; mask1 and not (num &amp; mask2)):\n    return False\n</pre> \n  <p>The above code will simple use the <code>mask1</code> to check if the most significant bit is set to <code>1</code> and the second most significant bit is set to <code>0</code>. if this is not a case, then we return <code>False</code>.</p> \n  <p>Let's move onto the implementation.</p> \n  <iframe src=\"https://leetcode.com/playground/uDppv3wN/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"uDppv3wN\"></iframe> \n  <p><strong>Complexity analysis</strong></p> \n  <ul> \n   <li>Time Complexity : <script type=\"math/tex; mode=display\">O(N)</script>.</li> \n   <li>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>.</li> \n  </ul> \n  <p><br> <br></p> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/sachinmalhotra1993\">@sachinmalhotra1993</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 392,
    "article_live": false,
    "title": "Is Subsequence",
    "title_slug": "is-subsequence",
    "content": "<p>\r\nGiven a string <b>s</b> and a string <b>t</b>, check if <b>s</b> is subsequence of <b>t</b>.\r\n</p>\r\n\r\n<p>\r\nYou may assume that there is only lower case English letters in both <b>s</b> and <b>t</b>. <b>t</b> is potentially a very long (length ~= 500,000) string, and <b>s</b> is a short string (<=100).\r\n</p>\r\n\r\n<p>\r\nA subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, <code>\"ace\"</code> is a subsequence of <code>\"abcde\"</code> while <code>\"aec\"</code> is not).\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<b>s</b> = <code>\"abc\"</code>, <b>t</b> = <code>\"ahbgdc\"</code>\r\n</p>\r\n<p>\r\nReturn <code>true</code>.\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<b>s</b> = <code>\"axc\"</code>, <b>t</b> = <code>\"ahbgdc\"</code>\r\n</p>\r\n<p>\r\nReturn <code>false</code>.\r\n</p>\r\n\r\n<p><b>Follow up:</b><br />\r\nIf there are lots of incoming S, say S1, S2, ... , Sk where k >= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code?</p>\r\n\r\n<p><b>Credits:</b><br />Special thanks to <a href=\"https://leetcode.com/pbrother/\">@pbrother</a> for adding this problem and creating all test cases.</p>",
    "tags": "Binary Search, Dynamic Programming, Greedy",
    "difficulty": 2,
    "frontend_article_id": 392
},
{
    "frontend_question_id": 391,
    "article_live": false,
    "title": "Perfect Rectangle",
    "title_slug": "perfect-rectangle",
    "content": "<p>Given N axis-aligned rectangles where N &gt; 0, determine if they all together form an exact cover of a rectangular region.</p>\r\n\r\n<p>Each rectangle is represented as a bottom-left point and a top-right point. For example, a unit square is represented as [1,1,2,2]. (coordinate of bottom-left point is (1, 1) and top-right point is (2, 2)).</p>\r\n\r\n<div style=\"float:right\"><img src=\"https://assets.leetcode.com/uploads/2018/10/22/rectangle_perfect.gif\" style=\"width: 249px; height: 250px;\" /></div>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\nrectangles = [\r\n  [1,1,3,3],\r\n  [3,1,4,2],\r\n  [3,2,4,4],\r\n  [1,3,2,4],\r\n  [2,3,3,4]\r\n]\r\n\r\nReturn true. All 5 rectangles together form an exact cover of a rectangular region.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div style=\"clear:both\">&nbsp;</div>\r\n\r\n<div style=\"float:right\"><img src=\"https://assets.leetcode.com/uploads/2018/10/22/rectangle_separated.gif\" style=\"width: 249px; height: 250px;\" /></div>\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\nrectangles = [\r\n  [1,1,2,3],\r\n  [1,3,2,4],\r\n  [3,1,4,2],\r\n  [3,2,4,4]\r\n]\r\n\r\nReturn false. Because there is a gap between the two rectangular regions.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div style=\"clear:both\">&nbsp;</div>\r\n\r\n<div style=\"float:right\"><img src=\"https://assets.leetcode.com/uploads/2018/10/22/rectangle_hole.gif\" style=\"width: 249px; height: 250px;\" /></div>\r\n\r\n<p><b>Example 3:</b></p>\r\n\r\n<pre>\r\nrectangles = [\r\n  [1,1,3,3],\r\n  [3,1,4,2],\r\n  [1,3,2,4],\r\n  [3,2,4,4]\r\n]\r\n\r\nReturn false. Because there is a gap in the top center.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div style=\"clear:both\">&nbsp;</div>\r\n\r\n<div style=\"float:right\"><img src=\"https://assets.leetcode.com/uploads/2018/10/22/rectangle_intersect.gif\" style=\"width: 249px; height: 250px;\" /></div>\r\n\r\n<p><b>Example 4:</b></p>\r\n\r\n<pre>\r\nrectangles = [\r\n  [1,1,3,3],\r\n  [3,1,4,2],\r\n  [1,3,2,4],\r\n  [2,2,4,4]\r\n]\r\n\r\nReturn false. Because two of the rectangles overlap with each other.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n",
    "tags": "",
    "difficulty": 3,
    "frontend_article_id": 391
},
{
    "frontend_question_id": 390,
    "article_live": false,
    "title": "Elimination Game",
    "title_slug": "elimination-game",
    "content": "<p>\r\nThere is a list of sorted integers from 1 to <i>n</i>. Starting from left to right, remove the first number and every other number afterward until you reach the end of the list.</p>\r\n\r\n<p>Repeat the previous step again, but this time from right to left, remove the right most number and every other number from the remaining numbers.</p>\r\n\r\n<p>We keep repeating the steps again, alternating left to right and right to left, until a single number remains.</p>\r\n\r\n<p>Find the last number that remains starting with a list of length <i>n</i>.</p>\r\n\r\n<p><b>Example:</b>\r\n<pre>\r\nInput:\r\nn = 9,\r\n<u>1</u> 2 <u>3</u> 4 <u>5</u> 6 <u>7</u> 8 <u>9</u>\r\n2 <u>4</u> 6 <u>8</u>\r\n<u>2</u> 6\r\n6\r\n\r\nOutput:\r\n6\r\n</pre>\r\n</p>",
    "tags": "",
    "difficulty": 2,
    "frontend_article_id": 390
},
{
    "frontend_question_id": 389,
    "article_live": false,
    "title": "Find the Difference",
    "title_slug": "find-the-difference",
    "content": "<p>\r\nGiven two strings <b><i>s</i></b> and <b><i>t</i></b> which consist of only lowercase letters.</p>\r\n\r\n<p>String <b><i>t</i></b> is generated by random shuffling string <b><i>s</i></b> and then add one more letter at a random position.</p>\r\n\r\n<p>Find the letter that was added in <b><i>t</i></b>.</p>\r\n\r\n<p><b>Example:</b>\r\n<pre>\r\nInput:\r\ns = \"abcd\"\r\nt = \"abcde\"\r\n\r\nOutput:\r\ne\r\n\r\nExplanation:\r\n'e' is the letter that was added.\r\n</pre>",
    "tags": "Hash Table, Bit Manipulation",
    "difficulty": 1,
    "frontend_article_id": 389
},
{
    "frontend_question_id": 388,
    "article_live": false,
    "title": "Longest Absolute File Path",
    "title_slug": "longest-absolute-file-path",
    "content": "<p>Suppose we abstract our file system by a string in the following manner:</p>\r\n\r\n<p>The string <code>\"dir\\n\\tsubdir1\\n\\tsubdir2\\n\\t\\tfile.ext\"</code> represents:</p>\r\n\r\n<pre>dir\r\n    subdir1\r\n    subdir2\r\n        file.ext\r\n</pre>\r\n\r\n<p>The directory <code>dir</code> contains an empty sub-directory <code>subdir1</code> and a sub-directory <code>subdir2</code> containing a file <code>file.ext</code>.</p>\r\n\r\n<p>The string <code>\"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\"</code> represents:</p>\r\n\r\n<pre>dir\r\n    subdir1\r\n        file1.ext\r\n        subsubdir1\r\n    subdir2\r\n        subsubdir2\r\n            file2.ext\r\n</pre>\r\n\r\n<p>The directory <code>dir</code> contains two sub-directories <code>subdir1</code> and <code>subdir2</code>. <code>subdir1</code> contains a file <code>file1.ext</code> and an empty second-level sub-directory <code>subsubdir1</code>. <code>subdir2</code> contains a second-level sub-directory <code>subsubdir2</code> containing a file <code>file2.ext</code>.</p>\r\n\r\n<p>We are interested in finding the longest (number of characters) absolute path to a file within our file system. For example, in the second example above, the longest absolute path is <code>\"dir/subdir2/subsubdir2/file2.ext\"</code>, and its length is <code>32</code> (not including the double quotes).</p>\r\n\r\n<p>Given a string representing the file system in the above format, return the length of the longest absolute path to file in the abstracted file system. If there is no file in the system, return <code>0</code>.</p>\r\n\r\n<p><b>Note:</b><br />\r\n<ul>\r\n<li>The name of a file contains at least a <code>.</code> and an extension.</li>\r\n<li>The name of a directory or sub-directory will not contain a <code>.</code>.</li>\r\n</ul>\r\n</p>\r\n\r\n<p>Time complexity required: <code>O(n)</code> where <code>n</code> is the size of the input string.</p>\r\n\r\n<p>Notice that <code>a/aa/aaa/file1.txt</code> is not the longest file path, if there is another path <code>aaaaaaaaaaaaaaaaaaaaa/sth.png</code>.</p>",
    "tags": "",
    "difficulty": 2,
    "frontend_article_id": 388
},
{
    "frontend_question_id": 387,
    "article_live": false,
    "title": "First Unique Character in a String",
    "title_slug": "first-unique-character-in-a-string",
    "content": "<p>\r\nGiven a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.\r\n</p>\r\n<p><b>Examples:</b>\r\n<pre>\r\ns = \"leetcode\"\r\nreturn 0.\r\n\r\ns = \"loveleetcode\",\r\nreturn 2.\r\n</pre>\r\n</p>\r\n\r\n<p>\r\n<b>Note:</b> You may assume the string contain only lowercase letters.\r\n</p>",
    "tags": "Hash Table, String",
    "difficulty": 1,
    "frontend_article_id": 387
},
{
    "frontend_question_id": 386,
    "article_live": false,
    "title": "Lexicographical Numbers",
    "title_slug": "lexicographical-numbers",
    "content": "<p>\r\nGiven an integer <i>n</i>, return 1 - <i>n</i> in lexicographical order.\r\n</p>\r\n\r\n<p>\r\nFor example, given 13, return: [1,10,11,12,13,2,3,4,5,6,7,8,9].\r\n</p>\r\n\r\n<p>\r\nPlease optimize your algorithm to use less time and space. The input size may be as large as 5,000,000.\r\n</p>",
    "tags": "",
    "difficulty": 2,
    "frontend_article_id": 386
},
{
    "frontend_question_id": 385,
    "article_live": false,
    "title": "Mini Parser",
    "title_slug": "mini-parser",
    "content": "<p>Given a nested list of integers represented as a string, implement a parser to deserialize it.</p>\r\n\r\n<p>Each element is either an integer, or a list -- whose elements may also be integers or other lists.</p>\r\n\r\n<p><b>Note:</b>\r\nYou may assume that the string is well-formed:\r\n<ul>\r\n<li>String is non-empty.</li>\r\n<li>String does not contain white spaces.</li>\r\n<li>String contains only digits <code>0-9</code>, <code>[</code>, <code>-</code> <code>,</code>, <code>]</code>.</li>\r\n</ul>\r\n</p>\r\n\r\n<p><b>Example 1:</b>\r\n<pre>\r\nGiven s = \"324\",\r\n\r\nYou should return a NestedInteger object which contains a single integer 324.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b>\r\n<pre>\r\nGiven s = \"[123,[456,[789]]]\",\r\n\r\nReturn a NestedInteger object containing a nested list with 2 elements:\r\n\r\n1. An integer containing value 123.\r\n2. A nested list containing two elements:\r\n    i.  An integer containing value 456.\r\n    ii. A nested list with one element:\r\n         a. An integer containing value 789.\r\n</pre>\r\n</p>",
    "tags": "String, Stack",
    "difficulty": 2,
    "frontend_article_id": 385
},
{
    "frontend_question_id": 384,
    "article_live": true,
    "article_slug": "shuffle-an-array",
    "title": "Shuffle an Array",
    "title_slug": "shuffle-an-array",
    "content": "<p>Shuffle a set of numbers without duplicates.\r\n</p>\r\n\r\n<p><b>Example:</b>\r\n<pre>\r\n// Init an array with set 1, 2, and 3.\r\nint[] nums = {1,2,3};\r\nSolution solution = new Solution(nums);\r\n\r\n// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.\r\nsolution.shuffle();\r\n\r\n// Resets the array back to its original configuration [1,2,3].\r\nsolution.reset();\r\n\r\n// Returns the random shuffling of array [1,2,3].\r\nsolution.shuffle();\r\n</pre>\r\n</p>",
    "tags": "",
    "difficulty": 2,
    "frontend_article_id": 384,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#initial-thoughts\">Initial Thoughts</a></li> \n    <li><a href=\"#approach-1-brute-force-accepted\">Approach #1 Brute Force [Accepted]</a></li> \n    <li><a href=\"#approach-2-fisher-yates-algorithm-accepted\">Approach #2 Fisher-Yates Algorithm [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"initial-thoughts\">Initial Thoughts</h4> \n  <p>Normally I would display more than two approaches, but shuffling is deceptively easy to do <em>almost</em> properly, and the Fisher-Yates algorithm is both the canonical solution and asymptotically optimal.</p> \n  <p>A few notes on randomness are necessary before beginning - both approaches displayed below assume that the languages' pseudorandom number generators (PRNGs) are sufficiently random. The sample code uses the simplest techniques available for getting pseudorandom numbers, but for each possible permutation of the array to be truly equally likely, more care must be taken. For example, an array of length <script type=\"math/tex; mode=display\">n</script> has <script type=\"math/tex; mode=display\">n!</script> distinct permutations. Therefore, in order to encode all permutations in an integer space, <script type=\"math/tex; mode=display\">\\lceil lg(n!)\\rceil</script> bits are necessary, which may not be guaranteed by the default PRNG.</p> \n  <h4 id=\"approach-1-brute-force-accepted\">Approach #1 Brute Force [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>If we put each number in a \"hat\" and draw them out at random, the order in which we draw them will define a random ordering.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>The brute force algorithm essentially puts each number in the aforementioned \"hat\", and draws them at random (without replacement) until there are none left. Mechanically, this is performed by copying the contents of <code>array</code> into a second auxiliary array named <code>aux</code> before overwriting each element of <code>array</code> with a randomly selected one from <code>aux</code>. After selecting each random element, it is removed from <code>aux</code> to prevent duplicate draws. The implementation of <code>reset</code> is simple, as we just store the original state of <code>nums</code> on construction.</p> \n  <p>The correctness of the algorithm follows from the fact that an element (without loss of generality) is equally likely to be selected during all iterations of the <code>for</code> loop. To prove this, observe that the probability of a particular element <script type=\"math/tex; mode=display\">e</script> being chosen on the <script type=\"math/tex; mode=display\">k</script>th iteration (indexed from 0) is simply <script type=\"math/tex; mode=display\">P(e</script> being chosen during the <script type=\"math/tex; mode=display\">k</script>th iteration<script type=\"math/tex; mode=display\">)\\cdot P(e</script> not being chosen before the <script type=\"math/tex; mode=display\">k</script>th iteration<script type=\"math/tex; mode=display\">)</script>. Given that the array to be shuffled has <script type=\"math/tex; mode=display\">n</script> elements, this probability is more concretely stated as the following:</p> \n  <p> <script type=\"math/tex; mode=display\">\n   \\frac{1}{n-k} \\cdot \\prod_{i=1}^{k} \\frac{n-i}{n-i+1}\n</script> </p> \n  <p>When expanded (and rearranged), it looks like this (for sufficiently large <script type=\"math/tex; mode=display\">k</script>):</p> \n  <p> <script type=\"math/tex; mode=display\">\n   (\\frac{n-1}{n}\n   \\cdot \\frac{n-2}{n-1}\n   \\cdot (\\ldots)\n   \\cdot \\frac{n-k+1}{n-k+2}\n   \\cdot \\frac{n-k}{n-k+1})\n   \\cdot \\frac{1}{n-k}\n</script> </p> \n  <p>For the base case (<script type=\"math/tex; mode=display\">k = 0</script>), it is trivial to see that <script type=\"math/tex; mode=display\">\\frac{1}{n-k} = \\frac{1}{n}</script>. For <script type=\"math/tex; mode=display\">k > 0</script>, the numerator of each fraction can be cancelled with the denominator of the next, leaving the <script type=\"math/tex; mode=display\">n</script> from the 0th draw as the only uncancelled denominator. Therefore, no matter on which draw an element is drawn, it is drawn with a <script type=\"math/tex; mode=display\">\\frac{1}{n}</script> chance, so each array permutation is equally likely to arise.</p> \n  <iframe src=\"https://leetcode.com/playground/FWMsaXQ7/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"FWMsaXQ7\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^2)</script> </p> <p>The quadratic time complexity arises from the calls to <code>list.remove</code> (or <code>list.pop</code>), which run in linear time. <script type=\"math/tex; mode=display\">n</script> linear list removals occur, which results in a fairly easy quadratic analysis.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script> </p> <p>Because the problem also asks us to implement <code>reset</code>, we must use linear additional space to store the original array. Otherwise, it would be lost upon the first call to <code>shuffle</code>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-fisher-yates-algorithm-accepted\">Approach #2 Fisher-Yates Algorithm [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>We can cut down the time and space complexities of <code>shuffle</code> with a bit of cleverness - namely, by swapping elements around within the array itself, we can avoid the linear space cost of the auxiliary array and the linear time cost of list modification.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>The Fisher-Yates algorithm is remarkably similar to the brute force solution. On each iteration of the algorithm, we generate a random integer between the current index and the last index of the array. Then, we swap the elements at the current index and the chosen index - this simulates drawing (and removing) the element from the hat, as the next range from which we select a random index will not include the most recently processed one. One small, yet important detail is that it is possible to swap an element with itself - otherwise, some array permutations would be more likely than others. To see this illustrated more clearly, consider the animation below:</p> \n  <p>!?!../Documents/384_Shuffle_an_Array.json:697,161!?!</p> \n  <iframe src=\"https://leetcode.com/playground/ftmztsv8/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"ftmztsv8\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script> </p> <p>The Fisher-Yates algorithm runs in linear time, as generating a random index and swapping two values can be done in constant time.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script> </p> <p>Although we managed to avoid using linear space on the auxiliary array from the brute force approach, we still need it for <code>reset</code>, so we're stuck with linear space complexity.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/emptyset\">@emptyset</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 383,
    "article_live": false,
    "title": "Ransom Note",
    "title_slug": "ransom-note",
    "content": "<p>\r\nGiven an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom \r\nnote can be constructed from the magazines ; otherwise, it will return false. \r\n</p>\r\n<p>\r\nEach letter in the magazine string can only be used once in your ransom note.\r\n</p>\r\n\r\n<p><b>Note:</b><br />\r\nYou may assume that both strings contain only lowercase letters.\r\n</p>\r\n\r\n<pre>\r\ncanConstruct(\"a\", \"b\") -> false\r\ncanConstruct(\"aa\", \"ab\") -> false\r\ncanConstruct(\"aa\", \"aab\") -> true\r\n</pre>\r\n",
    "tags": "String",
    "difficulty": 1,
    "frontend_article_id": 383
},
{
    "frontend_question_id": 382,
    "article_live": false,
    "title": "Linked List Random Node",
    "title_slug": "linked-list-random-node",
    "content": "<p>Given a singly linked list, return a random node's value from the linked list. Each node must have the <b>same probability</b> of being chosen.</p>\r\n\r\n<p><b>Follow up:</b><br />\r\nWhat if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space?\r\n</p>\r\n\r\n<p><b>Example:</b>\r\n<pre>\r\n// Init a singly linked list [1,2,3].\r\nListNode head = new ListNode(1);\r\nhead.next = new ListNode(2);\r\nhead.next.next = new ListNode(3);\r\nSolution solution = new Solution(head);\r\n\r\n// getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning.\r\nsolution.getRandom();\r\n</pre>\r\n</p>",
    "tags": "Reservoir Sampling",
    "difficulty": 2,
    "frontend_article_id": 382
},
{
    "frontend_question_id": 381,
    "article_live": false,
    "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
    "title_slug": "insert-delete-getrandom-o1-duplicates-allowed",
    "content": "<p>Design a data structure that supports all following operations in <i>average</i> <b>O(1)</b> time.</p>\r\n<b>Note: Duplicate elements are allowed.</b>\r\n<p>\r\n<ol>\r\n<li><code>insert(val)</code>: Inserts an item val to the collection.</li>\r\n<li><code>remove(val)</code>: Removes an item val from the collection if present.</li>\r\n<li><code>getRandom</code>: Returns a random element from current collection of elements. The probability of each element being returned is <b>linearly related</b> to the number of same value the collection contains.</li>\r\n</ol>\r\n</p>\r\n\r\n<p><b>Example:</b>\r\n<pre>\r\n// Init an empty collection.\r\nRandomizedCollection collection = new RandomizedCollection();\r\n\r\n// Inserts 1 to the collection. Returns true as the collection did not contain 1.\r\ncollection.insert(1);\r\n\r\n// Inserts another 1 to the collection. Returns false as the collection contained 1. Collection now contains [1,1].\r\ncollection.insert(1);\r\n\r\n// Inserts 2 to the collection, returns true. Collection now contains [1,1,2].\r\ncollection.insert(2);\r\n\r\n// getRandom should return 1 with the probability 2/3, and returns 2 with the probability 1/3.\r\ncollection.getRandom();\r\n\r\n// Removes 1 from the collection, returns true. Collection now contains [1,2].\r\ncollection.remove(1);\r\n\r\n// getRandom should return 1 and 2 both equally likely.\r\ncollection.getRandom();\r\n</pre>\r\n</p>",
    "tags": "Array, Hash Table, Design",
    "difficulty": 3,
    "frontend_article_id": 381
},
{
    "frontend_question_id": 380,
    "article_live": false,
    "title": "Insert Delete GetRandom O(1)",
    "title_slug": "insert-delete-getrandom-o1",
    "content": "<p>Design a data structure that supports all following operations in <i>average</i> <b>O(1)</b> time.</p>\r\n\r\n<p>\r\n<ol>\r\n<li><code>insert(val)</code>: Inserts an item val to the set if not already present.</li>\r\n<li><code>remove(val)</code>: Removes an item val from the set if present.</li>\r\n<li><code>getRandom</code>: Returns a random element from current set of elements. Each element must have the <b>same probability</b> of being returned.</li>\r\n</ol>\r\n</p>\r\n\r\n<p><b>Example:</b>\r\n<pre>\r\n// Init an empty set.\r\nRandomizedSet randomSet = new RandomizedSet();\r\n\r\n// Inserts 1 to the set. Returns true as 1 was inserted successfully.\r\nrandomSet.insert(1);\r\n\r\n// Returns false as 2 does not exist in the set.\r\nrandomSet.remove(2);\r\n\r\n// Inserts 2 to the set, returns true. Set now contains [1,2].\r\nrandomSet.insert(2);\r\n\r\n// getRandom should return either 1 or 2 randomly.\r\nrandomSet.getRandom();\r\n\r\n// Removes 1 from the set, returns true. Set now contains [2].\r\nrandomSet.remove(1);\r\n\r\n// 2 was already in the set, so return false.\r\nrandomSet.insert(2);\r\n\r\n// Since 2 is the only number in the set, getRandom always return 2.\r\nrandomSet.getRandom();\r\n</pre>\r\n</p>",
    "tags": "Array, Hash Table, Design",
    "difficulty": 2,
    "frontend_article_id": 380
},
{
    "frontend_question_id": 379,
    "article_live": false,
    "title": "Design Phone Directory",
    "title_slug": "design-phone-directory",
    "tags": "Linked List, Design",
    "difficulty": 2,
    "frontend_article_id": 379
},
{
    "frontend_question_id": 378,
    "article_live": false,
    "title": "Kth Smallest Element in a Sorted Matrix",
    "title_slug": "kth-smallest-element-in-a-sorted-matrix",
    "content": "<p>Given a <i>n</i> x <i>n</i> matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.</p>\r\n\r\n<p>\r\nNote that it is the kth smallest element in the sorted order, not the kth distinct element.\r\n</p>\r\n\r\n<p><b>Example:</b>\r\n<pre>\r\nmatrix = [\r\n   [ 1,  5,  9],\r\n   [10, 11, 13],\r\n   [12, 13, 15]\r\n],\r\nk = 8,\r\n\r\nreturn 13.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note: </b><br>\r\nYou may assume k is always valid, 1 &le; k &le; n<sup>2</sup>.</p>",
    "tags": "Binary Search, Heap",
    "difficulty": 2,
    "frontend_article_id": 378
},
{
    "frontend_question_id": 377,
    "article_live": false,
    "title": "Combination Sum IV",
    "title_slug": "combination-sum-iv",
    "content": "<p> Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.</p>\r\n\r\n<p><b>Example:</b>\r\n<pre>\r\n<i><b>nums</b></i> = [1, 2, 3]\r\n<i><b>target</b></i> = 4\r\n\r\nThe possible combination ways are:\r\n(1, 1, 1, 1)\r\n(1, 1, 2)\r\n(1, 2, 1)\r\n(1, 3)\r\n(2, 1, 1)\r\n(2, 2)\r\n(3, 1)\r\n\r\nNote that different sequences are counted as different combinations.\r\n\r\nTherefore the output is <i><b>7</i></b>.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Follow up:</b><br />\r\nWhat if negative numbers are allowed in the given array?<br />\r\nHow does it change the problem?<br />\r\nWhat limitation we need to add to the question to allow negative numbers? </p>\r\n\r\n<p><b>Credits:</b><br />Special thanks to <a href=\"https://leetcode.com/pbrother/\">@pbrother</a> for adding this problem and creating all test cases.</p>",
    "tags": "Dynamic Programming",
    "difficulty": 2,
    "frontend_article_id": 377
},
{
    "frontend_question_id": 376,
    "article_live": true,
    "article_slug": "wiggle-subsequence",
    "title": "Wiggle Subsequence",
    "title_slug": "wiggle-subsequence",
    "content": "<p>A sequence of numbers is called a <strong>wiggle sequence</strong> if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence.</p>\r\n\r\n<p>For example, <code>[1,7,4,9,2,5]</code> is a wiggle sequence because the differences <code>(6,-3,5,-7,3)</code> are alternately positive and negative. In contrast, <code>[1,4,7,2,5]</code> and <code>[1,7,4,5,5]</code> are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero.</p>\r\n\r\n<p>Given a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[1,7,4,9,2,5]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">6\r\n<strong>Explanation:</strong> </span>The entire sequence is a wiggle sequence.</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">[1,17,5,10,13,15,10,5,16,8]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">7\r\n</span><span id=\"example-output-1\"><strong>Explanation: </strong></span>There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-3-1\">[1,2,3,4,5,6,7,8,9]</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">2</span></pre>\r\n\r\n<p><b>Follow up:</b><br />\r\nCan you do it in O(<i>n</i>) time?</p>\r\n</div>\r\n</div>\r\n",
    "tags": "Dynamic Programming, Greedy",
    "difficulty": 2,
    "frontend_article_id": 376,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#summary\">Summary</a></li> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-dynamic-programming-accepted\">Approach #2 Dynamic Programming [Accepted]</a></li> \n      <li><a href=\"#approach-3-linear-dynamic-programming-accepted\">Approach #3 Linear Dynamic Programming [Accepted]</a></li> \n      <li><a href=\"#approach-4-space-optimized-dynamic-programming-accepted\">Approach #4 Space-Optimized Dynamic Programming [Accepted]</a></li> \n      <li><a href=\"#approach-5-greedy-approach-accepted\">Approach #5 Greedy Approach [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"summary\">Summary</h2> \n  <p>We need to find the length of the longest wiggle subsequence. A wiggle subsequence consists of a subsequence with numbers which appears in alternating ascending / descending order.</p> \n  <h2 id=\"solution\">Solution</h2> \n  <h4 id=\"approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</h4> \n  <p>Here, we can find the length of every possible wiggle subsequence and find the maximum length out of them. To implement this, we use a recursive function, <script type=\"math/tex; mode=display\">\\text{calculate}(\\text{nums}, \\text{index}, \\text{isUp})</script> which takes the array <script type=\"math/tex; mode=display\">\\text{nums}</script>, the <script type=\"math/tex; mode=display\">\\text{index}</script> from which we need to find the length of the longest wiggle subsequence, boolean variable <script type=\"math/tex; mode=display\">\\text{isUp}</script> to tell whether we need to find an increasing wiggle or decreasing wiggle respectively. If the function <script type=\"math/tex; mode=display\">\\text{calculate}</script> is called after an increasing wiggle, we need to find the next decreasing wiggle with the same function. If the function <script type=\"math/tex; mode=display\">\\text{calculate}</script> is called after a decreasing wiggle, we need to find the next increasing wiggle with the same function.</p> \n  <iframe src=\"https://leetcode.com/playground/JXWefkVB/shared\" frameborder=\"0\" name=\"JXWefkVB\" width=\"100%\" height=\"326\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time complexity : <script type=\"math/tex; mode=display\">O(n!)</script>. <script type=\"math/tex; mode=display\">\\text{calculate}()</script> will be called maximum <script type=\"math/tex; mode=display\">n!</script> times.</li> \n   <li>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Recursion of depth <script type=\"math/tex; mode=display\">n</script> is used.</li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-dynamic-programming-accepted\">Approach #2 Dynamic Programming [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>To understand this approach, take two arrays for dp named <script type=\"math/tex; mode=display\">up</script> and <script type=\"math/tex; mode=display\">down</script>.</p> \n  <p>Whenever we pick up any element of the array to be a part of the wiggle subsequence, that element could be a part of a rising wiggle or a falling wiggle depending upon which element we have taken prior to it.</p> \n  <p> <script type=\"math/tex; mode=display\">up[i]</script> refers to the length of the longest wiggle subsequence obtained so far considering <script type=\"math/tex; mode=display\">i^{th}</script> element as the last element of the wiggle subsequence and ending with a rising wiggle.</p> \n  <p>Similarly, <script type=\"math/tex; mode=display\">down[i]</script> refers to the length of the longest wiggle subsequence obtained so far considering <script type=\"math/tex; mode=display\">i^{th}</script> element as the last element of the wiggle subsequence and ending with a falling wiggle.</p> \n  <p> <script type=\"math/tex; mode=display\">up[i]</script> will be updated every time we find a rising wiggle ending with the <script type=\"math/tex; mode=display\">i^{th}</script> element. Now, to find <script type=\"math/tex; mode=display\">up[i]</script>, we need to consider the maximum out of all the previous wiggle subsequences ending with a falling wiggle i.e. <script type=\"math/tex; mode=display\">down[j]</script>, for every <script type=\"math/tex; mode=display\">j&lt;i</script> and <script type=\"math/tex; mode=display\">nums[i]&gt;nums[j]</script>. Similarly, <script type=\"math/tex; mode=display\">down[i]</script> will be updated.</p> \n  <iframe src=\"https://leetcode.com/playground/5DeX9SiP/shared\" frameborder=\"0\" name=\"5DeX9SiP\" width=\"100%\" height=\"360\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time complexity : <script type=\"math/tex; mode=display\">O(n^2)</script>. Loop inside a loop.</li> \n   <li>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Two arrays of the same length are used for dp.</li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-linear-dynamic-programming-accepted\">Approach #3 Linear Dynamic Programming [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Any element in the array could correspond to only one of the three possible states:</p> \n  <ol> \n   <li>up position, it means <script type=\"math/tex; mode=display\">nums[i] > nums[i-1]</script> </li> \n   <li>down position, it means <script type=\"math/tex; mode=display\">nums[i] < nums[i-1]</script> </li> \n   <li>equals to position, <script type=\"math/tex; mode=display\">nums[i] == nums[i-1]</script> </li> \n  </ol> \n  <p>The updates are done as:</p> \n  <p>If <script type=\"math/tex; mode=display\">nums[i] > nums[i-1]</script>, that means it wiggles up. The element before it must be a down position. So <script type=\"math/tex; mode=display\">up[i] = down[i-1] + 1</script>, <script type=\"math/tex; mode=display\">down[i]</script> remains the same as <script type=\"math/tex; mode=display\">down[i-1]</script>. If <script type=\"math/tex; mode=display\">nums[i] < nums[i-1]</script>, that means it wiggles down. The element before it must be a up position. So <script type=\"math/tex; mode=display\">down[i] = up[i-1] + 1</script>, <script type=\"math/tex; mode=display\">up[i]</script> remains the same as <script type=\"math/tex; mode=display\">up[i-1]</script>. If <script type=\"math/tex; mode=display\">nums[i] == nums[i-1]</script>, that means it will not change anything becaue it didn't wiggle at all. So both <script type=\"math/tex; mode=display\">down[i]</script> and <script type=\"math/tex; mode=display\">up[i]</script> remain the same as <script type=\"math/tex; mode=display\">down[i-1]</script> and <script type=\"math/tex; mode=display\">up[i-1]</script>.</p> \n  <p>At the end, we can find the larger out of <script type=\"math/tex; mode=display\">up[length-1]</script> and <script type=\"math/tex; mode=display\">down[length-1]</script> to find the max. wiggle subsequence length, where <script type=\"math/tex; mode=display\">length</script> refers to the number of elements in the given array.</p> \n  <p>The process can be illustrated with the following example:</p> \n  <!--![Wiggle gif](https://leetcode.com/media/original_images/376_Wiggle_Subsequence.gif)--> \n  <p>!?!../Documents/376_Wiggle.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/iKGkFpFG/shared\" frameborder=\"0\" name=\"iKGkFpFG\" width=\"100%\" height=\"428\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Only one pass over the array length.</li> \n   <li>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Two arrays of the same length are used for dp.</li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-4-space-optimized-dynamic-programming-accepted\">Approach #4 Space-Optimized Dynamic Programming [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>This approach relies on the same concept as <a href=\"https://leetcode.com/articles/wiggle-subsequence/#approach-3-linear-dynamic-programming-accepted\">Approach #3</a>. But we can observe that in the DP approach, for updating elements <script type=\"math/tex; mode=display\">up[i]</script> and <script type=\"math/tex; mode=display\">down[i]</script>, we need only the elements <script type=\"math/tex; mode=display\">up[i-1]</script> and <script type=\"math/tex; mode=display\">down[i-1]</script>. Thus, we can save space by not using the whole array, but only the last elements.</p> \n  <iframe src=\"https://leetcode.com/playground/hUCEjR4D/shared\" frameborder=\"0\" name=\"hUCEjR4D\" width=\"100%\" height=\"292\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Only one pass over the array length.</li> \n   <li>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant space is used.</li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-5-greedy-approach-accepted\">Approach #5 Greedy Approach [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>We need not necessarily need dp to solve this problem. This problem is equivalent to finding the number of alternating max. and min. peaks in the array. Since, if we choose any other intermediate number to be a part of the current wiggle subsequence, the maximum length of that wiggle subsequence will always be less than or equal to the one obtained by choosing only the consecutive max. and min. elements.</p> \n  <p>This can be clarified by looking at the following figure: <img alt=\"Wiggle Peaks\" src=\"https://leetcode.com/media/original_images/376_Wiggle_Subsequence.PNG\"></p> \n  <p>From the above figure, we can see that if we choose <strong>C</strong> instead of <strong>D</strong> as the 2nd point in the wiggle subsequence, we can't include the point <strong>E</strong>. Thus, we won't obtain the maximum length wiggle subsequence.</p> \n  <p>Thus, to solve this problem, we maintain a variable <script type=\"math/tex; mode=display\">\\text{prevdiff}</script>, where <script type=\"math/tex; mode=display\">\\text{prevdiff}</script> is used to indicate whether the current subsequence of numbers lies in an increasing or decreasing wiggle. If <script type=\"math/tex; mode=display\">\\text{prevdiff} > 0</script>, it indicates that we have found the increasing wiggle and are looking for a decreasing wiggle now. Thus, we update the length of the found subsequence when <script type=\"math/tex; mode=display\">\\text{diff}</script> (<script type=\"math/tex; mode=display\">nums[i]-nums[i-1]</script>) becomes negative. Similarly, if <script type=\"math/tex; mode=display\">\\text{prevdiff} < 0</script>, we will update the count when <script type=\"math/tex; mode=display\">\\text{diff}</script> (<script type=\"math/tex; mode=display\">nums[i]-nums[i-1]</script>) becomes positive.</p> \n  <p>When the complete array has been traversed, we get the required count, which represents the length of the longest wiggle subsequence.</p> \n  <iframe src=\"https://leetcode.com/playground/AqoaR5Ks/shared\" frameborder=\"0\" name=\"AqoaR5Ks\" width=\"100%\" height=\"326\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. We traverse the given array once.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. No extra space is used.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 375,
    "article_live": true,
    "article_slug": "guess-number-higher-or-lower-ii",
    "title": "Guess Number Higher or Lower II",
    "title_slug": "guess-number-higher-or-lower-ii",
    "content": "<p>We are playing the Guess Game. The game is as follows:</p>\r\n\r\n<p>I pick a number from <strong>1</strong> to <strong>n</strong>. You have to guess which number I picked.</p>\r\n\r\n<p>Every time you guess wrong, I&#39;ll tell you whether the number I picked is higher or lower.</p>\r\n\r\n<p>However, when you guess a particular number x, and you guess wrong, you pay <b>$x</b>. You win the game when you guess the number I picked.</p>\r\n\r\n<p><b>Example:</b></p>\r\n\r\n<pre>\r\nn = 10, I pick 8.\r\n\r\nFirst round:  You guess 5, I tell you that it&#39;s higher. You pay $5.\r\nSecond round: You guess 7, I tell you that it&#39;s higher. You pay $7.\r\nThird round:  You guess 9, I tell you that it&#39;s lower. You pay $9.\r\n\r\nGame over. 8 is the number I picked.\r\n\r\nYou end up paying $5 + $7 + $9 = $21.\r\n</pre>\r\n\r\n<p>Given a particular <strong>n &ge; 1</strong>, find out how much money you need to have to guarantee a <b>win</b>.</p>",
    "tags": "Dynamic Programming, Minimax",
    "difficulty": 2,
    "frontend_article_id": 375,
    "article_content": ""
},
{
    "frontend_question_id": 374,
    "article_live": true,
    "article_slug": "guess-number-higher-or-lower",
    "title": "Guess Number Higher or Lower",
    "title_slug": "guess-number-higher-or-lower",
    "content": "<p>We are playing the Guess Game. The game is as follows:</p>\r\n\r\n<p>I pick a number from <b>1</b> to <b><i>n</i></b>. You have to guess which number I picked.</p>\r\n\r\n<p>Every time you guess wrong, I&#39;ll tell you whether the number is higher or lower.</p>\r\n\r\n<p>You call a pre-defined API <code>guess(int num)</code> which returns 3 possible results (<code>-1</code>, <code>1</code>, or <code>0</code>):</p>\r\n\r\n<pre>\r\n-1 : My number is lower\r\n 1 : My number is higher\r\n 0 : Congrats! You got it!\r\n</pre>\r\n\r\n<p><strong>Example :</strong></p>\r\n\r\n<div>\r\n<pre>\r\n<strong>Input: </strong>n = <span id=\"example-input-1-1\">10</span>, pick = <span id=\"example-input-1-2\">6</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">6</span>\r\n</pre>\r\n</div>\r\n",
    "tags": "Binary Search",
    "difficulty": 1,
    "frontend_article_id": 374,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-binary-search-accepted\">Approach #2 Binary Search [Accepted]</a></li> \n      <li><a href=\"#approach-3-ternary-search-accepted\">Approach #3 Ternary Search [Accepted]</a></li> \n     </ul> </li> \n    <li><a href=\"#follow-up\">Follow up</a>\n     <ul> \n      <li><a href=\"#comparisons-between-binary-search-and-ternary-search\">Comparisons between Binary Search and Ternary Search</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</h4> \n  <p>We check every number from 1 to n-1 and pass it to the <script type=\"math/tex; mode=display\">guess</script> function. The number for which a 0 is returned is the required answer.</p> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"cm\">/* The guess API is defined in the parent class GuessGame.</span>\n<span class=\"cm\">   @param num, your guess</span>\n<span class=\"cm\">   @return -1 if my number is lower, 1 if my number is higher, otherwise return 0</span>\n<span class=\"cm\">      int guess(int num); */</span>\n\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"kd\">extends</span> <span class=\"n\">GuessGame</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">guessNumber</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">guess</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n                <span class=\"k\">return</span> <span class=\"n\">i</span><span class=\"o\">;</span>\n        <span class=\"k\">return</span> <span class=\"n\">n</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. We scan all the numbers from 1 to n.</li> \n   <li>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. No extra space is used.</li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-binary-search-accepted\">Approach #2 Binary Search [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>We can apply Binary Search to find the given number. We start with the mid number. We pass that number to the <script type=\"math/tex; mode=display\">guess</script> function. If it returns a -1, it implies that the guessed number is larger than the required one. Thus, we use Binary Search for numbers lower than itself. Similarly, if it returns a 1, we use Binary Search for numbers higher than itself.</p> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"cm\">/* The guess API is defined in the parent class GuessGame.</span>\n<span class=\"cm\">   @param num, your guess</span>\n<span class=\"cm\">   @return -1 if my number is lower, 1 if my number is higher, otherwise return 0</span>\n<span class=\"cm\">      int guess(int num); */</span>\n\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"kd\">extends</span> <span class=\"n\">GuessGame</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">guessNumber</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">low</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"o\">;</span>\n        <span class=\"kt\">int</span> <span class=\"n\">high</span> <span class=\"o\">=</span> <span class=\"n\">n</span><span class=\"o\">;</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">low</span> <span class=\"o\">&lt;=</span> <span class=\"n\">high</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kt\">int</span> <span class=\"n\">mid</span> <span class=\"o\">=</span> <span class=\"n\">low</span> <span class=\"o\">+</span> <span class=\"o\">(</span><span class=\"n\">high</span> <span class=\"o\">-</span> <span class=\"n\">low</span><span class=\"o\">)</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"o\">;</span>\n            <span class=\"kt\">int</span> <span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"n\">guess</span><span class=\"o\">(</span><span class=\"n\">mid</span><span class=\"o\">);</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">res</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n                <span class=\"k\">return</span> <span class=\"n\">mid</span><span class=\"o\">;</span>\n            <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">res</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n                <span class=\"n\">high</span> <span class=\"o\">=</span> <span class=\"n\">mid</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">;</span>\n            <span class=\"k\">else</span>\n                <span class=\"n\">low</span> <span class=\"o\">=</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time complexity : <script type=\"math/tex; mode=display\">O\\big(\\log_2 n\\big)</script>. Binary Search is used.</li> \n   <li>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. No extra space is used.</li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-ternary-search-accepted\">Approach #3 Ternary Search [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In Binary Search, we choose the middle element as the pivot in splitting. In Ternary Search, we choose two pivots (say <script type=\"math/tex; mode=display\">m1</script> and <script type=\"math/tex; mode=display\">m2</script>) such that the given range is divided into three equal parts. If the required number <script type=\"math/tex; mode=display\">num</script> is less than <script type=\"math/tex; mode=display\">m1</script> then we apply ternary search on the left segment of <script type=\"math/tex; mode=display\">m1</script>. If <script type=\"math/tex; mode=display\">num</script> lies between <script type=\"math/tex; mode=display\">m1</script> and <script type=\"math/tex; mode=display\">m2</script>, we apply ternary search between <script type=\"math/tex; mode=display\">m1</script> and <script type=\"math/tex; mode=display\">m2</script>. Otherwise we will search in the segment right to <script type=\"math/tex; mode=display\">m2</script>.</p> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"cm\">/* The guess API is defined in the parent class GuessGame.</span>\n<span class=\"cm\">   @param num, your guess</span>\n<span class=\"cm\">   @return -1 if my number is lower, 1 if my number is higher, otherwise return 0</span>\n<span class=\"cm\">      int guess(int num); */</span>\n\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"kd\">extends</span> <span class=\"n\">GuessGame</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">guessNumber</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">low</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"o\">;</span>\n        <span class=\"kt\">int</span> <span class=\"n\">high</span> <span class=\"o\">=</span> <span class=\"n\">n</span><span class=\"o\">;</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">low</span> <span class=\"o\">&lt;=</span> <span class=\"n\">high</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kt\">int</span> <span class=\"n\">mid1</span> <span class=\"o\">=</span> <span class=\"n\">low</span> <span class=\"o\">+</span> <span class=\"o\">(</span><span class=\"n\">high</span> <span class=\"o\">-</span> <span class=\"n\">low</span><span class=\"o\">)</span> <span class=\"o\">/</span> <span class=\"mi\">3</span><span class=\"o\">;</span>\n            <span class=\"kt\">int</span> <span class=\"n\">mid2</span> <span class=\"o\">=</span> <span class=\"n\">high</span> <span class=\"o\">-</span> <span class=\"o\">(</span><span class=\"n\">high</span> <span class=\"o\">-</span> <span class=\"n\">low</span><span class=\"o\">)</span> <span class=\"o\">/</span> <span class=\"mi\">3</span><span class=\"o\">;</span>\n            <span class=\"kt\">int</span> <span class=\"n\">res1</span> <span class=\"o\">=</span> <span class=\"n\">guess</span><span class=\"o\">(</span><span class=\"n\">mid1</span><span class=\"o\">);</span>\n            <span class=\"kt\">int</span> <span class=\"n\">res2</span> <span class=\"o\">=</span> <span class=\"n\">guess</span><span class=\"o\">(</span><span class=\"n\">mid2</span><span class=\"o\">);</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">res1</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n                <span class=\"k\">return</span> <span class=\"n\">mid1</span><span class=\"o\">;</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">res2</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n                <span class=\"k\">return</span> <span class=\"n\">mid2</span><span class=\"o\">;</span>\n            <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">res1</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n                <span class=\"n\">high</span> <span class=\"o\">=</span> <span class=\"n\">mid1</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">;</span>\n            <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">res2</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n                <span class=\"n\">low</span> <span class=\"o\">=</span> <span class=\"n\">mid2</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">;</span>\n            <span class=\"k\">else</span> <span class=\"o\">{</span>\n                <span class=\"n\">low</span> <span class=\"o\">=</span> <span class=\"n\">mid1</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">;</span>\n                <span class=\"n\">high</span> <span class=\"o\">=</span> <span class=\"n\">mid2</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time complexity : <script type=\"math/tex; mode=display\">O\\big(\\log_3 n \\big)</script>. Ternary Search is used.</li> \n   <li>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. No extra space is used.</li> \n  </ul> \n  <hr> \n  <h2 id=\"follow-up\">Follow up</h2> \n  <p>It seems that ternary search is able to terminate earlier compared to binary search. But why is binary search more widely used?</p> \n  <h4 id=\"comparisons-between-binary-search-and-ternary-search\">Comparisons between Binary Search and Ternary Search</h4> \n  <p>Ternary Search is worse than Binary Search. The following outlines the recursive formula to count comparisons of Binary Search in the worst case.</p> \n  <p> <script type=\"math/tex; mode=display\">\n\\begin{align*}\nT(n) &= T\\bigg(\\frac{n}{2} \\ \\bigg) + 2, \\quad T(1) = 1 \\\\\nT\\bigg(\\frac{n}{2} \\ \\bigg) &= T\\bigg(\\frac{n}{2^2} \\ \\bigg) + 2 \\\\\n\\\\\n\\therefore{} \\quad T(n) &= T\\bigg(\\frac{n}{2^2} \\ \\bigg) + 2 \\times 2 \\\\\n&= T\\bigg(\\frac{n}{2^3} \\ \\bigg) + 3 \\times 2 \\\\\n&= \\ldots \\\\\n&= T\\bigg(\\frac{n}{2^{\\log_2 n}} \\ \\bigg) + 2 \\log_2 n \\\\\n&= T(1) + 2 \\log_2 n \\\\\n&= 1 + 2 \\log_2 n\n\\end{align*}\n</script> </p> \n  <p>The following outlines the recursive formula to count comparisons of Ternary Search in the worst case.</p> \n  <p> <script type=\"math/tex; mode=display\">\n\\begin{align*}\nT(n) &= T\\bigg(\\frac{n}{3} \\ \\bigg) + 4, \\quad T(1) = 1 \\\\\nT\\bigg(\\frac{n}{3} \\ \\bigg) &= T\\bigg(\\frac{n}{3^2} \\ \\bigg) + 4 \\\\\n\\\\\n\\therefore{} \\quad T(n) &= T\\bigg(\\frac{n}{3^2} \\ \\bigg) + 2 \\times 4 \\\\\n&= T\\bigg(\\frac{n}{3^3} \\ \\bigg) + 3 \\times 4 \\\\\n&= \\ldots \\\\\n&= T\\bigg(\\frac{n}{3^{\\log_3 n}} \\ \\bigg) + 4 \\log_3 n \\\\\n&= T(1) + 4 \\log_3 n \\\\\n&= 1 + 4 \\log_3 n\n\\end{align*}\n</script> </p> \n  <p>As shown above, the total comparisons in the worst case for ternary and binary search are <script type=\"math/tex; mode=display\">1 + 4 \\log_3 n</script> and <script type=\"math/tex; mode=display\">1 + 2 \\log_2 n</script> comparisons respectively. To determine which is larger, we can just look at the expression <script type=\"math/tex; mode=display\">2 \\log_3 n</script> and <script type=\"math/tex; mode=display\">\\log_2 n</script> . The expression <script type=\"math/tex; mode=display\">2 \\log_3 n</script> can be written as <script type=\"math/tex; mode=display\">\\frac{2}{\\log_2 3} \\times \\log_2 n</script> . Since the value of <script type=\"math/tex; mode=display\">\\frac{2}{\\log_2 3}</script> is greater than one, Ternary Search does more comparisons than Binary Search in the worst case.</p> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 373,
    "article_live": false,
    "title": "Find K Pairs with Smallest Sums",
    "title_slug": "find-k-pairs-with-smallest-sums",
    "content": "<p>You are given two integer arrays <b>nums1</b> and <b>nums2</b> sorted in ascending order and an integer <b>k</b>.</p>\r\n\r\n<p>Define a pair <b>(u,v)</b> which consists of one element from the first array and one element from the second array.</p>\r\n\r\n<p>Find the k pairs <b>(u<sub>1</sub>,v<sub>1</sub>),(u<sub>2</sub>,v<sub>2</sub>) ...(u<sub>k</sub>,v<sub>k</sub>)</b> with the smallest sums.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>nums1 = <span id=\"example-input-1-1\">[1,7,11]</span>, nums2 = <span id=\"example-input-1-2\">[2,4,6]</span>, k = <span id=\"example-input-1-3\">3</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">[[1,2],[1,4],[1,6]] \r\n<strong>Explanation: </strong></span>The first 3 pairs are returned from the sequence: \r\n&nbsp;            [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>nums1 = [1,1,2], nums2 = [1,2,3], k = 2\r\n<strong>Output: </strong>[1,1],[1,1]<span>\r\n<strong>Explanation: </strong></span>The first 2 pairs are returned from the sequence: \r\n&nbsp;            [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>nums1 = [1,2], nums2 = [3], k = 3\r\n<strong>Output: </strong>[1,3],[2,3]<span>\r\n<strong>Explanation: </strong></span>All possible pairs are returned from the sequence: [1,3],[2,3]\r\n</pre>",
    "tags": "Heap",
    "difficulty": 2,
    "frontend_article_id": 373
},
{
    "frontend_question_id": 372,
    "article_live": false,
    "title": "Super Pow",
    "title_slug": "super-pow",
    "content": "<p>Your task is to calculate <i>a</i><sup><i>b</i></sup> mod 1337 where <i>a</i> is a positive integer and <i>b</i> is an extremely large positive integer given in the form of an array.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<div>\r\n<pre>\r\n<strong>Input: </strong>a = <span id=\"example-input-1-1\">2</span>, b = <span id=\"example-input-1-2\">[3]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">8</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>a = <span id=\"example-input-2-1\">2</span>, b = <span id=\"example-input-2-2\">[1,0]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">1024</span>\r\n</pre>\r\n</div>\r\n</div>",
    "tags": "Math",
    "difficulty": 2,
    "frontend_article_id": 372
},
{
    "frontend_question_id": 371,
    "article_live": false,
    "title": "Sum of Two Integers",
    "title_slug": "sum-of-two-integers",
    "content": "<p>Calculate the sum of two integers <i>a</i> and <i>b</i>, but you are <b>not allowed</b> to use the operator <code>+</code> and <code>-</code>.</p>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>a = <span id=\"example-input-1-1\">1</span>, b = <span id=\"example-input-1-2\">2</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">3</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>a = -<span id=\"example-input-2-1\">2</span>, b = <span id=\"example-input-2-2\">3</span>\r\n<strong>Output: </strong>1\r\n</pre>\r\n</div>\r\n</div>",
    "tags": "Bit Manipulation",
    "difficulty": 1,
    "frontend_article_id": 371
},
{
    "frontend_question_id": 370,
    "article_live": true,
    "article_slug": "range-addition",
    "title": "Range Addition",
    "title_slug": "range-addition",
    "tags": "Array",
    "difficulty": 2,
    "frontend_article_id": 370,
    "article_content": ""
},
{
    "frontend_question_id": 369,
    "article_live": false,
    "title": "Plus One Linked List",
    "title_slug": "plus-one-linked-list",
    "tags": "Linked List",
    "difficulty": 2,
    "frontend_article_id": 369
},
{
    "frontend_question_id": 368,
    "article_live": false,
    "title": "Largest Divisible Subset",
    "title_slug": "largest-divisible-subset",
    "content": "<p>Given a set of <b>distinct</b> positive integers, find the largest subset such that every pair (S<sub>i</sub>, S<sub>j</sub>) of elements in this subset satisfies:</p>\r\n\r\n<p>S<sub>i</sub> % S<sub>j</sub> = 0 or S<sub>j</sub> % S<sub>i</sub> = 0.</p>\r\n\r\n<p>If there are multiple solutions, return any subset is fine.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<div>\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[1,2,3]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">[1,2] </span>(of course, [1,3] will also be ok)\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">[1,2,4,8]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">[1,2,4,8]</span>\r\n</pre>\r\n</div>\r\n</div>",
    "tags": "Math, Dynamic Programming",
    "difficulty": 2,
    "frontend_article_id": 368
},
{
    "frontend_question_id": 367,
    "article_live": false,
    "title": "Valid Perfect Square",
    "title_slug": "valid-perfect-square",
    "content": "<p>Given a positive integer <i>num</i>, write a function which returns True if <i>num</i> is a perfect square else False.</p>\r\n\r\n<p><b>Note:</b> <b>Do not</b> use any built-in library function such as <code>sqrt</code>.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<div>\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">16</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">true</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">14</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">false</span>\r\n</pre>\r\n</div>\r\n</div>",
    "tags": "Math, Binary Search",
    "difficulty": 1,
    "frontend_article_id": 367
},
{
    "frontend_question_id": 366,
    "article_live": false,
    "title": "Find Leaves of Binary Tree",
    "title_slug": "find-leaves-of-binary-tree",
    "tags": "Tree, Depth-first Search",
    "difficulty": 2,
    "frontend_article_id": 366
},
{
    "frontend_question_id": 365,
    "article_live": false,
    "title": "Water and Jug Problem",
    "title_slug": "water-and-jug-problem",
    "content": "<p>You are given two jugs with capacities <i>x</i> and <i>y</i> litres. There is an infinite amount of water supply available. You need to determine whether it is possible to measure exactly <i>z</i> litres using these two jugs.</p>\r\n\r\n<p>If <i>z</i> liters of water is measurable, you must have <i>z</i> liters of water contained within <b>one or both buckets</b> by the end.</p>\r\n\r\n<p>Operations allowed:</p>\r\n\r\n<ul>\r\n\t<li>Fill any of the jugs completely with water.</li>\r\n\t<li>Empty any of the jugs.</li>\r\n\t<li>Pour water from one jug into another till the other jug is completely full or the first jug itself is empty.</li>\r\n</ul>\r\n\r\n<p><b>Example 1:</b> (From the famous <a href=\"https://www.youtube.com/watch?v=BVtQNK_ZUJg\" target=\"_blank\"><i>&quot;Die Hard&quot;</i> example</a>)</p>\r\n\r\n<pre>\r\nInput: x = 3, y = 5, z = 4\r\nOutput: True\r\n</pre>\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\nInput: x = 2, y = 6, z = 5\r\nOutput: False\r\n</pre>",
    "tags": "Math",
    "difficulty": 2,
    "frontend_article_id": 365
},
{
    "frontend_question_id": 364,
    "article_live": false,
    "title": "Nested List Weight Sum II",
    "title_slug": "nested-list-weight-sum-ii",
    "tags": "Depth-first Search",
    "difficulty": 2,
    "frontend_article_id": 364
},
{
    "frontend_question_id": 363,
    "article_live": false,
    "title": "Max Sum of Rectangle No Larger Than K",
    "title_slug": "max-sum-of-rectangle-no-larger-than-k",
    "content": "<p>Given a non-empty 2D matrix <i>matrix</i> and an integer <i>k</i>, find the max sum of a rectangle in the <i>matrix</i> such that its sum is no larger than <i>k</i>.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>matrix = <span id=\"example-input-1-1\">[[1,0,1],[0,-2,3]]</span>, k = <span id=\"example-input-1-2\">2</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">2 \r\n<strong>Explanation:</strong></span>&nbsp;Because the sum of rectangle <code>[[0, 1], [-2, 3]]</code> is 2,\r\n&nbsp;            and 2 is the max number no larger than k (k = 2).</pre>\r\n\r\n<p><b>Note:</b></p>\r\n\r\n<ol>\r\n\t<li>The rectangle inside the matrix must have an area &gt; 0.</li>\r\n\t<li>What if the number of rows is much larger than the number of columns?</li>\r\n</ol>",
    "tags": "Binary Search, Dynamic Programming, Queue",
    "difficulty": 3,
    "frontend_article_id": 363
},
{
    "frontend_question_id": 362,
    "article_live": false,
    "title": "Design Hit Counter",
    "title_slug": "design-hit-counter",
    "tags": "Design",
    "difficulty": 2,
    "frontend_article_id": 362
},
{
    "frontend_question_id": 361,
    "article_live": false,
    "title": "Bomb Enemy",
    "title_slug": "bomb-enemy",
    "tags": "Dynamic Programming",
    "difficulty": 2,
    "frontend_article_id": 361
},
{
    "frontend_question_id": 360,
    "article_live": false,
    "title": "Sort Transformed Array",
    "title_slug": "sort-transformed-array",
    "tags": "Math, Two Pointers",
    "difficulty": 2,
    "frontend_article_id": 360
},
{
    "frontend_question_id": 359,
    "article_live": false,
    "title": "Logger Rate Limiter",
    "title_slug": "logger-rate-limiter",
    "tags": "Hash Table, Design",
    "difficulty": 1,
    "frontend_article_id": 359
},
{
    "frontend_question_id": 358,
    "article_live": false,
    "title": "Rearrange String k Distance Apart",
    "title_slug": "rearrange-string-k-distance-apart",
    "tags": "Hash Table, Heap, Greedy",
    "difficulty": 3,
    "frontend_article_id": 358
},
{
    "frontend_question_id": 357,
    "article_live": false,
    "title": "Count Numbers with Unique Digits",
    "title_slug": "count-numbers-with-unique-digits",
    "content": "<p>Given a <b>non-negative</b> integer n, count all numbers with unique digits, x, where 0 &le; x &lt; 10<sup>n</sup>.</p>\r\n\r\n<div>\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">2</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">91 \r\n<strong>Explanation: </strong></span>The answer should be the total numbers in the range of 0 &le; x &lt; 100, \r\n&nbsp;            excluding <code>11,22,33,44,55,66,77,88,99</code>\r\n</pre>\r\n</div>",
    "tags": "Math, Dynamic Programming, Backtracking",
    "difficulty": 2,
    "frontend_article_id": 357
},
{
    "frontend_question_id": 356,
    "article_live": false,
    "title": "Line Reflection",
    "title_slug": "line-reflection",
    "tags": "Hash Table, Math",
    "difficulty": 2,
    "frontend_article_id": 356
},
{
    "frontend_question_id": 355,
    "article_live": false,
    "title": "Design Twitter",
    "title_slug": "design-twitter",
    "content": "<p>Design a simplified version of Twitter where users can post tweets, follow/unfollow another user and is able to see the 10 most recent tweets in the user's news feed. Your design should support the following methods:</p>\r\n\r\n<p>\r\n<ol>\r\n<li><b>postTweet(userId, tweetId)</b>: Compose a new tweet.</li>\r\n<li><b>getNewsFeed(userId)</b>: Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.</li>\r\n<li><b>follow(followerId, followeeId)</b>: Follower follows a followee.</li>\r\n<li><b>unfollow(followerId, followeeId)</b>: Follower unfollows a followee.</li>\r\n</ol>\r\n</p>\r\n\r\n<p><b>Example:</b>\r\n<pre>\r\nTwitter twitter = new Twitter();\r\n\r\n// User 1 posts a new tweet (id = 5).\r\ntwitter.postTweet(1, 5);\r\n\r\n// User 1's news feed should return a list with 1 tweet id -> [5].\r\ntwitter.getNewsFeed(1);\r\n\r\n// User 1 follows user 2.\r\ntwitter.follow(1, 2);\r\n\r\n// User 2 posts a new tweet (id = 6).\r\ntwitter.postTweet(2, 6);\r\n\r\n// User 1's news feed should return a list with 2 tweet ids -> [6, 5].\r\n// Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.\r\ntwitter.getNewsFeed(1);\r\n\r\n// User 1 unfollows user 2.\r\ntwitter.unfollow(1, 2);\r\n\r\n// User 1's news feed should return a list with 1 tweet id -> [5],\r\n// since user 1 is no longer following user 2.\r\ntwitter.getNewsFeed(1);\r\n</pre>\r\n</p>",
    "tags": "Hash Table, Heap, Design",
    "difficulty": 2,
    "frontend_article_id": 355
},
{
    "frontend_question_id": 354,
    "article_live": false,
    "title": "Russian Doll Envelopes",
    "title_slug": "russian-doll-envelopes",
    "content": "<p>You have a number of envelopes with widths and heights given as a pair of integers <code>(w, h)</code>. One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope.</p>\r\n\r\n<p>What is the maximum number of envelopes can you Russian doll? (put one inside other)</p>\r\n\r\n<p><b>Note:</b><br />\r\nRotation is not allowed.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<div>\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[[5,4],[6,4],[6,7],[2,3]]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">3 \r\n<strong>Explanation: T</strong></span>he maximum number of envelopes you can Russian doll is <code>3</code> ([2,3] =&gt; [5,4] =&gt; [6,7]).\r\n</pre>\r\n</div>\r\n",
    "tags": "Binary Search, Dynamic Programming",
    "difficulty": 3,
    "frontend_article_id": 354
},
{
    "frontend_question_id": 353,
    "article_live": false,
    "title": "Design Snake Game",
    "title_slug": "design-snake-game",
    "tags": "Design, Queue",
    "difficulty": 2,
    "frontend_article_id": 353
},
{
    "frontend_question_id": 352,
    "article_live": false,
    "title": "Data Stream as Disjoint Intervals",
    "title_slug": "data-stream-as-disjoint-intervals",
    "content": "<p>Given a data stream input of non-negative integers a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub>, ..., summarize the numbers seen so far as a list of disjoint intervals.</p>\r\n\r\n<p>For example, suppose the integers from the data stream are 1, 3, 7, 2, 6, ..., then the summary will be:</p>\r\n\r\n<pre>\r\n[1, 1]\r\n[1, 1], [3, 3]\r\n[1, 1], [3, 3], [7, 7]\r\n[1, 3], [7, 7]\r\n[1, 3], [6, 7]\r\n</pre>\r\n\r\n<p><b>Follow up:</b><br />\r\nWhat if there are lots of merges and the number of disjoint intervals are small compared to the data stream&#39;s size?</p>",
    "tags": "Binary Search Tree",
    "difficulty": 3,
    "frontend_article_id": 352
},
{
    "frontend_question_id": 351,
    "article_live": true,
    "article_slug": "android-unlock-patterns",
    "title": "Android Unlock Patterns",
    "title_slug": "android-unlock-patterns",
    "tags": "Dynamic Programming, Backtracking",
    "difficulty": 2,
    "frontend_article_id": 351,
    "article_content": ""
},
{
    "frontend_question_id": 350,
    "article_live": false,
    "title": "Intersection of Two Arrays II",
    "title_slug": "intersection-of-two-arrays-ii",
    "content": "<p>Given two arrays, write a function to compute their intersection.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>nums1 = <span id=\"example-input-1-1\">[1,2,2,1]</span>, nums2 = <span id=\"example-input-1-2\">[2,2]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">[2,2]</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>nums1 = <span id=\"example-input-2-1\">[4,9,5]</span>, nums2 = <span id=\"example-input-2-2\">[9,4,9,8,4]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">[4,9]</span></pre>\r\n</div>\r\n\r\n<p><b>Note:</b></p>\r\n\r\n<ul>\r\n\t<li>Each element in the result should appear as many times as it shows in both arrays.</li>\r\n\t<li>The result can be in any order.</li>\r\n</ul>\r\n\r\n<p><b>Follow up:</b></p>\r\n\r\n<ul>\r\n\t<li>What if the given array is already sorted? How would you optimize your algorithm?</li>\r\n\t<li>What if <i>nums1</i>&#39;s size is small compared to <i>nums2</i>&#39;s size? Which algorithm is better?</li>\r\n\t<li>What if elements of <i>nums2</i> are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</li>\r\n</ul>\r\n",
    "tags": "Hash Table, Two Pointers, Binary Search, Sort",
    "difficulty": 1,
    "frontend_article_id": 350
},
{
    "frontend_question_id": 349,
    "article_live": false,
    "title": "Intersection of Two Arrays",
    "title_slug": "intersection-of-two-arrays",
    "content": "<p>Given two arrays, write a function to compute their intersection.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>nums1 = <span id=\"example-input-1-1\">[1,2,2,1]</span>, nums2 = <span id=\"example-input-1-2\">[2,2]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">[2]</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>nums1 = <span id=\"example-input-2-1\">[4,9,5]</span>, nums2 = <span id=\"example-input-2-2\">[9,4,9,8,4]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">[9,4]</span></pre>\r\n</div>\r\n\r\n<p><b>Note:</b></p>\r\n\r\n<ul>\r\n\t<li>Each element in the result must be unique.</li>\r\n\t<li>The result can be in any order.</li>\r\n</ul>\r\n\r\n<p>&nbsp;</p>\r\n",
    "tags": "Hash Table, Two Pointers, Binary Search, Sort",
    "difficulty": 1,
    "frontend_article_id": 349
},
{
    "frontend_question_id": 348,
    "article_live": false,
    "title": "Design Tic-Tac-Toe",
    "title_slug": "design-tic-tac-toe",
    "tags": "Design",
    "difficulty": 2,
    "frontend_article_id": 348
},
{
    "frontend_question_id": 347,
    "article_live": false,
    "title": "Top K Frequent Elements",
    "title_slug": "top-k-frequent-elements",
    "content": "<p>Given a non-empty array of integers, return the <b><i>k</i></b> most frequent elements.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>nums = <span id=\"example-input-1-1\">[1,1,1,2,2,3]</span>, k = <span id=\"example-input-1-2\">2</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">[1,2]</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>nums = <span id=\"example-input-2-1\">[1]</span>, k = <span id=\"example-input-2-2\">1</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">[1]</span></pre>\r\n</div>\r\n\r\n<p><b>Note: </b></p>\r\n\r\n<ul>\r\n\t<li>You may assume <i>k</i> is always valid, 1 &le; <i>k</i> &le; number of unique elements.</li>\r\n\t<li>Your algorithm&#39;s time complexity <b>must be</b> better than O(<i>n</i> log <i>n</i>), where <i>n</i> is the array&#39;s size.</li>\r\n</ul>\r\n",
    "tags": "Hash Table, Heap",
    "difficulty": 2,
    "frontend_article_id": 347
},
{
    "frontend_question_id": 346,
    "article_live": false,
    "title": "Moving Average from Data Stream",
    "title_slug": "moving-average-from-data-stream",
    "tags": "Design, Queue",
    "difficulty": 1,
    "frontend_article_id": 346
},
{
    "frontend_question_id": 345,
    "article_live": false,
    "title": "Reverse Vowels of a String",
    "title_slug": "reverse-vowels-of-a-string",
    "content": "<p>Write a function that takes a string as input and reverse only the vowels of a string.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">&quot;hello&quot;</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">&quot;holle&quot;</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">&quot;leetcode&quot;</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">&quot;leotcede&quot;</span></pre>\r\n</div>\r\n\r\n<p><b>Note:</b><br />\r\nThe vowels does not include the letter &quot;y&quot;.</p>\r\n\r\n<p>&nbsp;</p>\r\n",
    "tags": "Two Pointers, String",
    "difficulty": 1,
    "frontend_article_id": 345
},
{
    "frontend_question_id": 344,
    "article_live": false,
    "title": "Reverse String",
    "title_slug": "reverse-string",
    "content": "<p>Write a function that takes a string as input and returns the string reversed.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<div>\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">&quot;hello&quot;</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">&quot;olleh&quot;</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">&quot;A man, a plan, a canal: Panama&quot;</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">&quot;amanaP :lanac a ,nalp a ,nam A&quot;</span>\r\n</pre>\r\n</div>\r\n</div>\r\n",
    "tags": "Two Pointers, String",
    "difficulty": 1,
    "frontend_article_id": 344
},
{
    "frontend_question_id": 343,
    "article_live": false,
    "title": "Integer Break",
    "title_slug": "integer-break",
    "content": "<p>Given a positive integer <i>n</i>, break it into the sum of <b>at least</b> two positive integers and maximize the product of those integers. Return the maximum product you can get.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<div>\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">2</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">1</span>\r\n<strong>Explanation: </strong>2 = 1 + 1, 1 &times; 1 = 1.</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">10</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">36</span>\r\n<strong>Explanation: </strong>10 = 3 + 3 + 4, 3 &times;&nbsp;3 &times;&nbsp;4 = 36.</pre>\r\n\r\n<p><b>Note</b>: You may assume that <i>n</i> is not less than 2 and not larger than 58.</p>\r\n</div>\r\n</div>",
    "tags": "Math, Dynamic Programming",
    "difficulty": 2,
    "frontend_article_id": 343
},
{
    "frontend_question_id": 342,
    "article_live": false,
    "title": "Power of Four",
    "title_slug": "power-of-four",
    "content": "<p>Given an integer (signed 32 bits), write a function to check whether it is a power of 4.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">16</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">true</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">5</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">false</span></pre>\r\n</div>\r\n\r\n<p><b>Follow up</b>: Could you solve it without loops/recursion?</p>",
    "tags": "Bit Manipulation",
    "difficulty": 1,
    "frontend_article_id": 342
},
{
    "frontend_question_id": 341,
    "article_live": false,
    "title": "Flatten Nested List Iterator",
    "title_slug": "flatten-nested-list-iterator",
    "content": "<p>Given a nested list of integers, implement an iterator to flatten it.</p>\r\n\r\n<p>Each element is either an integer, or a list -- whose elements may also be integers or other lists.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<div>\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[[1,1],2,[1,1]]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">[1,1,2,1,1]\r\n</span><strong>Explanation: </strong>By calling <i>next</i> repeatedly until <i>hasNext</i> returns false, \r\n&nbsp;            the order of elements returned by <i>next</i> should be: <code>[1,1,2,1,1]</code>.</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">[1,[4,[6]]]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">[1,4,6]\r\n</span><strong>Explanation: </strong>By calling <i>next</i> repeatedly until <i>hasNext</i> returns false, \r\n&nbsp;            the order of elements returned by <i>next</i> should be: <code>[1,4,6]</code>.\r\n</pre>\r\n</div>\r\n</div>\r\n",
    "tags": "Stack, Design",
    "difficulty": 2,
    "frontend_article_id": 341
},
{
    "frontend_question_id": 340,
    "article_live": false,
    "title": "Longest Substring with At Most K Distinct Characters",
    "title_slug": "longest-substring-with-at-most-k-distinct-characters",
    "tags": "Hash Table, String",
    "difficulty": 3,
    "frontend_article_id": 340
},
{
    "frontend_question_id": 339,
    "article_live": true,
    "article_slug": "nested-list-weight-sum",
    "title": "Nested List Weight Sum",
    "title_slug": "nested-list-weight-sum",
    "tags": "Depth-first Search",
    "difficulty": 1,
    "frontend_article_id": 339,
    "article_content": ""
},
{
    "frontend_question_id": 338,
    "article_live": true,
    "article_slug": "counting-bits",
    "title": "Counting Bits",
    "title_slug": "counting-bits",
    "content": "<p>Given a non negative integer number <b>num</b>. For every numbers <b>i</b> in the range <b>0 &le; i &le; num</b> calculate the number of 1&#39;s in their binary representation and return them as an array.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">2</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">[0,1,1]</span></pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">5</span>\r\n<strong>Output: </strong><code>[0,1,1,2,1,2]</code>\r\n</pre>\r\n\r\n<p><b>Follow up:</b></p>\r\n\r\n<ul>\r\n\t<li>It is very easy to come up with a solution with run time <b>O(n*sizeof(integer))</b>. But can you do it in linear time <b>O(n)</b> /possibly in a single pass?</li>\r\n\t<li>Space complexity should be <b>O(n)</b>.</li>\r\n\t<li>Can you do it like a boss? Do it without using any builtin function like <b>__builtin_popcount</b> in c++ or in any other language.</li>\r\n</ul>",
    "tags": "Dynamic Programming, Bit Manipulation",
    "difficulty": 2,
    "frontend_article_id": 338,
    "article_content": ""
},
{
    "frontend_question_id": 337,
    "article_live": false,
    "title": "House Robber III",
    "title_slug": "house-robber-iii",
    "content": "<p>The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the &quot;root.&quot; Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that &quot;all houses in this place forms a binary tree&quot;. It will automatically contact the police if two directly-linked houses were broken into on the same night.</p>\r\n\r\n<p>Determine the maximum amount of money the thief can rob tonight without alerting the police.</p>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>[3,2,3,null,3,null,1]\r\n\r\n     <font color=\"red\">3</font>\r\n    / \\\r\n   2   3\r\n    \\   \\ \r\n     <font color=\"red\">3   1\r\n</font>\r\n<strong>Output:</strong> 7 \r\n<strong>Explanation:</strong>&nbsp;Maximum amount of money the thief can rob = <font color=\"red\" style=\"font-family: sans-serif, Arial, Verdana, &quot;Trebuchet MS&quot;;\">3</font><span style=\"font-family: sans-serif, Arial, Verdana, &quot;Trebuchet MS&quot;;\"> + </span><font color=\"red\" style=\"font-family: sans-serif, Arial, Verdana, &quot;Trebuchet MS&quot;;\">3</font><span style=\"font-family: sans-serif, Arial, Verdana, &quot;Trebuchet MS&quot;;\"> + </span><font color=\"red\" style=\"font-family: sans-serif, Arial, Verdana, &quot;Trebuchet MS&quot;;\">1</font><span style=\"font-family: sans-serif, Arial, Verdana, &quot;Trebuchet MS&quot;;\"> = </span><b style=\"font-family: sans-serif, Arial, Verdana, &quot;Trebuchet MS&quot;;\">7</b><span style=\"font-family: sans-serif, Arial, Verdana, &quot;Trebuchet MS&quot;;\">.</span></pre>\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>[3,4,5,1,3,null,1]\r\n\r\n&nbsp;    3\r\n    / \\\r\n   <font color=\"red\">4</font>   <font color=\"red\">5</font>\r\n  / \\   \\ \r\n 1   3   1\r\n\r\n<strong>Output:</strong> 9\r\n<strong>Explanation:</strong>&nbsp;Maximum amount of money the thief can rob = <font color=\"red\">4</font> + <font color=\"red\">5</font> = <b>9</b>.\r\n</pre>",
    "tags": "Tree, Depth-first Search",
    "difficulty": 2,
    "frontend_article_id": 337
},
{
    "frontend_question_id": 336,
    "article_live": false,
    "title": "Palindrome Pairs",
    "title_slug": "palindrome-pairs",
    "content": "<p>Given a list of <b>unique</b> words, find all pairs of <b><i>distinct</i></b> indices <code>(i, j)</code> in the given list, so that the concatenation of the two words, i.e. <code>words[i] + words[j]</code> is a palindrome.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<div>\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[&quot;abcd&quot;,&quot;dcba&quot;,&quot;lls&quot;,&quot;s&quot;,&quot;sssll&quot;]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">[[0,1],[1,0],[3,2],[2,4]] \r\n<strong>E</strong></span><strong>xplanation<span>: </span></strong>The palindromes are <code>[&quot;dcbaabcd&quot;,&quot;abcddcba&quot;,&quot;slls&quot;,&quot;llssssll&quot;]</code>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">[&quot;bat&quot;,&quot;tab&quot;,&quot;cat&quot;]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">[[0,1],[1,0]] \r\n</span><span id=\"example-output-1\"><strong>E</strong></span><strong>xplanation<span>: </span></strong>The palindromes are <code>[&quot;battab&quot;,&quot;tabbat&quot;]</code>\r\n</pre>\r\n</div>\r\n</div>",
    "tags": "Hash Table, String, Trie",
    "difficulty": 3,
    "frontend_article_id": 336
},
{
    "frontend_question_id": 335,
    "article_live": false,
    "title": "Self Crossing",
    "title_slug": "self-crossing",
    "content": "<p>You are given an array <i>x</i> of <code>n</code> positive numbers. You start at point <code>(0,0)</code> and moves <code>x[0]</code> metres to the north, then <code>x[1]</code> metres to the west, <code>x[2]</code> metres to the south, <code>x[3]</code> metres to the east and so on. In other words, after each move your direction changes counter-clockwise.</p>\r\n\r\n<p>Write a one-pass algorithm with <code>O(1)</code> extra space to determine, if your path crosses itself, or not.</p>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><code>[2,1,1,2]</code>\r\n\r\n?????\r\n?   ?\r\n???????&gt;\r\n    ?\r\n\r\n<strong>Input: </strong>true \r\n<strong>Explanation:</strong>&nbsp;self crossing\r\n</pre>\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> <code>[1,2,3,4]</code>\r\n\r\n????????\r\n?      ?\r\n?\r\n?\r\n?????????????&gt;\r\n\r\n<strong>Output: </strong>false \r\n<strong>Explanation: </strong>not self crossing\r\n</pre>\r\n\r\n<p><b>Example 3:</b></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> <code>[1,1,1,1]</code>\r\n\r\n?????\r\n?   ?\r\n?????&gt;\r\n\r\n<strong>Output:</strong> true \r\n<strong>Explanation:</strong>&nbsp;self crossing\r\n</pre>",
    "tags": "Math",
    "difficulty": 3,
    "frontend_article_id": 335
},
{
    "frontend_question_id": 334,
    "article_live": false,
    "title": "Increasing Triplet Subsequence",
    "title_slug": "increasing-triplet-subsequence",
    "content": "<p>Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.</p>\r\n\r\n<p>Formally the function should:</p>\r\n\r\n<blockquote>Return true if there exists <i>i, j, k </i><br />\r\nsuch that <i>arr[i]</i> &lt; <i>arr[j]</i> &lt; <i>arr[k]</i> given 0 &le; <i>i</i> &lt; <i>j</i> &lt; <i>k</i> &le; <i>n</i>-1 else return false.</blockquote>\r\n\r\n<p><strong>Note: </strong>Your algorithm should run in O(<i>n</i>) time complexity and O(<i>1</i>) space complexity.</p>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[1,2,3,4,5]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">true</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">[5,4,3,2,1]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">false</span>\r\n</pre>\r\n</div>\r\n</div>",
    "tags": "",
    "difficulty": 2,
    "frontend_article_id": 334
},
{
    "frontend_question_id": 333,
    "article_live": false,
    "title": "Largest BST Subtree",
    "title_slug": "largest-bst-subtree",
    "tags": "Tree",
    "difficulty": 2,
    "frontend_article_id": 333
},
{
    "frontend_question_id": 332,
    "article_live": false,
    "title": "Reconstruct Itinerary",
    "title_slug": "reconstruct-itinerary",
    "content": "<p>Given a list of airline tickets represented by pairs of departure and arrival airports <code>[from, to]</code>, reconstruct the itinerary in order. All of the tickets belong to a man who departs from <code>JFK</code>. Thus, the itinerary must begin with <code>JFK</code>.</p>\r\n\r\n<p><b>Note:</b></p>\r\n\r\n<ol>\r\n\t<li>If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary <code>[&quot;JFK&quot;, &quot;LGA&quot;]</code> has a smaller lexical order than <code>[&quot;JFK&quot;, &quot;LGB&quot;]</code>.</li>\r\n\t<li>All airports are represented by three capital letters (IATA code).</li>\r\n\t<li>You may assume all tickets form at least one valid itinerary.</li>\r\n</ol>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\n<code><strong>Input: </strong></code><code>[[&quot;MUC&quot;, &quot;LHR&quot;], [&quot;JFK&quot;, &quot;MUC&quot;], [&quot;SFO&quot;, &quot;SJC&quot;], [&quot;LHR&quot;, &quot;SFO&quot;]]</code>\r\n<strong>Output: </strong><code>[&quot;JFK&quot;, &quot;MUC&quot;, &quot;LHR&quot;, &quot;SFO&quot;, &quot;SJC&quot;]</code>\r\n</pre>\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\n<code><strong>Input: </strong></code><code>[[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]</code>\r\n<strong>Output: </strong><code>[&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]</code>\r\n<strong>Explanation: </strong>Another possible reconstruction is <code>[&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;]</code>.\r\n&nbsp;            But it is larger in lexical order.\r\n</pre>\r\n",
    "tags": "Depth-first Search, Graph",
    "difficulty": 2,
    "frontend_article_id": 332
},
{
    "frontend_question_id": 331,
    "article_live": false,
    "title": "Verify Preorder Serialization of a Binary Tree",
    "title_slug": "verify-preorder-serialization-of-a-binary-tree",
    "content": "<p>One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node&#39;s value. If it is a null node, we record using a sentinel value such as <code>#</code>.</p>\r\n\r\n<pre>\r\n     _9_\r\n    /   \\\r\n   3     2\r\n  / \\   / \\\r\n 4   1  #  6\r\n/ \\ / \\   / \\\r\n# # # #   # #\r\n</pre>\r\n\r\n<p>For example, the above binary tree can be serialized to the string <code>&quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</code>, where <code>#</code> represents a null node.</p>\r\n\r\n<p>Given a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree. Find an algorithm without reconstructing the tree.</p>\r\n\r\n<p>Each comma separated value in the string must be either an integer or a character <code>&#39;#&#39;</code> representing <code>null</code> pointer.</p>\r\n\r\n<p>You may assume that the input format is always valid, for example it could never contain two consecutive commas such as <code>&quot;1,,3&quot;</code>.</p>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><code>&quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</code>\r\n<strong>Output: </strong><code>true</code></pre>\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><code>&quot;1,#&quot;</code>\r\n<strong>Output: </strong><code>false</code>\r\n</pre>\r\n\r\n<p><b>Example 3:</b></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><code>&quot;9,#,#,1&quot;</code>\r\n<strong>Output: </strong><code>false</code></pre>",
    "tags": "Stack",
    "difficulty": 2,
    "frontend_article_id": 331
},
{
    "frontend_question_id": 330,
    "article_live": true,
    "article_slug": "patching-array",
    "title": "Patching Array",
    "title_slug": "patching-array",
    "content": "<p>Given a sorted positive integer array <i>nums</i> and an integer <i>n</i>, add/patch elements to the array such that any number in range <code>[1, n]</code> inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required.</p>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><i>nums</i> = <code>[1,3]</code>, <i>n</i> = <code>6</code>\r\n<strong>Output: </strong>1 \r\n<strong>Explanation:</strong>\r\nCombinations of <i>nums</i> are <code>[1], [3], [1,3]</code>, which form possible sums of: <code>1, 3, 4</code>.\r\nNow if we add/patch <code>2</code> to <i>nums</i>, the combinations are: <code>[1], [2], [3], [1,3], [2,3], [1,2,3]</code>.\r\nPossible sums are <code>1, 2, 3, 4, 5, 6</code>, which now covers the range <code>[1, 6]</code>.\r\nSo we only need <code>1</code> patch.</pre>\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><i>nums</i> = <code>[1,5,10]</code>, <i>n</i> = <code>20</code>\r\n<strong>Output:</strong> 2\r\n<strong>Explanation: </strong>The two patches can be <code>[2, 4]</code>.\r\n</pre>\r\n\r\n<p><b>Example 3:</b></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><i>nums</i> = <code>[1,2,2]</code>, <i>n</i> = <code>5</code>\r\n<strong>Output:</strong> 0\r\n</pre>",
    "tags": "Greedy",
    "difficulty": 3,
    "frontend_article_id": 330,
    "article_content": ""
},
{
    "frontend_question_id": 329,
    "article_live": true,
    "article_slug": "longest-increasing-path-matrix",
    "title": "Longest Increasing Path in a Matrix",
    "title_slug": "longest-increasing-path-in-a-matrix",
    "content": "<p>Given an integer matrix, find the length of the longest increasing path.</p>\r\n\r\n<p>From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).</p>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>nums = \r\n[\r\n  [<font color=\"red\">9</font>,9,4],\r\n  [<font color=\"red\">6</font>,6,8],\r\n  [<font color=\"red\">2</font>,<font color=\"red\">1</font>,1]\r\n] \r\n<strong>Output:</strong> 4 \r\n<strong>Explanation:</strong> The longest increasing path is <code>[1, 2, 6, 9]</code>.\r\n</pre>\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = \r\n[\r\n  [<font color=\"red\">3</font>,<font color=\"red\">4</font>,<font color=\"red\">5</font>],\r\n  [3,2,<font color=\"red\">6</font>],\r\n  [2,2,1]\r\n] \r\n<strong>Output: </strong>4 \r\n<strong>Explanation: </strong>The longest increasing path is <code>[3, 4, 5, 6]</code>. Moving diagonally is not allowed.\r\n</pre>",
    "tags": "Depth-first Search, Topological Sort, Memoization",
    "difficulty": 3,
    "frontend_article_id": 329,
    "article_content": ""
},
{
    "frontend_question_id": 328,
    "article_live": true,
    "article_slug": "odd-even-linked-list",
    "title": "Odd Even Linked List",
    "title_slug": "odd-even-linked-list",
    "content": "<p>Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.</p>\r\n\r\n<p>You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.</p>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code>\r\n<strong>Output: </strong><code>1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</code>\r\n</pre>\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>2<code>-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL</code>\r\n<strong>Output: </strong><code>2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</code>\r\n</pre>\r\n\r\n<p><b>Note:</b></p>\r\n\r\n<ul>\r\n\t<li>The relative order inside both the even and odd groups should remain as it was in the input.</li>\r\n\t<li>The first node is considered odd, the second node even and so on ...</li>\r\n</ul>\r\n",
    "tags": "Linked List",
    "difficulty": 2,
    "frontend_article_id": 328,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <h2 id=\"solution\">Solution</h2> \n  <p><strong>Intuition</strong></p> \n  <p>Put the odd nodes in a linked list and the even nodes in another. Then link the evenList to the tail of the oddList.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>The solution is very intuitive. But it is not trivial to write a concise and bug-free code.</p> \n  <p>A well-formed <code>LinkedList</code> need two pointers head and tail to support operations at both ends. The variables <code>head</code> and <code>odd</code> are the head pointer and tail pointer of one <code>LinkedList</code> we call oddList; the variables <code>evenHead</code> and <code>even</code> are the head pointer and tail pointer of another <code>LinkedList</code> we call evenList. The algorithm traverses the original LinkedList and put the odd nodes into the oddList and the even nodes into the evenList. To traverse a LinkedList we need at least one pointer as an iterator for the current node. But here the pointers <code>odd</code> and <code>even</code> not only serve as the tail pointers but also act as the iterators of the original list.</p> \n  <p>The best way of solving any linked list problem is to visualize it either in your mind or on a piece of paper. An illustration of our algorithm is following:</p> \n  <p align=\"center\"><img alt=\"Illustration of odd even linked list\" src=\"../Figures/328_Odd_Even.svg\" title=\"Odd Even Linked List\" width=\"539px\"></p> \n  <p align=\"center\"><em>Figure 1. Step by step example of the odd and even linked list.</em></p> \n  <iframe src=\"https://leetcode.com/playground/hwsGSV9j/shared\" frameborder=\"0\" width=\"100%\" height=\"293\" name=\"hwsGSV9j\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. There are total <script type=\"math/tex; mode=display\">n</script> nodes and we visit each node once.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. All we need is the four pointers.</p> </li> \n  </ul> \n </div> \n</div>"
},
{
    "frontend_question_id": 327,
    "article_live": false,
    "title": "Count of Range Sum",
    "title_slug": "count-of-range-sum",
    "content": "<p>Given an integer array <code>nums</code>, return the number of range sums that lie in <code>[lower, upper]</code> inclusive.<br />\r\nRange sum <code>S(i, j)</code> is defined as the sum of the elements in <code>nums</code> between indices <code>i</code> and <code>j</code> (<code>i</code> &le; <code>j</code>), inclusive.</p>\r\n\r\n<p><b>Note:</b><br />\r\nA naive algorithm of <i>O</i>(<i>n</i><sup>2</sup>) is trivial. You MUST do better than that.</p>\r\n\r\n<p><b>Example:</b></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><i>nums</i> = <code>[-2,5,-1]</code>, <i>lower</i> = <code>-2</code>, <i>upper</i> = <code>2</code>,\r\n<strong>Output: </strong>3 \r\n<strong>Explanation: </strong>The three ranges are : <code>[0,0]</code>, <code>[2,2]</code>, <code>[0,2]</code> and their respective sums are: <code>-2, -1, 2</code>.\r\n</pre>",
    "tags": "Divide and Conquer, Binary Search Tree",
    "difficulty": 3,
    "frontend_article_id": 327
},
{
    "frontend_question_id": 326,
    "article_live": true,
    "article_slug": "power-of-three",
    "title": "Power of Three",
    "title_slug": "power-of-three",
    "content": "<p>Given an integer, write a function to determine if it is a power of three.</p>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 27\r\n<strong>Output:</strong> true\r\n</pre>\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 0\r\n<strong>Output:</strong> false</pre>\r\n\r\n<p><b>Example 3:</b></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 9\r\n<strong>Output:</strong> true</pre>\r\n\r\n<p><b>Example 4:</b></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 45\r\n<strong>Output:</strong> false</pre>\r\n\r\n<p><b>Follow up:</b><br />\r\nCould you do it without using any loop / recursion?</p>",
    "tags": "Math",
    "difficulty": 1,
    "frontend_article_id": 326,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-loop-iteration-accepted\">Approach #1 Loop Iteration [Accepted]</a></li> \n      <li><a href=\"#approach-2-base-conversion-accepted\">Approach #2 Base Conversion [Accepted]</a></li> \n      <li><a href=\"#approach-3-mathematics-accepted\">Approach #3 Mathematics [Accepted]</a></li> \n      <li><a href=\"#approach-4-integer-limitations-accepted\">Approach #4 Integer Limitations [Accepted]</a></li> \n     </ul> </li> \n    <li><a href=\"#performance-measurements\">Performance Measurements</a></li> \n    <li><a href=\"#conclusion\">Conclusion</a></li> \n    <li><a href=\"#references\">References</a></li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <p>In this article we will look into ways of speeding up simple computations and why that is useful in practice.</p> \n  <hr> \n  <h4 id=\"approach-1-loop-iteration-accepted\">Approach #1 Loop Iteration [Accepted]</h4> \n  <p>One simple way of finding out if a number <code>n</code> is a power of a number <code>b</code> is to keep dividing <code>n</code> by <code>b</code> as long as the remainder is <strong>0</strong>. This is because we can write</p> \n  <p> <script type=\"math/tex; mode=display\">\n\\begin{align*}\nn &= b^x \\\\\nn &= b \\times b \\times \\ldots \\times b\n\\end{align*}\n</script> </p> \n  <p>Hence it should be possible to divide <code>n</code> by <code>b</code> <code>x</code> times, every time with a remainder of <strong>0</strong> and the end result to be <strong>1</strong>.</p> \n  <iframe src=\"https://leetcode.com/playground/oqtKkauN/shared\" frameborder=\"0\" name=\"oqtKkauN\" width=\"100%\" height=\"275\"></iframe> \n  <p>Notice that we need a guard to check that <code>n != 0</code>, otherwise the while loop will never finish. For negative numbers, the algorithm does not make sense, so we will include this guard as well.</p> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(log_b(n))</script>. In our case that is <script type=\"math/tex; mode=display\">O(log_3n)</script>. The number of divisions is given by that logarithm.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. We are not using any additional memory.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-base-conversion-accepted\">Approach #2 Base Conversion [Accepted]</h4> \n  <p>In Base 10, all powers of 10 start with the digit <strong>1</strong> and then are followed only by <strong>0</strong> (e.g. 10, 100, 1000). This is true for other bases and their respective powers. For instance in <em>base 2</em>, the representations of <script type=\"math/tex; mode=display\">10_2</script>, <script type=\"math/tex; mode=display\">100_2</script> and <script type=\"math/tex; mode=display\">1000_2</script> are <script type=\"math/tex; mode=display\">2_{10}</script>, <script type=\"math/tex; mode=display\">4_{10}</script> and <script type=\"math/tex; mode=display\">8_{10}</script> respectively. Therefore if we convert our number to base 3 and the representation is of the form 100...0, then the number is a power of 3.</p> \n  <p><strong>Proof</strong></p> \n  <p>Given the base 3 representation of a number as the array <code>s</code>, with the least significant digit on index 0, the formula for converting from base <strong>3</strong> to base <strong>10</strong> is:</p> \n  <p> <script type=\"math/tex; mode=display\">\n\\sum_{i=0}^{len(s) - 1} s[i] * 3^{i}\n</script> </p> \n  <p>Therefore, having just one digit of <strong>1</strong> and everything else <strong>0</strong> means the number is a power of 3.</p> \n  <p><strong>Implementation</strong></p> \n  <p>All we need to do is convert <sup>[4]</sup> the number to <em>base 3</em> and check if it is written as a leading <strong>1</strong> followed by all <strong>0</strong>.</p> \n  <p>A couple of built-in Java functions will help us along the way.</p> \n  <iframe src=\"https://leetcode.com/playground/JHQszU9Y/shared\" frameborder=\"0\" name=\"JHQszU9Y\" width=\"100%\" height=\"71\"></iframe> \n  <p>The code above converts <code>number</code> into base <code>base</code> and returns the result as a <code>String</code>. For example, <code>Integer.toString(5, 2) == \"101\"</code> and <code>Integer.toString(5, 3) == \"12\"</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/whcADo6Z/shared\" frameborder=\"0\" name=\"whcADo6Z\" width=\"100%\" height=\"71\"></iframe> \n  <p>The code above checks if a certain <strong>Regular Expression</strong><sup>[2]</sup> pattern exists inside a string. For instance the above will return true if the substring \"123\" exists inside the string <code>myString</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/dQUs9bjm/shared\" frameborder=\"0\" name=\"dQUs9bjm\" width=\"100%\" height=\"71\"></iframe> \n  <p>We will use the regular expression above for checking if the string starts with <strong>1</strong> <code>^1</code>, is followed by zero or more <strong>0</strong>s <code>0*</code> and contains nothing else <code>$</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/NhaMEsdz/shared\" frameborder=\"0\" name=\"NhaMEsdz\" width=\"100%\" height=\"139\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(log_3n)</script>.</p> <p>Assumptions:</p> \n    <ul> \n     <li><code>Integer.toString()</code> - Base conversion is generally implemented as a repeated division. The complexity of should be similar to our approach #1: <script type=\"math/tex; mode=display\">O(log_3n)</script>.</li> \n     <li><code>String.matches()</code> - Method iterates over the entire string. The number of digits in the base 3 representation of <code>n</code> is <script type=\"math/tex; mode=display\">O(log_3n)</script>.</li> \n    </ul> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(log_3n)</script>.</p> <p>We are using two additional variables,</p> \n    <ul> \n     <li>The string of the base 3 representation of the number (size <script type=\"math/tex; mode=display\">log_3n</script>)</li> \n     <li>The string of the regular expression (constant size)</li> \n    </ul> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-mathematics-accepted\">Approach #3 Mathematics [Accepted]</h4> \n  <p>We can use mathematics as follows</p> \n  <p> <script type=\"math/tex; mode=display\">\nn = 3^i \\\\\ni = log_3(n) \\\\\ni = \\frac{log_b(n)}{log_b(3)}\n</script> </p> \n  <p><code>n</code> is a power of three if and only if <code>i</code> is an integer. In Java, we check if a number is an integer by taking the decimal part (using <code>% 1</code>) and checking if it is 0.</p> \n  <iframe src=\"https://leetcode.com/playground/rfdsFHXp/shared\" frameborder=\"0\" name=\"rfdsFHXp\" width=\"100%\" height=\"139\"></iframe> \n  <p><strong>Common pitfalls</strong></p> \n  <p>This solution is problematic because we start using <code>double</code>s, which means we are subject to precision errors. This means, we should never use <code>==</code> when comparing <code>double</code>s. That is because the result of <code>Math.log10(n) / Math.log10(3)</code> could be <code>5.0000001</code> or <code>4.9999999</code>. This effect can be observed by using the function <code>Math.log()</code> instead of <code>Math.log10()</code>.</p> \n  <p>In order to fix that, we need to compare the result against an <code>epsilon</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/NsNRPhpt/shared\" frameborder=\"0\" name=\"NsNRPhpt\" width=\"100%\" height=\"71\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">Unknown</script> The expensive operation here is <code>Math.log</code>, which upper bounds the time complexity of our algorithm. The implementation is dependent on the language we are using and the compiler<sup>[3]</sup></p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. We are not using any additional memory. The <code>epsilon</code> variable can be inlined.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-4-integer-limitations-accepted\">Approach #4 Integer Limitations [Accepted]</h4> \n  <p>An important piece of information can be deduced from the function signature</p> \n  <iframe src=\"https://leetcode.com/playground/9YvN5pNn/shared\" frameborder=\"0\" name=\"9YvN5pNn\" width=\"100%\" height=\"71\"></iframe> \n  <p>In particular, <code>n</code> is of type <code>int</code>. In Java, this means it is a 4 byte, signed integer [ref]. The maximum value of this data type is <strong>2147483647</strong>. Three ways of calculating this value are</p> \n  <ul> \n   <li><a href=\"https://stackoverflow.com/questions/15004944/max-value-of-integer\">Google</a></li> \n   <li><code>System.out.println(Integer.MAX_VALUE);</code></li> \n   <li>MaxInt = <script type=\"math/tex; mode=display\">\\frac{ 2^{32} }{2} - 1</script> since we use 32 bits to represent the number, half of the range is used for negative numbers and 0 is part of the positive numbers</li> \n  </ul> \n  <p>Knowing the limitation of <code>n</code>, we can now deduce that the maximum value of <code>n</code> that is also a power of three is <strong>1162261467</strong>. We calculate this as:</p> \n  <p> <script type=\"math/tex; mode=display\">\n3^{\\lfloor{}log_3{MaxInt}\\rfloor{}} = 3^{\\lfloor{}19.56\\rfloor{}} = 3^{19} = 1162261467\n</script> </p> \n  <p>Therefore, the possible values of <code>n</code> where we should return <code>true</code> are <script type=\"math/tex; mode=display\">3^0</script>, <script type=\"math/tex; mode=display\">3^1</script> ... <script type=\"math/tex; mode=display\">3^{19}</script>. Since 3 is a prime number, the only divisors of <script type=\"math/tex; mode=display\">3^{19}</script> are <script type=\"math/tex; mode=display\">3^0</script>, <script type=\"math/tex; mode=display\">3^1</script> ... <script type=\"math/tex; mode=display\">3^{19}</script>, therefore all we need to do is divide <script type=\"math/tex; mode=display\">3^{19}</script> by <code>n</code>. A remainder of <strong>0</strong> means <code>n</code> is a divisor of <script type=\"math/tex; mode=display\">3^{19}</script> and therefore a power of three.</p> \n  <iframe src=\"https://leetcode.com/playground/nFdyeL8J/shared\" frameborder=\"0\" name=\"nFdyeL8J\" width=\"100%\" height=\"139\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(1)</script>. We are only doing one operation.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. We are not using any additional memory.</p> </li> \n  </ul> \n  <h2 id=\"performance-measurements\">Performance Measurements</h2> \n  <p>Single runs of the function make it is hard to accurately measure the difference of the two solutions. On LeetCode, on the <em>Accepted Solutions Runtime Distribution</em> page, all solutions being between <code>15 ms</code> and <code>20 ms</code>. For completeness, we have proposed the following benchmark to see how the two solutions differ.</p> \n  <p><strong>Java Benchmark Code</strong> <iframe src=\"https://leetcode.com/playground/DrxGaCVC/shared\" frameborder=\"0\" name=\"DrxGaCVC\" width=\"100%\" height=\"173\"></iframe></p> \n  <p>In the table below, the values are in seconds.</p> \n  <table> \n   <thead> \n    <tr> \n     <th align=\"center\">Iterations</th> \n     <th align=\"center\"> <script type=\"math/tex; mode=display\">10^6</script> </th> \n     <th align=\"center\"> <script type=\"math/tex; mode=display\">10^7</script> </th> \n     <th align=\"center\"> <script type=\"math/tex; mode=display\">10^8</script> </th> \n     <th align=\"center\"> <script type=\"math/tex; mode=display\">10^9</script> </th> \n     <th align=\"center\"> <script type=\"math/tex; mode=display\">Maxint</script> </th> \n    </tr> \n   </thead> \n   <tbody> \n    <tr> \n     <td align=\"center\">Java Approach #1 (Naive)</td> \n     <td align=\"center\">0.04</td> \n     <td align=\"center\">0.07</td> \n     <td align=\"center\">0.30</td> \n     <td align=\"center\">2.47</td> \n     <td align=\"center\">5.26</td> \n    </tr> \n    <tr> \n     <td align=\"center\">Java Approach #2 (Strings)</td> \n     <td align=\"center\">0.68</td> \n     <td align=\"center\">4.02</td> \n     <td align=\"center\">38.90</td> \n     <td align=\"center\">409.16</td> \n     <td align=\"center\">893.89</td> \n    </tr> \n    <tr> \n     <td align=\"center\">Java Approach #3 (Logarithms)</td> \n     <td align=\"center\">0.09</td> \n     <td align=\"center\">0.50</td> \n     <td align=\"center\">4.59</td> \n     <td align=\"center\">45.53</td> \n     <td align=\"center\">97.50</td> \n    </tr> \n    <tr> \n     <td align=\"center\">Java Approach #4 (Fast)</td> \n     <td align=\"center\">0.04</td> \n     <td align=\"center\">0.06</td> \n     <td align=\"center\">0.08</td> \n     <td align=\"center\">0.41</td> \n     <td align=\"center\">0.78</td> \n    </tr> \n   </tbody> \n  </table> \n  <p>As we can see, for small values of N, the difference is not noticeable, but as we do more iterations and the values of <code>n</code> passed to <code>isPowerOfThree()</code> grow, we see significant boosts in performance for Approach #4.</p> \n  <h2 id=\"conclusion\">Conclusion</h2> \n  <p>Simple optimizations like this might seem negligible, but historically, when computation power was an issue, it allowed certain computer programs (such as Quake 3<sup>[1]</sup>) possible.</p> \n  <h2 id=\"references\">References</h2> \n  <ul> \n   <li>[1] <a href=\"https://en.wikipedia.org/wiki/Fast_inverse_square_root\">https://en.wikipedia.org/wiki/Fast_inverse_square_root</a></li> \n   <li>[2] <a href=\"https://en.wikipedia.org/wiki/Regular_expression\">https://en.wikipedia.org/wiki/Regular_expression</a></li> \n   <li>[3] <a href=\"http://developer.classpath.org/doc/java/lang/StrictMath-source.html\">http://developer.classpath.org/doc/java/lang/StrictMath-source.html</a></li> \n   <li>[4] <a href=\"https://www.cut-the-knot.org/recurrence/conversion.shtml\">http://www.cut-the-knot.org/recurrence/conversion.shtml</a></li> \n  </ul> \n  <p>Analysis written by: <a href=\"http://andrei.cioara.me\">@aicioara</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 325,
    "article_live": false,
    "title": "Maximum Size Subarray Sum Equals k",
    "title_slug": "maximum-size-subarray-sum-equals-k",
    "tags": "Hash Table",
    "difficulty": 2,
    "frontend_article_id": 325
},
{
    "frontend_question_id": 324,
    "article_live": false,
    "title": "Wiggle Sort II",
    "title_slug": "wiggle-sort-ii",
    "content": "<p>Given an unsorted array <code>nums</code>, reorder it such that <code>nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]...</code>.</p>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><code>nums = [1, 5, 1, 1, 6, 4]</code>\r\n<strong>Output: </strong>One possible answer is <code>[1, 4, 1, 5, 1, 6]</code>.</pre>\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><code>nums = [1, 3, 2, 2, 3, 1]</code>\r\n<strong>Output:</strong> One possible answer is <code>[2, 3, 1, 3, 1, 2]</code>.</pre>\r\n\r\n<p><b>Note:</b><br />\r\nYou may assume all input has valid answer.</p>\r\n\r\n<p><b>Follow Up:</b><br />\r\nCan you do it in O(n) time and/or in-place with O(1) extra space?</p>",
    "tags": "Sort",
    "difficulty": 2,
    "frontend_article_id": 324
},
{
    "frontend_question_id": 323,
    "article_live": false,
    "title": "Number of Connected Components in an Undirected Graph",
    "title_slug": "number-of-connected-components-in-an-undirected-graph",
    "tags": "Depth-first Search, Breadth-first Search, Union Find, Graph",
    "difficulty": 2,
    "frontend_article_id": 323
},
{
    "frontend_question_id": 322,
    "article_live": true,
    "article_slug": "coin-change",
    "title": "Coin Change",
    "title_slug": "coin-change",
    "content": "<p>You are given coins of different denominations and a total amount of money <i>amount</i>. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return <code>-1</code>.</p>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>coins = <code>[1, 2, 5]</code>, amount = <code>11</code>\r\n<strong>Output: </strong><code>3</code> \r\n<strong>Explanation:</strong> 11 = 5 + 5 + 1</pre>\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>coins = <code>[2]</code>, amount = <code>3</code>\r\n<strong>Output: </strong>-1\r\n</pre>\r\n\r\n<p><b>Note</b>:<br />\r\nYou may assume that you have an infinite number of each kind of coin.</p>\r\n",
    "tags": "Dynamic Programming",
    "difficulty": 2,
    "frontend_article_id": 322,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#summary\">Summary</a></li> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-time-limit-exceeded\">Approach #1 (Brute force) [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-dynamic-programming-top-down-accepted\">Approach #2 (Dynamic programming - Top down) [Accepted]</a></li> \n      <li><a href=\"#approach-3-dynamic-programming-bottom-up-accepted\">Approach #3 (Dynamic programming - Bottom up) [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"summary\">Summary</h2> \n  <p>This article is for intermediate users. It introduces the following ideas: Backtracking, Dynamic programming.</p> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-time-limit-exceeded\">Approach #1 (Brute force) [Time Limit Exceeded]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>The problem could be modeled as the following optimization problem : <script type=\"math/tex; mode=display\">\n\\min_{x} \\sum_{i=0}^{n - 1} x_i \\\\\n\\text{subject to} \\sum_{i=0}^{n - 1} x_i*c_i = S\n</script> </p> \n  <p>, where <script type=\"math/tex; mode=display\">S</script> is the amount, <script type=\"math/tex; mode=display\">c_i</script> is the coin denominations, <script type=\"math/tex; mode=display\">x_i</script> is the number of coins with denominations <script type=\"math/tex; mode=display\">c_i</script> used in change of amount <script type=\"math/tex; mode=display\">S</script>. We could easily see that <script type=\"math/tex; mode=display\">x_i = [{0, \\frac{S}{c_i}}]</script>.</p> \n  <p>A trivial solution is to enumerate all subsets of coin frequencies <script type=\"math/tex; mode=display\">[x_0\\dots\\ x_{n - 1}]</script> that satisfy the constraints above, compute their sums and return the minimum among them.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>To apply this idea, the algorithm uses backtracking technique to generate all combinations of coin frequencies <script type=\"math/tex; mode=display\">[x_0\\dots\\ x_{n-1}]</script> in the range <script type=\"math/tex\">[{0, \\frac{S}{c_i}}]</script> which satisfy the constraints above. It makes a sum of the combinations and returns their minimum or <script type=\"math/tex; mode=display\">-1</script> in case there is no acceptable combination.</p> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>    \n\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">coinChange</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">coins</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">amount</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">coinChange</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">coins</span><span class=\"o\">,</span> <span class=\"n\">amount</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"nf\">coinChange</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">idxCoin</span><span class=\"o\">,</span> <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">coins</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">amount</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">amount</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n            <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">idxCoin</span> <span class=\"o\">&lt;</span> <span class=\"n\">coins</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">amount</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kt\">int</span> <span class=\"n\">maxVal</span> <span class=\"o\">=</span> <span class=\"n\">amount</span><span class=\"o\">/</span><span class=\"n\">coins</span><span class=\"o\">[</span><span class=\"n\">idxCoin</span><span class=\"o\">];</span>\n            <span class=\"kt\">int</span> <span class=\"n\">minCost</span> <span class=\"o\">=</span> <span class=\"n\">Integer</span><span class=\"o\">.</span><span class=\"na\">MAX_VALUE</span><span class=\"o\">;</span>\n            <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">x</span> <span class=\"o\">&lt;=</span> <span class=\"n\">maxVal</span><span class=\"o\">;</span> <span class=\"n\">x</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n                <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">amount</span> <span class=\"o\">&gt;=</span> <span class=\"n\">x</span> <span class=\"o\">*</span> <span class=\"n\">coins</span><span class=\"o\">[</span><span class=\"n\">idxCoin</span><span class=\"o\">])</span> <span class=\"o\">{</span>\n                    <span class=\"kt\">int</span> <span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"n\">coinChange</span><span class=\"o\">(</span><span class=\"n\">idxCoin</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">coins</span><span class=\"o\">,</span> <span class=\"n\">amount</span> <span class=\"o\">-</span> <span class=\"n\">x</span> <span class=\"o\">*</span> <span class=\"n\">coins</span><span class=\"o\">[</span><span class=\"n\">idxCoin</span><span class=\"o\">]);</span>\n                    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">res</span> <span class=\"o\">!=</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n                        <span class=\"n\">minCost</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">min</span><span class=\"o\">(</span><span class=\"n\">minCost</span><span class=\"o\">,</span> <span class=\"n\">res</span> <span class=\"o\">+</span> <span class=\"n\">x</span><span class=\"o\">);</span>\n                <span class=\"o\">}</span>                    \n            <span class=\"o\">}</span>           \n            <span class=\"k\">return</span> <span class=\"o\">(</span><span class=\"n\">minCost</span> <span class=\"o\">==</span> <span class=\"n\">Integer</span><span class=\"o\">.</span><span class=\"na\">MAX_VALUE</span><span class=\"o\">)?</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"o\">:</span> <span class=\"n\">minCost</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>        \n        <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>  \n<span class=\"o\">}</span>\n\n<span class=\"c1\">// Time Limit Exceeded</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time complexity : <script type=\"math/tex; mode=display\">O(S^n)</script>. In the worst case, complexity is exponential in the number of the coins <script type=\"math/tex; mode=display\">n</script>. The reason is that every coin denomination <script type=\"math/tex; mode=display\">c_i</script> could have at most <script type=\"math/tex; mode=display\">\\frac{S}{c_i}</script> values. Therefore the number of possible combinations is :</li> \n  </ul> \n  <p> <script type=\"math/tex; mode=display\">\n\\frac{S}{c_1}*\\frac{S}{c_2}*\\frac{S}{c_3}\\ldots\\frac{S}{c_n} = \\frac{S^{n}}{{c_1}*{c_2}*{c_3}\\ldots{c_n}}\n</script> </p> \n  <ul> \n   <li>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. In the worst case the maximum depth of recursion is <script type=\"math/tex; mode=display\">n</script>. Therefore we need <script type=\"math/tex; mode=display\">O( n)</script> space used by the system recursive stack.</li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-dynamic-programming-top-down-accepted\">Approach #2 (Dynamic programming - Top down) [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Could we improve the exponential solution above? Definitely! The problem could be solved with polynomial time using Dynamic programming technique. First, let's define:</p> \n  <blockquote> \n   <p> <script type=\"math/tex; mode=display\">F(S)</script> - minimum number of coins needed to make change for amount <script type=\"math/tex; mode=display\">S</script> using coin denominations <script type=\"math/tex; mode=display\">[{c_0\\ldots c_{n-1}}]</script> </p> \n  </blockquote> \n  <p>We note that this problem has an optimal substructure property, which is the key piece in solving any Dynamic Programming problems. In other words, the optimal solution can be constructed from optimal solutions of its subproblems. How to split the problem into subproblems? Let's assume that we know <script type=\"math/tex; mode=display\">F(S)</script> where some change <script type=\"math/tex; mode=display\">val_1, val_2, \\ldots</script> for <script type=\"math/tex; mode=display\">S</script> which is optimal and the last coin's denomination is <script type=\"math/tex; mode=display\">C</script>. Then the following equation should be true because of optimal substructure of the problem:</p> \n  <p> <script type=\"math/tex; mode=display\">\nF(S) = F(S - C) + 1\n</script> </p> \n  <p>But we don't know which is the denomination of the last coin <script type=\"math/tex; mode=display\">C</script>. We compute <script type=\"math/tex; mode=display\">F(S - c_i)</script> for each possible denomination <script type=\"math/tex; mode=display\">c_0, c_1, c_2 \\ldots c_{n -1}</script> and choose the minimum among them. The following recurrence relation holds:</p> \n  <p> <script type=\"math/tex; mode=display\">\nF(S) = \\min_{i=0 ... n-1} { F(S - c_i) } + 1 \\\\\n\\text{subject to} \\ \\  S-c_i \\geq 0 \\\\\n</script> </p> \n  <p> <script type=\"math/tex; mode=display\">\nF(S) = 0 \\ , \\text{when} \\ S = 0 \\\\\nF(S) = -1 \\ , \\text{when} \\ n = 0\n</script> </p> \n  <p align=\"center\"><img alt=\"Recursion tree for finding coin change of amount 6 with coin denominations {1,2,3}.\" src=\"https://leetcode.com/media/original_images/322_coin_change_tree.png\" width=\"100%\"></p> \n  <p>In the recursion tree above, we could see that a lot of subproblems were calculated multiple times. For example the problem <script type=\"math/tex; mode=display\">F(1)</script> was calculated <script type=\"math/tex; mode=display\">13</script> times. Therefore we should cache the solutions to the subproblems in a table and access them in constant time when necessary</p> \n  <p><strong>Algorithm</strong></p> \n  <p>The idea of the algorithm is to build the solution of the problem from top to bottom. It applies the idea described above. It use backtracking and cut the partial solutions in the recursive tree, which doesn't lead to a viable solution. Тhis happens when we try to make a change of a coin with a value greater than the amount <em><script type=\"math/tex; mode=display\">S</script></em>. To improve time complexity we should store the solutions of the already calculated subproblems in a table.</p> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">coinChange</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">coins</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">amount</span><span class=\"o\">)</span> <span class=\"o\">{</span>        \n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">amount</span> <span class=\"o\">&lt;</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n        <span class=\"k\">return</span> <span class=\"n\">coinChange</span><span class=\"o\">(</span><span class=\"n\">coins</span><span class=\"o\">,</span> <span class=\"n\">amount</span><span class=\"o\">,</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">amount</span><span class=\"o\">]);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"nf\">coinChange</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">coins</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">rem</span><span class=\"o\">,</span> <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">count</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">rem</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"o\">;</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">rem</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">count</span><span class=\"o\">[</span><span class=\"n\">rem</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"n\">count</span><span class=\"o\">[</span><span class=\"n\">rem</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">];</span>\n        <span class=\"kt\">int</span> <span class=\"n\">min</span> <span class=\"o\">=</span> <span class=\"n\">Integer</span><span class=\"o\">.</span><span class=\"na\">MAX_VALUE</span><span class=\"o\">;</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">coin</span> <span class=\"o\">:</span> <span class=\"n\">coins</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kt\">int</span> <span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"n\">coinChange</span><span class=\"o\">(</span><span class=\"n\">coins</span><span class=\"o\">,</span> <span class=\"n\">rem</span> <span class=\"o\">-</span> <span class=\"n\">coin</span><span class=\"o\">,</span> <span class=\"n\">count</span><span class=\"o\">);</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">res</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">0</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">res</span> <span class=\"o\">&lt;</span> <span class=\"n\">min</span><span class=\"o\">)</span>\n                <span class=\"n\">min</span> <span class=\"o\">=</span> <span class=\"mi\">1</span> <span class=\"o\">+</span> <span class=\"n\">res</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n        <span class=\"n\">count</span><span class=\"o\">[</span><span class=\"n\">rem</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">min</span> <span class=\"o\">==</span> <span class=\"n\">Integer</span><span class=\"o\">.</span><span class=\"na\">MAX_VALUE</span><span class=\"o\">)</span> <span class=\"o\">?</span> <span class=\"o\">-</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">min</span><span class=\"o\">;</span>\n        <span class=\"k\">return</span> <span class=\"n\">count</span><span class=\"o\">[</span><span class=\"n\">rem</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">];</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(S*n)</script>. where S is the amount, n is denomination count. In the worst case the recursive tree of the algorithm has height of <script type=\"math/tex; mode=display\">S</script> and the algorithm solves only <script type=\"math/tex; mode=display\">S</script> subproblems because it caches precalculated solutions in a table. Each subproblem is computed with <script type=\"math/tex; mode=display\">n</script> iterations, one by coin denomination. Therefore there is <script type=\"math/tex; mode=display\">O(S*n)</script> time complexity.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(S)</script>, where <script type=\"math/tex; mode=display\">S</script> is the amount to change We use extra space for the memoization table.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-dynamic-programming-bottom-up-accepted\">Approach #3 (Dynamic programming - Bottom up) [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>For the iterative solution, we think in bottom-up manner. Before calculating <em><script type=\"math/tex; mode=display\">F(i)</script></em>, we have to compute all minimum counts for amounts up to <script type=\"math/tex; mode=display\">i</script>. On each iteration <script type=\"math/tex; mode=display\">i</script> of the algorithm <em><script type=\"math/tex; mode=display\">F(i)</script></em> is computed as <script type=\"math/tex; mode=display\">\\min_{j=0 \\ldots n-1}{F(i -c_j)} + 1</script> </p> \n  <p align=\"center\"><img alt=\"Bottom-up approach using a table to build up the solution to F6.\" src=\"https://leetcode.com/media/original_images/322_coin_change_table.png\" width=\"539px\"></p> \n  <p>In the example above you can see that:</p> \n  <p> <script type=\"math/tex; mode=display\">\n\\begin{align}\nF(3) &= \\min\\{{F(3- c_1), F(3-c_2), F(3-c_3)}\\} + 1 \\\\\n&= \\min\\{{F(3- 1), F(3-2), F(3-3)}\\} + 1 \\\\\n&= \\min\\{{F(2), F(1), F(0)}\\} + 1 \\\\\n&= \\min\\{{1, 1, 0}\\} + 1 \\\\\n&= 1\n\\end{align}\n</script> </p> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">coinChange</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">coins</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">amount</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">max</span> <span class=\"o\">=</span> <span class=\"n\">amount</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">;</span>             \n        <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">dp</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">amount</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">];</span>  \n        <span class=\"n\">Arrays</span><span class=\"o\">.</span><span class=\"na\">fill</span><span class=\"o\">(</span><span class=\"n\">dp</span><span class=\"o\">,</span> <span class=\"n\">max</span><span class=\"o\">);</span>  \n        <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>   \n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;=</span> <span class=\"n\">amount</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;</span> <span class=\"n\">coins</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">j</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n                <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">coins</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">]</span> <span class=\"o\">&lt;=</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                    <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">min</span><span class=\"o\">(</span><span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">],</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"n\">coins</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">]]</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n                <span class=\"o\">}</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">amount</span><span class=\"o\">]</span> <span class=\"o\">&gt;</span> <span class=\"n\">amount</span> <span class=\"o\">?</span> <span class=\"o\">-</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">amount</span><span class=\"o\">];</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time complexity : <script type=\"math/tex; mode=display\">O(S*n)</script>. On each step the algorithm finds the next <em><script type=\"math/tex; mode=display\">F(i)</script></em> in <script type=\"math/tex; mode=display\">n</script> iterations, where <script type=\"math/tex; mode=display\">1\\leq i \\leq S</script>. Therefore in total the iterations are <script type=\"math/tex; mode=display\">S*n</script>.</li> \n   <li>Space complexity : <script type=\"math/tex; mode=display\">O(S)</script>. We use extra space for the memoization table.</li> \n  </ul> \n  <p>Analysis written by: @elmirap.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 321,
    "article_live": false,
    "title": "Create Maximum Number",
    "title_slug": "create-maximum-number",
    "content": "<p>Given two arrays of length <code>m</code> and <code>n</code> with digits <code>0-9</code> representing two numbers. Create the maximum number of length <code>k &lt;= m + n</code> from digits of the two. The relative order of the digits from the same array must be preserved. Return an array of the <code>k</code> digits.</p>\r\n\r\n<p><strong>Note: </strong>You should try to optimize your time and space complexity.</p>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>\r\nnums1 = <code>[3, 4, 6, 5]</code>\r\nnums2 = <code>[9, 1, 2, 5, 8, 3]</code>\r\nk = <code>5</code>\r\n<strong>Output:</strong>\r\n<code>[9, 8, 6, 5, 3]</code></pre>\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>\r\nnums1 = <code>[6, 7]</code>\r\nnums2 = <code>[6, 0, 4]</code>\r\nk = <code>5</code>\r\n<strong>Output:</strong>\r\n<code>[6, 7, 6, 0, 4]</code></pre>\r\n\r\n<p><b>Example 3:</b></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>\r\nnums1 = <code>[3, 9]</code>\r\nnums2 = <code>[8, 9]</code>\r\nk = <code>3</code>\r\n<strong>Output:</strong>\r\n<code>[9, 8, 9]</code>\r\n</pre>",
    "tags": "Dynamic Programming, Greedy",
    "difficulty": 3,
    "frontend_article_id": 321
},
{
    "frontend_question_id": 320,
    "article_live": true,
    "article_slug": "generalized-abbreviation",
    "title": "Generalized Abbreviation",
    "title_slug": "generalized-abbreviation",
    "tags": "Backtracking, Bit Manipulation",
    "difficulty": 2,
    "frontend_article_id": 320,
    "article_content": ""
},
{
    "frontend_question_id": 319,
    "article_live": false,
    "title": "Bulb Switcher",
    "title_slug": "bulb-switcher",
    "content": "<p>There are <i>n</i> bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it&#39;s off or turning off if it&#39;s on). For the <i>i</i>-th round, you toggle every <i>i</i> bulb. For the <i>n</i>-th round, you only toggle the last bulb. Find how many bulbs are on after <i>n</i> rounds.</p>\r\n\r\n<p><b>Example:</b></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>3\r\n<strong>Output:</strong> 1 \r\n<strong>Explanation:</strong> \r\nAt first, the three bulbs are <b>[off, off, off]</b>.\r\nAfter first round, the three bulbs are <b>[on, on, on]</b>.\r\nAfter second round, the three bulbs are <b>[on, off, on]</b>.\r\nAfter third round, the three bulbs are <b>[on, off, off]</b>. \r\n\r\nSo you should return 1, because there is only one bulb is on.\r\n</pre>\r\n",
    "tags": "Math, Brainteaser",
    "difficulty": 2,
    "frontend_article_id": 319
},
{
    "frontend_question_id": 318,
    "article_live": false,
    "title": "Maximum Product of Word Lengths",
    "title_slug": "maximum-product-of-word-lengths",
    "content": "<p>Given a string array <code>words</code>, find the maximum value of <code>length(word[i]) * length(word[j])</code> where the two words do not share common letters. You may assume that each word will contain only lower case letters. If no such two words exist, return 0.</p>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> <code>[&quot;abcw&quot;,&quot;baz&quot;,&quot;foo&quot;,&quot;bar&quot;,&quot;xtfn&quot;,&quot;abcdef&quot;]</code>\r\n<b>Output: </b><code>16 \r\n<strong>Explanation: </strong></code>The two words can be <code>&quot;abcw&quot;, &quot;xtfn&quot;</code><span style=\"font-family: sans-serif, Arial, Verdana, &quot;Trebuchet MS&quot;;\">.</span></pre>\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> <code>[&quot;a&quot;,&quot;ab&quot;,&quot;abc&quot;,&quot;d&quot;,&quot;cd&quot;,&quot;bcd&quot;,&quot;abcd&quot;]</code>\r\n<b>Output: </b><code>4 \r\n<strong>Explanation: </strong></code>The two words can be <code>&quot;ab&quot;, &quot;cd&quot;</code><span style=\"font-family: sans-serif, Arial, Verdana, &quot;Trebuchet MS&quot;;\">.</span></pre>\r\n\r\n<p><b>Example 3:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> <code>[&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;,&quot;aaaa&quot;]</code>\r\n<b>Output: </b><code>0 \r\n<strong>Explanation: </strong></code>No such pair of words.\r\n</pre>",
    "tags": "Bit Manipulation",
    "difficulty": 2,
    "frontend_article_id": 318
},
{
    "frontend_question_id": 317,
    "article_live": false,
    "title": "Shortest Distance from All Buildings",
    "title_slug": "shortest-distance-from-all-buildings",
    "tags": "Breadth-first Search",
    "difficulty": 3,
    "frontend_article_id": 317
},
{
    "frontend_question_id": 316,
    "article_live": false,
    "title": "Remove Duplicate Letters",
    "title_slug": "remove-duplicate-letters",
    "content": "<p>Given a string which contains only lowercase letters, remove duplicate letters so that every letter appear once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.</p>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> <code>&quot;bcabc&quot;</code>\r\n<b>Output:</b> <code>&quot;abc&quot;</code>\r\n</pre>\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> <code>&quot;cbacdcbc&quot;</code>\r\n<b>Output:</b> <code>&quot;acdb&quot;</code>\r\n</pre>",
    "tags": "Stack, Greedy",
    "difficulty": 3,
    "frontend_article_id": 316
},
{
    "frontend_question_id": 315,
    "article_live": false,
    "title": "Count of Smaller Numbers After Self",
    "title_slug": "count-of-smaller-numbers-after-self",
    "content": "<p>You are given an integer array <i>nums</i> and you have to return a new <i>counts</i> array. The <i>counts</i> array has the property where <code>counts[i]</code> is the number of smaller elements to the right of <code>nums[i]</code>.</p>\r\n\r\n<p><b>Example:</b></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [5,2,6,1]\r\n<strong>Output:</strong> <code>[2,1,1,0] \r\n<strong>Explanation:</strong></code>\r\nTo the right of 5 there are <b>2</b> smaller elements (2 and 1).\r\nTo the right of 2 there is only <b>1</b> smaller element (1).\r\nTo the right of 6 there is <b>1</b> smaller element (1).\r\nTo the right of 1 there is <b>0</b> smaller element.\r\n</pre>\r\n",
    "tags": "Divide and Conquer, Binary Indexed Tree, Segment Tree, Binary Search Tree",
    "difficulty": 3,
    "frontend_article_id": 315
},
{
    "frontend_question_id": 314,
    "article_live": false,
    "title": "Binary Tree Vertical Order Traversal",
    "title_slug": "binary-tree-vertical-order-traversal",
    "tags": "Hash Table",
    "difficulty": 2,
    "frontend_article_id": 314
},
{
    "frontend_question_id": 313,
    "article_live": false,
    "title": "Super Ugly Number",
    "title_slug": "super-ugly-number",
    "content": "<p>Write a program to find the <code>n<sup>th</sup></code> super ugly number.</p>\r\n\r\n<p>Super ugly numbers are positive numbers whose all prime factors are in the given prime list <code>primes</code> of size <code>k</code>.</p>\r\n\r\n<p><b>Example:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> n = 12, <code>primes</code> = <code>[2,7,13,19]</code>\r\n<b>Output:</b> 32 \r\n<strong>Explanation: </strong><code>[1,2,4,7,8,13,14,16,19,26,28,32] </code>is the sequence of the first 12 \r\n             super ugly numbers given <code>primes</code> = <code>[2,7,13,19]</code> of size 4.</pre>\r\n\r\n<p><b>Note:</b></p>\r\n\r\n<ul>\r\n\t<li><code>1</code> is a super ugly number for any given <code>primes</code>.</li>\r\n\t<li>The given numbers in <code>primes</code> are in ascending order.</li>\r\n\t<li>0 &lt; <code>k</code> &le; 100, 0 &lt; <code>n</code> &le; 10<sup>6</sup>, 0 &lt; <code>primes[i]</code> &lt; 1000.</li>\r\n\t<li>The n<sup>th</sup> super ugly number is guaranteed to fit in a 32-bit signed integer.</li>\r\n</ul>\r\n",
    "tags": "Math, Heap",
    "difficulty": 2,
    "frontend_article_id": 313
},
{
    "frontend_question_id": 312,
    "article_live": false,
    "title": "Burst Balloons",
    "title_slug": "burst-balloons",
    "content": "<p>Given <code>n</code> balloons, indexed from <code>0</code> to <code>n-1</code>. Each balloon is painted with a number on it represented by array <code>nums</code>. You are asked to burst all the balloons. If the you burst balloon <code>i</code> you will get <code>nums[left] * nums[i] * nums[right]</code> coins. Here <code>left</code> and <code>right</code> are adjacent indices of <code>i</code>. After the burst, the <code>left</code> and <code>right</code> then becomes adjacent.</p>\r\n\r\n<p>Find the maximum coins you can collect by bursting the balloons wisely.</p>\r\n\r\n<p><b>Note:</b></p>\r\n\r\n<ul>\r\n\t<li>You may imagine <code>nums[-1] = nums[n] = 1</code>. They are not real therefore you can not burst them.</li>\r\n\t<li>0 &le; <code>n</code> &le; 500, 0 &le; <code>nums[i]</code> &le; 100</li>\r\n</ul>\r\n\r\n<p><b>Example:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> <code>[3,1,5,8]</code>\r\n<b>Output:</b> <code>167 \r\n<strong>Explanation: </strong></code>nums = [3,1,5,8] --&gt; [3,5,8] --&gt;   [3,8]   --&gt;  [8]  --&gt; []\r\n&nbsp;            coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167\r\n</pre>",
    "tags": "Divide and Conquer, Dynamic Programming",
    "difficulty": 3,
    "frontend_article_id": 312
},
{
    "frontend_question_id": 311,
    "article_live": false,
    "title": "Sparse Matrix Multiplication",
    "title_slug": "sparse-matrix-multiplication",
    "tags": "Hash Table",
    "difficulty": 2,
    "frontend_article_id": 311
},
{
    "frontend_question_id": 310,
    "article_live": false,
    "title": "Minimum Height Trees",
    "title_slug": "minimum-height-trees",
    "content": "<p>For a undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels.</p>\r\n\r\n<p><b>Format</b><br />\r\nThe graph contains <code>n</code> nodes which are labeled from <code>0</code> to <code>n - 1</code>. You will be given the number <code>n</code> and a list of undirected <code>edges</code> (each edge is a pair of labels).</p>\r\n\r\n<p>You can assume that no duplicate edges will appear in <code>edges</code>. Since all edges are undirected, <code>[0, 1]</code> is the same as <code>[1, 0]</code> and thus will not appear together in <code>edges</code>.</p>\r\n\r\n<p><b>Example 1 :</b></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> <code>n = 4</code>, <code>edges = [[1, 0], [1, 2], [1, 3]]</code>\r\n\r\n        0\r\n        |\r\n        1\r\n       / \\\r\n      2   3 \r\n\r\n<strong>Output:</strong> <code>[1]</code>\r\n</pre>\r\n\r\n<p><b>Example 2 :</b></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> <code>n = 6</code>, <code>edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]</code>\r\n\r\n     0  1  2\r\n      \\ | /\r\n        3\r\n        |\r\n        4\r\n        |\r\n        5 \r\n\r\n<strong>Output:</strong> <code>[3, 4]</code></pre>\r\n\r\n<p><b>Note</b>:</p>\r\n\r\n<ul>\r\n\t<li>According to the <a href=\"https://en.wikipedia.org/wiki/Tree_(graph_theory)\" target=\"_blank\">definition of tree on Wikipedia</a>: &ldquo;a tree is an undirected graph in which any two vertices are connected by <i>exactly</i> one path. In other words, any connected graph without simple cycles is a tree.&rdquo;</li>\r\n\t<li>The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.</li>\r\n</ul>",
    "tags": "Breadth-first Search, Graph",
    "difficulty": 2,
    "frontend_article_id": 310
},
{
    "frontend_question_id": 309,
    "article_live": false,
    "title": "Best Time to Buy and Sell Stock with Cooldown",
    "title_slug": "best-time-to-buy-and-sell-stock-with-cooldown",
    "content": "<p>Say you have an array for which the <i>i</i><sup>th</sup> element is the price of a given stock on day <i>i</i>.</p>\r\n\r\n<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:</p>\r\n\r\n<ul>\r\n\t<li>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</li>\r\n\t<li>After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)</li>\r\n</ul>\r\n\r\n<p><b>Example:</b></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [1,2,3,0,2]\r\n<strong>Output: </strong>3 \r\n<strong>Explanation:</strong> transactions = [buy, sell, cooldown, buy, sell]\r\n</pre>",
    "tags": "Dynamic Programming",
    "difficulty": 2,
    "frontend_article_id": 309
},
{
    "frontend_question_id": 308,
    "article_live": false,
    "title": "Range Sum Query 2D - Mutable",
    "title_slug": "range-sum-query-2d-mutable",
    "tags": "Binary Indexed Tree, Segment Tree",
    "difficulty": 3,
    "frontend_article_id": 308
},
{
    "frontend_question_id": 307,
    "article_live": true,
    "article_slug": "range-sum-query-mutable",
    "title": "Range Sum Query - Mutable",
    "title_slug": "range-sum-query-mutable",
    "content": "<p>Given an integer array <i>nums</i>, find the sum of the elements between indices <i>i</i> and <i>j</i> (<i>i</i> &le; <i>j</i>), inclusive.</p>\r\n\r\n<p>The <i>update(i, val)</i> function modifies <i>nums</i> by updating the element at index <i>i</i> to <i>val</i>.</p>\r\n\r\n<p><b>Example:</b></p>\r\n\r\n<pre>\r\nGiven nums = [1, 3, 5]\r\n\r\nsumRange(0, 2) -&gt; 9\r\nupdate(1, 2)\r\nsumRange(0, 2) -&gt; 8\r\n</pre>\r\n\r\n<p><b>Note:</b></p>\r\n\r\n<ol>\r\n\t<li>The array is only modifiable by the <i>update</i> function.</li>\r\n\t<li>You may assume the number of calls to <i>update</i> and <i>sumRange</i> function is distributed evenly.</li>\r\n</ol>\r\n",
    "tags": "Binary Indexed Tree, Segment Tree",
    "difficulty": 2,
    "frontend_article_id": 307,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#summary\">Summary</a></li> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-naive-time-limit-exceeded\">Approach #1 (Naive) [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-sqrt-decomposition-accepted\">Approach #2 (Sqrt decomposition) [Accepted]</a></li> \n      <li><a href=\"#approach-3-segment-tree-accepted\">Approach #3 (Segment tree) [Accepted]</a>\n       <ul> \n        <li><a href=\"#1-build-segment-tree\">1. Build segment tree</a></li> \n        <li><a href=\"#2-update-segment-tree\">2. Update segment tree</a></li> \n        <li><a href=\"#3-range-sum-query\">3. Range Sum Query</a></li> \n       </ul> </li> \n     </ul> </li> \n    <li><a href=\"#further-thoughts\">Further Thoughts</a></li> \n   </ul> \n  </div> \n  <h2 id=\"summary\">Summary</h2> \n  <p>This article is for intermediate level readers. It introduces the following concepts: Range sum query, Sqrt decomposition, Segment tree.</p> \n  <h2 id=\"solution\">Solution</h2> \n  <h4 id=\"approach-1-naive-time-limit-exceeded\">Approach #1 (Naive) [Time Limit Exceeded]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>A trivial solution for Range Sum Query - <code>RSQ(i, j)</code> is to iterate the array from index <script type=\"math/tex; mode=display\">i</script> to <script type=\"math/tex; mode=display\">j</script> and sum each element.</p> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">private</span> <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">;</span>\n<span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">sumRange</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">i</span><span class=\"o\">;</span> <span class=\"n\">l</span> <span class=\"o\">&lt;=</span> <span class=\"n\">j</span><span class=\"o\">;</span> <span class=\"n\">l</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n        <span class=\"n\">sum</span> <span class=\"o\">+=</span> <span class=\"n\">data</span><span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">];</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">sum</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">update</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">val</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n<span class=\"c1\">// Time Limit Exceeded</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script> - range sum query, <script type=\"math/tex; mode=display\">O(1)</script> - update query</p> <p>For range sum query we access each element from the array for constant time and in the worst case we access <script type=\"math/tex; mode=display\">n</script> elements. Therefore time complexity is <script type=\"math/tex; mode=display\">O(n)</script>. Time complexity of update query is <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n  </ul> \n  <h4 id=\"approach-2-sqrt-decomposition-accepted\">Approach #2 (Sqrt decomposition) [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>The idea is to split the array in blocks with length of <script type=\"math/tex; mode=display\">\\sqrt{n}</script>. Then we calculate the sum of each block and store it in auxiliary memory <code>b</code>. To query <code>RSQ(i, j)</code>, we will add the sums of all the blocks lying inside and those that partially overlap with range <script type=\"math/tex; mode=display\">[i \\ldots j]</script>.</p> \n  <p><strong>Algorithm</strong></p> \n  <p align=\"center\"><img alt=\"Range sum query using SQRT decomposition\" src=\"https://leetcode.com/media/original_images/307_RSQ_Sqrt.png\" width=\"539px\"></p> \n  <p align=\"center\"><em>Figure 1. Range sum query using SQRT decomposition.</em></p> \n  <p>In the example above, the array <code>nums</code>'s length is <code>9</code>, which is split into blocks of size <script type=\"math/tex; mode=display\">\\sqrt{9}</script>. To get <code>RSQ(1, 7)</code> we add <code>b[1]</code>. It stores the sum of <code>range [3, 5]</code> and partially sums from <code>block 0</code> and <code>block 2</code>, which are overlapping boundary blocks.</p> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">private</span> <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">b</span><span class=\"o\">;</span>\n<span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">len</span><span class=\"o\">;</span>\n<span class=\"kd\">private</span> <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">;</span>\n\n<span class=\"kd\">public</span> <span class=\"nf\">NumArray</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">nums</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">;</span>\n    <span class=\"kt\">double</span> <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">sqrt</span><span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">);</span>\n    <span class=\"n\">len</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">)</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">ceil</span><span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">/</span><span class=\"n\">l</span><span class=\"o\">);</span>\n    <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span> <span class=\"o\">[</span><span class=\"n\">len</span><span class=\"o\">];</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span>\n        <span class=\"n\">b</span><span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">/</span> <span class=\"n\">len</span><span class=\"o\">]</span> <span class=\"o\">+=</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">];</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">sumRange</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">startBlock</span> <span class=\"o\">=</span> <span class=\"n\">i</span> <span class=\"o\">/</span> <span class=\"n\">len</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">endBlock</span> <span class=\"o\">=</span> <span class=\"n\">j</span> <span class=\"o\">/</span> <span class=\"n\">len</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">startBlock</span> <span class=\"o\">==</span> <span class=\"n\">endBlock</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"n\">i</span><span class=\"o\">;</span> <span class=\"n\">k</span> <span class=\"o\">&lt;=</span> <span class=\"n\">j</span><span class=\"o\">;</span> <span class=\"n\">k</span><span class=\"o\">++)</span>\n            <span class=\"n\">sum</span> <span class=\"o\">+=</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">];</span>\n    <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"n\">i</span><span class=\"o\">;</span> <span class=\"n\">k</span> <span class=\"o\">&lt;=</span> <span class=\"o\">(</span><span class=\"n\">startBlock</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">*</span> <span class=\"n\">len</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">;</span> <span class=\"n\">k</span><span class=\"o\">++)</span>\n            <span class=\"n\">sum</span> <span class=\"o\">+=</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">];</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"n\">startBlock</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">;</span> <span class=\"n\">k</span> <span class=\"o\">&lt;=</span> <span class=\"n\">endBlock</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">;</span> <span class=\"n\">k</span><span class=\"o\">++)</span>\n            <span class=\"n\">sum</span> <span class=\"o\">+=</span> <span class=\"n\">b</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">];</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"n\">endBlock</span> <span class=\"o\">*</span> <span class=\"n\">len</span><span class=\"o\">;</span> <span class=\"n\">k</span> <span class=\"o\">&lt;=</span> <span class=\"n\">j</span><span class=\"o\">;</span> <span class=\"n\">k</span><span class=\"o\">++)</span>\n            <span class=\"n\">sum</span> <span class=\"o\">+=</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">];</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">sum</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">update</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">b_l</span> <span class=\"o\">=</span> <span class=\"n\">i</span> <span class=\"o\">/</span> <span class=\"n\">len</span><span class=\"o\">;</span>\n    <span class=\"n\">b</span><span class=\"o\">[</span><span class=\"n\">b_l</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">b</span><span class=\"o\">[</span><span class=\"n\">b_l</span><span class=\"o\">]</span> <span class=\"o\">-</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">+</span> <span class=\"n\">val</span><span class=\"o\">;</span>\n    <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">val</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n<span class=\"c1\">// Accepted</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script> - preprocessing, <script type=\"math/tex; mode=display\">O(\\sqrt{n})</script> - range sum query, <script type=\"math/tex; mode=display\">O(1)</script> - update query</p> <p>For range sum query in the worst-case scenario we have to sum approximately <script type=\"math/tex; mode=display\">3 \\sqrt{n}</script> elements. In this case the range includes <script type=\"math/tex; mode=display\">\\sqrt{n} - 2</script> blocks, which total sum costs <script type=\"math/tex; mode=display\">\\sqrt{n} - 2</script> operations. In addition to this we have to add the sum of the two boundary blocks. This takes another <script type=\"math/tex; mode=display\">2 (\\sqrt{n} - 1)</script> operations. The total amount of operations is around <script type=\"math/tex; mode=display\">3 \\sqrt{n}</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(\\sqrt{n})</script>.</p> <p>We need additional <script type=\"math/tex; mode=display\">\\sqrt{n}</script> memory to store all block sums.</p> </li> \n  </ul> \n  <h4 id=\"approach-3-segment-tree-accepted\">Approach #3 (Segment tree) [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Segment tree is a very flexible data structure, because it is used to solve numerous range query problems like finding minimum, maximum, sum, greatest common divisor, least common denominator in array in logarithmic time.</p> \n  <p align=\"center\"><img alt=\"Illustration of Segment tree\" src=\"https://leetcode.com/media/original_images/307_RSQ_SegmentTree.png\" width=\"539px\"></p> \n  <p align=\"center\"><em>Figure 2. Illustration of Segment tree.</em></p> \n  <p>The segment tree for array <script type=\"math/tex; mode=display\">a[0, 1, \\ldots ,n-1]</script> is a binary tree in which each node contains <strong>aggregate</strong> information (min, max, sum, etc.) for a subrange <script type=\"math/tex; mode=display\">[i \\ldots j]</script> of the array, as its left and right child hold information for range <script type=\"math/tex; mode=display\">[i \\ldots \\frac{i+j}{2}]</script> and <script type=\"math/tex; mode=display\">[\\frac{i + j}{2} + 1, j]</script>.</p> \n  <p>Segment tree could be implemented using either an array or a tree. For an array implementation, if the element at index <script type=\"math/tex; mode=display\">i</script> is not a leaf, its left and right child are stored at index <script type=\"math/tex; mode=display\">2i</script> and <script type=\"math/tex; mode=display\">2i + 1</script> respectively.</p> \n  <p>In the example above (Figure 2), every leaf node contains the initial array elements <code>{2,4,5,7,8,9}</code>. The internal nodes contain the sum of the corresponding elements in range - <code>(11)</code> for the elements from index 0 to index 2. The root <code>(35)</code> being the sum of its children <code>(6)</code>;<code>(29)</code>, holds the total sum of the entire array.</p> \n  <p>Segment Tree can be broken down to the three following steps:</p> \n  <ol> \n   <li>Pre-processing step which builds the segment tree from a given array.</li> \n   <li>Update the segment tree when an element is modified.</li> \n   <li>Calculate the Range Sum Query using the segment tree.</li> \n  </ol> \n  <h5 id=\"1-build-segment-tree\">1. Build segment tree</h5> \n  <p>We will use a very effective bottom-up approach to build segment tree. We already know from the above that if some node <script type=\"math/tex; mode=display\">p</script> holds the sum of <script type=\"math/tex; mode=display\">[i \\ldots j]</script> range, its left and right children hold the sum for range <script type=\"math/tex; mode=display\">[i \\ldots \\frac{i + j}{2}]</script> and <script type=\"math/tex; mode=display\">[\\frac{i + j}{2} + 1, j]</script> respectively.</p> \n  <p>Therefore to find the sum of node <script type=\"math/tex; mode=display\">p</script>, we need to calculate the sum of its right and left child in advance.</p> \n  <p>We begin from the leaves, initialize them with input array elements <script type=\"math/tex; mode=display\">a[0, 1, \\ldots, n-1]</script>. Then we move upward to the higher level to calculate the parents' sum till we get to the root of the segment tree.</p> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">tree</span><span class=\"o\">;</span>\n<span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"o\">;</span>\n<span class=\"kd\">public</span> <span class=\"nf\">NumArray</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span>\n        <span class=\"n\">tree</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">n</span> <span class=\"o\">*</span> <span class=\"mi\">2</span><span class=\"o\">];</span>\n        <span class=\"n\">buildTree</span><span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">buildTree</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>  <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">n</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++,</span>  <span class=\"n\">j</span><span class=\"o\">++)</span>\n        <span class=\"n\">tree</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">];</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">n</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"o\">--</span><span class=\"n\">i</span><span class=\"o\">)</span>\n        <span class=\"n\">tree</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">tree</span><span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">*</span> <span class=\"mi\">2</span><span class=\"o\">]</span> <span class=\"o\">+</span> <span class=\"n\">tree</span><span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">*</span> <span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">];</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script> </p> <p>Time complexity is <script type=\"math/tex; mode=display\">O(n)</script>, because we calculate the sum of one node during each iteration of the for loop. There are approximately <script type=\"math/tex; mode=display\">2n</script> nodes in a segment tree.</p> <p>This could be proved in the following way: Segmented tree for array with <script type=\"math/tex; mode=display\">n</script> elements has <script type=\"math/tex; mode=display\">n</script> leaves (the array elements itself). The number of nodes in each level is half the number in the level below.</p> <p>So if we sum the number by level we will get:</p> <p> <script type=\"math/tex; mode=display\">\nn + n/2  + n/4 + n/8 + \\ldots + 1 \\approx 2n\n</script> </p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>.</p> <p>We used <script type=\"math/tex; mode=display\">2n</script> extra space to store the segment tree.</p> </li> \n  </ul> \n  <h5 id=\"2-update-segment-tree\">2. Update segment tree</h5> \n  <p>When we update the array at some index <script type=\"math/tex; mode=display\">i</script> we need to rebuild the segment tree, because there are tree nodes which contain the sum of the modified element. Again we will use a bottom-up approach. We update the leaf node that stores <script type=\"math/tex; mode=display\">a[i]</script>. From there we will follow the path up to the root updating the value of each parent as a sum of its children values.</p> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kt\">void</span> <span class=\"nf\">update</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">pos</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">pos</span> <span class=\"o\">+=</span> <span class=\"n\">n</span><span class=\"o\">;</span>\n    <span class=\"n\">tree</span><span class=\"o\">[</span><span class=\"n\">pos</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">val</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">pos</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">left</span> <span class=\"o\">=</span> <span class=\"n\">pos</span><span class=\"o\">;</span>\n        <span class=\"kt\">int</span> <span class=\"n\">right</span> <span class=\"o\">=</span> <span class=\"n\">pos</span><span class=\"o\">;</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">pos</span> <span class=\"o\">%</span> <span class=\"mi\">2</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">right</span> <span class=\"o\">=</span> <span class=\"n\">pos</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>\n            <span class=\"n\">left</span> <span class=\"o\">=</span> <span class=\"n\">pos</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n        <span class=\"c1\">// parent is updated after child is updated</span>\n        <span class=\"n\">tree</span><span class=\"o\">[</span><span class=\"n\">pos</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">tree</span><span class=\"o\">[</span><span class=\"n\">left</span><span class=\"o\">]</span> <span class=\"o\">+</span> <span class=\"n\">tree</span><span class=\"o\">[</span><span class=\"n\">right</span><span class=\"o\">];</span>\n        <span class=\"n\">pos</span> <span class=\"o\">/=</span> <span class=\"mi\">2</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(\\log n)</script>.</p> <p>Algorithm has <script type=\"math/tex; mode=display\">O(\\log n)</script> time complexity, because there are a few tree nodes with range that include <script type=\"math/tex; mode=display\">i</script>th array element, one on each level. There are <script type=\"math/tex; mode=display\">\\log(n)</script> levels.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n  </ul> \n  <h5 id=\"3-range-sum-query\">3. Range Sum Query</h5> \n  <p>We can find range sum query <script type=\"math/tex; mode=display\">[L, R]</script> using segment tree in the following way:</p> \n  <p>Algorithm hold loop invariant:</p> \n  <p> <script type=\"math/tex; mode=display\">l \\le r</script> and sum of <script type=\"math/tex; mode=display\">[L \\ldots l]</script> and <script type=\"math/tex; mode=display\">[r \\ldots R]</script> has been calculated, where <script type=\"math/tex; mode=display\">l</script> and <script type=\"math/tex; mode=display\">r</script> are the left and right boundary of calculated sum. Initially we set <script type=\"math/tex; mode=display\">l</script> with left leaf <script type=\"math/tex; mode=display\">L</script> and <script type=\"math/tex; mode=display\">r</script> with right leaf <script type=\"math/tex; mode=display\">R</script>. Range <script type=\"math/tex; mode=display\">[l, r]</script> shrinks on each iteration till range borders meets after approximately <script type=\"math/tex; mode=display\">\\log n</script> iterations of the algorithm</p> \n  <ul> \n   <li>Loop till <script type=\"math/tex; mode=display\">l \\le r</script> \n    <ul> \n     <li>Check if <script type=\"math/tex; mode=display\">l</script> is right child of its parent <script type=\"math/tex; mode=display\">P</script> \n      <ul> \n       <li> <script type=\"math/tex; mode=display\">l</script> is right child of <script type=\"math/tex; mode=display\">P</script>. Then <script type=\"math/tex; mode=display\">P</script> contains sum of range of <script type=\"math/tex; mode=display\">l</script> and another child which is outside the range <script type=\"math/tex; mode=display\">[l, r]</script> and we don't need parent <script type=\"math/tex; mode=display\">P</script> sum. Add <script type=\"math/tex; mode=display\">l</script> to <script type=\"math/tex; mode=display\">sum</script> without its parent <script type=\"math/tex; mode=display\">P</script> and set <script type=\"math/tex; mode=display\">l</script> to point to the right of <script type=\"math/tex; mode=display\">P</script> on the upper level.</li> \n       <li> <script type=\"math/tex; mode=display\">l</script> is not right child of <script type=\"math/tex; mode=display\">P</script>. Then parent <script type=\"math/tex; mode=display\">P</script> contains sum of range which lies in <script type=\"math/tex; mode=display\">[l, r]</script>. Add <script type=\"math/tex; mode=display\">P</script> to <script type=\"math/tex; mode=display\">sum</script> and set <script type=\"math/tex; mode=display\">l</script> to point to the parent of <script type=\"math/tex; mode=display\">P</script> </li> \n      </ul> </li> \n     <li>Check if <script type=\"math/tex; mode=display\">r</script> is left child of its parent <script type=\"math/tex; mode=display\">P</script> \n      <ul> \n       <li> <script type=\"math/tex; mode=display\">r</script> is left child of <script type=\"math/tex; mode=display\">P</script>. Then <script type=\"math/tex; mode=display\">P</script> contains sum of range of <script type=\"math/tex; mode=display\">r</script> and another child which is outside the range <script type=\"math/tex; mode=display\">[l, r]</script> and we don't need parent <script type=\"math/tex; mode=display\">P</script> sum. Add <script type=\"math/tex; mode=display\">r</script> to <script type=\"math/tex; mode=display\">sum</script> without its parent <script type=\"math/tex; mode=display\">P</script> and set <script type=\"math/tex; mode=display\">r</script> to point to the left of <script type=\"math/tex; mode=display\">P</script> on the upper level.</li> \n       <li> <script type=\"math/tex; mode=display\">r</script> is not left child of <script type=\"math/tex; mode=display\">P</script>. Then parent <script type=\"math/tex; mode=display\">P</script> contains sum of range which lies in <script type=\"math/tex; mode=display\">[l, r]</script>. Add <script type=\"math/tex; mode=display\">P</script> to <script type=\"math/tex; mode=display\">sum</script> and set <script type=\"math/tex; mode=display\">r</script> to point to the parent of <script type=\"math/tex; mode=display\">P</script> </li> \n      </ul> </li> \n    </ul> </li> \n  </ul> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">sumRange</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// get leaf with value 'l'</span>\n    <span class=\"n\">l</span> <span class=\"o\">+=</span> <span class=\"n\">n</span><span class=\"o\">;</span>\n    <span class=\"c1\">// get leaf with value 'r'</span>\n    <span class=\"n\">r</span> <span class=\"o\">+=</span> <span class=\"n\">n</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">&lt;=</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">((</span><span class=\"n\">l</span> <span class=\"o\">%</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n           <span class=\"n\">sum</span> <span class=\"o\">+=</span> <span class=\"n\">tree</span><span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">];</span>\n           <span class=\"n\">l</span><span class=\"o\">++;</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">if</span> <span class=\"o\">((</span><span class=\"n\">r</span> <span class=\"o\">%</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n           <span class=\"n\">sum</span> <span class=\"o\">+=</span> <span class=\"n\">tree</span><span class=\"o\">[</span><span class=\"n\">r</span><span class=\"o\">];</span>\n           <span class=\"n\">r</span><span class=\"o\">--;</span>\n        <span class=\"o\">}</span>\n        <span class=\"n\">l</span> <span class=\"o\">/=</span> <span class=\"mi\">2</span><span class=\"o\">;</span>\n        <span class=\"n\">r</span> <span class=\"o\">/=</span> <span class=\"mi\">2</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">sum</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(\\log n)</script> </p> <p>Time complexity is <script type=\"math/tex; mode=display\">O(\\log n)</script> because on each iteration of the algorithm we move one level up, either to the parent of the current node or to the next sibling of parent to the left or right direction till the two boundaries meet. In the worst-case scenario this happens at the root after <script type=\"math/tex; mode=display\">\\log n</script> iterations of the algorithm.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n  </ul> \n  <h2 id=\"further-thoughts\">Further Thoughts</h2> \n  <p>The iterative version of Segment Trees was introduced in this article. A more intuitive, recursive version of Segment Trees to solve this problem is discussed <a href=\"https://leetcode.com/articles/recursive-approach-segment-trees-range-sum-queries-lazy-propagation/\">here</a>. The concept of Lazy Propagation is also introduced there.</p> \n  <p>There is an alternative solution of the problem using Binary Indexed Tree. It is faster and simpler to code. You can find it <a href=\"https://leetcode.com/discuss/74222/java-using-binary-indexed-tree-with-clear-explanation\">here</a>.</p> \n  <p>Analysis written by: @elmirap.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 306,
    "article_live": false,
    "title": "Additive Number",
    "title_slug": "additive-number",
    "content": "<p>Additive number is a string whose digits can form additive sequence.</p>\r\n\r\n<p>A valid additive sequence should contain <b>at least</b> three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.</p>\r\n\r\n<p>Given a string containing only digits <code>&#39;0&#39;-&#39;9&#39;</code>, write a function to determine if it&#39;s an additive number.</p>\r\n\r\n<p><b>Note:</b> Numbers in the additive sequence <b>cannot</b> have leading zeros, so sequence <code>1, 2, 03</code> or <code>1, 02, 3</code> is invalid.</p>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> <code>&quot;112358&quot;</code>\r\n<b>Output:</b> true \r\n<strong>Explanation: </strong>The digits can form an additive sequence: <code>1, 1, 2, 3, 5, 8</code>. \r\n&nbsp;            1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8\r\n</pre>\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> <code>&quot;199100199&quot;</code>\r\n<b>Output:</b> true \r\n<strong>Explanation: </strong>The additive sequence is: <code>1, 99, 100, 199</code><span style=\"font-family: sans-serif, Arial, Verdana, &quot;Trebuchet MS&quot;;\">.</span>&nbsp;\r\n&nbsp;            1 + 99 = 100, 99 + 100 = 199</pre>\r\n\r\n<p><b>Follow up:</b><br />\r\nHow would you handle overflow for very large input integers?</p>",
    "tags": "Backtracking",
    "difficulty": 2,
    "frontend_article_id": 306
},
{
    "frontend_question_id": 305,
    "article_live": true,
    "article_slug": "number-of-islands-ii",
    "title": "Number of Islands II",
    "title_slug": "number-of-islands-ii",
    "tags": "Union Find",
    "difficulty": 3,
    "frontend_article_id": 305,
    "article_content": ""
},
{
    "frontend_question_id": 304,
    "article_live": true,
    "article_slug": "range-sum-query-2d-immutable",
    "title": "Range Sum Query 2D - Immutable",
    "title_slug": "range-sum-query-2d-immutable",
    "content": "<p>Given a 2D matrix <i>matrix</i>, find the sum of the elements inside the rectangle defined by its upper left corner (<i>row</i>1, <i>col</i>1) and lower right corner (<i>row</i>2, <i>col</i>2).</p>\r\n\r\n<p>\r\n<img src=\"/static/images/courses/range_sum_query_2d.png\" border=\"0\" alt=\"Range Sum Query 2D\" /><br />\r\n<small>The above rectangle (with the red border) is defined by (row1, col1) = <b>(2, 1)</b> and (row2, col2) = <b>(4, 3)</b>, which contains sum = <b>8</b>.</small>\r\n</p>\r\n\r\n<p><b>Example:</b><br>\r\n<pre>\r\nGiven matrix = [\r\n  [3, 0, 1, 4, 2],\r\n  [5, 6, 3, 2, 1],\r\n  [1, 2, 0, 1, 5],\r\n  [4, 1, 0, 1, 7],\r\n  [1, 0, 3, 0, 5]\r\n]\r\n\r\nsumRegion(2, 1, 4, 3) -> 8\r\nsumRegion(1, 1, 2, 2) -> 11\r\nsumRegion(1, 2, 2, 4) -> 12\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>You may assume that the matrix does not change.</li>\r\n<li>There are many calls to <i>sumRegion</i> function.</li>\r\n<li>You may assume that <i>row</i>1 &le; <i>row</i>2 and <i>col</i>1 &le; <i>col</i>2.</li>\r\n</ol>\r\n</p>",
    "tags": "Dynamic Programming",
    "difficulty": 2,
    "frontend_article_id": 304,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-time-limit-exceeded\">Approach #1 (Brute Force) [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-caching-memory-limit-exceeded\">Approach #2 (Caching) [Memory Limit Exceeded]</a></li> \n      <li><a href=\"#approach-3-caching-rows-accepted\">Approach #3 (Caching Rows) [Accepted]</a></li> \n      <li><a href=\"#approach-4-caching-smarter-accepted\">Approach #4 (Caching Smarter) [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-time-limit-exceeded\">Approach #1 (Brute Force) [Time Limit Exceeded]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Each time <em>sumRegion</em> is called, we use a double for loop to sum all elements from <script type=\"math/tex; mode=display\">(row1, col1) \\rightarrow (row2, col2)</script>.</p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">private</span> <span class=\"kt\">int</span><span class=\"o\">[][]</span> <span class=\"n\">data</span><span class=\"o\">;</span>\n\n<span class=\"kd\">public</span> <span class=\"nf\">NumMatrix</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[][]</span> <span class=\"n\">matrix</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">matrix</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">sumRegion</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">row1</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">col1</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">row2</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">col2</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">row1</span><span class=\"o\">;</span> <span class=\"n\">r</span> <span class=\"o\">&lt;=</span> <span class=\"n\">row2</span><span class=\"o\">;</span> <span class=\"n\">r</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">col1</span><span class=\"o\">;</span> <span class=\"n\">c</span> <span class=\"o\">&lt;=</span> <span class=\"n\">col2</span><span class=\"o\">;</span> <span class=\"n\">c</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"n\">sum</span> <span class=\"o\">+=</span> <span class=\"n\">data</span><span class=\"o\">[</span><span class=\"n\">r</span><span class=\"o\">][</span><span class=\"n\">c</span><span class=\"o\">];</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">sum</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(mn)</script> time per query. Assume that <script type=\"math/tex; mode=display\">m</script> and <script type=\"math/tex; mode=display\">n</script> represents the number of rows and columns respectively, each <em>sumRegion</em> query can go through at most <script type=\"math/tex; mode=display\">m \\times n</script> elements.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Note that <code>data</code> is a <em>reference</em> to <code>matrix</code> and is not a copy of it.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-caching-memory-limit-exceeded\">Approach #2 (Caching) [Memory Limit Exceeded]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Since <em>sumRegion</em> could be called many times, we definitely need to do some pre-processing.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>We could trade in extra space for speed by pre-calculating all possible rectangular region sum and store them in a hash table. Each <em>sumRegion</em> query now takes only constant time complexity.</p> \n  <p><strong>Complexity analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(1)</script> time per query, <script type=\"math/tex; mode=display\">O(m^2n^2)</script> time pre-computation. Each <em>sumRegion</em> query takes <script type=\"math/tex; mode=display\">O(1)</script> time as the hash table lookup's time complexity is constant. The pre-computation will take <script type=\"math/tex; mode=display\">O(m^2n^2)</script> time as there are a total of <script type=\"math/tex; mode=display\">m^2 \\times n^2</script> possibilities need to be cached.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(m^2n^2)</script>. Since there are <script type=\"math/tex; mode=display\">mn</script> different possibilities for both top left and bottom right points of the rectangular region, the extra space required is <script type=\"math/tex; mode=display\">O(m^2n^2)</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-caching-rows-accepted\">Approach #3 (Caching Rows) [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Remember from the <a href=\"https://leetcode.com/course/chapters/leetcode-101/range-sum-query-immutable/\">1D version</a> where we used a cumulative sum array? Could we apply that directly to solve this 2D version?</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Try to see the 2D matrix as <script type=\"math/tex; mode=display\">m</script> rows of 1D arrays. To find the region sum, we just accumulate the sum in the region row by row.</p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">private</span> <span class=\"kt\">int</span><span class=\"o\">[][]</span> <span class=\"n\">dp</span><span class=\"o\">;</span>\n\n<span class=\"kd\">public</span> <span class=\"nf\">NumMatrix</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[][]</span> <span class=\"n\">matrix</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">matrix</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">==</span> <span class=\"mi\">0</span> <span class=\"o\">||</span> <span class=\"n\">matrix</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">].</span><span class=\"na\">length</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"k\">return</span><span class=\"o\">;</span>\n    <span class=\"n\">dp</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">matrix</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">][</span><span class=\"n\">matrix</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">].</span><span class=\"na\">length</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">];</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">r</span> <span class=\"o\">&lt;</span> <span class=\"n\">matrix</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">r</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">c</span> <span class=\"o\">&lt;</span> <span class=\"n\">matrix</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">].</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">c</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">r</span><span class=\"o\">][</span><span class=\"n\">c</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">r</span><span class=\"o\">][</span><span class=\"n\">c</span><span class=\"o\">]</span> <span class=\"o\">+</span> <span class=\"n\">matrix</span><span class=\"o\">[</span><span class=\"n\">r</span><span class=\"o\">][</span><span class=\"n\">c</span><span class=\"o\">];</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">sumRegion</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">row1</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">col1</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">row2</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">col2</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">row</span> <span class=\"o\">=</span> <span class=\"n\">row1</span><span class=\"o\">;</span> <span class=\"n\">row</span> <span class=\"o\">&lt;=</span> <span class=\"n\">row2</span><span class=\"o\">;</span> <span class=\"n\">row</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n        <span class=\"n\">sum</span> <span class=\"o\">+=</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">row</span><span class=\"o\">][</span><span class=\"n\">col2</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"o\">-</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">row</span><span class=\"o\">][</span><span class=\"n\">col1</span><span class=\"o\">];</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">sum</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(m)</script> time per query, <script type=\"math/tex; mode=display\">O(mn)</script> time pre-computation. The pre-computation in the constructor takes <script type=\"math/tex; mode=display\">O(mn)</script> time. The <em>sumRegion</em> query takes <script type=\"math/tex; mode=display\">O(m)</script> time.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(mn)</script>. The algorithm uses <script type=\"math/tex; mode=display\">O(mn)</script> space to store the cumulative sum of all rows.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-4-caching-smarter-accepted\">Approach #4 (Caching Smarter) [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>We used a cumulative sum array in the <a href=\"https://leetcode.com/course/chapters/leetcode-101/range-sum-query-immutable/\">1D version</a>. We notice that the cumulative sum is computed with respect to the origin at index 0. Extending this analogy to the 2D case, we could pre-compute a cumulative region sum with respect to the origin at <script type=\"math/tex; mode=display\">(0, 0)</script>.</p> \n  <p><img alt=\"Sum OD\" src=\"https://leetcode.com/static/images/courses/sum_od.png\"><br> <small>Sum(OD) is the cumulative region sum with respect to the origin at (0, 0).</small></p> \n  <p>How do we derive <script type=\"math/tex; mode=display\">Sum(ABCD)</script> using the pre-computed cumulative region sum?</p> \n  <p><img alt=\"Sum OB\" src=\"https://leetcode.com/static/images/courses/sum_ob.png\"><br> <small>Sum(OB) is the cumulative region sum on top of the rectangle.</small></p> \n  <p><img alt=\"Sum OC\" src=\"https://leetcode.com/static/images/courses/sum_oc.png\"><br> <small>Sum(OC) is the cumulative region sum to the left of the rectangle.</small></p> \n  <p><img alt=\"Sum OA\" src=\"https://leetcode.com/static/images/courses/sum_oa.png\"><br> <small>Sum(OA) is the cumulative region sum to the top left corner of the rectangle.</small></p> \n  <p>Note that the region <script type=\"math/tex; mode=display\">Sum(OA)</script> is covered twice by both <script type=\"math/tex; mode=display\">Sum(OB)</script> and <script type=\"math/tex; mode=display\">Sum(OC)</script>. We could use the principle of inclusion-exclusion to calculate <script type=\"math/tex; mode=display\">Sum(ABCD)</script> as following:</p> \n  <p> <script type=\"math/tex; mode=display\">\nSum(ABCD) = Sum(OD) - Sum(OB) - Sum(OC) + Sum(OA)\n</script> </p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">private</span> <span class=\"kt\">int</span><span class=\"o\">[][]</span> <span class=\"n\">dp</span><span class=\"o\">;</span>\n\n<span class=\"kd\">public</span> <span class=\"nf\">NumMatrix</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[][]</span> <span class=\"n\">matrix</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">matrix</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">==</span> <span class=\"mi\">0</span> <span class=\"o\">||</span> <span class=\"n\">matrix</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">].</span><span class=\"na\">length</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"k\">return</span><span class=\"o\">;</span>\n    <span class=\"n\">dp</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">matrix</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">][</span><span class=\"n\">matrix</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">].</span><span class=\"na\">length</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">];</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">r</span> <span class=\"o\">&lt;</span> <span class=\"n\">matrix</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">r</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">c</span> <span class=\"o\">&lt;</span> <span class=\"n\">matrix</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">].</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">c</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">r</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">][</span><span class=\"n\">c</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">r</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">][</span><span class=\"n\">c</span><span class=\"o\">]</span> <span class=\"o\">+</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">r</span><span class=\"o\">][</span><span class=\"n\">c</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"o\">+</span> <span class=\"n\">matrix</span><span class=\"o\">[</span><span class=\"n\">r</span><span class=\"o\">][</span><span class=\"n\">c</span><span class=\"o\">]</span> <span class=\"o\">-</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">r</span><span class=\"o\">][</span><span class=\"n\">c</span><span class=\"o\">];</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">sumRegion</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">row1</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">col1</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">row2</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">col2</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">row2</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">][</span><span class=\"n\">col2</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"o\">-</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">row1</span><span class=\"o\">][</span><span class=\"n\">col2</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"o\">-</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">row2</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">][</span><span class=\"n\">col1</span><span class=\"o\">]</span> <span class=\"o\">+</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">row1</span><span class=\"o\">][</span><span class=\"n\">col1</span><span class=\"o\">];</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(1)</script> time per query, <script type=\"math/tex; mode=display\">O(mn)</script> time pre-computation. The pre-computation in the constructor takes <script type=\"math/tex; mode=display\">O(mn)</script> time. Each <em>sumRegion</em> query takes <script type=\"math/tex; mode=display\">O(1)</script> time.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(mn)</script>. The algorithm uses <script type=\"math/tex; mode=display\">O(mn)</script> space to store the cumulative region sum.</p> </li> \n  </ul> \n </div> \n</div>"
},
{
    "frontend_question_id": 303,
    "article_live": true,
    "article_slug": "range-sum-query-immutable",
    "title": "Range Sum Query - Immutable",
    "title_slug": "range-sum-query-immutable",
    "content": "<p>Given an integer array <i>nums</i>, find the sum of the elements between indices <i>i</i> and <i>j</i> (<i>i</i> &le; <i>j</i>), inclusive.</p>\r\n\r\n<p><b>Example:</b><br>\r\n<pre>\r\nGiven nums = [-2, 0, 3, -5, 2, -1]\r\n\r\nsumRange(0, 2) -> 1\r\nsumRange(2, 5) -> -1\r\nsumRange(0, 5) -> -3\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>You may assume that the array does not change.</li>\r\n<li>There are many calls to <i>sumRange</i> function.</li>\r\n</ol>\r\n</p>",
    "tags": "Dynamic Programming",
    "difficulty": 1,
    "frontend_article_id": 303,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-time-limit-exceeded\">Approach #1 (Brute Force) [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-caching-accepted\">Approach #2 (Caching) [Accepted]</a></li> \n      <li><a href=\"#approach-3-caching-accepted\">Approach #3 (Caching) [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-time-limit-exceeded\">Approach #1 (Brute Force) [Time Limit Exceeded]</h4> \n  <p>Each time <em>sumRange</em> is called, we use a for loop to sum each individual element from index <script type=\"math/tex; mode=display\">i</script> to <script type=\"math/tex; mode=display\">j</script>.</p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">private</span> <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">data</span><span class=\"o\">;</span>\n\n<span class=\"kd\">public</span> <span class=\"nf\">NumArray</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">sumRange</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"n\">i</span><span class=\"o\">;</span> <span class=\"n\">k</span> <span class=\"o\">&lt;=</span> <span class=\"n\">j</span><span class=\"o\">;</span> <span class=\"n\">k</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n        <span class=\"n\">sum</span> <span class=\"o\">+=</span> <span class=\"n\">data</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">];</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">sum</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity analysis:</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script> time per query. Each <em>sumRange</em> query takes <script type=\"math/tex; mode=display\">O(n)</script> time.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Note that <code>data</code> is a <em>reference</em> to <code>nums</code> and is not a copy of it.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-caching-accepted\">Approach #2 (Caching) [Accepted]</h4> \n  <p>Imagine that <em>sumRange</em> is called one thousand times with the exact same arguments. How could we speed that up?</p> \n  <p>We could trade in extra space for speed. By pre-computing all range sum possibilities and store its results in a hash table, we can speed up the query to constant time.</p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">private</span> <span class=\"n\">Map</span><span class=\"o\">&lt;</span><span class=\"n\">Pair</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">,</span> <span class=\"n\">Integer</span><span class=\"o\">&gt;,</span> <span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">map</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HashMap</span><span class=\"o\">&lt;&gt;();</span>\n\n<span class=\"kd\">public</span> <span class=\"nf\">NumArray</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">i</span><span class=\"o\">;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">j</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"n\">sum</span> <span class=\"o\">+=</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">];</span>\n            <span class=\"n\">map</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"n\">Pair</span><span class=\"o\">.</span><span class=\"na\">create</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">j</span><span class=\"o\">),</span> <span class=\"n\">sum</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">sumRange</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">map</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">Pair</span><span class=\"o\">.</span><span class=\"na\">create</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">j</span><span class=\"o\">));</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(1)</script> time per query, <script type=\"math/tex; mode=display\">O(n^2)</script> time pre-computation. The pre-computation done in the constructor takes <script type=\"math/tex; mode=display\">O(n^2)</script> time. Each <em>sumRange</em> query's time complexity is <script type=\"math/tex; mode=display\">O(1)</script> as the hash table's look up operation is constant time.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n^2)</script>. The extra space required is <script type=\"math/tex; mode=display\">O(n^2)</script> as there are <script type=\"math/tex; mode=display\">n</script> candidates for both <script type=\"math/tex; mode=display\">i</script> and <script type=\"math/tex; mode=display\">j</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-caching-accepted\">Approach #3 (Caching) [Accepted]</h4> \n  <p>The above approach takes a lot of space, could we optimize it?</p> \n  <p>Imagine that we pre-compute the cummulative sum from index <script type=\"math/tex; mode=display\">0</script> to <script type=\"math/tex; mode=display\">k</script>. Could we use this information to derive <script type=\"math/tex; mode=display\">Sum(i, j)</script>?</p> \n  <p>Let us define <script type=\"math/tex; mode=display\">sum[k]</script> as the cumulative sum for <script type=\"math/tex; mode=display\">nums[0 \\cdots k-1]</script> (inclusive):</p> \n  <p> <script type=\"math/tex; mode=display\">\nsum[k] = \\left\\{ \\begin{array}{rl} \\sum_{i=0}^{k-1}nums[i] & , k > 0 \\\\ 0 &, k = 0 \\end{array} \\right.\n</script> </p> \n  <p>Now, we can calculate <em>sumRange</em> as following:</p> \n  <p> <script type=\"math/tex; mode=display\">\nsumRange(i, j) = sum[j + 1] - sum[i]\n</script> </p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">private</span> <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">sum</span><span class=\"o\">;</span>\n\n<span class=\"kd\">public</span> <span class=\"nf\">NumArray</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">];</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n        <span class=\"n\">sum</span><span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">sum</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">+</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">];</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">sumRange</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">sum</span><span class=\"o\">[</span><span class=\"n\">j</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"o\">-</span> <span class=\"n\">sum</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">];</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p>Notice in the code above we inserted a dummy 0 as the first element in the <em>sum</em> array. This trick saves us from an extra conditional check in <em>sumRange</em> function.</p> \n  <p><strong>Complexity analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(1)</script> time per query, <script type=\"math/tex; mode=display\">O(n)</script> time pre-computation. Since the cumulative sum is cached, each <em>sumRange</em> query can be calculated in <script type=\"math/tex; mode=display\">O(1)</script> time.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>.</p> </li> \n  </ul> \n </div> \n</div>"
},
{
    "frontend_question_id": 302,
    "article_live": true,
    "article_slug": "smallest-rectangle-enclosing-black-pixels",
    "title": "Smallest Rectangle Enclosing Black Pixels",
    "title_slug": "smallest-rectangle-enclosing-black-pixels",
    "tags": "Binary Search",
    "difficulty": 3,
    "frontend_article_id": 302,
    "article_content": ""
},
{
    "frontend_question_id": 301,
    "article_live": true,
    "article_slug": "remove-invalid-parentheses",
    "title": "Remove Invalid Parentheses",
    "title_slug": "remove-invalid-parentheses",
    "content": "<p>Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.</p>\r\n\r\n<p><strong>Note:</strong>&nbsp;The input string may contain letters other than the parentheses <code>(</code> and <code>)</code>.</p>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> &quot;()())()&quot;\r\n<b>Output:</b> [&quot;()()()&quot;, &quot;(())()&quot;]\r\n</pre>\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> &quot;(a)())()&quot;\r\n<b>Output:</b> [&quot;(a)()()&quot;, &quot;(a())()&quot;]\r\n</pre>\r\n\r\n<p><b>Example 3:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> &quot;)(&quot;\r\n<b>Output: </b>[&quot;&quot;]\r\n</pre>",
    "tags": "Depth-first Search, Breadth-first Search",
    "difficulty": 3,
    "frontend_article_id": 301,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-backtracking\">Approach 1: Backtracking</a></li> \n      <li><a href=\"#approach-2-limited-backtracking\">Approach 2: Limited Backtracking!</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-backtracking\">Approach 1: Backtracking</h4> \n  <p><strong>Intuition</strong></p> \n  <p>For this question, we are given an expression consisting of parentheses and there can be some misplaced or extra brackets in the expression that cause it to be invalid. An expression consisting of parentheses is considered valid only when every closing bracket has a corresponding opening bracket and vice versa.</p> \n  <p>This means if we start looking at each of the bracket from left to right, as soon as we encounter a closing bracket, there should be an unmatched opening bracket available to match it. Otherwise the expression would become invalid. The expression can also become invalid if the number of opening parentheses i.e. <code>(</code> are more than the number of closing parentheses i.e. <code>)</code>.</p> \n  <p>Let us look at an invalid expression and all the possible valid expressions that can be formed from it by removing some of the brackets. There is no restriction on which parentheses we can remove. We simply have to make the expression valid.</p> \n  <blockquote> \n   <p>The only condition is that we should be removing the minimum number of brackets to make an invalid expression, valid. If this condition was not present, we could potentially remove most of the brackets and come down to say 2 brackets in the end which form <code>()</code> and that would be a valid expression.</p> \n  </blockquote> \n  <p></p>\n  <center> \n   <img src=\"../Figures/301/Diag_1.png\" width=\"800\">\n  </center>\n  <p></p> \n  <p>An important thing to observe in the above diagram is that there are multiple ways of reaching the same solution i.e. say the optimal number of parentheses to be removed to make the original expression valid is K. We can remove multiple different sets of K brackets that will eventually give us the same final expression. But, each valid expression should be recorded only once. We have to take care of this in our solution. Note that there are other possible ways of reaching one of the two valid expressions shown above. We have simply shown 3 ways each for the two valid expressions.</p> \n  <p>Coming back to our problem, the question that now arises is, how to decide which of the parentheses to remove?</p> \n  <blockquote> \n   <p>Since we don't know which of the brackets can possibly be removed, we try out all the options!</p> \n  </blockquote> \n  <p>For every bracket we have two choices:</p> \n  <ul> \n   <li>Either it can be considered a part of the final expression OR</li> \n   <li>It can be ignored i.e. we can delete it from our final expression.</li> \n  </ul> \n  <p>Such kind of problems where we have multiple options and we have no strategy or metric of deciding greedily which option to take, we try out all of the options and see which ones lead to an answer. These type of problems are perfect candidates for the programming paradigm, <code>Recursion</code>.</p> \n  <p><strong>Algorithm</strong></p> \n  <ol> \n   <li>Initialize an array that will store all of our valid expressions finally.</li> \n   <li>Start with the leftmost bracket in the given sequence and proceed right in the recursion.</li> \n   <li>The state of recursion is defined by the index which we are currently processing in the original expression. Let this index be represented by the character <code>i</code>. Also, we have two different variables <code>left_count</code> and <code>right_count</code> that represent the number of left and right parentheses we have added to our expression till now. These are the parentheses that were considered.</li> \n   <li>If the current character i.e. <code>S[i]</code> (considering S is the expression string) is neither a closing or an opening parenthesis, then we simply add this character to our final solution string for the current recursion.</li> \n   <li>However, if the current character is either of the two brackets i.e. <code>S[i] == '(' or S[i] == ')'</code>, then we have two options. We can either discard this character by marking it an invalid character or we can consider this bracket to be a part of the final expression.</li> \n   <li>When all of the parentheses in the original expression have been processed, we simply check if the expression represented by <code>expr</code> i.e. the expression formed till now is valid one or not. The way we check if the final expression is valid or not is by looking at the values in <code>left_count</code> and <code>right_count</code>. For an expression to be valid <code>left_count == right_count</code>. If it is indeed valid, then it could be one of our possible solutions.\n    <ul> \n     <li>Even though we have a valid expression, we also need to keep track of the number of removals we did to get this expression. This is done by another variable passed in recursion called <code>rem_count</code>.</li> \n     <li>Once recursion finishes we check if the current value of <code>rem_count</code> is &lt; the least number of steps we took to form a valid expression till now i.e. the global minima. If this is not the case, we don't record the new expression, else we record it.</li> \n    </ul> </li> \n  </ol> \n  <p>One small optimization that we can do from an implementation perspective is introducing some sort of pruning in our algorithm. Right now we simply go till the very end i.e. process all of the parentheses and when we are done processing all of them, we check if the expression we have can be considered or not.</p> \n  <p>We have to wait till the very end to decide if the expression formed in recursion is a valid expression or not. Is there a way for us to cutoff from some of the recursion paths early on because they wouldn't lead to a solution? The answer to this is Yes! The optimization is based on the following idea.</p> \n  <p>For a left bracket encountered during recursion, if we decide to consider it, then it may or may not lead to an invalid final expression. It may lead to an invalid expression eventually if there are no matching closing bracket available afterwards. But, we don't know for sure if this will happen or not.</p> \n  <blockquote> \n   <p>However, for a closing bracket, if we decide to keep it as a part of our final expression (remember for every bracket we have two options, either to keep it or to remove it and recurse further) and there is no corresponding opening bracket to match it in the expression till now, then it will definitely lead to an invalid expression no matter what we do afterwards.</p> \n  </blockquote> \n  <p>e.g.</p> \n  <pre>( (  ) ) )\n</pre> \n  <p>In this case the third closing bracket will make the expression invalid. No matter what comes afterwards, this will give us an invalid expression and if such a thing happens, we shouldn't recurse further and simply prune the recursion tree.</p> \n  <p>That is why, in addition to having the index in the original string/expression which we are currently processing and the expression string formed till now, we also keep track of the number of left and right parentheses. Whenever we keep a left parenthesis in the expression, we increment its counter. For a right parenthesis, we check if <code>right_count &lt; left_count</code>. If this is the case then only we consider that right parenthesis and recurse further. Otherwise we don't as we know it will make the expression invalid. This simple optimization saves a lot of runtime.</p> \n  <p>Now, let us look at the implementation for this algorithm.</p> \n  <iframe src=\"https://leetcode.com/playground/CqP9Vt73/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"CqP9Vt73\"></iframe> \n  <p><strong>Complexity analysis</strong></p> \n  <ul> \n   <li>Time Complexity : <script type=\"math/tex; mode=display\">O(2^N)</script> since in the worst case we will have only left parentheses in the expression and for every bracket we will have two options i.e. whether to remove it or consider it. Considering that the expression has <script type=\"math/tex; mode=display\">N</script> parentheses, the time complexity will be <script type=\"math/tex; mode=display\">O(2^N)</script>.</li> \n   <li>Space Complexity : <script type=\"math/tex; mode=display\">O(N)</script> because we are resorting to a recursive solution and for a recursive solution there is always stack space used as internal function states are saved onto a stack during recursion. The maximum depth of recursion decides the stack space used. Since we process one character at a time and the base case for the recursion is when we have processed all of the characters of the expression string, the size of the stack would be <script type=\"math/tex; mode=display\">O(N)</script>. Note that we are not considering the space required to store the valid expressions. We only count the intermediate space here. <br> <br></li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-limited-backtracking\">Approach 2: Limited Backtracking!</h4> \n  <p>Although the previous solution does get accepted on the platform, it is a very inefficient solution because we try removing each and every possible parentheses from the expression and in the end we check two things:</p> \n  <ol> \n   <li>if the expression is valid or not</li> \n   <li>if the total number of removed parentheses removed in the current recursion is less than the global minimum till now or not.</li> \n  </ol> \n  <p>We cannot determine which of the parentheses are misplaced because, as the problem statement puts across, we can remove multiple combinations of parentheses and end up with a valid expression. This means there can be multiple valid expressions from a single invalid expression and we have to find all of them.</p> \n  <blockquote> \n   <p>The one thing all these valid expressions have in common is that they will all be of the same length i.e. as compared to the original expression, all of these expressions will have the same number of characters removed.</p> \n  </blockquote> \n  <p>What if we could determine this count?</p> \n  <p>What if in addition to determining this count of characters to be removed, we could also determine the number of left parentheses and number of right parentheses to be removed from the original expression to get <strong>any</strong> valid expression?</p> \n  <p>This would cut down the computations immensely and the runtime would plummet as a result. The reason for this is, if we knew how many left and right parentheses are to be removed from the original expression to get a valid expression, we would cut down on so many unwanted recursive calls.</p> \n  <p>Imagine the original expression to be 1000 characters with only 3 misplaced <code>(</code> parentheses and 2 misplaced <code>)</code> parentheses. In our previous solution we would end up trying to remove each one of left and right parentheses and try to reach a valid expression in the end whereas we should only be trying out removing 3 <code>(</code> brackets and 2 <code>)</code> brackets.</p> \n  <blockquote> \n   <p>This is the exact number of <code>(</code> and <code>)</code> that have to be removed to get a valid expression. No more, no less.</p> \n  </blockquote> \n  <p>Let us look at how we can find out the number of misplaced left and right parentheses in a given expression first and then we will slightly modify our original algorithm to incorporate these counts as well.</p> \n  <ol> \n   <li>We process the expression one bracket at a time starting from the left.</li> \n   <li>Suppose we encounter an opening bracket i.e. <code>(</code>, it may or may not lead to an invalid expression because there can be a matching ending bracket somewhere in the remaining part of the expression. Here, we simply increment the counter keeping track of left parentheses till now. <code>left += 1</code></li> \n   <li>If we encounter a closing bracket, this has two meanings:\n    <ul> \n     <li>Either there was no matching opening bracket for this closing bracket and in that case we have an invalid expression. This is the case when <code>left == 0</code> i.e. when there are no unmatched left brackets available. In such a case we increment another counter say <code>right += 1</code> to represent misplaced right parentheses.</li> \n     <li>Or, we had some unmatched opening bracket available to match this closing bracket. This is the case when <code>left &gt; 0</code>. In this case we simply decrement the left counter we had i.e. <code>left -= 1</code></li> \n    </ul> </li> \n   <li>Continue processing the string until all parentheses have been processed.</li> \n   <li>In the end the values of <code>left</code> and <code>right</code> would tell us the number of unmatched <code>(</code> and <code>)</code> parentheses respectively.</li> \n  </ol> \n  <p>Now that we have these two values available that tell us the total number of left i.e. <code>(</code> and right i.e. <code>)</code> parentheses that have to be removed to make the invalid expression valid, we will modify our original algorithm discussed in the previous session to avoid unwanted recursions.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>The overall algorithm remains exactly the same as before. The changes that we will incorporate are listed below:</p> \n  <ul> \n   <li>The state of the recursion is now defined by five different variables:\n    <ol> \n     <li><code>index</code> which represents the current character that we have to process in the original string.</li> \n     <li><code>left_count</code> which represents the number of left parentheses that have been added to the expression we are building.</li> \n     <li><code>right_count</code> which represents the number of right parentheses that have been added to the expression we are building.</li> \n     <li><code>left_rem</code> is the number of left parentheses that remain to be removed.</li> \n     <li><code>right_rem</code> represents the number of right parentheses that remain to be removed. Overall, for the final expression to be valid, <code>left_rem == 0</code> and <code>right_rem == 0</code>.</li> \n    </ol> </li> \n   <li>When we decide to not consider a parenthesis i.e. delete a parenthesis, be it a left or a right parentheses, we have to consider their corresponding remaining counts as well. This means that we can only discard a left parentheses if <code>left_rem &gt; 0</code> and similarly for the right one we will check for <code>right_rem &gt; 0</code>.</li> \n   <li>There are no changes to checks for <strong>considering</strong> a parenthesis. Only the conditions change for <strong>discarding</strong> a parenthesis.</li> \n   <li>Condition for an expression being valid in the base case would now become <code>left_rem == 0 and right_rem == 0</code>. Note that we don't have to check if <code>left_count == right_count</code> anymore because in the case of a valid expression, we would have removed all the misplaced or invalid parenthesis by the time the recursion ends. So, the only check we need if <code>left_rem == 0 and right_rem == 0</code>.</li> \n  </ul> \n  <blockquote> \n   <p>The most important thing here is that we have completely gotten rid of checking if the number of parentheses removed is lesser than the current minimum or not. The reason for this is we always remove the same number of parentheses as defined by <code>left_rem + right_rem</code> at the start of recursion.</p> \n  </blockquote> \n  <p>Now let us look at the implementation for this modified version of algorithm.</p> \n  <iframe src=\"https://leetcode.com/playground/YQCnqBTg/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"YQCnqBTg\"></iframe> \n  <p><strong>Complexity analysis</strong></p> \n  <ul> \n   <li>Time Complexity : The optimization that we have performed is simply a better form of pruning. Pruning here is something that will vary from one test case to another. In the worst case, we can have something like <code>(((((((((</code> and the <code>left_rem = len(S)</code> and in such a case we can discard all of the characters because all are misplaced. So, in the worst case we <strong>still</strong> have 2 options per parenthesis and that gives us a complexity of <script type=\"math/tex; mode=display\">O(2^N)</script>.</li> \n   <li>Space Complexity : The space complexity remains the same i.e. <script type=\"math/tex; mode=display\">O(N)</script> as previous solution. We have to go to a maximum recursion depth of <script type=\"math/tex; mode=display\">N</script> before hitting the base case. Note that we are not considering the space required to store the valid expressions. We only count the intermediate space here.</li> \n  </ul> \n  <p><br> <br></p> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/sachinmalhotra1993\">@sachinmalhotra1993</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 300,
    "article_live": true,
    "article_slug": "longest-increasing-subsequence",
    "title": "Longest Increasing Subsequence",
    "title_slug": "longest-increasing-subsequence",
    "content": "<p>Given an unsorted array of integers, find the length of longest increasing subsequence.</p>\r\n\r\n<p><b>Example:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> <code>[10,9,2,5,3,7,101,18]\r\n</code><b>Output: </b>4 \r\n<strong>Explanation: </strong>The longest increasing subsequence is <code>[2,3,7,101]</code>, therefore the length is <code>4</code>. </pre>\r\n\r\n<p><strong>Note: </strong></p>\r\n\r\n<ul>\r\n\t<li>There may be more than one LIS combination, it is only necessary for you to return the length.</li>\r\n\t<li>Your algorithm should run in O(<i>n<sup>2</sup></i>) complexity.</li>\r\n</ul>\r\n\r\n<p><b>Follow up:</b> Could you improve it to O(<i>n</i> log <i>n</i>) time complexity?</p>\r\n",
    "tags": "Binary Search, Dynamic Programming",
    "difficulty": 2,
    "frontend_article_id": 300,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-recursion-with-memorization-memory-limit-exceeded\">Approach #2 Recursion with memorization [Memory Limit Exceeded]</a></li> \n      <li><a href=\"#approach-3-dynamic-programming-accepted\">Approach #3 Dynamic Programming [Accepted]</a></li> \n      <li><a href=\"#approach-4-dynamic-programming-with-binary-searchaccepted\">Approach #4 Dynamic Programming with Binary Search[Accepted]:</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>The simplest approach is to try to find all increasing subsequences and then returning the maximum length of longest increasing subsequence. In order to do this, we make use of a recursive function <script type=\"math/tex; mode=display\">lengthofLIS</script> which returns the length of the LIS possible from the current element(corresponding to <script type=\"math/tex; mode=display\">curpos</script>) onwards(including the current element). Inside each function call, we consider two cases:</p> \n  <ol> \n   <li> <p>The current element is larger than the previous element included in the LIS. In this case, we can include the current element in the LIS. Thus, we find out the length of the LIS obtained by including it. Further, we also find out the length of LIS possible by not including the current element in the LIS. The value returned by the current function call is, thus, the maximum out of the two lengths.</p> </li> \n   <li> <p>The current element is smaller than the previous element included in the LIS. In this case, we can't include the current element in the LIS. Thus, we find out only the length of the LIS possible by not including the current element in the LIS, which is returned by the current function call.</p> </li> \n  </ol> \n  <iframe src=\"https://leetcode.com/playground/JJmfKUWT/shared\" frameborder=\"0\" name=\"JJmfKUWT\" width=\"100%\" height=\"394\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(2^n)</script>. Size of recursion tree will be <script type=\"math/tex; mode=display\">2^n</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n^2)</script>. <script type=\"math/tex; mode=display\">memo</script> array of size <script type=\"math/tex; mode=display\">n * n</script> is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-recursion-with-memorization-memory-limit-exceeded\">Approach #2 Recursion with memorization [Memory Limit Exceeded]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In the previous approach, many recursive calls had to made again and again with the same parameters. This redundancy can be eliminated by storing the results obtained for a particular call in a 2-d memorization array <script type=\"math/tex; mode=display\">memo</script>. <script type=\"math/tex; mode=display\">memo[i][j]</script> represents the length of the LIS possible using <script type=\"math/tex; mode=display\">nums[i]</script> as the previous element considered to be included/not included in the LIS, with <script type=\"math/tex; mode=display\">nums[j]</script> as the current element considered to be included/not included in the LIS. Here, <script type=\"math/tex; mode=display\">nums</script> represents the given array.</p> \n  <iframe src=\"https://leetcode.com/playground/3KbbB2JZ/shared\" frameborder=\"0\" name=\"3KbbB2JZ\" width=\"100%\" height=\"479\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^2)</script>. Size of recursion tree can go upto <script type=\"math/tex; mode=display\">n^2</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n^2)</script>. <script type=\"math/tex; mode=display\">memo</script> array of <script type=\"math/tex; mode=display\">n*n</script> is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-dynamic-programming-accepted\">Approach #3 Dynamic Programming [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>This method relies on the fact that the longest increasing subsequence possible upto the <script type=\"math/tex; mode=display\">i^{th}</script> index in a given array is independent of the elements coming later on in the array. Thus, if we know the length of the LIS upto <script type=\"math/tex; mode=display\">i^{th}</script> index, we can figure out the length of the LIS possible by including the <script type=\"math/tex; mode=display\">(i+1)^{th}</script> element based on the elements with indices <script type=\"math/tex; mode=display\">j</script> such that <script type=\"math/tex; mode=display\">0 \\leq j \\leq (i + 1)</script>.</p> \n  <p>We make use of a <script type=\"math/tex; mode=display\">dp</script> array to store the required data. <script type=\"math/tex; mode=display\">dp[i]</script> represents the length of the longest increasing subsequence possible considering the array elements upto the <script type=\"math/tex; mode=display\">i^{th}</script> index only ,by necessarily including the <script type=\"math/tex; mode=display\">i^{th}</script> element. In order to find out <script type=\"math/tex; mode=display\">dp[i]</script>, we need to try to append the current element(<script type=\"math/tex; mode=display\">nums[i]</script>) in every possible increasing subsequences upto the <script type=\"math/tex; mode=display\">(i-1)^{th}</script> index(including the <script type=\"math/tex; mode=display\">(i-1)^{th}</script> index), such that the new sequence formed by adding the current element is also an increasing subsequence. Thus, we can easily determine <script type=\"math/tex; mode=display\">dp[i]</script> using: </p> \n  <p> <script type=\"math/tex; mode=display\">dp[i] = \\text{max}(dp[j]) + 1, \\forall 0\\leq j < i</script> </p> \n  <p>At the end, the maximum out of all the <script type=\"math/tex; mode=display\">dp[i]</script>'s to determine the final result.</p> \n  <p> <script type=\"math/tex; mode=display\">LIS_{length}= \\text{max}(dp[i]), \\forall 0\\leq i < n</script> </p> \n  <p>The following animation illustrates the method:</p> \n  <!--![LIS](../Figures/300_LIS1.gif)--> \n  <p>!?!../Documents/300_LIS.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/LwPDtrvk/shared\" frameborder=\"0\" name=\"LwPDtrvk\" width=\"100%\" height=\"411\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^2)</script>. Two loops of <script type=\"math/tex; mode=display\">n</script> are there.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. <script type=\"math/tex; mode=display\">dp</script> array of size <script type=\"math/tex; mode=display\">n</script> is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-4-dynamic-programming-with-binary-searchaccepted\">Approach #4 Dynamic Programming with Binary Search[Accepted]:</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In this approach, we scan the array from left to right. We also make use of a <script type=\"math/tex; mode=display\">dp</script> array initialized with all 0's. This <script type=\"math/tex; mode=display\">dp</script> array is meant to store the increasing subsequence formed by including the currently encountered element. While traversing the <script type=\"math/tex; mode=display\">nums</script> array, we keep on filling the <script type=\"math/tex; mode=display\">dp</script> array with the elements encountered so far. For the element corresponding to the <script type=\"math/tex; mode=display\">j^{th}</script> index (<script type=\"math/tex; mode=display\">nums[j]</script>), we determine its correct position in the <script type=\"math/tex; mode=display\">dp</script> array(say <script type=\"math/tex; mode=display\">i^{th}</script> index) by making use of Binary Search(which can be used since the <script type=\"math/tex; mode=display\">dp</script> array is storing increasing subsequence) and also insert it at the correct position. An important point to be noted is that for Binary Search, we consider only that portion of the <script type=\"math/tex; mode=display\">dp</script> array in which we have made the updates by inserting some elements at their correct positions(which remains always sorted). Thus, only the elements upto the <script type=\"math/tex; mode=display\">i^{th}</script> index in the <script type=\"math/tex; mode=display\">dp</script> array can determine the position of the current element in it. Since, the element enters its correct position(<script type=\"math/tex; mode=display\">i</script>) in an ascending order in the <script type=\"math/tex; mode=display\">dp</script> array, the subsequence formed so far in it is surely an increasing subsequence. Whenever this position index <script type=\"math/tex; mode=display\">i</script> becomes equal to the length of the LIS formed so far(<script type=\"math/tex; mode=display\">len</script>), it means, we need to update the <script type=\"math/tex; mode=display\">len</script> as <script type=\"math/tex; mode=display\">len = len + 1</script>.</p> \n  <p>Note: <script type=\"math/tex; mode=display\">dp</script> array does not result in longest increasing subsequence, but length of <script type=\"math/tex; mode=display\">dp</script> array will give you length of LIS.</p> \n  <p>Consider the example:</p> \n  <p>input: [0, 8, 4, 12, 2]</p> \n  <p>dp: [0]</p> \n  <p>dp: [0, 8]</p> \n  <p>dp: [0, 4]</p> \n  <p>dp: [0, 4, 12]</p> \n  <p>dp: [0 , 2, 12] which is not the longest increasing subsequence, but length of <script type=\"math/tex; mode=display\">dp</script> array results in length of Longest Increasing Subsequence.</p> \n  <iframe src=\"https://leetcode.com/playground/aHs6zyFb/shared\" frameborder=\"0\" name=\"aHs6zyFb\" width=\"100%\" height=\"343\"></iframe> \n  <p>Note: Arrays.binarySearch() method returns index of the search key, if it is contained in the array, else it returns (-(insertion point) - 1). The insertion point is the point at which the key would be inserted into the array: the index of the first element greater than the key, or a.length if all elements in the array are less than the specified key.</p> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(nlog(n))</script>. Binary search takes <script type=\"math/tex; mode=display\">log(n)</script> time and it is called <script type=\"math/tex; mode=display\">n</script> times.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. <script type=\"math/tex; mode=display\">dp</script> array of size <script type=\"math/tex; mode=display\">n</script> is used.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 299,
    "article_live": false,
    "title": "Bulls and Cows",
    "title_slug": "bulls-and-cows",
    "content": "<p>You are playing the following <a href=\"https://en.wikipedia.org/wiki/Bulls_and_Cows\" target=\"_blank\">Bulls and Cows</a> game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called &quot;bulls&quot;) and how many digits match the secret number but locate in the wrong position (called &quot;cows&quot;). Your friend will use successive guesses and hints to eventually derive the secret number.</p>\r\n\r\n<p>Write a function to return a hint according to the secret number and friend&#39;s guess, use <code>A</code> to indicate the bulls and <code>B</code> to indicate the cows.&nbsp;</p>\r\n\r\n<p>Please note that both secret number and friend&#39;s guess may contain duplicate digits.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> secret = &quot;1807&quot;, guess = &quot;7810&quot;\r\n\r\n<strong>Output:</strong> &quot;1A3B&quot;\r\n\r\n<strong>Explanation:</strong> <code>1</code><span style=\"font-family: sans-serif, Arial, Verdana, &quot;Trebuchet MS&quot;;\"> bull and </span><code>3</code><span style=\"font-family: sans-serif, Arial, Verdana, &quot;Trebuchet MS&quot;;\"> cows. The bull is </span><code>8</code><span style=\"font-family: sans-serif, Arial, Verdana, &quot;Trebuchet MS&quot;;\">, the cows are </span><code>0</code><span style=\"font-family: sans-serif, Arial, Verdana, &quot;Trebuchet MS&quot;;\">, </span><code>1</code><span style=\"font-family: sans-serif, Arial, Verdana, &quot;Trebuchet MS&quot;;\"> and </span><code>7<font face=\"sans-serif, Arial, Verdana, Trebuchet MS\">.</font></code></pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> secret = &quot;1123&quot;, guess = &quot;0111&quot;\r\n\r\n<strong>Output:</strong> &quot;1A1B&quot;\r\n\r\n<strong>Explanation: </strong>The 1st <code>1 </code><span style=\"font-family: sans-serif, Arial, Verdana, &quot;Trebuchet MS&quot;;\">in friend&#39;s guess is a bull, the 2nd or 3rd </span><code>1</code><span style=\"font-family: sans-serif, Arial, Verdana, &quot;Trebuchet MS&quot;;\"> is a cow</span><span style=\"font-family: sans-serif, Arial, Verdana, &quot;Trebuchet MS&quot;;\">.</span></pre>\r\n\r\n<p><strong>Note: </strong>You may assume that the secret number and your friend&#39;s guess only contain digits, and their lengths are always equal.</p>",
    "tags": "Hash Table",
    "difficulty": 2,
    "frontend_article_id": 299
},
{
    "frontend_question_id": 298,
    "article_live": true,
    "article_slug": "binary-tree-longest-consecutive-sequence",
    "title": "Binary Tree Longest Consecutive Sequence",
    "title_slug": "binary-tree-longest-consecutive-sequence",
    "tags": "Tree",
    "difficulty": 2,
    "frontend_article_id": 298,
    "article_content": ""
},
{
    "frontend_question_id": 297,
    "article_live": true,
    "article_slug": "serialize-and-deserialize-binary-tree",
    "title": "Serialize and Deserialize Binary Tree",
    "title_slug": "serialize-and-deserialize-binary-tree",
    "content": "<p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p>\r\n\r\n<p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>\r\n\r\n<p><strong>Example:&nbsp;</strong></p>\r\n\r\n<pre>\r\nYou may serialize the following tree:\r\n\r\n    1\r\n   / \\\r\n  2   3\r\n     / \\\r\n    4   5\r\n\r\nas <code>&quot;[1,2,3,null,null,4,5]&quot;</code>\r\n</pre>\r\n\r\n<p><strong>Clarification:</strong> The above format is the same as <a href=\"/faq/#binary-tree\">how LeetCode serializes a binary tree</a>. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.</p>\r\n\r\n<p><strong>Note:&nbsp;</strong>Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.</p>\r\n",
    "tags": "Tree, Design",
    "difficulty": 3,
    "frontend_article_id": 297,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-depth-first-search-dfs\">Approach 1: Depth First Search (DFS)</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-depth-first-search-dfs\">Approach 1: Depth First Search (DFS)</h4> \n  <p><strong>Intuition</strong></p> \n  <p></p>\n  <center>\n   <img src=\"../Figures/297_BST.png\" width=\"550px\">\n  </center>\n  <p></p> \n  <p>The <strong>serialization</strong> of a <code>Binary Search Tree</code> is essentially to encode its values and more importantly its structure. One can traverse the tree to accomplish the above task. And it is well know that we have two general strategies to do so:</p> \n  <ul> \n   <li> <p><em>Breadth First Search</em> (<code>BFS</code>)</p> <p>We scan through the tree level by level, following the order of height, from top to bottom. The nodes on higher level would be visited before the ones with lower levels.</p> </li> \n   <li> <p><em>Depth First Search</em> (<code>DFS</code>)</p> <p>In this strategy, we adopt the <code>depth</code> as the priority, so that one would start from a root and reach all the way down to certain leaf, and then back to root to reach another branch.</p> <p>The DFS strategy can further be distinguished as <code>preorder</code>, <code>inorder</code>, and <code>postorder</code> depending on the relative order among the root node, left node and right node.</p> </li> \n  </ul> \n  <p>In this task, however, the <code>DFS</code> strategy is more adapted for our needs, since the linkage among the adjacent nodes is naturally encoded in the order, which is rather helpful for the later task of <strong>deserialization</strong>. </p> \n  <p>Therefore, in this solution, we demonstrate an example with the <code>preorder</code> DFS strategy. One can check out more tutorial about <code>Binary Search Tree</code> on the <a href=\"https://leetcode.com/explore/learn/card/introduction-to-data-structure-binary-search-tree/\">LeetCode Explore</a>.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>First of all, here is the definition of the <code>TreeNode</code> which we would use in the following implementation.</p> \n  <iframe src=\"https://leetcode.com/playground/SxYN955n/shared\" frameborder=\"0\" width=\"100%\" height=\"225\" name=\"SxYN955n\"></iframe> \n  <p>The preorder DFS traverse follows <em>recursively</em> the order of<br> <code>root -&gt; left subtree -&gt; right subtree</code>.</p> \n  <p>As an example, let's serialize the following tree. Note that serialization contains information about the node values as well as the information about the tree structure.</p> \n  <!--![LIS](../Figures/297/297_tr.gif)--> \n  <p>!?!../Documents/297_LIS.json:1000,622!?!</p> \n  <p>We start from the root, node <code>1</code>, the serialization string is <code>1,</code>. Then we jump to its left subtree with the root node <code>2</code>, and the serialization string becomes <code>1,2,</code>. Now starting from node <code>2</code>, we visit its left node <code>3</code> (<code>1,2,3,None,None,</code>) and right node <code>4</code> (<code>1,2,3,None,None,4,None,None</code>) sequentially. Note that <code>None,None,</code> appears for each leaf to mark the absence of left and right child node, this is how we save the tree structure during the serialization. And finally, we get back to the root node <code>1</code> and visit its right subtree which happens to be a leaf node <code>5</code>. Finally, the serialization string is done as <code>1,2,3,None,None,4,None,None,5,None,None,</code>.</p> \n  <iframe src=\"https://leetcode.com/playground/4VwaajsS/shared\" frameborder=\"0\" width=\"100%\" height=\"395\" name=\"4VwaajsS\"></iframe> \n  <p>Now let's deserialize the serialization string constructed above <code>1,2,3,None,None,4,None,None,5,None,None,</code>. It goes along the string, initiate the node value and then calls itself to construct its left and right child nodes. </p> \n  <iframe src=\"https://leetcode.com/playground/C4mD8jDQ/shared\" frameborder=\"0\" width=\"100%\" height=\"446\" name=\"C4mD8jDQ\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : in both serialization and deserialization functions, we visit each node exactly once, thus the time complexity is <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of nodes, <em>i.e.</em> the size of tree. </p> </li> \n   <li> <p>Space complexity : in both serialization and deserialization functions, we keep the entire tree, either at the beginning or at the end, therefore, the space complexity is <script type=\"math/tex; mode=display\">O(N)</script>. </p> </li> \n  </ul> \n  <p>The solutions with BFS or other DFS strategies normally will have the same time and space complexity.</p> \n  <p><strong>Further Space Optimization</strong></p> \n  <p>In the above solution, we store the node value and the references to <code>None</code> child nodes, which means <script type=\"math/tex; mode=display\">N \\cdot V + 2N</script> complexity, where <script type=\"math/tex; mode=display\">V</script> is the size of value. That is called <em>natural serialization</em>, and has was implemented above.</p> \n  <p>The <script type=\"math/tex; mode=display\">N \\cdot V</script> component here is the encoding of values, can't be optimized further, but there is a way to reduce <script type=\"math/tex; mode=display\">2N</script> part which is the encoding of the tree structure.</p> \n  <p>The number of unique binary tree structures that can be constructed using <code>n</code> nodes is <script type=\"math/tex; mode=display\">C(n)</script>, where <script type=\"math/tex; mode=display\">C(n)</script> is the <code>nth</code> Catalan number. Please refer to <a href=\"https://leetcode.com/articles/unique-binary-search-trees/\">this article</a> for more information.</p> \n  <p>There are <script type=\"math/tex; mode=display\">C(n)</script> possible structural configurations of a binary tree with n nodes, so the largest index value that we might need to store is <script type=\"math/tex; mode=display\">C(n) - 1</script>. That means storing the index value could require up to 1 bit for <script type=\"math/tex; mode=display\">n \\leq 2</script>, or <script type=\"math/tex; mode=display\">\\lceil log_2(C(n) - 1) \\rceil</script> bits for <script type=\"math/tex; mode=display\">n > 2</script>.</p> \n  <p>In this way one could reduce the encoding of the tree structure by <script type=\"math/tex; mode=display\">log(N)</script>. More precisely, the <a href=\"https://en.wikipedia.org/wiki/Catalan_number\">Catalan numbers</a> grow as <script type=\"math/tex; mode=display\">C(n) \\sim \\frac{4^n}{n^{3/2}\\sqrt{\\pi}}</script> and hence the theoretical minimum of storage for the tree structure that could be achieved is <script type=\"math/tex; mode=display\">log(C(n)) \\sim 2n - \\frac{3}{2}\\log(n) - \\frac{1}{2}\\log(\\pi)</script> </p> \n  <p>Analysis written by @<a href=\"https://leetcode.com/liaison/\">liaison</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 296,
    "article_live": true,
    "article_slug": "best-meeting-point",
    "title": "Best Meeting Point",
    "title_slug": "best-meeting-point",
    "tags": "Math, Sort",
    "difficulty": 3,
    "frontend_article_id": 296,
    "article_content": ""
},
{
    "frontend_question_id": 295,
    "article_live": true,
    "article_slug": "find-median-from-data-stream",
    "title": "Find Median from Data Stream",
    "title_slug": "find-median-from-data-stream",
    "content": "<p>Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.</p>\r\nFor example,\r\n\r\n<p><code>[2,3,4]</code>, the median is <code>3</code></p>\r\n\r\n<p><code>[2,3]</code>, the median is <code>(2 + 3) / 2 = 2.5</code></p>\r\n\r\n<p>Design a data structure that supports the following two operations:</p>\r\n\r\n<ul>\r\n\t<li>void addNum(int num) - Add a integer number from the data stream to the data structure.</li>\r\n\t<li>double findMedian() - Return the median of all elements so far.</li>\r\n</ul>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\naddNum(1)\r\naddNum(2)\r\nfindMedian() -&gt; 1.5\r\naddNum(3) \r\nfindMedian() -&gt; 2\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Follow up:</strong></p>\r\n\r\n<ol>\r\n\t<li>If all integer numbers from the stream are between 0&nbsp;and 100, how would you optimize it?</li>\r\n\t<li>If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?</li>\r\n</ol>\r\n",
    "tags": "Heap, Design",
    "difficulty": 3,
    "frontend_article_id": 295,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-simple-sorting-time-limit-exceeded\">Approach #1 Simple Sorting [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-insertion-sort-time-limit-exceeded\">Approach #2 Insertion Sort [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-3-two-heaps-accepted\">Approach #3 Two Heaps! [Accepted]</a></li> \n      <li><a href=\"#approach-4-multiset-and-two-pointers-accepted\">Approach #4 Multiset and Two Pointers [Accepted]</a></li> \n      <li><a href=\"#further-thoughts\">Further Thoughts</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-simple-sorting-time-limit-exceeded\">Approach #1 Simple Sorting [Time Limit Exceeded]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Do what the question says.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Store the numbers in a resize-able container. Every time you need to output the median, sort the container and output the median.</p> \n  <iframe src=\"https://leetcode.com/playground/4f383Thu/shared\" frameborder=\"0\" name=\"4f383Thu\" width=\"100%\" height=\"377\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity: <script type=\"math/tex; mode=display\">O(n \\cdot log(n)) + O(1) \\simeq O(n \\cdot log(n))</script>.</p> \n    <ul> \n     <li>Adding a number takes amortized <script type=\"math/tex; mode=display\">O(1)</script> time for a container with an efficient resizing scheme.</li> \n     <li>Finding the median is primarily dependent on the sorting that takes place. This takes <script type=\"math/tex; mode=display\">O(n \\cdot log(n))</script> time for a standard comparative sort.</li> \n    </ul> </li> \n   <li> <p>Space complexity: <script type=\"math/tex; mode=display\">O(n)</script> linear space to hold input in a container. No extra space other than that needed (since sorting can usually be done in-place).</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-insertion-sort-time-limit-exceeded\">Approach #2 Insertion Sort [Time Limit Exceeded]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Keeping our input container always sorted (i.e. maintaining the sorted nature of the container as an <em>invariant</em>).</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Which algorithm allows a number to be added to a sorted list of numbers and yet keeps the entire list sorted? Well, for one, <strong>insertion sort!</strong></p> \n  <p>We assume that the current list is already sorted. When a new number comes, we have to add it to the list while maintaining the sorted nature of the list. This is achieved easily by finding the correct place to insert the incoming number, using a <strong>binary search</strong> (remember, the list is <em>always sorted</em>). Once the position is found, we need to shift all higher elements by one space to make room for the incoming number.</p> \n  <p>This method would work well when the amount of insertion queries is lesser or about the same as the amount of median finding queries.</p> \n  <iframe src=\"https://leetcode.com/playground/k7RdqeEJ/shared\" frameborder=\"0\" name=\"k7RdqeEJ\" width=\"100%\" height=\"394\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity: <script type=\"math/tex; mode=display\">O(n) + O(log(n)) \\approx O(n)</script>.</p> \n    <ul> \n     <li>Binary Search takes <script type=\"math/tex; mode=display\">O(log(n))</script> time to find correct insertion position.</li> \n     <li>Insertion can take up to <script type=\"math/tex; mode=display\">O(n)</script> time since elements have to be shifted inside the container to make room for the new element.</li> \n    </ul> </li> \n  </ul> \n  <blockquote> \n   <p><strong>Pop quiz:</strong> Can we use a <em>linear</em> search instead of a <em>binary</em> search to find insertion position, without incurring any significant runtime penalty?</p> \n  </blockquote> \n  <ul> \n   <li>Space complexity: <script type=\"math/tex; mode=display\">O(n)</script> linear space to hold input in a container.</li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-two-heaps-accepted\">Approach #3 Two Heaps! [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>The above two approaches gave us some valuable insights on how to tackle this problem. Concretely, one can infer two things:</p> \n  <ol> \n   <li>If we could maintain direct access to median elements at all times, then finding the median would take a constant amount of time.</li> \n   <li>If we could find a reasonably fast way of adding numbers to our containers, additional penalties incurred could be lessened.</li> \n  </ol> \n  <p>But perhaps the most important insight, which is not readily observable, is the fact that we <em>only</em> need a consistent way to access the median elements. Keeping the <em>entire</em> input sorted is <strong>not a requirement.</strong></p> \n  <blockquote> \n   <p>Well, if only there were a data structure which could handle our needs.</p> \n  </blockquote> \n  <p>As it turns out there are two data structures for the job:</p> \n  <ul> \n   <li>Heaps (or Priority Queues <sup id=\"fnref:note-1\"><a class=\"footnote-ref\" href=\"#fn:note-1\" rel=\"footnote\">1</a></sup>)</li> \n   <li>Self-balancing Binary Search Trees (we'll talk more about them in <a href=\"#approach-4-multiset-and-two-pointers-accepted\">Approach #4</a>)</li> \n  </ul> \n  <p>Heaps are a natural ingredient for this dish! Adding elements to them take logarithmic order of time. They also give direct access to the maximal/minimal elements in a group.</p> \n  <p>If we could maintain <em>two</em> heaps in the following way:</p> \n  <ul> \n   <li>A max-heap to store the smaller half of the input numbers</li> \n   <li>A min-heap to store the larger half of the input numbers</li> \n  </ul> \n  <p>This gives access to median values in the input: they comprise the top of the heaps!</p> \n  <p><strong>Wait, what? How?</strong></p> \n  <p>If the following conditions are met:</p> \n  <ol> \n   <li>Both the heaps are balanced (or nearly balanced)</li> \n   <li>The max-heap contains all the smaller numbers while the min-heap contains all the larger numbers</li> \n  </ol> \n  <p>then we can say that:</p> \n  <ol> \n   <li>All the numbers in the max-heap are smaller or equal to the top element of the max-heap (let's call it <script type=\"math/tex; mode=display\">x</script>)</li> \n   <li>All the numbers in the min-heap are larger or equal to the top element of the min-heap (let's call it <script type=\"math/tex; mode=display\">y</script>)</li> \n  </ol> \n  <p>Then <script type=\"math/tex; mode=display\">x</script> and/or <script type=\"math/tex; mode=display\">y</script> are smaller than (or equal to) almost half of the elements and larger than (or equal to) the other half. That is <em>the</em> definition of <strong>median</strong> elements.</p> \n  <p>This leads us to a huge point of pain in this approach: <strong>balancing the two heaps!</strong></p> \n  <p><strong>Algorithm</strong></p> \n  <ul> \n   <li> <p>Two priority queues:</p> \n    <ol> \n     <li>A max-heap <code>lo</code> to store the smaller half of the numbers</li> \n     <li>A min-heap <code>hi</code> to store the larger half of the numbers</li> \n    </ol> </li> \n   <li> <p>The max-heap <code>lo</code> is allowed to store, at worst, one more element more than the min-heap <code>hi</code>. Hence if we have processed <script type=\"math/tex; mode=display\">k</script> elements:</p> \n    <ul> \n     <li>If <script type=\"math/tex; mode=display\">k = 2*n + 1 \\quad (\\forall \\, n \\in \\mathbb{Z})</script>, then <code>lo</code> is allowed to hold <script type=\"math/tex; mode=display\">n+1</script> elements, while <code>hi</code> can hold <script type=\"math/tex; mode=display\">n</script> elements.</li> \n     <li>If <script type=\"math/tex; mode=display\">k = 2*n \\quad (\\forall \\, n \\in \\mathbb{Z})</script>, then both heaps are balanced and hold <script type=\"math/tex; mode=display\">n</script> elements each.</li> \n    </ul> <p>This gives us the nice property that when the heaps are perfectly balanced, the median can be derived from the tops of both heaps. Otherwise, the top of the max-heap <code>lo</code> holds the legitimate median.</p> </li> \n   <li> <p>Adding a number <code>num</code>:</p> \n    <ul> \n     <li>Add <code>num</code> to max-heap <code>lo</code>. Since <code>lo</code> received a new element, we must do a balancing step for <code>hi</code>. So remove the largest element from <code>lo</code> and offer it to <code>hi</code>.</li> \n     <li>The min-heap <code>hi</code> might end holding more elements than the max-heap <code>lo</code>, after the previous operation. We fix that by removing the smallest element from <code>hi</code> and offering it to <code>lo</code>.</li> \n    </ul> <p>The above step ensures that we do not disturb the nice little size property we just mentioned.</p> </li> \n  </ul> \n  <p>A little example will clear this up! Say we take input from the stream <code>[41, 35, 62, 5, 97, 108]</code>. The run-though of the algorithm looks like this:</p> \n  <div class=\"codehilite\">\n   <pre><span></span>Adding number <span class=\"m\">41</span>\nMaxHeap lo<span class=\"o\">:</span> <span class=\"p\">[</span><span class=\"m\">41</span><span class=\"p\">]</span>           <span class=\"o\">//</span> MaxHeap stores the largest value at the top <span class=\"p\">(</span>index <span class=\"m\">0</span><span class=\"p\">)</span>\nMinHeap hi<span class=\"o\">:</span> <span class=\"p\">[]</span>             <span class=\"o\">//</span> MinHeap stores the smallest value at the top <span class=\"p\">(</span>index <span class=\"m\">0</span><span class=\"p\">)</span>\nMedian is <span class=\"m\">41</span>\n<span class=\"o\">=======================</span>\nAdding number <span class=\"m\">35</span>\nMaxHeap lo<span class=\"o\">:</span> <span class=\"p\">[</span><span class=\"m\">35</span><span class=\"p\">]</span>\nMinHeap hi<span class=\"o\">:</span> <span class=\"p\">[</span><span class=\"m\">41</span><span class=\"p\">]</span>\nMedian is <span class=\"m\">38</span>\n<span class=\"o\">=======================</span>\nAdding number <span class=\"m\">62</span>\nMaxHeap lo<span class=\"o\">:</span> <span class=\"p\">[</span><span class=\"m\">41</span><span class=\"p\">,</span> <span class=\"m\">35</span><span class=\"p\">]</span>\nMinHeap hi<span class=\"o\">:</span> <span class=\"p\">[</span><span class=\"m\">62</span><span class=\"p\">]</span>\nMedian is <span class=\"m\">41</span>\n<span class=\"o\">=======================</span>\nAdding number <span class=\"m\">4</span>\nMaxHeap lo<span class=\"o\">:</span> <span class=\"p\">[</span><span class=\"m\">35</span><span class=\"p\">,</span> <span class=\"m\">4</span><span class=\"p\">]</span>\nMinHeap hi<span class=\"o\">:</span> <span class=\"p\">[</span><span class=\"m\">41</span><span class=\"p\">,</span> <span class=\"m\">62</span><span class=\"p\">]</span>\nMedian is <span class=\"m\">38</span>\n<span class=\"o\">=======================</span>\nAdding number <span class=\"m\">97</span>\nMaxHeap lo<span class=\"o\">:</span> <span class=\"p\">[</span><span class=\"m\">41</span><span class=\"p\">,</span> <span class=\"m\">35</span><span class=\"p\">,</span> <span class=\"m\">4</span><span class=\"p\">]</span>\nMinHeap hi<span class=\"o\">:</span> <span class=\"p\">[</span><span class=\"m\">62</span><span class=\"p\">,</span> <span class=\"m\">97</span><span class=\"p\">]</span>\nMedian is <span class=\"m\">41</span>\n<span class=\"o\">=======================</span>\nAdding number <span class=\"m\">108</span>\nMaxHeap lo<span class=\"o\">:</span> <span class=\"p\">[</span><span class=\"m\">41</span><span class=\"p\">,</span> <span class=\"m\">35</span><span class=\"p\">,</span> <span class=\"m\">4</span><span class=\"p\">]</span>\nMinHeap hi<span class=\"o\">:</span> <span class=\"p\">[</span><span class=\"m\">62</span><span class=\"p\">,</span> <span class=\"m\">97</span><span class=\"p\">,</span> <span class=\"m\">108</span><span class=\"p\">]</span>\nMedian is <span class=\"m\">51.5</span>\n</pre>\n  </div> \n  <iframe src=\"https://leetcode.com/playground/asbkCdUD/shared\" frameborder=\"0\" name=\"asbkCdUD\" width=\"100%\" height=\"479\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity: <script type=\"math/tex; mode=display\">O(5 * log(n)) + O(1) \\approx O(log(n))</script>.</p> \n    <ul> \n     <li>At worst, there are three heap insertions and two heap deletions from the top. Each of these takes about <script type=\"math/tex; mode=display\">O(log(n))</script> time.</li> \n     <li>Finding the mean takes constant <script type=\"math/tex; mode=display\">O(1)</script> time since the tops of heaps are directly accessible.</li> \n    </ul> </li> \n   <li> <p>Space complexity: <script type=\"math/tex; mode=display\">O(n)</script> linear space to hold input in containers.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-4-multiset-and-two-pointers-accepted\">Approach #4 Multiset and Two Pointers [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Self-balancing Binary Search Trees (like an <a href=\"https://en.wikipedia.org/wiki/AVL_tree\">AVL Tree</a>) have some <em>very</em> interesting properties. They maintain the tree's height to a logarithmic bound. Thus inserting a new element has reasonably good time performance. The median <strong>always</strong> winds up in the root of the tree and/or one of its children. Solving this problem using the same approach as <a href=\"#approach-3-two-heaps-accepted\">Approach #3</a> but using a Self-balancing BST seems like a good choice. Except the fact that implementing such a tree is not trivial and prone to errors.</p> \n  <p><em>Why reinvent the wheel?</em> Most languages implement a <code>multiset</code> class which emulates such behavior. The only problem remains keeping track of the median elements. That is easily solved with <strong>pointers!</strong> <sup id=\"fnref:note-2\"><a class=\"footnote-ref\" href=\"#fn:note-2\" rel=\"footnote\">2</a></sup></p> \n  <p>We maintain two pointers: one for the lower median element and the other for the higher median element. When the total number of elements is odd, both the pointers point to the same median element (since there is only one median in this case). When the number of elements is even, the pointers point to two consecutive elements, whose mean is the representative median of the input.</p> \n  <p><strong>Algorithm</strong></p> \n  <ul> \n   <li> <p>Two iterators/pointers <code>lo_median</code> and <code>hi_median</code>, which iterate over the <code>data</code> multiset.</p> </li> \n   <li> <p>While adding a number <code>num</code>, three cases arise:</p> \n    <ol> \n     <li>The container is currently <strong>empty.</strong> Hence we simply insert <code>num</code> and set both pointers to point to this element.</li> \n     <li> <p>The container currently holds an <strong>odd</strong> number of elements. This means that both the pointers currently point to the same element.</p> \n      <ul> \n       <li>If <code>num</code> is not equal to the current median element, then <code>num</code> goes on either side of it. Whichever side it goes, the size of that part increases and hence the corresponding pointer is updated. For example, if <code>num</code> is less than the median element, the size of the lesser half of input increases by <script type=\"math/tex; mode=display\">1</script> on inserting <code>num</code>. Thus it makes sense to decrement <code>lo_median</code>.</li> \n       <li>If <code>num</code> is equal to the current median element, then the action taken is dependent on how <code>num</code> is inserted into <code>data</code>. <strong>NOTE:</strong> In our given C++ code example, <code>std::multiset::insert</code> inserts an element <em>after</em> all elements of equal value. Hence we increment <code>hi_median</code>.</li> \n      </ul> </li> \n     <li> <p>The container currently holds an <strong>even</strong> number of elements. This means that the pointers currently point to consecutive elements.</p> \n      <ul> \n       <li>If <code>num</code> is a number between both median elements, then <code>num</code> becomes the new median. Both pointers must point to it.</li> \n       <li>Otherwise, <code>num</code> increases the size of either the lesser or higher half of the input. We update the pointers accordingly. It is important to remember that both the pointers <strong><em>must</em></strong> point to the same element now.</li> \n      </ul> </li> \n    </ol> </li> \n   <li> <p>Finding the median is easy! It is simply the <strong>mean</strong> of the elements pointed to by the two pointers <code>lo_median</code> and <code>hi_median</code>.</p> </li> \n  </ul> \n  <iframe src=\"https://leetcode.com/playground/NJ4LimHc/shared\" frameborder=\"0\" name=\"NJ4LimHc\" width=\"100%\" height=\"515\"></iframe> \n  <p>A much shorter (but harder to understand), <strong><em>one</em></strong> <em>pointer</em> version <sup id=\"fnref:note-3\"><a class=\"footnote-ref\" href=\"#fn:note-3\" rel=\"footnote\">3</a></sup> of this solution is given below:</p> \n  <iframe src=\"https://leetcode.com/playground/ZAJQwdQE/shared\" frameborder=\"0\" name=\"ZAJQwdQE\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity: <script type=\"math/tex; mode=display\">O(log(n)) + O(1) \\approx O(log(n))</script>.</p> \n    <ul> \n     <li>Inserting a number takes <script type=\"math/tex; mode=display\">O(log(n))</script> time for a standard <code>multiset</code> scheme. <sup id=\"fnref:note-4\"><a class=\"footnote-ref\" href=\"#fn:note-4\" rel=\"footnote\">4</a></sup></li> \n     <li>Finding the mean takes constant <script type=\"math/tex; mode=display\">O(1)</script> time since the median elements are directly accessible from the two pointers.</li> \n    </ul> </li> \n   <li> <p>Space complexity: <script type=\"math/tex; mode=display\">O(n)</script> linear space to hold input in container.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"further-thoughts\">Further Thoughts</h4> \n  <p>There are so many ways around this problem, that frankly, it is scary. Here are a few more that I came across:</p> \n  <ul> \n   <li> <p><strong>Buckets!</strong> If the numbers in the stream are statistically distributed, then it is easier to keep track of buckets where the median would land, than the entire array. Once you know the correct bucket, simply sort it find the median. If the bucket size is significantly smaller than the size of input processed, this results in huge time saving. <a href=\"https://leetcode.com/mitbbs8080/\">@mitbbs8080</a> has an interesting implementation <a href=\"https://discuss.leetcode.com/post/32180\">here.</a></p> </li> \n   <li> <p><strong>Reservoir Sampling.</strong> Following along the lines of using buckets: if the stream is statistically distributed, you can rely on Reservoir Sampling. Basically, if you could maintain just one good bucket (or <em>reservoir</em>) which could hold a representative sample of the entire stream, you could estimate the median of the entire stream from just this one bucket. This means good time and memory performance. Reservoir Sampling lets you do just that. Determining a <strong>\"good\"</strong> size for your reservoir? <em>Now, that's a whole other challenge.</em> A good explanation for this can be found in <a href=\"https://stackoverflow.com/a/10693752/2844164\">this StackOverflow answer.</a></p> </li> \n   <li> <p><strong>Segment Trees</strong> are a great data structure if you need to do a lot of insertions or a lot of read queries over a limited range of input values. They allow us to do all such operations <em>fast</em> and in roughly the <em>same amount of time</em>, <strong>always.</strong> The only problem is that they are far from trivial to implement. Take a look at my <a href=\"https://leetcode.com/articles/recursive-approach-segment-trees-range-sum-queries-lazy-propagation/\">introductory article on Segment Trees</a> if you are interested.</p> </li> \n   <li> <p><strong>Order Statistic Trees</strong> are data structures which seem to be tailor-made for this problem. They have all the nice features of a BST, but also let you find the <script type=\"math/tex; mode=display\">k^{th}</script> order element stored in the tree. They are a pain to implement and no standard interview would require you to code these up. But they are fun to use if they are already implemented in the language of your choice. <sup id=\"fnref:note-5\"><a class=\"footnote-ref\" href=\"#fn:note-5\" rel=\"footnote\">5</a></sup></p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by <a href=\"https://leetcode.com/babhishek21\">@babhishek21</a>.</p> \n  <div class=\"footnote\"> \n   <hr> \n   <ol> \n    <li id=\"fn:note-1\"> <p>Priority Queues queue out elements based on a predefined priority. They are an abstract concept and can, as such, be implemented in many different ways. Heaps are an efficient way to implement Priority Queues.&nbsp;<a class=\"footnote-backref\" href=\"#fnref:note-1\" rev=\"footnote\" title=\"Jump back to footnote 1 in the text\">↩</a></p> </li> \n    <li id=\"fn:note-2\"> <p>Shout-out to <a href=\"https://leetcode.com/pharese/\">@pharese</a> for this approach.&nbsp;<a class=\"footnote-backref\" href=\"#fnref:note-2\" rev=\"footnote\" title=\"Jump back to footnote 2 in the text\">↩</a></p> </li> \n    <li id=\"fn:note-3\"> <p>Inspired from <a href=\"https://discuss.leetcode.com/topic/74963/o-n-log-k-c-using-multiset-and-updating-middle-iterator/\">this post</a> by <a href=\"https://leetcode.com/stefanpochmann\">@StefanPochmann</a>.&nbsp;<a class=\"footnote-backref\" href=\"#fnref:note-3\" rev=\"footnote\" title=\"Jump back to footnote 3 in the text\">↩</a></p> </li> \n    <li id=\"fn:note-4\"> <p><a href=\"http://en.cppreference.com/w/cpp/container/multiset/insert\">Hinting</a> can reduce that to amortized constant <script type=\"math/tex; mode=display\">O(1)</script> time.&nbsp;<a class=\"footnote-backref\" href=\"#fnref:note-4\" rev=\"footnote\" title=\"Jump back to footnote 4 in the text\">↩</a></p> </li> \n    <li id=\"fn:note-5\"> <p><a href=\"https://gcc.gnu.org/onlinedocs/libstdc++/manual/policy_based_data_structures_test.html\"><strong>GNU</strong> <code>libstdc++</code></a> users are in luck! Take a look at <a href=\"https://stackoverflow.com/a/11228573/2844164\">this StackOverflow answer.</a>&nbsp;<a class=\"footnote-backref\" href=\"#fnref:note-5\" rev=\"footnote\" title=\"Jump back to footnote 5 in the text\">↩</a></p> </li> \n   </ol> \n  </div> \n </div> \n</div>"
},
{
    "frontend_question_id": 294,
    "article_live": false,
    "title": "Flip Game II",
    "title_slug": "flip-game-ii",
    "tags": "Backtracking",
    "difficulty": 2,
    "frontend_article_id": 294
},
{
    "frontend_question_id": 293,
    "article_live": false,
    "title": "Flip Game",
    "title_slug": "flip-game",
    "tags": "String",
    "difficulty": 1,
    "frontend_article_id": 293
},
{
    "frontend_question_id": 292,
    "article_live": true,
    "article_slug": "nim-game",
    "title": "Nim Game",
    "title_slug": "nim-game",
    "content": "<p>You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.</p>\r\n\r\n<p>Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> <code>4</code>\r\n<strong>Output:</strong> false \r\n<strong>Explanation: </strong>If there are 4 stones in the heap, then you will never win the game;\r\n&nbsp;            No matter 1, 2, or 3 stones you remove, the last stone will always be \r\n&nbsp;            removed by your friend.</pre>",
    "tags": "Brainteaser",
    "difficulty": 1,
    "frontend_article_id": 292,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <h2 id=\"solution\">Solution</h2> \n  <p>You can <em>always</em> win a Nim game if the number of stones <script type=\"math/tex; mode=display\">n</script> in the pile is not divisible by <script type=\"math/tex; mode=display\">4</script>.</p> \n  <p><strong>Reasoning</strong></p> \n  <p>Let us think of the small cases. It is clear that if there are only one, two, or three stones in the pile, and it is your turn, you can win the game by taking all of them. Like the problem description says, if there are exactly four stones in the pile, you will lose. Because no matter how many you take, you will leave some stones behind for your opponent to take and win the game. So in order to win, you have to ensure that you never reach the situation where there are exactly four stones on the pile on your turn.</p> \n  <p>Similarly, if there are five, six, or seven stones you can win by taking just enough to leave four stones for your opponent so that they lose. But if there are eight stones on the pile, you will inevitably lose, because regardless whether you pick one, two or three stones from the pile, your opponent can pick three, two or one stone to ensure that, again, four stones will be left to you on your turn.</p> \n  <p>It is obvious that the same pattern repeats itself for <script type=\"math/tex; mode=display\">n=4,8,12,16,\\dots</script>, basically all multiples of <script type=\"math/tex; mode=display\">4</script>.</p> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">canWinNim</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">%</span> <span class=\"mi\">4</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span><span class=\"o\">);</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <p>Time complexity is <script type=\"math/tex; mode=display\">O(1)</script>, since only one check is performed. No additional space is used, so space complexity is also <script type=\"math/tex; mode=display\">O(1)</script>.</p> \n  <p><strong>References</strong></p> \n  <p><a href=\"https://www.cs.umd.edu/~gordon/ysp/nim.pdf\">Lecture on Nim Games</a> from University of Maryland: MATH 199: Math, Game Theory and the Theory of Games, Summer 2006.</p> \n  <p>Analysis written by: @noran</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 291,
    "article_live": false,
    "title": "Word Pattern II",
    "title_slug": "word-pattern-ii",
    "tags": "Backtracking",
    "difficulty": 3,
    "frontend_article_id": 291
},
{
    "frontend_question_id": 290,
    "article_live": false,
    "title": "Word Pattern",
    "title_slug": "word-pattern",
    "content": "<p>Given a <code>pattern</code> and a string <code>str</code>, find if <code>str</code> follows the same pattern.</p>\r\n\r\n<p>Here <b>follow</b> means a full match, such that there is a bijection between a letter in <code>pattern</code> and a <b>non-empty</b> word in <code>str</code>.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> pattern = <code>&quot;abba&quot;</code>, str = <code>&quot;dog cat cat dog&quot;</code>\r\n<strong>Output:</strong> true</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>pattern = <code>&quot;abba&quot;</code>, str = <code>&quot;dog cat cat fish&quot;</code>\r\n<strong>Output:</strong> false</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> pattern = <code>&quot;aaaa&quot;</code>, str = <code>&quot;dog cat cat dog&quot;</code>\r\n<strong>Output:</strong> false</pre>\r\n\r\n<p><strong>Example 4:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> pattern = <code>&quot;abba&quot;</code>, str = <code>&quot;dog dog dog dog&quot;</code>\r\n<strong>Output:</strong> false</pre>\r\n\r\n<p><b>Notes:</b><br />\r\nYou may assume <code>pattern</code> contains only lowercase letters, and <code>str</code> contains lowercase letters separated by a single space.</p>",
    "tags": "Hash Table",
    "difficulty": 1,
    "frontend_article_id": 290
},
{
    "frontend_question_id": 289,
    "article_live": false,
    "title": "Game of Life",
    "title_slug": "game-of-life",
    "content": "<p>According to the <a href=\"https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\" target=\"_blank\">Wikipedia&#39;s article</a>: &quot;The <b>Game of Life</b>, also known simply as <b>Life</b>, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.&quot;</p>\r\n\r\n<p>Given a <i>board</i> with <i>m</i> by <i>n</i> cells, each cell has an initial state <i>live</i> (1) or <i>dead</i> (0). Each cell interacts with its <a href=\"https://en.wikipedia.org/wiki/Moore_neighborhood\" target=\"_blank\">eight neighbors</a> (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):</p>\r\n\r\n<ol>\r\n\t<li>Any live cell with fewer than two live neighbors dies, as if caused by under-population.</li>\r\n\t<li>Any live cell with two or three live neighbors lives on to the next generation.</li>\r\n\t<li>Any live cell with more than three live neighbors dies, as if by over-population..</li>\r\n\t<li>Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.</li>\r\n</ol>\r\n\r\n<p>Write a function to compute the next state (after one update) of the board given its current state.&nbsp;<span>The next state is created by applying the above rules simultaneously to every cell in the current state, where&nbsp;births and deaths occur simultaneously.</span></p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: \r\n</strong><span id=\"example-input-1-1\">[\r\n&nbsp; [0,1,0],\r\n&nbsp; [0,0,1],\r\n&nbsp; [1,1,1],\r\n&nbsp; [0,0,0]\r\n]</span>\r\n<strong>Output: \r\n</strong><span id=\"example-output-1\">[\r\n&nbsp; [0,0,0],\r\n&nbsp; [1,0,1],\r\n&nbsp; [0,1,1],\r\n&nbsp; [0,1,0]\r\n]</span>\r\n</pre>\r\n\r\n<p><b>Follow up</b>:</p>\r\n\r\n<ol>\r\n\t<li>Could you solve it in-place? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells.</li>\r\n\t<li>In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?</li>\r\n</ol>\r\n",
    "tags": "Array",
    "difficulty": 2,
    "frontend_article_id": 289
},
{
    "frontend_question_id": 288,
    "article_live": true,
    "article_slug": "unique-word-abbreviation",
    "title": "Unique Word Abbreviation",
    "title_slug": "unique-word-abbreviation",
    "tags": "Hash Table, Design",
    "difficulty": 2,
    "frontend_article_id": 288,
    "article_content": ""
},
{
    "frontend_question_id": 287,
    "article_live": true,
    "article_slug": "find-the-duplicate-number",
    "title": "Find the Duplicate Number",
    "title_slug": "find-the-duplicate-number",
    "content": "<p>Given an array <i>nums</i> containing <i>n</i> + 1 integers where each integer is between 1 and <i>n</i> (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> <code>[1,3,4,2,2]</code>\r\n<b>Output:</b> 2\r\n</pre>\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> [3,1,3,4,2]\r\n<b>Output:</b> 3</pre>\r\n\r\n<p><b>Note:</b></p>\r\n\r\n<ol>\r\n\t<li>You <b>must not</b> modify the array (assume the array is read only).</li>\r\n\t<li>You must use only constant, <i>O</i>(1) extra space.</li>\r\n\t<li>Your runtime complexity should be less than <em>O</em>(<em>n</em><sup>2</sup>).</li>\r\n\t<li>There is only one duplicate number in the array, but it could be repeated more than once.</li>\r\n</ol>\r\n",
    "tags": "Array, Two Pointers, Binary Search",
    "difficulty": 2,
    "frontend_article_id": 287,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#note\">Note</a></li> \n    <li><a href=\"#proof\">Proof</a></li> \n    <li><a href=\"#approach-1-sorting-accepted\">Approach #1 Sorting [Accepted]</a></li> \n    <li><a href=\"#approach-2-set-accepted\">Approach #2 Set [Accepted]</a></li> \n    <li><a href=\"#approach-3-floyds-tortoise-and-hare-cycle-detection-accepted\">Approach #3 Floyd's Tortoise and Hare (Cycle Detection) [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"note\">Note</h4> \n  <p>The first two approaches mentioned do not satisfy the constraints given in the prompt, but they are solutions that you might be likely to come up with during a technical interview. As an interviewer, I personally would <em>not</em> expect someone to come up with the cycle detection solution unless they have heard it before.</p> \n  <h4 id=\"proof\">Proof</h4> \n  <p>Proving that at least one duplicate must exist in <code>nums</code> is simple application of the <a href=\"https://en.wikipedia.org/wiki/Pigeonhole_principle\">pigeonhole principle</a>. Here, each number in <code>nums</code> is a \"pigeon\" and each distinct number that can appear in <code>nums</code> is a \"pigeonhole\". Because there are <script type=\"math/tex; mode=display\">n+1</script> numbers are <script type=\"math/tex; mode=display\">n</script> distinct possible numbers, the pigeonhole principle implies that at least one of the numbers is duplicated.</p> \n  <h4 id=\"approach-1-sorting-accepted\">Approach #1 Sorting [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>If the numbers are sorted, then any duplicate numbers will be adjacent in the sorted array.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Given the intuition, the algorithm follows fairly simply. First, we sort the array, and then we compare each element to the previous element. Because there is exactly one duplicated element in the array, we know that the array is of at least length 2, and we can return the duplicate element as soon as we find it.</p> \n  <iframe src=\"https://leetcode.com/playground/bQGYqfgj/shared\" frameborder=\"0\" width=\"100%\" height=\"259\" name=\"bQGYqfgj\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(nlgn)</script> </p> <p>The <code>sort</code> invocation costs <script type=\"math/tex; mode=display\">O(nlgn)</script> time in Python and Java, so it dominates the subsequent linear scan.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script> (or <script type=\"math/tex; mode=display\">O(n)</script>)</p> <p>Here, we sort <code>nums</code> in place, so the memory footprint is constant. If we cannot modify the input array, then we must allocate linear space for a copy of <code>nums</code> and sort that instead.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-set-accepted\">Approach #2 Set [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>If we store each element as we iterate over the array, we can simply check each element as we iterate over the array.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>In order to achieve linear time complexity, we need to be able to insert elements into a data structure (and look them up) in constant time. A <code>Set</code> satisfies these constraints nicely, so we iterate over the array and insert each element into <code>seen</code>. Before inserting it, we check whether it is already there. If it is, then we found our duplicate, so we return it.</p> \n  <iframe src=\"https://leetcode.com/playground/jP4YUkB7/shared\" frameborder=\"0\" width=\"100%\" height=\"276\" name=\"jP4YUkB7\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script> </p> <p><code>Set</code> in both Python and Java rely on underlying hash tables, so insertion and lookup have amortized constant time complexities. The algorithm is therefore linear, as it consists of a <code>for</code> loop that performs constant work <script type=\"math/tex; mode=display\">n</script> times.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script> </p> <p>In the worst case, the duplicate element appears twice, with one of its appearances at array index <script type=\"math/tex; mode=display\">n-1</script>. In this case, <code>seen</code> will contain <script type=\"math/tex; mode=display\">n-1</script> distinct values, and will therefore occupy <script type=\"math/tex; mode=display\">O(n)</script> space.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-floyds-tortoise-and-hare-cycle-detection-accepted\">Approach #3 Floyd's Tortoise and Hare (Cycle Detection) [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>If we interpret <code>nums</code> such that for each pair of index <script type=\"math/tex; mode=display\">i</script> and value <script type=\"math/tex; mode=display\">v_i</script>, the \"next\" value <script type=\"math/tex; mode=display\">v_j</script> is at index <script type=\"math/tex; mode=display\">v_i</script>, we can reduce this problem to cycle detection. See the solution to <a href=\"https://leetcode.com/problems/linked-list-cycle-ii/solution/\">Linked List Cycle II</a> for more details.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>First off, we can easily show that the constraints of the problem imply that a cycle <em>must</em> exist. Because each number in <code>nums</code> is between <script type=\"math/tex; mode=display\">1</script> and <script type=\"math/tex; mode=display\">n</script>, it will necessarily point to an index that exists. Therefore, the list can be traversed infinitely, which implies that there is a cycle. Additionally, because <script type=\"math/tex; mode=display\">0</script> cannot appear as a value in <code>nums</code>, <code>nums[0]</code> cannot be part of the cycle. Therefore, traversing the array in this manner from <code>nums[0]</code> is equivalent to traversing a cyclic linked list. Given this, the problem can be solved just like <a href=\"https://leetcode.com/problems/linked-list-cycle-ii/\">Linked List Cycle II</a>.</p> \n  <p>To see the algorithm in action, check out the animation below:</p> \n  <p>!?!../Documents/287_Find_the_Duplicate_Number.json:1280,720!?!</p> \n  <iframe src=\"https://leetcode.com/playground/RMBz6AQR/shared\" frameborder=\"0\" width=\"100%\" height=\"412\" name=\"RMBz6AQR\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script> </p> <p>For detailed analysis, refer to <a href=\"https://leetcode.com/problems/linked-list-cycle-ii/solution/#approach-2-floyds-tortoise-and-hare-accepted\">Linked List Cycle II</a>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script> </p> <p>For detailed analysis, refer to <a href=\"https://leetcode.com/problems/linked-list-cycle-ii/solution/#approach-2-floyds-tortoise-and-hare-accepted\">Linked List Cycle II</a>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis and solutions written by: <a href=\"https://leetcode.com/emptyset\">@emptyset</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 286,
    "article_live": true,
    "article_slug": "walls-and-gates",
    "title": "Walls and Gates",
    "title_slug": "walls-and-gates",
    "tags": "Breadth-first Search",
    "difficulty": 2,
    "frontend_article_id": 286,
    "article_content": ""
},
{
    "frontend_question_id": 285,
    "article_live": false,
    "title": "Inorder Successor in BST",
    "title_slug": "inorder-successor-in-bst",
    "tags": "Tree",
    "difficulty": 2,
    "frontend_article_id": 285
},
{
    "frontend_question_id": 284,
    "article_live": false,
    "title": "Peeking Iterator",
    "title_slug": "peeking-iterator",
    "content": "<p>Given an Iterator class interface with methods: <code>next()</code> and <code>hasNext()</code>, design and implement a PeekingIterator that support the <code>peek()</code> operation -- it essentially peek() at the element that will be returned by the next call to next().</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\nAssume that the iterator is initialized to the beginning of the list: <strong><code>[1,2,3]</code></strong>.\r\n\r\nCall <strong><code>next()</code></strong> gets you <strong>1</strong>, the first element in the list.\r\nNow you call <strong><code>peek()</code></strong> and it returns <strong>2</strong>, the next element. Calling <strong><code>next()</code></strong> after that <i><b>still</b></i> return <strong>2</strong>. \r\nYou call <strong><code>next()</code></strong> the final time and it returns <strong>3</strong>, the last element. \r\nCalling <strong><code>hasNext()</code></strong> after that should return <strong>false</strong>.\r\n</pre>\r\n\r\n<p><b>Follow up</b>: How would you extend your design to be generic and work with all types, not just integer?</p>\r\n",
    "tags": "Design",
    "difficulty": 2,
    "frontend_article_id": 284
},
{
    "frontend_question_id": 283,
    "article_live": true,
    "article_slug": "move-zeroes",
    "title": "Move Zeroes",
    "title_slug": "move-zeroes",
    "content": "<p>Given an array <code>nums</code>, write a function to move all <code>0</code>&#39;s to the end of it while maintaining the relative order of the non-zero elements.</p>\r\n\r\n<p><b>Example:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> <code>[0,1,0,3,12]</code>\r\n<b>Output:</b> <code>[1,3,12,0,0]</code></pre>\r\n\r\n<p><b>Note</b>:</p>\r\n\r\n<ol>\r\n\t<li>You must do this <b>in-place</b> without making a copy of the array.</li>\r\n\t<li>Minimize the total number of operations.</li>\r\n</ol>",
    "tags": "Array, Two Pointers",
    "difficulty": 1,
    "frontend_article_id": 283,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-space-sub-optimal-accepted\">Approach #1 (Space Sub-Optimal) [Accepted]</a></li> \n      <li><a href=\"#approach-2-space-optimal-operation-sub-optimal-accepted\">Approach #2 (Space Optimal, Operation Sub-Optimal) [Accepted]</a></li> \n      <li><a href=\"#approach-3-optimal-accepted\">Approach #3 (Optimal) [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <p>This question comes under a broad category of \"Array Transformation\". This category is the meat of tech interviews. Mostly because arrays are such a simple and easy to use data structure. Traversal or representation doesn't require any boilerplate code and most of your code will look like the Pseudocode itself.</p> \n  <p>The 2 requirements of the question are:</p> \n  <ol> \n   <li> <p>Move all the 0's to the end of array.</p> </li> \n   <li> <p>All the non-zero elements must retain their original order.</p> </li> \n  </ol> \n  <p>It's good to realize here that both the requirements are mutually exclusive, i.e., you can solve the individual sub-problems and then combine them for the final solution.</p> \n  <h4 id=\"approach-1-space-sub-optimal-accepted\">Approach #1 (Space Sub-Optimal) [Accepted]</h4> \n  <p><strong>C++</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kt\">void</span> <span class=\"nf\">moveZeroes</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">nums</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">();</span>\n\n    <span class=\"c1\">// Count the zeroes</span>\n    <span class=\"kt\">int</span> <span class=\"n\">numZeroes</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">n</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">numZeroes</span> <span class=\"o\">+=</span> <span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"c1\">// Make all the non-zero elements retain their original order.</span>\n    <span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">ans</span><span class=\"p\">;</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">n</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"n\">ans</span><span class=\"p\">.</span><span class=\"n\">push_back</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]);</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"c1\">// Move all zeroes to the end</span>\n    <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">numZeroes</span><span class=\"o\">--</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">ans</span><span class=\"p\">.</span><span class=\"n\">push_back</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"c1\">// Combine the result</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">n</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">ans</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">];</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <p>Space Complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Since we are creating the \"ans\" array to store results.</p> \n  <p>Time Complexity: <script type=\"math/tex; mode=display\">O(n)</script>. However, the total number of operations are sub-optimal. We can achieve the same result in less number of operations.</p> \n  <p>If asked in an interview, the above solution would be a good start. You can explain the interviewer(not code) the above and build your base for the next Optimal Solution.</p> \n  <hr> \n  <h4 id=\"approach-2-space-optimal-operation-sub-optimal-accepted\">Approach #2 (Space Optimal, Operation Sub-Optimal) [Accepted]</h4> \n  <p>This approach works the same way as above, i.e. , first fulfills one requirement and then another. The catch? It does it in a clever way. The above problem can also be stated in alternate way, \" Bring all the non 0 elements to the front of array keeping their relative order same\".</p> \n  <p>This is a 2 pointer approach. The fast pointer which is denoted by variable \"cur\" does the job of processing new elements. If the newly found element is not a 0, we record it just after the last found non-0 element. The position of last found non-0 element is denoted by the slow pointer \"lastNonZeroFoundAt\" variable. As we keep finding new non-0 elements, we just overwrite them at the \"lastNonZeroFoundAt + 1\" 'th index. This overwrite will not result in any loss of data because we already processed what was there(if it were non-0,it already is now written at it's corresponding index,or if it were 0 it will be handled later in time).</p> \n  <p>After the \"cur\" index reaches the end of array, we now know that all the non-0 elements have been moved to beginning of array in their original order. Now comes the time to fulfil other requirement, \"Move all 0's to the end\". We now simply need to fill all the indexes after the \"lastNonZeroFoundAt\" index with 0.</p> \n  <p><strong>C++</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kt\">void</span> <span class=\"nf\">moveZeroes</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">nums</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">lastNonZeroFoundAt</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"c1\">// If the current element is not 0, then we need to</span>\n    <span class=\"c1\">// append it just in front of last non 0 element we found. </span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">nums</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">();</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">lastNonZeroFoundAt</span><span class=\"o\">++</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">];</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n    <span class=\"c1\">// After we have finished processing new elements,</span>\n    <span class=\"c1\">// all the non-zero elements are already at beginning of array.</span>\n    <span class=\"c1\">// We just need to fill remaining array with 0's.</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">lastNonZeroFoundAt</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">nums</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">();</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <p>Space Complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Only constant space is used.</p> \n  <p>Time Complexity: <script type=\"math/tex; mode=display\">O(n)</script>. However, the total number of operations are still sub-optimal. The total operations (array writes) that code does is <script type=\"math/tex; mode=display\">n</script> (Total number of elements).</p> \n  <hr> \n  <h4 id=\"approach-3-optimal-accepted\">Approach #3 (Optimal) [Accepted]</h4> \n  <p>The total number of operations of the previous approach is sub-optimal. For example, the array which has all (except last) leading zeroes: [0, 0, 0, ..., 0, 1].How many write operations to the array? For the previous approach, it writes 0's <script type=\"math/tex; mode=display\">n-1</script> times, which is not necessary. We could have instead written just once. How? ..... By only fixing the non-0 element,i.e., 1.</p> \n  <p>The optimal approach is again a subtle extension of above solution. A simple realization is if the current element is non-0, its' correct position can at best be it's current position or a position earlier. If it's the latter one, the current position will be eventually occupied by a non-0 ,or a 0, which lies at a index greater than 'cur' index. We fill the current position by 0 right away,so that unlike the previous solution, we don't need to come back here in next iteration.</p> \n  <p>In other words, the code will maintain the following invariant:</p> \n  <blockquote> \n   <ol> \n    <li> <p>All elements before the slow pointer (lastNonZeroFoundAt) are non-zeroes.</p> </li> \n    <li> <p>All elements between the current and slow pointer are zeroes.</p> </li> \n   </ol> \n  </blockquote> \n  <p>Therefore, when we encounter a non-zero element, we need to swap elements pointed by current and slow pointer, then advance both pointers. If it's zero element, we just advance current pointer.</p> \n  <p>With this invariant in-place, it's easy to see that the algorithm will work.</p> \n  <p><strong>C++</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kt\">void</span> <span class=\"nf\">moveZeroes</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">nums</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">lastNonZeroFoundAt</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">cur</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">cur</span> <span class=\"o\">&lt;</span> <span class=\"n\">nums</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">();</span> <span class=\"n\">cur</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">cur</span><span class=\"p\">]</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"n\">swap</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">lastNonZeroFoundAt</span><span class=\"o\">++</span><span class=\"p\">],</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">cur</span><span class=\"p\">]);</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <p>Space Complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Only constant space is used.</p> \n  <p>Time Complexity: <script type=\"math/tex; mode=display\">O(n)</script>. However, the total number of operations are optimal. The total operations (array writes) that code does is Number of non-0 elements.This gives us a much better best-case (when most of the elements are 0) complexity than last solution. However, the worst-case (when all elements are non-0) complexity for both the algorithms is same.</p> \n  <p>Analysis written by: @spandan.pathak</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 282,
    "article_live": true,
    "article_slug": "expression-add-operators",
    "title": "Expression Add Operators",
    "title_slug": "expression-add-operators",
    "content": "<p>Given a string that contains only digits <code>0-9</code> and a target value, return all possibilities to add <b>binary</b> operators (not unary) <code>+</code>, <code>-</code>, or <code>*</code> between the digits so they evaluate to the target value.</p>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> <code><em>num</em> = </code>&quot;123&quot;, <em>target</em> = 6\r\n<b>Output: </b>[&quot;1+2+3&quot;, &quot;1*2*3&quot;] \r\n</pre>\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> <code><em>num</em> = </code>&quot;232&quot;, <em>target</em> = 8\r\n<b>Output: </b>[&quot;2*3+2&quot;, &quot;2+3*2&quot;]</pre>\r\n\r\n<p><b>Example 3:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> <code><em>num</em> = </code>&quot;105&quot;, <em>target</em> = 5\r\n<b>Output: </b>[&quot;1*0+5&quot;,&quot;10-5&quot;]</pre>\r\n\r\n<p><b>Example 4:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> <code><em>num</em> = </code>&quot;00&quot;, <em>target</em> = 0\r\n<b>Output: </b>[&quot;0+0&quot;, &quot;0-0&quot;, &quot;0*0&quot;]\r\n</pre>\r\n\r\n<p><b>Example 5:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> <code><em>num</em> = </code>&quot;3456237490&quot;, <em>target</em> = 9191\r\n<b>Output: </b>[]\r\n</pre>",
    "tags": "Divide and Conquer",
    "difficulty": 3,
    "frontend_article_id": 282,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-backtracking\">Approach 1: Backtracking</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-backtracking\">Approach 1: Backtracking</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Let us first look at what the question asks us to do before getting at the approach to solve it. So, we are given a string of numbers and 3 different operators:</p> \n  <ul> \n   <li><code>+</code> Addition,</li> \n   <li><code>-</code> Subtraction or</li> \n   <li><code>*</code> Multiplication</li> \n  </ul> \n  <p>We have to find all possible combinations of binary operators between the digits so that the overall value of the resulting expression becomes equal to a given target value. Let us look at a few possibilities of what it means exactly to <em>place the operators between digits</em> so that the question becomes clearer.</p> \n  <p>Let's say we are given the following set of digits <code>\"123456789\"</code> and the target value given to us is <code>45</code>. Let us see some of the possible resulting expressions that we can get by placing the operators in different locations.</p> \n  <pre>1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45\n1 + 2 - 3 + 4 - 5 + 6 - 7 + 8 - 9 = -3\n1 + 2 * 3 - 4 + 5 + 6 - 7 * 8 - 9 = -51\n1 + 2 + 3 + 4 + 5 - 6 * 7 + 8 * 9 = 45\n</pre> \n  <p>These are just 4 of the many resulting expressions that are possible by using the given string of digits and the three operators.</p> \n  <p>By looking at the above examples we can't really figure out any specific pattern among the resulting expressions that tells us which of them will give us the resulting target.</p> \n  <p>Since the question explicitly states that we are given binary operators, this means that each of the operator would require two operands.</p> \n  <blockquote> \n   <p>We can consider each of our digits as an operand.</p> \n  </blockquote> \n  <p>This means that between every pair of digits we can have any of the three operators i.e. <script type=\"math/tex; mode=display\">+</script>, <script type=\"math/tex; mode=display\">-</script> or <script type=\"math/tex; mode=display\">\\times</script>.</p> \n  <p>If you've looked at the question's statement and the examples that are given in the question, you would realize that there is an example where the digits are <code>\"105\"</code> and the target value is <code>5</code>. For this particular example, there are two expressions given to us and they are <code>1*0+5</code> and <code>10-5</code>.</p> \n  <p>The second expression is something that you need to look out for before getting to solve this question because this complicates things a bit.</p> \n  <p>It would have been an easier question to solve if we just had to consider those expressions that simply had <em>digits as operands</em>.</p> \n  <p>But, in this question, we can have all sorts of digits getting together and forming a bigger number that becomes a part of the expression. Let us look at some example expressions for the digits <code>\"123456\"</code> and target <code>30</code>.</p> \n  <pre>1 * 23 - 4 + 5 + 6 = 30\n12 - 3 * 4 + 5 * 6 = 30\n1 - 23 - 4 + 56 = 30\n</pre> \n  <p>So this means that although the number of operators that we have are defined for us i.e. 3 different binary operators, but the number of operands are <strong>not really well defined for us</strong>.</p> \n  <p>This is a big portion of the original problem that we need to address in our solution.</p> \n  <p>Since we are asked to find out all of the valid expressions whose value equals the given target and we don't really know what specific operator between two operands would eventually give us a valid expression,</p> \n  <blockquote> \n   <p>We try out all of the options.</p> \n  </blockquote> \n  <p>This means that once we have defined what the operands are for our given expression, we would have three possible choices of operators between each consecutive pair of operands.</p> \n  <p>From an implementation perspective, what would an operand imply with respect to our original string?</p> \n  <blockquote> \n   <p>An operand would be an integer formed from a substring of our original string.</p> \n  </blockquote> \n  <p>Let's look at two different array partitions for the given string <code>\"123456789\"</code></p> \n  <p></p>\n  <center> \n   <img src=\"../Figures/282/282_Expression_Add_Operators_Diag_1.png\" height=\"300\">\n  </center>\n  <p></p> \n  <p>Since we are required to return all of the valid expressions that evaluate to a given target value, we have to try all possible partitions of the given array thereby considering all of the possible operands that can be formed from the digits.</p> \n  <p>This <code>try out everything</code> hints at a backtracking solution and that is exactly what we are going to look at here.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Let's quickly look at the steps involved in our backtracking algorithm before looking at the pseudo-code.</p> \n  <ol> \n   <li>As discussed above, we have multiple choices of what operators to use and what the operands can be and hence, we have to look at all the possibilities to find <strong><em>all</em></strong> valid expressions.</li> \n   <li>Our recursion step will have an <code>index</code> and the original string of digits as input along with the expression built till now.</li> \n   <li>At every step, we will consider all possible operands starting from <code>index</code> i.e. all substrings <script type=\"math/tex; mode=display\">digits[index : ]</script> and once we fix an operand, we will have three recursive calls wherein we try 3 different operators after this operand.</li> \n   <li>We keep on building our expression like this and eventually, the entire string would be processed. At that time we check if the expression we built till now is a valid expression or not and we record it if it is a valid one.</li> \n  </ol> \n  <pre>1. procedure recurse(digits, index, expression):\n2.     if we have reached the end of the string:\n3.         if the expression evaluates to the target:\n4.             Valid Expression found!\n5.     else:\n6.         for all operands starting from current index:\n7.             try out operator * and recurse\n8.             try out operator + and recurse\n9.             try out operator - and recurse\n</pre> \n  <p>The algorithm now looks pretty straightforward. However, the implementation is something that needs more thought and there are some things that we need to address before actually looking at the implementation.</p> \n  <p>When we are done building an expression out of all of the digits in our original string i.e. the base case, then we check if the expression is a valid expression or not. Right ?</p> \n  <blockquote> \n   <p>How do we actually check if an expression is a valid one or not if all we have is a string representing the expression and not the integer value for the same?</p> \n  </blockquote> \n  <p>Well, one way to go about this is to write a custom <code>eval</code> function that takes in a string and returns the value of that expression. If you do that (Python people can use the inbuilt function <code>eval</code> for this), you will get a TLE i.e. time limit exceeded error.</p> \n  <p><br></p> \n  <p><strong>Can't we keep track of the expression's value on the fly?</strong></p> \n  <p>Well yes. That's the idea we will go with. Instead of just keeping track of what the expression string is, we will also keep track of it's value along the way so that when the recursion hits the base case, we can check in <script type=\"math/tex; mode=display\">O(1)</script> time if the expression's value equals the target value or not.</p> \n  <p>The implementation would have been straightforward had it just been <code>+</code> and <code>-</code> operators involved. This is because both these operators have an equal precedence. That means that we can continue to evaluate the expression on the fly without any problems. Have a look at the following example.</p> \n  <p></p>\n  <center> \n   <img src=\"../Figures/282/282_Expression_Add_Operators_Diag_2.png\" width=\"550\">\n  </center>\n  <p></p> \n  <p>So far so good. Now let us add the <code>*</code> operator as well and see how building the expression on the fly like this breaks.</p> \n  <p></p>\n  <center> \n   <img src=\"../Figures/282/282_Expression_Add_Operators_Diag_3.png\" width=\"550\">\n  </center>\n  <p></p> \n  <p>What we mean by building the expression on the fly is that we keep track of the expression's value till now and we simply consider that value as one of the two operands for our operators. As we can see from the two examples above, this would have worked had it just been <code>+</code> and <code>-</code> operators.</p> \n  <p>But, this approach is bound to fail because the <code>*</code> operator takes precedence over <code>+</code> and <code>-</code>. The <code>*</code> operator would require the <strong><em>actual</em></strong> previous operand in our expression rather than the current value of the expression. i.e. In the above example, the <code>*</code> operator needed <code>2</code> rather than <code>12</code> to get us the correct value of <code>18</code>.</p> \n  <p><br></p> \n  <p><strong>How to handle this?</strong></p> \n  <p>The idea on how to handle this problem springs from the discussion above. We simply need to keep track of the last operand in our expression and how it modified the expression's value overall so that when we consider the <code>*</code> operator, we can <strong>reverse</strong> the effects of the previous operand and consider it for multiplication. Let's take a look at the example that was breaking before.</p> \n  <p></p>\n  <center> \n   <img src=\"../Figures/282/282_Expression_Add_Operators_Diag_4.png\" width=\"550\">\n  </center>\n  <p></p> \n  <p>Now we can look at the actual implementation of this algorithm.</p> \n  <iframe src=\"https://leetcode.com/playground/9UiLcbBm/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"9UiLcbBm\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <p>For the complexity analysis, let us look at what the major sections of the code are.</p> \n  <ol> \n   <li>The first is considering all of the operands. Operands essentially is a substring of the original string. There are <script type=\"math/tex; mode=display\">O(N^2)</script> possible substrings if the string is of length N.</li> \n   <li>Then, for every operand we have <script type=\"math/tex; mode=display\">3</script> different choices of operators that can come after it. These three operators translate to 3 different recursive calls.</li> \n   <li>Another one that doesn't seem like much but will come into the picture for Python and Java is keeping track of the expression till now. i.e. the <code>ops</code> variable in the code above.</li> \n   <li>Finally, the complexity of handling the base case.</li> \n  </ol> \n  <p><strong>Time Complexity</strong></p> \n  <ul> \n   <li>Time complexity for considering all operators for all operands, <script type=\"math/tex; mode=display\">O(3^N)</script>. This is <script type=\"math/tex; mode=display\">O(3^N)</script> because in the worst case scenario, each digit will be an operand on its own for a single expression and between every adjacent pair of digits we have 3 different choices for operators.</li> \n   <li>Also, for each recursive call we have a <code>for</code> loop to consider successive digits as a single operand. That raises the total number of recursive calls to <script type=\"math/tex; mode=display\">O(N \\times 3^N)</script> </li> \n   <li>For the base case we use a <code>StringBuilder::toString</code> operation in Java and <code>.join()</code> operation in Python and that takes <script type=\"math/tex; mode=display\">O(N)</script> time. Here N represents the length of our expression. In the worst case, each digit would be an operand and we would have <script type=\"math/tex; mode=display\">N</script> digits and <script type=\"math/tex; mode=display\">N - 1</script> operators. So <script type=\"math/tex; mode=display\">O(N)</script>. This is for one expression. In the worst case, we can have <script type=\"math/tex; mode=display\">O(N^2 \\times 3^N)</script> valid expressions.</li> \n   <li>Overall time complexity = <script type=\"math/tex; mode=display\">O(N^2 \\times 3^N)</script>.</li> \n  </ul> \n  <p><strong>Space Complexity</strong> :</p> \n  <ul> \n   <li>The answers array that holds all of our expressions is something that is common in both the implementations. The space occupied is equivalent to the number of valid expressions which in the worst case be all of the expressions. Hence, the size of the answer array would essentially be equal to the total recursive calls which as stated before are <script type=\"math/tex; mode=display\">O(N^2 \\times 3^N)</script>.</li> \n   <li>An important thing that we should not ignore about the space complexity is the intermediate data structures we are using in both Python and Java. For every recursive call we create a new <code>StringBuffer</code> in Java or a new <code>list</code> in Python and there will be <script type=\"math/tex; mode=display\">O(N^2 \\times 3^N)</script> recursive calls.</li> \n   <li>Overall space complexity = <script type=\"math/tex; mode=display\">O(N^2 \\times 3^N)</script>.</li> \n  </ul> \n  <p><br> <br></p> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/sachinmalhotra1993\">@sachinmalhotra1993</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 281,
    "article_live": false,
    "title": "Zigzag Iterator",
    "title_slug": "zigzag-iterator",
    "tags": "Design",
    "difficulty": 2,
    "frontend_article_id": 281
},
{
    "frontend_question_id": 280,
    "article_live": true,
    "article_slug": "wiggle-sort",
    "title": "Wiggle Sort",
    "title_slug": "wiggle-sort",
    "tags": "Array, Sort",
    "difficulty": 2,
    "frontend_article_id": 280,
    "article_content": ""
},
{
    "frontend_question_id": 279,
    "article_live": false,
    "title": "Perfect Squares",
    "title_slug": "perfect-squares",
    "content": "<p>Given a positive integer <i>n</i>, find the least number of perfect square numbers (for example, <code>1, 4, 9, 16, ...</code>) which sum to <i>n</i>.</p>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> <i>n</i> = <code>12</code>\r\n<b>Output:</b> 3 \r\n<strong>Explanation: </strong><code>12 = 4 + 4 + 4.</code></pre>\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> <i>n</i> = <code>13</code>\r\n<b>Output:</b> 2\r\n<strong>Explanation: </strong><code>13 = 4 + 9.</code></pre>",
    "tags": "Math, Dynamic Programming, Breadth-first Search",
    "difficulty": 2,
    "frontend_article_id": 279
},
{
    "frontend_question_id": 278,
    "article_live": true,
    "article_slug": "first-bad-version",
    "title": "First Bad Version",
    "title_slug": "first-bad-version",
    "content": "<p>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.</p>\r\n\r\n<p>Suppose you have <code>n</code> versions <code>[1, 2, ..., n]</code> and you want to find out the first bad one, which causes all the following ones to be bad.</p>\r\n\r\n<p>You are given an API <code>bool isBadVersion(version)</code> which will return whether <code>version</code> is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</p>\r\n\r\n<p><b>Example:</b></p>\r\n\r\n<pre>\r\nGiven n = 5, and version = 4 is the first bad version.\r\n\r\n<code>call isBadVersion(3) -&gt; false\r\ncall isBadVersion(5)&nbsp;-&gt; true\r\ncall isBadVersion(4)&nbsp;-&gt; true\r\n\r\nThen 4 is the first bad version.&nbsp;</code>\r\n</pre>",
    "tags": "Binary Search",
    "difficulty": 1,
    "frontend_article_id": 278,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#summary\">Summary</a></li> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-linear-scan-time-limit-exceeded\">Approach #1 (Linear Scan) [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-binary-search-accepted\">Approach #2 (Binary Search) [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"summary\">Summary</h2> \n  <p>This is a very simple problem. There is a subtle trap that you may fall into if you are not careful. Other than that, it is a direct application of a very famous algorithm.</p> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-linear-scan-time-limit-exceeded\">Approach #1 (Linear Scan) [Time Limit Exceeded]</h4> \n  <p>The straight forward way is to brute force it by doing a linear scan.</p> \n  <iframe src=\"https://leetcode.com/playground/Ezb8JYsL/shared\" frameborder=\"0\" name=\"Ezb8JYsL\" width=\"100%\" height=\"190\"></iframe> \n  <p><strong>Complexity analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Assume that <script type=\"math/tex; mode=display\">isBadVersion(version)</script> takes constant time to check if a <em>version</em> is bad. It takes at most <script type=\"math/tex; mode=display\">n - 1</script> checks, therefore the overall time complexity is <script type=\"math/tex; mode=display\">O(n)</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-binary-search-accepted\">Approach #2 (Binary Search) [Accepted]</h4> \n  <p>It is not difficult to see that this could be solved using a classic algorithm - Binary search. Let us see how the search space could be halved each time below.</p> \n  <div class=\"codehilite\">\n   <pre><span></span>Scenario #1: isBadVersion(mid) =&gt; false\n\n 1 2 3 4 5 6 7 8 9\n G G G G G G B B B       G = Good, B = Bad\n |       |       |\nleft    mid    right\n</pre>\n  </div> \n  <p>Let us look at the first scenario above where <script type=\"math/tex; mode=display\">isBadVersion(mid) \\Rightarrow  false</script>. We know that all versions preceding and including <script type=\"math/tex; mode=display\">mid</script> are all good. So we set <script type=\"math/tex; mode=display\">left = mid + 1</script> to indicate that the new search space is the interval <script type=\"math/tex; mode=display\">[mid + 1, right]</script> (inclusive).</p> \n  <div class=\"codehilite\">\n   <pre><span></span>Scenario #2: isBadVersion(mid) =&gt; true\n\n 1 2 3 4 5 6 7 8 9\n G G G B B B B B B       G = Good, B = Bad\n |       |       |\nleft    mid    right\n</pre>\n  </div> \n  <p>The only scenario left is where <script type=\"math/tex; mode=display\">isBadVersion(mid) \\Rightarrow true</script>. This tells us that <script type=\"math/tex; mode=display\">mid</script> may or may not be the first bad version, but we can tell for sure that all versions after <script type=\"math/tex; mode=display\">mid</script> can be discarded. Therefore we set <script type=\"math/tex; mode=display\">right = mid</script> as the new search space of interval <script type=\"math/tex; mode=display\">[left,mid]</script> (inclusive).</p> \n  <p>In our case, we indicate <script type=\"math/tex; mode=display\">left</script> and <script type=\"math/tex; mode=display\">right</script> as the boundary of our search space (both inclusive). This is why we initialize <script type=\"math/tex; mode=display\">left = 1</script> and <script type=\"math/tex; mode=display\">right = n </script>. How about the terminating condition? We could guess that <script type=\"math/tex; mode=display\">left</script> and <script type=\"math/tex; mode=display\">right</script> eventually both meet and it must be the first bad version, but how could you tell for sure?</p> \n  <p>The formal way is to <a href=\"http://www.cs.cornell.edu/courses/cs211/2006sp/Lectures/L06-Induction/binary_search.html\">prove by induction</a>, which you can read up yourself if you are interested. Here is a helpful tip to quickly prove the correctness of your binary search algorithm during an interview. We just need to test an input of size 2. Check if it reduces the search space to a single element (which must be the answer) for both of the scenarios above. If not, your algorithm will never terminate.</p> \n  <p>If you are setting <script type=\"math/tex; mode=display\">mid = \\frac{left + right}{2}</script>, you have to be very careful. Unless you are using a language that does not overflow such as <a href=\"https://www.reddit.com/r/Python/comments/36xu5z/can_integer_operations_overflow_in_python/\">Python</a>, <script type=\"math/tex; mode=display\">left + right</script> could overflow. One way to fix this is to use <script type=\"math/tex; mode=display\">left + \\frac{right - left}{2}</script> instead.</p> \n  <p>If you fall into this subtle overflow bug, you are not alone. Even Jon Bentley's own implementation of binary search had this <a href=\"https://en.wikipedia.org/wiki/Binary_search_algorithm#Implementation_issues\">overflow bug</a> and remained undetected for over twenty years.</p> \n  <iframe src=\"https://leetcode.com/playground/VQBrosDg/shared\" frameborder=\"0\" name=\"VQBrosDg\" width=\"100%\" height=\"275\"></iframe> \n  <p><strong>Complexity analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(\\log n)</script>. The search space is halved each time, so the time complexity is <script type=\"math/tex; mode=display\">O(\\log n)</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n  </ul> \n </div> \n</div>"
},
{
    "frontend_question_id": 277,
    "article_live": false,
    "title": "Find the Celebrity",
    "title_slug": "find-the-celebrity",
    "tags": "Array",
    "difficulty": 2,
    "frontend_article_id": 277
},
{
    "frontend_question_id": 276,
    "article_live": false,
    "title": "Paint Fence",
    "title_slug": "paint-fence",
    "tags": "Dynamic Programming",
    "difficulty": 1,
    "frontend_article_id": 276
},
{
    "frontend_question_id": 275,
    "article_live": false,
    "title": "H-Index II",
    "title_slug": "h-index-ii",
    "content": "<p>Given an array of citations <strong>sorted&nbsp;in ascending order </strong>(each citation is a non-negative integer) of a researcher, write a function to compute the researcher&#39;s h-index.</p>\r\n\r\n<p>According to the&nbsp;<a href=\"https://en.wikipedia.org/wiki/H-index\" target=\"_blank\">definition of h-index on Wikipedia</a>: &quot;A scientist has index&nbsp;<i>h</i>&nbsp;if&nbsp;<i>h</i>&nbsp;of his/her&nbsp;<i>N</i>&nbsp;papers have&nbsp;<b>at least</b>&nbsp;<i>h</i>&nbsp;citations each, and the other&nbsp;<i>N &minus; h</i>&nbsp;papers have&nbsp;<b>no more than</b>&nbsp;<i>h&nbsp;</i>citations each.&quot;</p>\r\n\r\n<p><b>Example:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> <code>citations = [0,1,3,5,6]</code>\r\n<b>Output:</b> 3 \r\n<strong>Explanation: </strong><code>[0,1,3,5,6] </code>means the researcher has <code>5</code> papers in total and each of them had \r\n             received 0<code>, 1, 3, 5, 6</code> citations respectively. \r\n&nbsp;            Since the researcher has <code>3</code> papers with <b>at least</b> <code>3</code> citations each and the remaining \r\n&nbsp;            two with <b>no more than</b> <code>3</code> citations each, her h-index is <code>3</code>.</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<p>If there are several possible values for&nbsp;<em>h</em>, the maximum one is taken as the h-index.</p>\r\n\r\n<p><strong>Follow up:</strong></p>\r\n\r\n<ul>\r\n\t<li>This is a follow up problem to&nbsp;<a href=\"/problems/h-index/description/\">H-Index</a>, where <code>citations</code> is now guaranteed to be sorted in ascending order.</li>\r\n\t<li>Could you solve it in logarithmic time complexity?</li>\r\n</ul>\r\n",
    "tags": "Binary Search",
    "difficulty": 2,
    "frontend_article_id": 275
},
{
    "frontend_question_id": 274,
    "article_live": true,
    "article_slug": "h-index",
    "title": "H-Index",
    "title_slug": "h-index",
    "content": "<p>Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher&#39;s h-index.</p>\r\n\r\n<p>According to the <a href=\"https://en.wikipedia.org/wiki/H-index\" target=\"_blank\">definition of h-index on Wikipedia</a>: &quot;A scientist has index <i>h</i> if <i>h</i> of his/her <i>N</i> papers have <b>at least</b> <i>h</i> citations each, and the other <i>N &minus; h</i> papers have <b>no more than</b> <i>h</i> citations each.&quot;</p>\r\n\r\n<p><b>Example:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> <code>citations = [3,0,6,1,5]</code>\r\n<b>Output:</b> 3 \r\n<strong>Explanation: </strong><code>[3,0,6,1,5] </code>means the researcher has <code>5</code> papers in total and each of them had \r\n             received <code>3, 0, 6, 1, 5</code> citations respectively. \r\n&nbsp;            Since the researcher has <code>3</code> papers with <b>at least</b> <code>3</code> citations each and the remaining \r\n&nbsp;            two with <b>no more than</b> <code>3</code> citations each, her h-index is <code>3</code>.</pre>\r\n\r\n<p><strong>Note:&nbsp;</strong>If there are several possible values for <em>h</em>, the maximum one is taken as the h-index.</p>\r\n",
    "tags": "Hash Table, Sort",
    "difficulty": 2,
    "frontend_article_id": 274,
    "article_content": ""
},
{
    "frontend_question_id": 273,
    "article_live": false,
    "title": "Integer to English Words",
    "title_slug": "integer-to-english-words",
    "content": "<p>Convert a non-negative integer to its english words representation. Given input is guaranteed to be less than 2<sup>31</sup> - 1.</p>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> 123\r\n<b>Output:</b> &quot;One Hundred Twenty Three&quot;\r\n</pre>\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> 12345\r\n<b>Output:</b> &quot;Twelve Thousand Three Hundred Forty Five&quot;</pre>\r\n\r\n<p><b>Example 3:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> 1234567\r\n<b>Output:</b> &quot;One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven&quot;\r\n</pre>\r\n\r\n<p><b>Example 4:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> 1234567891\r\n<b>Output:</b> &quot;One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One&quot;\r\n</pre>\r\n",
    "tags": "Math, String",
    "difficulty": 3,
    "frontend_article_id": 273
},
{
    "frontend_question_id": 272,
    "article_live": false,
    "title": "Closest Binary Search Tree Value II",
    "title_slug": "closest-binary-search-tree-value-ii",
    "tags": "Stack, Tree",
    "difficulty": 3,
    "frontend_article_id": 272
},
{
    "frontend_question_id": 271,
    "article_live": false,
    "title": "Encode and Decode Strings",
    "title_slug": "encode-and-decode-strings",
    "tags": "String",
    "difficulty": 2,
    "frontend_article_id": 271
},
{
    "frontend_question_id": 270,
    "article_live": false,
    "title": "Closest Binary Search Tree Value",
    "title_slug": "closest-binary-search-tree-value",
    "tags": "Binary Search, Tree",
    "difficulty": 1,
    "frontend_article_id": 270
},
{
    "frontend_question_id": 269,
    "article_live": false,
    "title": "Alien Dictionary",
    "title_slug": "alien-dictionary",
    "tags": "Graph, Topological Sort",
    "difficulty": 3,
    "frontend_article_id": 269
},
{
    "frontend_question_id": 268,
    "article_live": true,
    "article_slug": "missing-number",
    "title": "Missing Number",
    "title_slug": "missing-number",
    "content": "<p>Given an array containing <i>n</i> distinct numbers taken from <code>0, 1, 2, ..., n</code>, find the one that is missing from the array.</p>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> [3,0,1]\r\n<b>Output:</b> 2\r\n</pre>\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> [9,6,4,2,3,5,7,0,1]\r\n<b>Output:</b> 8\r\n</pre>\r\n\r\n<p><b>Note</b>:<br />\r\nYour algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?</p>",
    "tags": "Array, Math, Bit Manipulation",
    "difficulty": 1,
    "frontend_article_id": 268,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-sorting-accepted\">Approach #1 Sorting [Accepted]</a></li> \n    <li><a href=\"#approach-2-hashset-accepted\">Approach #2 HashSet [Accepted]</a></li> \n    <li><a href=\"#approach-3-bit-manipulation-accepted\">Approach #3 Bit Manipulation [Accepted]</a></li> \n    <li><a href=\"#approach-4-gauss-formula-accepted\">Approach #4 Gauss' Formula [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-sorting-accepted\">Approach #1 Sorting [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>If <code>nums</code> were in order, it would be easy to see which number is missing.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>First, we sort <code>nums</code>. Then, we check the two special cases that can be handled in constant time - ensuring that 0 is at the beginning and that <script type=\"math/tex; mode=display\">n</script> is at the end. Given that those assumptions hold, the missing number must somewhere between (but not including) 0 and <script type=\"math/tex; mode=display\">n</script>. To find it, we ensure that the number we expect to be at each index is indeed there. Because we handled the edge cases, this is simply the previous number plus 1. Thus, as soon as we find an unexpected number, we can simply return the expected number.</p> \n  <iframe src=\"https://leetcode.com/playground/BpPhWC2o/shared\" frameborder=\"0\" width=\"100%\" height=\"480\" name=\"BpPhWC2o\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">\\mathcal{O}(nlgn)</script> </p> <p>The only elements of the algorithm that have asymptotically nonconstant time complexity are the main <code>for</code> loop (which runs in <script type=\"math/tex; mode=display\">\\mathcal{O}(n)</script> time), and the <code>sort</code> invocation (which runs in <script type=\"math/tex; mode=display\">\\mathcal{O}(nlgn)</script> time for Python and Java). Therefore, the runtime is dominated by <code>sort</code>, and the entire runtime is <script type=\"math/tex; mode=display\">\\mathcal{O}(nlgn)</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">\\mathcal{O}(1)</script> (or <script type=\"math/tex; mode=display\">\\mathcal{O}(n)</script>)</p> <p>In the sample code, we sorted <code>nums</code> in place, allowing us to avoid allocating additional space. If modifying <code>nums</code> is forbidden, we can allocate an <script type=\"math/tex; mode=display\">\\mathcal{O}(n)</script> size copy and sort that instead.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-hashset-accepted\">Approach #2 HashSet [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>A brute force method for solving this problem would be to simply check for the presence of each number that we expect to be present. The naive implementation might use a linear scan of the array to check for containment, but we can use a <code>HashSet</code> to get constant time containment queries and overall linear runtime.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>This algorithm is almost identical to the brute force approach, except we first insert each element of <code>nums</code> into a set, allowing us to later query for containment in <script type=\"math/tex; mode=display\">\\mathcal{O}(1)</script> time.</p> \n  <iframe src=\"https://leetcode.com/playground/UBNtYrmj/shared\" frameborder=\"0\" width=\"100%\" height=\"293\" name=\"UBNtYrmj\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">\\mathcal{O}(n)</script> </p> <p>Because the set allows for <script type=\"math/tex; mode=display\">\\mathcal{O}(1)</script> containment queries, the main loop runs in <script type=\"math/tex; mode=display\">\\mathcal{O}(n)</script> time. Creating <code>num_set</code> costs <script type=\"math/tex; mode=display\">\\mathcal{O}(n)</script> time, as each set insertion runs in amortized <script type=\"math/tex; mode=display\">\\mathcal{O}(1)</script> time, so the overall runtime is <script type=\"math/tex; mode=display\">\\mathcal{O}(n + n) = \\mathcal{O}(n)</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">\\mathcal{O}(n)</script> </p> <p><code>nums</code> contains <script type=\"math/tex; mode=display\">n-1</script> distinct elements, so it costs <script type=\"math/tex; mode=display\">\\mathcal{O}(n)</script> space to store a set containing all of them.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-bit-manipulation-accepted\">Approach #3 Bit Manipulation [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>We can harness the fact that XOR is its own inverse to find the missing element in linear time.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Because we know that <code>nums</code> contains <script type=\"math/tex; mode=display\">n</script> numbers and that it is missing exactly one number on the range <script type=\"math/tex; mode=display\">[0..n-1]</script>, we know that <script type=\"math/tex; mode=display\">n</script> definitely replaces the missing number in <code>nums</code>. Therefore, if we initialize an integer to <script type=\"math/tex; mode=display\">n</script> and XOR it with every index and value, we will be left with the missing number. Consider the following example (the values have been sorted for intuitive convenience, but need not be):</p> \n  <p></p>\n  <table> \n   <tbody>\n    <tr> \n     <th>Index</th> \n     <td>0</td> \n     <td>1</td> \n     <td>2</td> \n     <td>3</td> \n    </tr> \n    <tr> \n     <th>Value</th> \n     <td>0</td> \n     <td>1</td> \n     <td>3</td> \n     <td>4</td> \n    </tr> \n   </tbody>\n  </table> \n  <p></p> \n  <p> <script type=\"math/tex; mode=display\">\n\\begin{align}\n    missing &= 4 \\wedge (0 \\wedge 0) \\wedge (1 \\wedge 1) \\wedge (2 \\wedge 3) \\wedge (3 \\wedge 4) \\\\\n            &= (4 \\wedge 4) \\wedge (0 \\wedge 0) \\wedge (1 \\wedge 1) \\wedge (3 \\wedge 3) \\wedge 2 \\\\\n            &= 0 \\wedge 0 \\wedge 0 \\wedge 0 \\wedge 2 \\\\ \n            &= 2\n\\end{align}\n</script> </p> \n  <iframe src=\"https://leetcode.com/playground/SFZgajWR/shared\" frameborder=\"0\" width=\"100%\" height=\"208\" name=\"SFZgajWR\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">\\mathcal{O}(n)</script> </p> <p>Assuming that XOR is a constant-time operation, this algorithm does constant work on <script type=\"math/tex; mode=display\">n</script> iterations, so the runtime is overall linear.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">\\mathcal{O}(1)</script> </p> <p>This algorithm allocates only constant additional space.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-4-gauss-formula-accepted\">Approach #4 Gauss' Formula [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>One of the most well-known stories in mathematics is of a young Gauss, forced to find the sum of the first 100 natural numbers by a lazy teacher. Rather than add the numbers by hand, he deduced a <a href=\"https://brilliant.org/wiki/sum-of-n-n2-or-n3/\">closed-form expression</a> for the sum, or so the story goes. You can see the formula below:</p> \n  <p> <script type=\"math/tex; mode=display\">\n    \\sum_{i=0}^{n}i = \\frac{n(n+1)}{2}\n</script> </p> \n  <p><strong>Algorithm</strong></p> \n  <p>We can compute the sum of <code>nums</code> in linear time, and by Gauss' formula, we can compute the sum of the first <script type=\"math/tex; mode=display\">n</script> natural numbers in constant time. Therefore, the number that is missing is simply the result of Gauss' formula minus the sum of <code>nums</code>, as <code>nums</code> consists of the first <script type=\"math/tex; mode=display\">n</script> natural numbers minus some number.</p> \n  <iframe src=\"https://leetcode.com/playground/3NM3eQvx/shared\" frameborder=\"0\" width=\"100%\" height=\"191\" name=\"3NM3eQvx\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">\\mathcal{O}(n)</script> </p> <p>Although Gauss' formula can be computed in <script type=\"math/tex; mode=display\">\\mathcal{O}(1)</script> time, summing <code>nums</code> costs us <script type=\"math/tex; mode=display\">\\mathcal{O}(n)</script> time, so the algorithm is overall linear. Because we have no information about <em>which</em> number is missing, an adversary could always design an input for which any algorithm that examines fewer than <script type=\"math/tex; mode=display\">n</script> numbers fails. Therefore, this solution is asymptotically optimal.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">\\mathcal{O}(1)</script> </p> <p>This approach only pushes a few integers around, so it has constant memory usage.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/emptyset\">@emptyset</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 267,
    "article_live": true,
    "article_slug": "palindrome-permutation-ii",
    "title": "Palindrome Permutation II",
    "title_slug": "palindrome-permutation-ii",
    "tags": "Backtracking",
    "difficulty": 2,
    "frontend_article_id": 267,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-backtracking-accepted\">Approach #2 Backtracking [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</h4> \n  <p>The simplest solution is generate every possible permutation of the given string <script type=\"math/tex; mode=display\">s</script> and check if the generated permutation is a palindrome. After this, the palindromic permuations can be added to a <script type=\"math/tex; mode=display\">set</script> in order to eliminate the duplicates. At the end, we can return an array comprised of the elements of this <script type=\"math/tex; mode=display\">set</script> as the resultant array.</p> \n  <p>Let's look at the way these permutations are generated. We make use of a recursive function <code>permute</code> which takes the index of the current element <script type=\"math/tex; mode=display\">current_index</script> as one of the arguments. Then, it swaps the current element with every other element in the array, lying towards its right, so as to generate a new ordering of the array elements. After the swapping has been done, it makes another call to <code>permute</code> but this time with the index of the next element in the array. While returning back, we reverse the swapping done in the current function call. Thus, when we reach the end of the array, a new ordering of the array's elements is generated.</p> \n  <p>The animation below depicts the ways the permutations are generated.</p> \n  <p>!?!../Documents/561_Array.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/6Ryph5jp/shared\" frameborder=\"0\" name=\"6Ryph5jp\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O((n+1)!)</script>. A total of <script type=\"math/tex; mode=display\">n!</script> permutations are possible. For every permutation generated, we need to check if it is a palindrome, each of which requires <script type=\"math/tex; mode=display\">O(n)</script> time.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The depth of the recursion tree can go upto <script type=\"math/tex; mode=display\">n</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-backtracking-accepted\">Approach #2 Backtracking [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>It might be possible that no palindromic permutation could be possible for the given string <script type=\"math/tex; mode=display\">s</script>. Thus, it is useless to generate the permutations in such a case. Taking this idea, firstly we check if a palindromic permutation is possible for <script type=\"math/tex; mode=display\">s</script>. If yes, then only we proceed further with generating the permutations. To check this, we make use of a hashmap <script type=\"math/tex; mode=display\">map</script> which stores the number of occurences of each character(out of 128 ASCII characters possible). If the number of characters with odd number of occurences exceeds 1, it indicates that no palindromic permutation is possible for <script type=\"math/tex; mode=display\">s</script>. To look at this checking process in detail, look at Approach 4 of the <a href=\"https://leetcode.com/articles/palindrome-permutation\">article</a> for Palindrome Permutation.</p> \n  <p>Once we are sure that a palindromic permutation is possible for <script type=\"math/tex; mode=display\">s</script>, we go for the generation of the required permutations. But, instead of wildly generating all the permutations, we can include some smartness in the generation of permutations i.e. we can generate only those permutations which are already palindromes.</p> \n  <p>One idea to to do so is to generate only the first half of the palindromic string and to append its reverse string to itself to generate the full length palindromic string.</p> \n  <p>Based on this idea, by making use of the number of occurences of the characters in <script type=\"math/tex; mode=display\">s</script> stored in <script type=\"math/tex; mode=display\">map</script>, we create a string <script type=\"math/tex; mode=display\">st</script> which contains all the characters of <script type=\"math/tex; mode=display\">s</script> but with the number of occurences of these characters in <script type=\"math/tex; mode=display\">st</script> reduced to half their original number of occurences in <script type=\"math/tex; mode=display\">s</script>.</p> \n  <p>Thus, now we can generate all the permutations of this string <script type=\"math/tex; mode=display\">st</script> and append the reverse of this permuted string to itself to create the palindromic permutations of <script type=\"math/tex; mode=display\">s</script>.</p> \n  <p>In case of a string <script type=\"math/tex; mode=display\">s</script> with odd length, whose palindromic permutations are possible, one of the characters in <script type=\"math/tex; mode=display\">s</script> must be occuring an odd number of times. We keep a track of this character, <script type=\"math/tex; mode=display\">ch</script>, and it is kept separte from the string <script type=\"math/tex; mode=display\">st</script>. We again generate the permutations for <script type=\"math/tex; mode=display\">st</script> similarly and append the reverse of the generated permutation to itself, but we also place the character <script type=\"math/tex; mode=display\">ch</script> at the middle of the generated string. </p> \n  <p>In this way, only the required palindromic permutations will be generated. Even if we go with the above idea, a lot of duplicate strings will be generated.</p> \n  <p>In order to avoid generating duplicate palindromic permutations in the first place itself, as much as possible, we can make use of this idea. As discussed in the last approach, we swap the current element with all the elements lying towards its right to generate the permutations. Before swapping, we can check if the elements being swapped are equal. If so, the permutations generated even after swapping the two will be duplicates(redundant). Thus, we need not proceed further in such a case.</p> \n  <p>See this animation for a clearer understanding.</p> \n  <p>!?!../Documents/267_Palindrome_Permutation_II.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/Nfi5WWm2/shared\" frameborder=\"0\" name=\"Nfi5WWm2\" width=\"100%\" height=\"515\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O\\big((\\frac{n}{2}+1)!\\big)</script>. Atmost <script type=\"math/tex; mode=display\">\\frac{n}{2}!</script> permutations need to be generated in the worst case. Further, for each permutation generated, <code>string.reverse()</code> function will take <script type=\"math/tex; mode=display\">n/4</script> time.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The depth of recursion tree can go upto <script type=\"math/tex; mode=display\">n/2</script> in the worst case.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 266,
    "article_live": true,
    "article_slug": "palindrome-permutation",
    "title": "Palindrome Permutation",
    "title_slug": "palindrome-permutation",
    "tags": "Hash Table",
    "difficulty": 1,
    "frontend_article_id": 266,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-accepted\">Approach #1 Brute Force [Accepted]</a></li> \n      <li><a href=\"#approach-2-using-hashmap-accepted\">Approach #2 Using HashMap [Accepted]</a></li> \n      <li><a href=\"#approach-3-using-array-accepted\">Approach #3 Using Array [Accepted]</a></li> \n      <li><a href=\"#approach-4-single-pass-accepted\">Approach #4 Single Pass [Accepted]:</a></li> \n      <li><a href=\"#approach-5-using-set-accepted\">Approach #5 Using Set [Accepted]:</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-accepted\">Approach #1 Brute Force [Accepted]</h4> \n  <p>If a string with an even length is a palindrome, every character in the string must always occur an even number of times. If the string with an odd length is a palindrome, every character except one of the characters must always occur an even number of times. Thus, in case of a palindrome, the number of characters with odd number of occurences can't exceed 1(1 in case of odd length and 0 in case of even length).</p> \n  <p>Based on the above observation, we can find the solution for the given problem. The given string could contain atmost all the ASCII characters from 0 to 127. Thus, we iterate over all the characters from 0 to 127. For every character chosen, we again iterate over the given string <script type=\"math/tex; mode=display\">s</script> and find the number of occurences, <script type=\"math/tex; mode=display\">ch</script>, of the current character in <script type=\"math/tex; mode=display\">s</script>. We also keep a track of the number of characters in the given string <script type=\"math/tex; mode=display\">s</script> with odd number of occurences in a variable <script type=\"math/tex; mode=display\">count</script>.</p> \n  <p>If, for any character currently considered, its corresponding count, <script type=\"math/tex; mode=display\">ch</script>, happens to be odd, we increment the value of <script type=\"math/tex; mode=display\">count</script>, to reflect the same. In case of even value of <script type=\"math/tex; mode=display\">ch</script> for any character, the <script type=\"math/tex; mode=display\">count</script> remains unchanged.</p> \n  <p>If, for any character, the <script type=\"math/tex; mode=display\">count</script> becomes greater than 1, it indicates that the given string <script type=\"math/tex; mode=display\">s</script> can't lead to the formation of a palindromic permutation based on the reasoning discussed above. But, if the value of <script type=\"math/tex; mode=display\">count</script> remains lesser than 2 even when all the possible characters have been considered, it indicates that a palindromic permutation can be formed from the given string <script type=\"math/tex; mode=display\">s</script>.</p> \n  <iframe src=\"https://leetcode.com/playground/2GTcGjDw/shared\" frameborder=\"0\" name=\"2GTcGjDw\" width=\"100%\" height=\"309\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(128*n)</script>. We iterate constant number of times(128) over the string <script type=\"math/tex; mode=display\">s</script> of length <script type=\"math/tex; mode=display\">n</script> giving a time complexity of <script type=\"math/tex; mode=display\">128n</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant extra space is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-using-hashmap-accepted\">Approach #2 Using HashMap [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>From the discussion above, we know that to solve the given problem, we need to count the number of characters with odd number of occurences in the given string <script type=\"math/tex; mode=display\">s</script>. To do so, we can also make use of a hashmap, <script type=\"math/tex; mode=display\">map</script>. This <script type=\"math/tex; mode=display\">map</script> takes the form <script type=\"math/tex; mode=display\">(character_i, number of occurences of character_i)</script>.</p> \n  <p>We traverse over the given string <script type=\"math/tex; mode=display\">s</script>. For every new character found in <script type=\"math/tex; mode=display\">s</script>, we create a new entry in the <script type=\"math/tex; mode=display\">map</script> for this character with the number of occurences as 1. Whenever we find the same character again, we update the number of occurences appropriately. </p> \n  <p>At the end, we traverse over the <script type=\"math/tex; mode=display\">map</script> created and find the number of characters with odd number of occurences. If this <script type=\"math/tex; mode=display\">count</script> happens to exceed 1 at any step, we conclude that a palindromic permutation isn't possible for the string <script type=\"math/tex; mode=display\">s</script>. But, if we can reach the end of the string with <script type=\"math/tex; mode=display\">count</script> lesser than 2, we conclude that a palindromic permutation is possible for <script type=\"math/tex; mode=display\">s</script>.</p> \n  <p>The following animation illustrates the process.</p> \n  <p>!?!../Documents/266_Palindrome_Permutation.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/QedxyvpM/shared\" frameborder=\"0\" name=\"QedxyvpM\" width=\"100%\" height=\"292\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. We traverse over the given string <script type=\"math/tex; mode=display\">s</script> with <script type=\"math/tex; mode=display\">n</script> characters once. We also traverse over the <script type=\"math/tex; mode=display\">map</script> which can grow upto a size of <script type=\"math/tex; mode=display\">n</script> in case all characters in <script type=\"math/tex; mode=display\">s</script> are distinct.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The hashmap can grow upto a size of <script type=\"math/tex; mode=display\">n</script>, in case all the characters in <script type=\"math/tex; mode=display\">s</script> are distinct.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-using-array-accepted\">Approach #3 Using Array [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Instead of making use of the inbuilt Hashmap, we can make use of an array as a hashmap. For this, we make use of an array <script type=\"math/tex; mode=display\">map</script> with length 128. Each index of this <script type=\"math/tex; mode=display\">map</script> corresponds to one of the 128 ASCII characters possible.</p> \n  <p>We traverse over the string <script type=\"math/tex; mode=display\">s</script> and put in the number of occurences of each character in this <script type=\"math/tex; mode=display\">map</script> appropriately as done in the last case. Later on, we find the number of characters with odd number of occurences to determine if a palindromic permutation is possible for the string <script type=\"math/tex; mode=display\">s</script> or not as done in previous approaches.</p> \n  <iframe src=\"https://leetcode.com/playground/pvhRBZgk/shared\" frameborder=\"0\" name=\"pvhRBZgk\" width=\"100%\" height=\"275\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. We traverse once over the string <script type=\"math/tex; mode=display\">s</script> of length <script type=\"math/tex; mode=display\">n</script>. Then, we traverse over the <script type=\"math/tex; mode=display\">map</script> of length 128(constant).</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant extra space is used for <script type=\"math/tex; mode=display\">map</script> of size 128.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-4-single-pass-accepted\">Approach #4 Single Pass [Accepted]:</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Instead of first traversing over the string <script type=\"math/tex; mode=display\">s</script> for finding the number of occurences of each element and then determining the <script type=\"math/tex; mode=display\">count</script> of characters with odd number of occurences in <script type=\"math/tex; mode=display\">s</script>, we can determine the value of <script type=\"math/tex; mode=display\">count</script> on the fly while traversing over <script type=\"math/tex; mode=display\">s</script>.</p> \n  <p>For this, we traverse over <script type=\"math/tex; mode=display\">s</script> and update the number of occurences of the character just encountered in the <script type=\"math/tex; mode=display\">map</script>. But, whevenever we update any entry in <script type=\"math/tex; mode=display\">map</script>, we also check if its value becomes even or odd. We start of with a <script type=\"math/tex; mode=display\">count</script> value of 0. If the value of the entry just updated in <script type=\"math/tex; mode=display\">map</script> happens to be odd, we increment the value of <script type=\"math/tex; mode=display\">count</script> to indicate that one more character with odd number of occurences has been found. But, if this entry happens to be even, we decrement the value of <script type=\"math/tex; mode=display\">count</script> to indicate that the number of characters with odd number of occurences has reduced by one. </p> \n  <p>But, in this case, we need to traverse till the end of the string to determine the final result, unlike the last approaches, where we could stop the traversal over <script type=\"math/tex; mode=display\">map</script> as soon as the <script type=\"math/tex; mode=display\">count</script> exceeded 1. This is because, even if the number of elements with odd number of occurences may seem very large at the current moment, but their occurences could turn out to be even when we traverse further in the string <script type=\"math/tex; mode=display\">s</script>.</p> \n  <p>At the end, we again check if the value of <script type=\"math/tex; mode=display\">count</script> is lesser than 2 to conclude that a palindromic permutation is possible for the string <script type=\"math/tex; mode=display\">s</script>.</p> \n  <iframe src=\"https://leetcode.com/playground/5AuTxAxU/shared\" frameborder=\"0\" name=\"5AuTxAxU\" width=\"100%\" height=\"292\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. We traverse over the string <script type=\"math/tex; mode=display\">s</script> of length <script type=\"math/tex; mode=display\">n</script> once only.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(128)</script>. A <script type=\"math/tex; mode=display\">map</script> of constant size(128) is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-5-using-set-accepted\">Approach #5 Using Set [Accepted]:</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Another modification of the last approach could be by making use of a <script type=\"math/tex; mode=display\">set</script> for keeping track of the number of elements with odd number of occurences in <script type=\"math/tex; mode=display\">s</script>. For doing this, we traverse over the characters of the string <script type=\"math/tex; mode=display\">s</script>. Whenver the number of occurences of a character becomes odd, we put its entry in the <script type=\"math/tex; mode=display\">set</script>. Later on, if we find the same element again, lead to its number of occurences as even, we remove its entry from the <script type=\"math/tex; mode=display\">set</script>. Thus, if the element occurs again(indicating an odd number of occurences), its entry won't exist in the <script type=\"math/tex; mode=display\">set</script>.</p> \n  <p>Based on this idea, when we find a character in the string <script type=\"math/tex; mode=display\">s</script> that isn't present in the <script type=\"math/tex; mode=display\">set</script>(indicating an odd number of occurences currently for this character), we put its corresponding entry in the <script type=\"math/tex; mode=display\">set</script>. If we find a character that is already present in the <script type=\"math/tex; mode=display\">set</script>(indicating an even number of occurences currently for this character), we remove its corresponding entry from the <script type=\"math/tex; mode=display\">set</script>.</p> \n  <p>At the end, the size of <script type=\"math/tex; mode=display\">set</script> indicates the number of elements with odd number of occurences in <script type=\"math/tex; mode=display\">s</script>. If it is lesser than 2, a palindromic permutation of the string <script type=\"math/tex; mode=display\">s</script> is possible, otherwise not.</p> \n  <p>Below code is inspired by <a href=\"https://leetcode.com/stefanpochmann\">@StefanPochmann</a></p> \n  <iframe src=\"https://leetcode.com/playground/PwqWXcwG/shared\" frameborder=\"0\" name=\"PwqWXcwG\" width=\"100%\" height=\"241\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. We traverse over the string <script type=\"math/tex; mode=display\">s</script> of length <script type=\"math/tex; mode=display\">n</script> once only.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The <script type=\"math/tex; mode=display\">set</script> can grow upto a maximum size of <script type=\"math/tex; mode=display\">n</script> in case of all distinct elements.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 265,
    "article_live": false,
    "title": "Paint House II",
    "title_slug": "paint-house-ii",
    "tags": "Dynamic Programming",
    "difficulty": 3,
    "frontend_article_id": 265
},
{
    "frontend_question_id": 264,
    "article_live": false,
    "title": "Ugly Number II",
    "title_slug": "ugly-number-ii",
    "content": "<p>Write a program to find the <code>n</code>-th ugly number.</p>\r\n\r\n<p>Ugly numbers are<strong> positive numbers</strong> whose prime factors only include <code>2, 3, 5</code>.&nbsp;</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> n = 10\r\n<strong>Output:</strong> 12\r\n<strong>Explanation: </strong><code>1, 2, 3, 4, 5, 6, 8, 9, 10, 12</code> is the sequence of the first <code>10</code> ugly numbers.</pre>\r\n\r\n<p><strong>Note: </strong>&nbsp;</p>\r\n\r\n<ol>\r\n\t<li><code>1</code> is typically treated as an ugly number.</li>\r\n\t<li><code>n</code> <b>does not exceed 1690</b>.</li>\r\n</ol>",
    "tags": "Math, Dynamic Programming, Heap",
    "difficulty": 2,
    "frontend_article_id": 264
},
{
    "frontend_question_id": 263,
    "article_live": false,
    "title": "Ugly Number",
    "title_slug": "ugly-number",
    "content": "<p>Write a program to check whether a given number is an ugly number.</p>\r\n\r\n<p>Ugly numbers are <strong>positive numbers</strong> whose prime factors only include <code>2, 3, 5</code>.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 6\r\n<strong>Output:</strong> true\r\n<strong>Explanation: </strong>6 = 2 &times;&nbsp;3</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 8\r\n<strong>Output:</strong> true\r\n<strong>Explanation: </strong>8 = 2 &times; 2 &times;&nbsp;2\r\n</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 14\r\n<strong>Output:</strong> false \r\n<strong>Explanation: </strong><code>14</code> is not ugly since it includes another prime factor <code>7</code>.\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1</code> is typically treated as an ugly number.</li>\r\n\t<li>Input is within the 32-bit signed integer range:&nbsp;[&minus;2<sup>31</sup>,&nbsp; 2<sup>31&nbsp;</sup>&minus; 1].</li>\r\n</ol>",
    "tags": "Math",
    "difficulty": 1,
    "frontend_article_id": 263
},
{
    "frontend_question_id": 261,
    "article_live": false,
    "title": "Graph Valid Tree",
    "title_slug": "graph-valid-tree",
    "tags": "Depth-first Search, Breadth-first Search, Union Find, Graph",
    "difficulty": 2,
    "frontend_article_id": 261
},
{
    "frontend_question_id": 260,
    "article_live": false,
    "title": "Single Number III",
    "title_slug": "single-number-iii",
    "content": "<p>Given an array of numbers <code>nums</code>, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>  <code>[1,2,1,3,2,5]</code>\r\n<strong>Output:</strong> <code>[3,5]</code></pre>\r\n\r\n<p><b>Note</b>:</p>\r\n\r\n<ol>\r\n\t<li>The order of the result is not important. So in the above example, <code>[5, 3]</code> is also correct.</li>\r\n\t<li>Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?</li>\r\n</ol>",
    "tags": "Bit Manipulation",
    "difficulty": 2,
    "frontend_article_id": 260
},
{
    "frontend_question_id": 259,
    "article_live": true,
    "article_slug": "3sum-smaller",
    "title": "3Sum Smaller",
    "title_slug": "3sum-smaller",
    "tags": "Array, Two Pointers",
    "difficulty": 2,
    "frontend_article_id": 259,
    "article_content": ""
},
{
    "frontend_question_id": 258,
    "article_live": false,
    "title": "Add Digits",
    "title_slug": "add-digits",
    "content": "<p>Given a non-negative integer <code>num</code>, repeatedly add all its digits until the result has only one digit.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> <code>38</code>\r\n<strong>Output:</strong> 2 \r\n<strong>Explanation: </strong>The process is like: <code>3 + 8 = 11</code>, <code>1 + 1 = 2</code>. \r\n&nbsp;            Since <code>2</code> has only one digit, return it.\r\n</pre>\r\n\r\n<p><b>Follow up:</b><br />\r\nCould you do it without any loop/recursion in O(1) runtime?</p>",
    "tags": "Math",
    "difficulty": 1,
    "frontend_article_id": 258
},
{
    "frontend_question_id": 257,
    "article_live": false,
    "title": "Binary Tree Paths",
    "title_slug": "binary-tree-paths",
    "content": "<p>Given a binary tree, return all root-to-leaf paths.</p>\r\n\r\n<p><strong>Note:</strong>&nbsp;A leaf is a node with no children.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>\r\n\r\n   1\r\n /   \\\r\n2     3\r\n \\\r\n  5\r\n\r\n<strong>Output:</strong> [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]\r\n\r\n<strong>Explanation:</strong> All root-to-leaf paths are: 1-&gt;2-&gt;5, 1-&gt;3\r\n</pre>",
    "tags": "Tree, Depth-first Search",
    "difficulty": 1,
    "frontend_article_id": 257
},
{
    "frontend_question_id": 256,
    "article_live": false,
    "title": "Paint House",
    "title_slug": "paint-house",
    "tags": "Dynamic Programming",
    "difficulty": 1,
    "frontend_article_id": 256
},
{
    "frontend_question_id": 255,
    "article_live": false,
    "title": "Verify Preorder Sequence in Binary Search Tree",
    "title_slug": "verify-preorder-sequence-in-binary-search-tree",
    "tags": "Stack, Tree",
    "difficulty": 2,
    "frontend_article_id": 255
},
{
    "frontend_question_id": 254,
    "article_live": false,
    "title": "Factor Combinations",
    "title_slug": "factor-combinations",
    "tags": "Backtracking",
    "difficulty": 2,
    "frontend_article_id": 254
},
{
    "frontend_question_id": 253,
    "article_live": true,
    "article_slug": "meeting-rooms-ii",
    "title": "Meeting Rooms II",
    "title_slug": "meeting-rooms-ii",
    "tags": "Heap, Greedy, Sort",
    "difficulty": 2,
    "frontend_article_id": 253,
    "article_content": ""
},
{
    "frontend_question_id": 252,
    "article_live": true,
    "article_slug": "meeting-rooms",
    "title": "Meeting Rooms",
    "title_slug": "meeting-rooms",
    "tags": "Sort",
    "difficulty": 1,
    "frontend_article_id": 252,
    "article_content": ""
},
{
    "frontend_question_id": 251,
    "article_live": false,
    "title": "Flatten 2D Vector",
    "title_slug": "flatten-2d-vector",
    "tags": "Design",
    "difficulty": 2,
    "frontend_article_id": 251
},
{
    "frontend_question_id": 250,
    "article_live": false,
    "title": "Count Univalue Subtrees",
    "title_slug": "count-univalue-subtrees",
    "tags": "Tree",
    "difficulty": 2,
    "frontend_article_id": 250
},
{
    "frontend_question_id": 249,
    "article_live": false,
    "title": "Group Shifted Strings",
    "title_slug": "group-shifted-strings",
    "tags": "Hash Table, String",
    "difficulty": 2,
    "frontend_article_id": 249
},
{
    "frontend_question_id": 248,
    "article_live": false,
    "title": "Strobogrammatic Number III",
    "title_slug": "strobogrammatic-number-iii",
    "tags": "Math, Recursion",
    "difficulty": 3,
    "frontend_article_id": 248
},
{
    "frontend_question_id": 247,
    "article_live": false,
    "title": "Strobogrammatic Number II",
    "title_slug": "strobogrammatic-number-ii",
    "tags": "Math, Recursion",
    "difficulty": 2,
    "frontend_article_id": 247
},
{
    "frontend_question_id": 246,
    "article_live": false,
    "title": "Strobogrammatic Number",
    "title_slug": "strobogrammatic-number",
    "tags": "Hash Table, Math",
    "difficulty": 1,
    "frontend_article_id": 246
},
{
    "frontend_question_id": 245,
    "article_live": false,
    "title": "Shortest Word Distance III",
    "title_slug": "shortest-word-distance-iii",
    "tags": "Array",
    "difficulty": 2,
    "frontend_article_id": 245
},
{
    "frontend_question_id": 244,
    "article_live": false,
    "title": "Shortest Word Distance II",
    "title_slug": "shortest-word-distance-ii",
    "tags": "Hash Table, Design",
    "difficulty": 2,
    "frontend_article_id": 244
},
{
    "frontend_question_id": 243,
    "article_live": true,
    "article_slug": "shortest-word-distance",
    "title": "Shortest Word Distance",
    "title_slug": "shortest-word-distance",
    "tags": "Array",
    "difficulty": 1,
    "frontend_article_id": 243,
    "article_content": ""
},
{
    "frontend_question_id": 242,
    "article_live": true,
    "article_slug": "valid-anagram",
    "title": "Valid Anagram",
    "title_slug": "valid-anagram",
    "content": "<p>Given two strings <em>s</em> and <em>t&nbsp;</em>, write a function to determine if <em>t</em> is an anagram of <em>s</em>.</p>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> <em>s</em> = &quot;anagram&quot;, <em>t</em> = &quot;nagaram&quot;\r\n<b>Output:</b> true\r\n</pre>\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> <em>s</em> = &quot;rat&quot;, <em>t</em> = &quot;car&quot;\r\n<b>Output: </b>false\r\n</pre>\r\n\r\n<p><strong>Note:</strong><br />\r\nYou may assume the string contains only lowercase alphabets.</p>\r\n\r\n<p><strong>Follow up:</strong><br />\r\nWhat if the inputs contain unicode characters? How would you adapt your solution to such case?</p>\r\n",
    "tags": "Hash Table, Sort",
    "difficulty": 1,
    "frontend_article_id": 242,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-sorting-accepted\">Approach #1 (Sorting) [Accepted]</a></li> \n      <li><a href=\"#approach-2-hash-table-accepted\">Approach #2 (Hash Table) [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-sorting-accepted\">Approach #1 (Sorting) [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>An anagram is produced by rearranging the letters of <script type=\"math/tex; mode=display\">s</script> into <script type=\"math/tex; mode=display\">t</script>. Therefore, if <script type=\"math/tex; mode=display\">t</script> is an anagram of <script type=\"math/tex; mode=display\">s</script>, sorting both strings will result in two identical strings. Furthermore, if <script type=\"math/tex; mode=display\">s</script> and <script type=\"math/tex; mode=display\">t</script> have different lengths, <script type=\"math/tex; mode=display\">t</script> must not be an anagram of <script type=\"math/tex; mode=display\">s</script> and we can return early.</p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">isAnagram</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">String</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()</span> <span class=\"o\">!=</span> <span class=\"n\">t</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"kt\">char</span><span class=\"o\">[]</span> <span class=\"n\">str1</span> <span class=\"o\">=</span> <span class=\"n\">s</span><span class=\"o\">.</span><span class=\"na\">toCharArray</span><span class=\"o\">();</span>\n    <span class=\"kt\">char</span><span class=\"o\">[]</span> <span class=\"n\">str2</span> <span class=\"o\">=</span> <span class=\"n\">t</span><span class=\"o\">.</span><span class=\"na\">toCharArray</span><span class=\"o\">();</span>\n    <span class=\"n\">Arrays</span><span class=\"o\">.</span><span class=\"na\">sort</span><span class=\"o\">(</span><span class=\"n\">str1</span><span class=\"o\">);</span>\n    <span class=\"n\">Arrays</span><span class=\"o\">.</span><span class=\"na\">sort</span><span class=\"o\">(</span><span class=\"n\">str2</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"n\">Arrays</span><span class=\"o\">.</span><span class=\"na\">equals</span><span class=\"o\">(</span><span class=\"n\">str1</span><span class=\"o\">,</span> <span class=\"n\">str2</span><span class=\"o\">);</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n \\log n)</script>. Assume that <script type=\"math/tex; mode=display\">n</script> is the length of <script type=\"math/tex; mode=display\">s</script>, sorting costs <script type=\"math/tex; mode=display\">O(n \\log n)</script> and comparing two strings costs <script type=\"math/tex; mode=display\">O(n)</script>. Sorting time dominates and the overall time complexity is <script type=\"math/tex; mode=display\">O(n \\log n)</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Space depends on the sorting implementation which, usually, costs <script type=\"math/tex; mode=display\">O(1)</script> auxiliary space if <code>heapsort</code> is used. Note that in Java, <code>toCharArray()</code> makes a copy of the string so it costs <script type=\"math/tex; mode=display\">O(n)</script> extra space, but we ignore this for complexity analysis because:</p> \n    <ul> \n     <li>It is a language dependent detail.</li> \n     <li>It depends on how the function is designed. For example, the function parameter types can be changed to <code>char[]</code>.</li> \n    </ul> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-hash-table-accepted\">Approach #2 (Hash Table) [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>To examine if <script type=\"math/tex; mode=display\">t</script> is a rearrangement of <script type=\"math/tex; mode=display\">s</script>, we can count occurrences of each letter in the two strings and compare them. Since both <script type=\"math/tex; mode=display\">s</script> and <script type=\"math/tex; mode=display\">t</script> contain only letters from <script type=\"math/tex; mode=display\">a-z</script>, a simple counter table of size 26 is suffice.</p> \n  <p>Do we need <em>two</em> counter tables for comparison? Actually no, because we could increment the counter for each letter in <script type=\"math/tex; mode=display\">s</script> and decrement the counter for each letter in <script type=\"math/tex; mode=display\">t</script>, then check if the counter reaches back to zero.</p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">isAnagram</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">String</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()</span> <span class=\"o\">!=</span> <span class=\"n\">t</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">counter</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"mi\">26</span><span class=\"o\">];</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">s</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">();</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n        <span class=\"n\">counter</span><span class=\"o\">[</span><span class=\"n\">s</span><span class=\"o\">.</span><span class=\"na\">charAt</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">-</span> <span class=\"sc\">'a'</span><span class=\"o\">]++;</span>\n        <span class=\"n\">counter</span><span class=\"o\">[</span><span class=\"n\">t</span><span class=\"o\">.</span><span class=\"na\">charAt</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">-</span> <span class=\"sc\">'a'</span><span class=\"o\">]--;</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">count</span> <span class=\"o\">:</span> <span class=\"n\">counter</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">count</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p>Or we could first increment the counter for <script type=\"math/tex; mode=display\">s</script>, then decrement the counter for <script type=\"math/tex; mode=display\">t</script>. If at any point the counter drops below zero, we know that <script type=\"math/tex; mode=display\">t</script> contains an extra letter not in <script type=\"math/tex; mode=display\">s</script> and return false immediately.</p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">isAnagram</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">String</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()</span> <span class=\"o\">!=</span> <span class=\"n\">t</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">table</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"mi\">26</span><span class=\"o\">];</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">s</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">();</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n        <span class=\"n\">table</span><span class=\"o\">[</span><span class=\"n\">s</span><span class=\"o\">.</span><span class=\"na\">charAt</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">-</span> <span class=\"sc\">'a'</span><span class=\"o\">]++;</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">t</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">();</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n        <span class=\"n\">table</span><span class=\"o\">[</span><span class=\"n\">t</span><span class=\"o\">.</span><span class=\"na\">charAt</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">-</span> <span class=\"sc\">'a'</span><span class=\"o\">]--;</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">table</span><span class=\"o\">[</span><span class=\"n\">t</span><span class=\"o\">.</span><span class=\"na\">charAt</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">-</span> <span class=\"sc\">'a'</span><span class=\"o\">]</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Time complexity is <script type=\"math/tex; mode=display\">O(n)</script> because accessing the counter table is a constant time operation.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Although we do use extra space, the space complexity is <script type=\"math/tex; mode=display\">O(1)</script> because the table's size stays constant no matter how large <script type=\"math/tex; mode=display\">n</script> is.</p> </li> \n  </ul> \n  <p><strong>Follow up</strong></p> \n  <p>What if the inputs contain unicode characters? How would you adapt your solution to such case?</p> \n  <p><strong>Answer</strong></p> \n  <p>Use a hash table instead of a fixed size counter. Imagine allocating a large size array to fit the entire range of unicode characters, which could go up to <a href=\"https://stackoverflow.com/a/5928054/490463\">more than 1 million</a>. A hash table is a more generic solution and could adapt to any range of characters.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 241,
    "article_live": false,
    "title": "Different Ways to Add Parentheses",
    "title_slug": "different-ways-to-add-parentheses",
    "content": "<p>Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are <code>+</code>, <code>-</code> and <code>*</code>.</p>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> <code>&quot;2-1-1&quot;</code>\r\n<b>Output:</b> <code>[0, 2]</code>\r\n<strong>Explanation: </strong>\r\n((2-1)-1) = 0 \r\n(2-(1-1)) = 2</pre>\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\n<b>Input: </b><code>&quot;2*3-4*5&quot;</code>\r\n<b>Output:</b> <code>[-34, -14, -10, -10, 10]</code>\r\n<strong>Explanation: \r\n</strong>(2*(3-(4*5))) = -34 \r\n((2*3)-(4*5)) = -14 \r\n((2*(3-4))*5) = -10 \r\n(2*((3-4)*5)) = -10 \r\n(((2*3)-4)*5) = 10<strong>\r\n</strong></pre>",
    "tags": "Divide and Conquer",
    "difficulty": 2,
    "frontend_article_id": 241
},
{
    "frontend_question_id": 240,
    "article_live": true,
    "article_slug": "search-a-2d-matrix-ii",
    "title": "Search a 2D Matrix II",
    "title_slug": "search-a-2d-matrix-ii",
    "content": "<p>Write an efficient algorithm that searches for a value in an <i>m</i> x <i>n</i> matrix. This matrix has the following properties:</p>\r\n\r\n<ul>\r\n\t<li>Integers in each row are sorted in ascending from left to right.</li>\r\n\t<li>Integers in each column are sorted in ascending from top to bottom.</li>\r\n</ul>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<p>Consider the following matrix:</p>\r\n\r\n<pre>\r\n[\r\n  [1,   4,  7, 11, 15],\r\n  [2,   5,  8, 12, 19],\r\n  [3,   6,  9, 16, 22],\r\n  [10, 13, 14, 17, 24],\r\n  [18, 21, 23, 26, 30]\r\n]\r\n</pre>\r\n\r\n<p>Given&nbsp;target&nbsp;=&nbsp;<code>5</code>, return&nbsp;<code>true</code>.</p>\r\n\r\n<p>Given&nbsp;target&nbsp;=&nbsp;<code>20</code>, return&nbsp;<code>false</code>.</p>\r\n",
    "tags": "Binary Search, Divide and Conquer",
    "difficulty": 2,
    "frontend_article_id": 240,
    "article_content": ""
},
{
    "frontend_question_id": 239,
    "article_live": false,
    "title": "Sliding Window Maximum",
    "title_slug": "sliding-window-maximum",
    "content": "<p>Given an array <em>nums</em>, there is a sliding window of size <em>k</em> which is moving from the very left of the array to the very right. You can only see the <em>k</em> numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> <em>nums</em> = <code>[1,3,-1,-3,5,3,6,7]</code>, and <em>k</em> = 3\r\n<strong>Output: </strong><code>[3,3,5,5,6,7] \r\n<strong>Explanation: \r\n</strong></code>\r\nWindow position                Max\r\n---------------               -----\r\n[1  3  -1] -3  5  3  6  7       <strong>3</strong>\r\n 1 [3  -1  -3] 5  3  6  7       <strong>3</strong>\r\n 1  3 [-1  -3  5] 3  6  7      <strong> 5</strong>\r\n 1  3  -1 [-3  5  3] 6  7       <strong>5</strong>\r\n 1  3  -1  -3 [5  3  6] 7       <strong>6</strong>\r\n 1  3  -1  -3  5 [3  6  7]      <strong>7</strong>\r\n</pre>\r\n\r\n<p><strong>Note: </strong><br />\r\nYou may assume <em>k</em> is always valid, 1 &le; k &le; input array&#39;s size for non-empty array.</p>\r\n\r\n<p><strong>Follow up:</strong><br />\r\nCould you solve it in linear time?</p>\r\n",
    "tags": "Heap",
    "difficulty": 3,
    "frontend_article_id": 239
},
{
    "frontend_question_id": 238,
    "article_live": false,
    "title": "Product of Array Except Self",
    "title_slug": "product-of-array-except-self",
    "content": "<p>Given an array <code>nums</code> of <em>n</em> integers where <em>n</em> &gt; 1, &nbsp;return an array <code>output</code> such that <code>output[i]</code> is equal to the product of all the elements of <code>nums</code> except <code>nums[i]</code>.</p>\r\n\r\n<p><b>Example:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b>  <code>[1,2,3,4]</code>\r\n<b>Output:</b> <code>[24,12,8,6]</code>\r\n</pre>\r\n\r\n<p><strong>Note: </strong>Please solve it <strong>without division</strong> and in O(<em>n</em>).</p>\r\n\r\n<p><strong>Follow up:</strong><br />\r\nCould you solve it with constant space complexity? (The output array <strong>does not</strong> count as extra space for the purpose of space complexity analysis.)</p>\r\n",
    "tags": "Array",
    "difficulty": 2,
    "frontend_article_id": 238
},
{
    "frontend_question_id": 237,
    "article_live": true,
    "article_slug": "delete-node-linked-list",
    "title": "Delete Node in a Linked List",
    "title_slug": "delete-node-in-a-linked-list",
    "content": "<p>Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.</p>\r\n\r\n<p>Given linked list --&nbsp;head =&nbsp;[4,5,1,9], which looks like following:</p>\r\n\r\n<pre>\r\n    4 -&gt; 5 -&gt; 1 -&gt; 9\r\n</pre>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> head = [4,5,1,9], node = 5\r\n<strong>Output:</strong> [4,1,9]\r\n<strong>Explanation: </strong>You are given the second node with value 5, the linked list\r\n&nbsp;            should become 4 -&gt; 1 -&gt; 9 after calling your function.\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> head = [4,5,1,9], node = 1\r\n<strong>Output:</strong> [4,5,9]\r\n<strong>Explanation: </strong>You are given the third node with value 1, the linked list\r\n             should become 4 -&gt; 5 -&gt; 9 after calling your function.\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>The linked list will have at least two elements.</li>\r\n\t<li>All of the nodes&#39; values will be unique.</li>\r\n\t<li>The given node&nbsp;will not be the tail and it will always be a valid node of the linked list.</li>\r\n\t<li>Do not return anything from your function.</li>\r\n</ul>\r\n",
    "tags": "Linked List",
    "difficulty": 1,
    "frontend_article_id": 237,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <h2 id=\"solution\">Solution</h2> \n  <h4 id=\"approach-swap-with-next-node-accepted\">Approach: Swap with Next Node [Accepted]</h4> \n  <p>The usual way of deleting a node <code>node</code> from a linked list is to modify the <code>next</code> pointer of the node <em>before</em> it, to point to the node <em>after</em> it.</p> \n  <p><img src=\"https://leetcode.com/media/original_images/237_LinkedList.png\" width=\"400\"></p> \n  <p>Since we do not have access to the node <em>before</em> the one we want to delete, we cannot modify the <code>next</code> pointer of that node in any way. Instead, we have to replace the value of the node we want to delete with the value in the node after it, and then delete the node after it.</p> \n  <p><img src=\"https://leetcode.com/media/original_images/237_LinkedList2.png\" width=\"400\"></p> \n  <p><img src=\"https://leetcode.com/media/original_images/237_LinkedList3.png\" width=\"400\"></p> \n  <p><img src=\"https://leetcode.com/media/original_images/237_LinkedList4.png\" width=\"330\"></p> \n  <p>Because we know that the node we want to delete is not the tail of the list, we can guarantee that this approach is possible.</p> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">deleteNode</span><span class=\"o\">(</span><span class=\"n\">ListNode</span> <span class=\"n\">node</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">val</span> <span class=\"o\">=</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">.</span><span class=\"na\">val</span><span class=\"o\">;</span>\n    <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <p>Time and space complexity are both <script type=\"math/tex; mode=display\">O(1)</script>.</p> \n  <p>Analysis written by: @noran</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 236,
    "article_live": false,
    "title": "Lowest Common Ancestor of a Binary Tree",
    "title_slug": "lowest-common-ancestor-of-a-binary-tree",
    "content": "<p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>\r\n\r\n<p>According to the <a href=\"https://en.wikipedia.org/wiki/Lowest_common_ancestor\" target=\"_blank\">definition of LCA on Wikipedia</a>: &ldquo;The lowest common ancestor is defined between two nodes p&nbsp;and q&nbsp;as the lowest node in T that has both p&nbsp;and q&nbsp;as descendants (where we allow <b>a node to be a descendant of itself</b>).&rdquo;</p>\r\n\r\n<p>Given the following binary tree:&nbsp; root =&nbsp;[3,5,1,6,2,0,8,null,null,7,4]</p>\r\n\r\n<pre>\r\n        _______3______\r\n       /              \\\r\n    ___5__          ___1__\r\n   /      \\        /      \\\r\n   6      _2       0       8\r\n         /  \\\r\n         7   4\r\n</pre>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\r\n<strong>Output:</strong> 3\r\n<strong>Explanation: </strong>The LCA of of nodes <code>5</code> and <code>1</code> is <code>3.</code>\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\r\n<strong>Output:</strong> 5\r\n<strong>Explanation: </strong>The LCA of nodes <code>5</code> and <code>4</code> is <code>5</code>, since a node can be a descendant of itself\r\n             according to the LCA definition.</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>All of the nodes&#39; values will be unique.</li>\r\n\t<li>p and q are different and both values will&nbsp;exist in the binary tree.</li>\r\n</ul>\r\n",
    "tags": "Tree",
    "difficulty": 2,
    "frontend_article_id": 236
},
{
    "frontend_question_id": 235,
    "article_live": false,
    "title": "Lowest Common Ancestor of a Binary Search Tree",
    "title_slug": "lowest-common-ancestor-of-a-binary-search-tree",
    "content": "<p>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.</p>\r\n\r\n<p>According to the <a href=\"https://en.wikipedia.org/wiki/Lowest_common_ancestor\" target=\"_blank\">definition of LCA on Wikipedia</a>: &ldquo;The lowest common ancestor is defined between two nodes p and q&nbsp;as the lowest node in T that has both p and q&nbsp;as descendants (where we allow <b>a node to be a descendant of itself</b>).&rdquo;</p>\r\n\r\n<p>Given binary search tree:&nbsp; root =&nbsp;[6,2,8,0,4,7,9,null,null,3,5]</p>\r\n\r\n<pre>\r\n        _______6______\r\n       /              \\\r\n    ___2__          ___8__\r\n   /      \\        /      \\\r\n   0      _4       7       9\r\n         /  \\\r\n         3   5\r\n</pre>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\r\n<strong>Output:</strong> 6\r\n<strong>Explanation: </strong>The LCA of nodes <code>2</code> and <code>8</code> is <code>6</code>.\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\r\n<strong>Output:</strong> 2\r\n<strong>Explanation: </strong>The LCA of nodes <code>2</code> and <code>4</code> is <code>2</code>, since a node can be a descendant of itself \r\n             according to the LCA definition.\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>All of the nodes&#39; values will be unique.</li>\r\n\t<li>p and q are different and both values will&nbsp;exist in the BST.</li>\r\n</ul>\r\n",
    "tags": "Tree",
    "difficulty": 1,
    "frontend_article_id": 235
},
{
    "frontend_question_id": 234,
    "article_live": false,
    "title": "Palindrome Linked List",
    "title_slug": "palindrome-linked-list",
    "content": "<p>Given a singly linked list, determine if it is a palindrome.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 1-&gt;2\r\n<strong>Output:</strong> false</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 1-&gt;2-&gt;2-&gt;1\r\n<strong>Output:</strong> true</pre>\r\n\r\n<p><b>Follow up:</b><br />\r\nCould you do it in O(n) time and O(1) space?</p>\r\n",
    "tags": "Linked List, Two Pointers",
    "difficulty": 1,
    "frontend_article_id": 234
},
{
    "frontend_question_id": 233,
    "article_live": true,
    "article_slug": "number-of-digit-one",
    "title": "Number of Digit One",
    "title_slug": "number-of-digit-one",
    "content": "<p>Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 13\r\n<strong>Output:</strong> 6 \r\n<strong>Explanation: </strong>Digit 1 occurred in the following numbers: 1, 10, 11, 12, 13.\r\n</pre>\r\n",
    "tags": "Math",
    "difficulty": 3,
    "frontend_article_id": 233,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute force [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-solve-it-mathematically-accepted\">Approach #2 Solve it mathematically [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute force [Time Limit Exceeded]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Do as directed in question.</p> \n  <p><strong>Algorithm</strong></p> \n  <ul> \n   <li>Iterate over <script type=\"math/tex; mode=display\">i</script> from <script type=\"math/tex; mode=display\">1</script> to <script type=\"math/tex; mode=display\">n</script>:</li> \n   <li>Convert <script type=\"math/tex; mode=display\">i</script> to string and count <script type=\"math/tex; mode=display\">\\text{'1'}</script> in each integer string</li> \n   <li>Add count of <script type=\"math/tex; mode=display\">\\text{'1'}</script> in each string to the sum, say <script type=\"math/tex; mode=display\">countr</script> </li> \n  </ul> \n  <iframe src=\"https://leetcode.com/playground/VwAzPgne/shared\" frameborder=\"0\" name=\"VwAzPgne\" width=\"100%\" height=\"207\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time complexity: <script type=\"math/tex; mode=display\">O(n*log_{10}(n))</script>.</li> \n   <li>We iterate from <script type=\"math/tex; mode=display\">1</script> to <script type=\"math/tex; mode=display\">n</script> </li> \n   <li> <p>In each iteration, we convert integer to string and count '1' in string which takes linear time in number of digits in <script type=\"math/tex; mode=display\">i</script>, which is <script type=\"math/tex; mode=display\">log_{10}(n)</script>.</p> </li> \n   <li> <p>Space complexity: <script type=\"math/tex; mode=display\">O(log_{10}(n))</script> Extra space for the countr and the converted string <script type=\"math/tex; mode=display\">\\text{str}</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-solve-it-mathematically-accepted\">Approach #2 Solve it mathematically [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>In Approach #1, we manually calculated the number of all the <script type=\"math/tex; mode=display\">'1'</script>s in the digits, but this is very slow. Hence, we need a way to find a pattern in the way <script type=\"math/tex; mode=display\">'1'</script>s (or for that matter any digit) appears in the numbers. We could then use the pattern to formulate the answer.</p> \n  <p>Consider the <script type=\"math/tex; mode=display\">1</script>s in <script type=\"math/tex; mode=display\">\\text{ones}</script> place , <script type=\"math/tex; mode=display\">\\text{tens}</script> place, <script type=\"math/tex; mode=display\">\\text{hundreds}</script> place and so on... An analysis has been performed in the following figure.</p> \n  <p align=\"center\"><img alt=\"Number of digit one\" src=\"../Figures/233/number_of_digit_one.png\" width=\"800px\"></p> \n  <p>From the figure, we can see that from digit '1' at <script type=\"math/tex; mode=display\">\\text{ones}</script> place repeat in group of 1 after interval of <script type=\"math/tex; mode=display\">10</script>. Similarly, '1' at <script type=\"math/tex; mode=display\">\\text{tens}</script> place repeat in group of 10 after interval of <script type=\"math/tex; mode=display\">100</script>. This can be formulated as <script type=\"math/tex; mode=display\">(n/(i*10))*i</script>.</p> \n  <p>Also, notice that if the digit at <script type=\"math/tex; mode=display\">\\text{tens}</script> place is <script type=\"math/tex; mode=display\">\\text{'1'}</script>, then the number of terms with <script type=\"math/tex; mode=display\">\\text{'1's}</script> is increased by <script type=\"math/tex; mode=display\">x+1</script>, if the number is say <script type=\"math/tex; mode=display\">\\text{\"ab1x\"}</script>. As if digits at <script type=\"math/tex; mode=display\">\\text{tens}</script> place is greater than <script type=\"math/tex; mode=display\">1</script>, then all the <script type=\"math/tex; mode=display\">10</script> occurances of numbers with <script type=\"math/tex; mode=display\">'1'</script> at <script type=\"math/tex; mode=display\">\\text{tens}</script> place have taken place, hence, we add <script type=\"math/tex; mode=display\">10</script>. This is formluated as <script type=\"math/tex; mode=display\">{\\min(\\max((\\text{n mod (i*10)} )-i+1,0),i)}</script>.</p> \n  <p>Lets take an example, say <script type=\"math/tex; mode=display\">n= 1234</script>.</p> \n  <p>No of <script type=\"math/tex; mode=display\">\\text{'1'}</script> in <script type=\"math/tex; mode=display\">\\text{ones}</script> place = <script type=\"math/tex; mode=display\">1234/10</script>(corresponding to 1,11,21,...1221) + <script type=\"math/tex; mode=display\">\\min(4,1)</script>(corresponding to 1231) =<script type=\"math/tex; mode=display\">124</script> </p> \n  <p>No of <script type=\"math/tex; mode=display\">\\text{'1'}</script> in <script type=\"math/tex; mode=display\">\\text{tens}</script> place = <script type=\"math/tex; mode=display\">(1234/100)*10</script>(corresponding to 10,11,12,...,110,111,...1919) +<script type=\"math/tex; mode=display\">\\min(21,10)</script>(corresponding to 1210,1211,...1219)=<script type=\"math/tex; mode=display\">130</script> </p> \n  <p>No of <script type=\"math/tex; mode=display\">\\text{'1'}</script> in <script type=\"math/tex; mode=display\">\\text{hundreds}</script> place = <script type=\"math/tex; mode=display\">(1234/1000)*100</script>(corresponding to 100,101,12,...,199) +<script type=\"math/tex; mode=display\">\\min(135,100)</script>(corresponding to 1100,1101...1199)=<script type=\"math/tex; mode=display\">200</script> </p> \n  <p>No of <script type=\"math/tex; mode=display\">\\text{'1'}</script> in <script type=\"math/tex; mode=display\">\\text{thousands}</script> place = <script type=\"math/tex; mode=display\">(1234/10000)*10000</script> +<script type=\"math/tex; mode=display\">\\min(235,1000)</script>(corresponding to 1000,1001,...1234)=<script type=\"math/tex; mode=display\">235</script> </p> \n  <p>Therefore, Total = <script type=\"math/tex; mode=display\">124+130+200+235 = 689</script>.</p> \n  <p>Herein, one formula has been devised, but many other formulae can be devised for faster implementations, but the essence and complexity remains the same. The users are encouraged to try to divise their own version of solution using the mathematical concepts.</p> \n  <p><strong>Algorithm</strong></p> \n  <ul> \n   <li>Iterate over <script type=\"math/tex; mode=display\">i</script> from <script type=\"math/tex; mode=display\">1</script> to <script type=\"math/tex; mode=display\">n</script> incrementing by <script type=\"math/tex; mode=display\">10</script> each time:</li> \n   <li>Add <script type=\"math/tex; mode=display\">(n/(i*10))*i</script> to <script type=\"math/tex; mode=display\">\\text{countr}</script> representing the repetition of groups of $$i$ sizes after each <script type=\"math/tex; mode=display\">(i*10)</script> interval.</li> \n   <li>Add <script type=\"math/tex; mode=display\">{\\min(\\max((\\text{n mod (i*10)} )-i+1,0),i)}</script> to <script type=\"math/tex; mode=display\">\\text{countr}</script> representing the additional digits dependant on the digit in <script type=\"math/tex; mode=display\">i</script>th place as described in intuition.</li> \n  </ul> \n  <iframe src=\"https://leetcode.com/playground/QVzpgtNB/shared\" frameborder=\"0\" name=\"QVzpgtNB\" width=\"100%\" height=\"207\"></iframe> \n  <p><strong>Complexity analysis</strong></p> \n  <ul> \n   <li>Time complexity: <script type=\"math/tex; mode=display\">O(log_{10}(n))</script>.</li> \n   <li> <p>No of iterations equal to the number of digits in n which is <script type=\"math/tex; mode=display\">log_{10}(n)</script> </p> </li> \n   <li> <p>Space complexity: <script type=\"math/tex; mode=display\">O(1)</script> space required.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by <a href=\"https://leetcode.com/abhinavbansal0\">@abhinavbansal0</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 232,
    "article_live": true,
    "article_slug": "implement-queue-using-stacks",
    "title": "Implement Queue using Stacks",
    "title_slug": "implement-queue-using-stacks",
    "content": "<p>Implement the following operations of a queue using stacks.</p>\r\n\r\n<ul>\r\n\t<li>push(x) -- Push element x to the back of queue.</li>\r\n\t<li>pop() -- Removes the element from in front of queue.</li>\r\n\t<li>peek() -- Get the front element.</li>\r\n\t<li>empty() -- Return whether the queue is empty.</li>\r\n</ul>\r\n\r\n<p><b>Example:</b></p>\r\n\r\n<pre>\r\nMyQueue queue = new MyQueue();\r\n\r\nqueue.push(1);\r\nqueue.push(2);  \r\nqueue.peek();  // returns 1\r\nqueue.pop();   // returns 1\r\nqueue.empty(); // returns false</pre>\r\n\r\n<p><b>Notes:</b></p>\r\n\r\n<ul>\r\n\t<li>You must use <i>only</i> standard operations of a stack -- which means only <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, and <code>is empty</code> operations are valid.</li>\r\n\t<li>Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.</li>\r\n\t<li>You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).</li>\r\n</ul>\r\n",
    "tags": "Stack, Design",
    "difficulty": 1,
    "frontend_article_id": 232,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#summary\">Summary</a></li> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-two-stacks-push-on-per-operation-pop-o1-per-operation\">Approach #1 (Two Stacks) Push - O(n) per operation, Pop - O(1) per operation.</a></li> \n      <li><a href=\"#approach-2-two-stacks-push-o1-per-operation-pop-amortized-o1-per-operation\">Approach #2 (Two Stacks) Push - O(1) per operation, Pop - Amortized O(1) per operation.</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"summary\">Summary</h2> \n  <p>This article is for beginners. It introduces the following ideas: Queue, Stack.</p> \n  <h2 id=\"solution\">Solution</h2> \n  <p>Queue is <strong>FIFO</strong> (first in - first out) data structure, in which the elements are inserted from one side - <code>rear</code> and removed from the other - <code>front</code>. The most intuitive way to implement it is with linked lists, but this article will introduce another approach using stacks. Stack is <strong>LIFO</strong> (last in - first out) data structure, in which elements are added and removed from the same end, called <code>top</code>. To satisfy <strong>FIFO</strong> property of a queue we need to keep two stacks. They serve to reverse arrival order of the elements and one of them store the queue elements in their final order.</p> \n  <hr> \n  <h4 id=\"approach-1-two-stacks-push-on-per-operation-pop-o1-per-operation\">Approach #1 (Two Stacks) Push - <script type=\"math/tex; mode=display\">O(n)</script> per operation, Pop - <script type=\"math/tex; mode=display\">O(1)</script> per operation.</h4> \n  <p><strong>Algorithm</strong></p> \n  <p><strong>Push</strong></p> \n  <p>A queue is FIFO (first-in-first-out) but a stack is LIFO (last-in-first-out). This means the newest element must be pushed to the bottom of the stack. To do so we first transfer all <code>s1</code> elements to auxiliary stack <code>s2</code>. Then the newly arrived element is pushed on top of <code>s2</code> and all its elements are popped and pushed to <code>s1</code>.</p> \n  <p align=\"center\"><img alt=\"Push an element in queue\" src=\"https://leetcode.com/media/original_images/232_queue_using_stacksBPush.png\" width=\"539px\"></p> \n  <p align=\"center\"><em>Figure 1. Push an element in queue</em></p> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">front</span><span class=\"o\">;</span>\n\n<span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">push</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">s1</span><span class=\"o\">.</span><span class=\"na\">empty</span><span class=\"o\">())</span>\n        <span class=\"n\">front</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">(!</span><span class=\"n\">s1</span><span class=\"o\">.</span><span class=\"na\">isEmpty</span><span class=\"o\">())</span>\n        <span class=\"n\">s2</span><span class=\"o\">.</span><span class=\"na\">push</span><span class=\"o\">(</span><span class=\"n\">s1</span><span class=\"o\">.</span><span class=\"na\">pop</span><span class=\"o\">());</span>\n    <span class=\"n\">s2</span><span class=\"o\">.</span><span class=\"na\">push</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">);</span>\n    <span class=\"k\">while</span> <span class=\"o\">(!</span><span class=\"n\">s2</span><span class=\"o\">.</span><span class=\"na\">isEmpty</span><span class=\"o\">())</span>\n        <span class=\"n\">s1</span><span class=\"o\">.</span><span class=\"na\">push</span><span class=\"o\">(</span><span class=\"n\">s2</span><span class=\"o\">.</span><span class=\"na\">pop</span><span class=\"o\">());</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>.</li> \n  </ul> \n  <p>Each element, with the exception of the newly arrived, is pushed and popped twice. The last inserted element is popped and pushed once. Therefore this gives <script type=\"math/tex; mode=display\">4 n + 2</script> operations where <script type=\"math/tex; mode=display\">n</script> is the queue size. The <code>push</code> and <code>pop</code> operations have <script type=\"math/tex; mode=display\">O(1)</script> time complexity.</p> \n  <ul> \n   <li>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. We need additional memory to store the queue elements</li> \n  </ul> \n  <p><strong>Pop</strong></p> \n  <p>The algorithm pops an element from the stack <code>s1</code>, because <code>s1</code> stores always on its top the first inserted element in the queue. The front element of the queue is kept as <code>front</code>.</p> \n  <p align=\"center\"><img alt=\"Pop an element from queue\" src=\"https://leetcode.com/media/original_images/232_queue_using_stacksBPop.png\" width=\"539px\"></p> \n  <p align=\"center\"><em>Figure 2. Pop an element from queue</em></p> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"c1\">// Removes the element from the front of queue.</span>\n<span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">pop</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"n\">s1</span><span class=\"o\">.</span><span class=\"na\">pop</span><span class=\"o\">();</span>\n    <span class=\"k\">if</span> <span class=\"o\">(!</span><span class=\"n\">s1</span><span class=\"o\">.</span><span class=\"na\">empty</span><span class=\"o\">())</span>\n        <span class=\"n\">front</span> <span class=\"o\">=</span> <span class=\"n\">s1</span><span class=\"o\">.</span><span class=\"na\">peek</span><span class=\"o\">();</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time complexity : <script type=\"math/tex; mode=display\">O(1)</script>.</li> \n   <li>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>.</li> \n  </ul> \n  <p><strong>Empty</strong></p> \n  <p>Stack <code>s1</code> contains all stack elements, so the algorithm checks <code>s1</code> size to return if the queue is empty.</p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"c1\">// Return whether the queue is empty.</span>\n<span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">empty</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">s1</span><span class=\"o\">.</span><span class=\"na\">isEmpty</span><span class=\"o\">();</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p>Time complexity : <script type=\"math/tex; mode=display\">O(1)</script>.</p> \n  <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>.</p> \n  <p><strong>Peek</strong></p> \n  <p>The <code>front</code> element is kept in constant memory and is modified when we push or pop an element.</p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"c1\">// Get the front element.</span>\n<span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">peek</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n  <span class=\"k\">return</span> <span class=\"n\">front</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p>Time complexity : <script type=\"math/tex; mode=display\">O(1)</script>. The <code>front</code> element has been calculated in advance and only returned in <code>peek</code> operation.</p> \n  <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>.</p> \n  <hr> \n  <h4 id=\"approach-2-two-stacks-push-o1-per-operation-pop-amortized-o1-per-operation\">Approach #2 (Two Stacks) Push - <script type=\"math/tex; mode=display\">O(1)</script> per operation, Pop - Amortized <script type=\"math/tex; mode=display\">O(1)</script> per operation.</h4> \n  <p><strong>Algorithm</strong></p> \n  <p><strong>Push</strong></p> \n  <p>The newly arrived element is always added on top of stack <code>s1</code> and the first element is kept as <code>front</code> queue element</p> \n  <p align=\"center\"><img alt=\"Push an element in queue\" src=\"https://leetcode.com/media/original_images/232_queue_using_stacksAPush.png\" width=\"539px\"></p> \n  <p align=\"center\"><em>Figure 3. Push an element in queue</em></p> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">private</span> <span class=\"n\">Stack</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">s1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Stack</span><span class=\"o\">&lt;&gt;();</span>\n<span class=\"kd\">private</span> <span class=\"n\">Stack</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">s2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Stack</span><span class=\"o\">&lt;&gt;();</span>\n\n<span class=\"c1\">// Push element x to the back of queue.</span>\n<span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">push</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">s1</span><span class=\"o\">.</span><span class=\"na\">empty</span><span class=\"o\">())</span>\n        <span class=\"n\">front</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">;</span>\n    <span class=\"n\">s1</span><span class=\"o\">.</span><span class=\"na\">push</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">);</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time complexity : <script type=\"math/tex; mode=display\">O(1)</script>.</li> \n  </ul> \n  <p>Аppending an element to a stack is an O(1) operation.</p> \n  <ul> \n   <li>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. We need additional memory to store the queue elements</li> \n  </ul> \n  <p><strong>Pop</strong></p> \n  <p>We have to remove element in front of the queue. This is the first inserted element in the stack <code>s1</code> and it is positioned at the bottom of the stack because of stack's <code>LIFO (last in - first out)</code> policy. To remove the bottom element from <code>s1</code>, we have to pop all elements from <code>s1</code> and to push them on to an additional stack <code>s2</code>, which helps us to store the elements of <code>s1</code> in reversed order. This way the bottom element of <code>s1</code> will be positioned on top of <code>s2</code> and we can simply pop it from stack <code>s2</code>. Once <code>s2</code> is empty, the algorithm transfer data from <code>s1</code> to <code>s2</code> again.</p> \n  <p align=\"center\"><img alt=\"Pop an element from stack\" src=\"https://leetcode.com/media/original_images/232_queue_using_stacksAPop.png\" width=\"539px\"></p> \n  <p align=\"center\"><em>Figure 4. Pop an element from stack</em></p> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"c1\">// Removes the element from in front of queue.</span>\n<span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">pop</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">s2</span><span class=\"o\">.</span><span class=\"na\">isEmpty</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n        <span class=\"k\">while</span> <span class=\"o\">(!</span><span class=\"n\">s1</span><span class=\"o\">.</span><span class=\"na\">isEmpty</span><span class=\"o\">())</span>\n            <span class=\"n\">s2</span><span class=\"o\">.</span><span class=\"na\">push</span><span class=\"o\">(</span><span class=\"n\">s1</span><span class=\"o\">.</span><span class=\"na\">pop</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n    <span class=\"n\">s2</span><span class=\"o\">.</span><span class=\"na\">pop</span><span class=\"o\">();</span>    \n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time complexity: Amortized <script type=\"math/tex; mode=display\">O(1)</script>, Worst-case <script type=\"math/tex; mode=display\">O(n)</script>.</li> \n  </ul> \n  <p>In the worst case scenario when stack <code>s2</code> is empty, the algorithm pops <script type=\"math/tex; mode=display\">n</script> elements from stack s1 and pushes <script type=\"math/tex; mode=display\">n</script> elements to <code>s2</code>, where <script type=\"math/tex; mode=display\">n</script> is the queue size. This gives <script type=\"math/tex; mode=display\">2n</script> operations, which is <script type=\"math/tex; mode=display\">O(n)</script>. But when stack <code>s2</code> is not empty the algorithm has <script type=\"math/tex; mode=display\">O(1)</script> time complexity. So what does it mean by Amortized <script type=\"math/tex; mode=display\">O(1)</script>? Please see the next section on Amortized Analysis for more information.</p> \n  <ul> \n   <li>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>.</li> \n  </ul> \n  <p><strong>Amortized Analysis</strong></p> \n  <p>Amortized analysis gives the average performance (over time) of each operation in the worst case. The basic idea is that a worst case operation can alter the state in such a way that the worst case cannot occur again for a long time, thus amortizing its cost.</p> \n  <p>Consider this example where we start with an empty queue with the following sequence of operations applied:</p> \n  <p> <script type=\"math/tex; mode=display\">\npush_1, push_2, \\ldots, push_n, pop_1,pop_2 \\ldots, pop_n\n</script> </p> \n  <p>The worst case time complexity of a single pop operation is <script type=\"math/tex; mode=display\">O(n)</script>. Since we have <script type=\"math/tex; mode=display\">n</script> pop operations, using the worst-case per operation analysis gives us a total of <script type=\"math/tex; mode=display\">O(n^2)</script> time.</p> \n  <p>However, in a sequence of operations the worst case does not occur often in each operation - some operations may be cheap, some may be expensive. Therefore, a traditional worst-case per operation analysis can give overly pessimistic bound. For example, in a dynamic array only some inserts take a linear time, though others - a constant time.</p> \n  <p>In the example above, the number of times pop operation can be called is limited by the number of push operations before it. Although a single pop operation could be expensive, it is expensive only once per <code>n</code> times (queue size), when <code>s2</code> is empty and there is a need for data transfer between <code>s1</code> and <code>s2</code>. Hence the total time complexity of the sequence is : <code>n</code> (for push operations) + <code>2*n</code> (for first pop operation) + <code>n - 1</code> ( for pop operations) which is <script type=\"math/tex; mode=display\">O(2*n)</script>.This gives <script type=\"math/tex; mode=display\">O(2n/2n)</script> = <script type=\"math/tex; mode=display\">O(1)</script> average time per operation.</p> \n  <p><strong>Empty</strong></p> \n  <p>Both stacks <code>s1</code> and <code>s2</code> contain all stack elements, so the algorithm checks <code>s1</code> and <code>s2</code> size to return if the queue is empty.</p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"c1\">// Return whether the queue is empty.</span>\n<span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">empty</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">s1</span><span class=\"o\">.</span><span class=\"na\">isEmpty</span><span class=\"o\">()</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">s2</span><span class=\"o\">.</span><span class=\"na\">isEmpty</span><span class=\"o\">();</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p>Time complexity : <script type=\"math/tex; mode=display\">O(1)</script>.</p> \n  <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>.</p> \n  <p><strong>Peek</strong></p> \n  <p>The <code>front</code> element is kept in constant memory and is modified when we push an element. When <code>s2</code> is not empty, front element is positioned on the top of <code>s2</code></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"c1\">// Get the front element.</span>\n<span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">peek</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(!</span><span class=\"n\">s2</span><span class=\"o\">.</span><span class=\"na\">isEmpty</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n            <span class=\"k\">return</span> <span class=\"n\">s2</span><span class=\"o\">.</span><span class=\"na\">peek</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">front</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p>Time complexity : <script type=\"math/tex; mode=display\">O(1)</script>.</p> \n  <p>The <code>front</code> element was either previously calculated or returned as a top element of stack <code>s2</code>. Therefore complexity is <script type=\"math/tex; mode=display\">O(1)</script> </p> \n  <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>.</p> \n  <p>Analysis written by: @elmirap.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 231,
    "article_live": false,
    "title": "Power of Two",
    "title_slug": "power-of-two",
    "content": "<p>Given an integer, write a function to determine if it is a power of two.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 1\r\n<strong>Output:</strong> true \r\n<strong>Explanation: </strong>2<sup>0</sup>&nbsp;= 1\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 16\r\n<strong>Output:</strong> true\r\n<strong>Explanation: </strong>2<sup>4</sup>&nbsp;= 16</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 218\r\n<strong>Output:</strong> false</pre>\r\n",
    "tags": "Math, Bit Manipulation",
    "difficulty": 1,
    "frontend_article_id": 231
},
{
    "frontend_question_id": 230,
    "article_live": false,
    "title": "Kth Smallest Element in a BST",
    "title_slug": "kth-smallest-element-in-a-bst",
    "content": "<p>Given a binary search tree, write a function <code>kthSmallest</code> to find the <b>k</b>th smallest element in it.</p>\r\n\r\n<p><b>Note: </b><br />\r\nYou may assume k is always valid, 1 &le; k &le; BST&#39;s total elements.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> root = [3,1,4,null,2], k = 1\r\n   3\r\n  / \\\r\n 1   4\r\n  \\\r\n&nbsp;  2\r\n<strong>Output:</strong> 1</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> root = [5,3,6,2,4,null,null,1], k = 3\r\n       5\r\n      / \\\r\n     3   6\r\n    / \\\r\n   2   4\r\n  /\r\n 1\r\n<strong>Output:</strong> 3\r\n</pre>\r\n\r\n<p><b>Follow up:</b><br />\r\nWhat if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?</p>\r\n",
    "tags": "Binary Search, Tree",
    "difficulty": 2,
    "frontend_article_id": 230
},
{
    "frontend_question_id": 229,
    "article_live": false,
    "title": "Majority Element II",
    "title_slug": "majority-element-ii",
    "content": "<p>Given an integer array of size <i>n</i>, find all elements that appear more than <code>&lfloor; n/3 &rfloor;</code> times.</p>\r\n\r\n<p><strong>Note: </strong>The algorithm should run in linear time and in O(1) space.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [3,2,3]\r\n<strong>Output:</strong> [3]</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [1,1,1,3,3,2,2,2]\r\n<strong>Output:</strong> [1,2]</pre>\r\n",
    "tags": "Array",
    "difficulty": 2,
    "frontend_article_id": 229
},
{
    "frontend_question_id": 228,
    "article_live": true,
    "article_slug": "summary-ranges",
    "title": "Summary Ranges",
    "title_slug": "summary-ranges",
    "content": "<p>Given a sorted integer array without duplicates, return the summary of its ranges.</p>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b>  [0,1,2,4,5,7]\r\n<b>Output:</b> [&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;]\r\n<strong>Explanation: </strong>0,1,2 form a continuous range;&nbsp;4,5 form a continuous range.\r\n</pre>\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b>  [0,2,3,4,6,8,9]\r\n<b>Output:</b> [&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;]\r\n<strong>Explanation: </strong>2,3,4 form a continuous range;&nbsp;8,9 form a continuous range.\r\n</pre>\r\n",
    "tags": "Array",
    "difficulty": 2,
    "frontend_article_id": 228,
    "article_content": ""
},
{
    "frontend_question_id": 227,
    "article_live": false,
    "title": "Basic Calculator II",
    "title_slug": "basic-calculator-ii",
    "content": "<p>Implement a basic calculator to evaluate a simple expression string.</p>\r\n\r\n<p>The expression string contains only <b>non-negative</b> integers, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> operators and empty spaces <code> </code>. The integer division should truncate toward zero.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>&quot;3+2*2&quot;\r\n<strong>Output:</strong> 7\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> &quot; 3/2 &quot;\r\n<strong>Output:</strong> 1</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> &quot; 3+5 / 2 &quot;\r\n<strong>Output:</strong> 5\r\n</pre>\r\n\r\n<p><b>Note:</b></p>\r\n\r\n<ul>\r\n\t<li>You may assume that the given expression is always valid.</li>\r\n\t<li><b>Do not</b> use the <code>eval</code> built-in library function.</li>\r\n</ul>",
    "tags": "String",
    "difficulty": 2,
    "frontend_article_id": 227
},
{
    "frontend_question_id": 226,
    "article_live": true,
    "article_slug": "invert-binary-tree",
    "title": "Invert Binary Tree",
    "title_slug": "invert-binary-tree",
    "content": "<p>Invert a binary tree.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<p>Input:</p>\r\n\r\n<pre>\r\n     4\r\n   /   \\\r\n  2     7\r\n / \\   / \\\r\n1   3 6   9</pre>\r\n\r\n<p>Output:</p>\r\n\r\n<pre>\r\n     4\r\n   /   \\\r\n  7     2\r\n / \\   / \\\r\n9   6 3   1</pre>\r\n\r\n<p><strong>Trivia:</strong><br />\r\nThis problem was inspired by <a href=\"https://twitter.com/mxcl/status/608682016205344768\" target=\"_blank\">this original tweet</a> by <a href=\"https://twitter.com/mxcl\" target=\"_blank\">Max Howell</a>:</p>\r\n\r\n<blockquote>Google: 90% of our engineers use the software you wrote (Homebrew), but you can&rsquo;t invert a binary tree on a whiteboard so f*** off.</blockquote>\r\n",
    "tags": "Tree",
    "difficulty": 1,
    "frontend_article_id": 226,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-recursive-accepted\">Approach #1 (Recursive) [Accepted]</a></li> \n      <li><a href=\"#approach-2-iterative-accepted\">Approach #2 (Iterative) [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-recursive-accepted\">Approach #1 (Recursive) [Accepted]</h4> \n  <p>This is a classic tree problem that is best-suited for a recursive approach.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>The inverse of an empty tree is the empty tree. The inverse of a tree with root <script type=\"math/tex; mode=display\">r</script>, and subtrees <script type=\"math/tex; mode=display\">\\mbox{right}</script> and <script type=\"math/tex; mode=display\">\\mbox{left}</script>, is a tree with root <script type=\"math/tex; mode=display\">r</script>, whose right subtree is the inverse of <script type=\"math/tex; mode=display\">\\mbox{left}</script>, and whose left subtree is the inverse of <script type=\"math/tex; mode=display\">\\mbox{right}</script>.</p> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">public</span> <span class=\"n\">TreeNode</span> <span class=\"nf\">invertTree</span><span class=\"o\">(</span><span class=\"n\">TreeNode</span> <span class=\"n\">root</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">root</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"n\">TreeNode</span> <span class=\"n\">right</span> <span class=\"o\">=</span> <span class=\"n\">invertTree</span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"o\">.</span><span class=\"na\">right</span><span class=\"o\">);</span>\n    <span class=\"n\">TreeNode</span> <span class=\"n\">left</span> <span class=\"o\">=</span> <span class=\"n\">invertTree</span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"o\">.</span><span class=\"na\">left</span><span class=\"o\">);</span>\n    <span class=\"n\">root</span><span class=\"o\">.</span><span class=\"na\">left</span> <span class=\"o\">=</span> <span class=\"n\">right</span><span class=\"o\">;</span>\n    <span class=\"n\">root</span><span class=\"o\">.</span><span class=\"na\">right</span> <span class=\"o\">=</span> <span class=\"n\">left</span><span class=\"o\">;</span>\n    <span class=\"k\">return</span> <span class=\"n\">root</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <p>Since each node in the tree is visited only once, the time complexity is <script type=\"math/tex; mode=display\">O(n)</script>, where <script type=\"math/tex; mode=display\">n</script> is the number of nodes in the tree. We cannot do better than that, since at the very least we have to visit each node to invert it.</p> \n  <p>Because of recursion, <script type=\"math/tex; mode=display\">O(h)</script> function calls will be placed on the stack in the worst case, where <script type=\"math/tex; mode=display\">h</script> is the height of the tree. Because <script type=\"math/tex; mode=display\">h\\in O(n)</script>, the space complexity is <script type=\"math/tex; mode=display\">O(n)</script>.</p> \n  <hr> \n  <h4 id=\"approach-2-iterative-accepted\">Approach #2 (Iterative) [Accepted]</h4> \n  <p>Alternatively, we can solve the problem iteratively, in a manner similar to breadth-first search.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>The idea is that we need to swap the left and right child of all nodes in the tree. So we create a queue to store nodes whose left and right child have not been swapped yet. Initially, only the root is in the queue. As long as the queue is not empty, remove the next node from the queue, swap its children, and add the children to the queue. Null nodes are not added to the queue. Eventually, the queue will be empty and all the children swapped, and we return the original root.</p> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">public</span> <span class=\"n\">TreeNode</span> <span class=\"nf\">invertTree</span><span class=\"o\">(</span><span class=\"n\">TreeNode</span> <span class=\"n\">root</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">root</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n    <span class=\"n\">Queue</span><span class=\"o\">&lt;</span><span class=\"n\">TreeNode</span><span class=\"o\">&gt;</span> <span class=\"n\">queue</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">LinkedList</span><span class=\"o\">&lt;</span><span class=\"n\">TreeNode</span><span class=\"o\">&gt;();</span>\n    <span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"o\">);</span>\n    <span class=\"k\">while</span> <span class=\"o\">(!</span><span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"na\">isEmpty</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n        <span class=\"n\">TreeNode</span> <span class=\"n\">current</span> <span class=\"o\">=</span> <span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"na\">poll</span><span class=\"o\">();</span>\n        <span class=\"n\">TreeNode</span> <span class=\"n\">temp</span> <span class=\"o\">=</span> <span class=\"n\">current</span><span class=\"o\">.</span><span class=\"na\">left</span><span class=\"o\">;</span>\n        <span class=\"n\">current</span><span class=\"o\">.</span><span class=\"na\">left</span> <span class=\"o\">=</span> <span class=\"n\">current</span><span class=\"o\">.</span><span class=\"na\">right</span><span class=\"o\">;</span>\n        <span class=\"n\">current</span><span class=\"o\">.</span><span class=\"na\">right</span> <span class=\"o\">=</span> <span class=\"n\">temp</span><span class=\"o\">;</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">current</span><span class=\"o\">.</span><span class=\"na\">left</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">current</span><span class=\"o\">.</span><span class=\"na\">left</span><span class=\"o\">);</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">current</span><span class=\"o\">.</span><span class=\"na\">right</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">current</span><span class=\"o\">.</span><span class=\"na\">right</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">root</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <p>Since each node in the tree is visited / added to the queue only once, the time complexity is <script type=\"math/tex; mode=display\">O(n)</script>, where <script type=\"math/tex; mode=display\">n</script> is the number of nodes in the tree.</p> \n  <p>Space complexity is <script type=\"math/tex; mode=display\">O(n)</script>, since in the worst case, the queue will contain all nodes in one level of the binary tree. For a full binary tree, the leaf level has <script type=\"math/tex; mode=display\">\\lceil \\frac{n}{2}\\rceil=O(n)</script> leaves.</p> \n  <p>Analysis written by: @noran</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 225,
    "article_live": true,
    "article_slug": "implement-stack-using-queues",
    "title": "Implement Stack using Queues",
    "title_slug": "implement-stack-using-queues",
    "content": "<p>Implement the following operations of a stack using queues.</p>\r\n\r\n<ul>\r\n\t<li>push(x) -- Push element x onto stack.</li>\r\n\t<li>pop() -- Removes the element on top of the stack.</li>\r\n\t<li>top() -- Get the top element.</li>\r\n\t<li>empty() -- Return whether the stack is empty.</li>\r\n</ul>\r\n\r\n<p><b>Example:</b></p>\r\n\r\n<pre>\r\nMyStack stack = new MyStack();\r\n\r\nstack.push(1);\r\nstack.push(2);  \r\nstack.top();   // returns 2\r\nstack.pop();   // returns 2\r\nstack.empty(); // returns false</pre>\r\n\r\n<p><b>Notes:</b></p>\r\n\r\n<ul>\r\n\t<li>You must use <i>only</i> standard operations of a queue -- which means only <code>push to back</code>, <code>peek/pop from front</code>, <code>size</code>, and <code>is empty</code> operations are valid.</li>\r\n\t<li>Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.</li>\r\n\t<li>You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).</li>\r\n</ul>\r\n",
    "tags": "Stack, Design",
    "difficulty": 1,
    "frontend_article_id": 225,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#summary\">Summary</a></li> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-two-queues-push-o1-pop-on\">Approach #1 (Two Queues, push - O(1), pop O(n) )</a></li> \n      <li><a href=\"#approach-2-two-queues-push-on-pop-o1\">Approach #2 (Two Queues, push - O(n), pop O(1) )</a></li> \n      <li><a href=\"#approach-3-one-queue-push-on-pop-o1\">Approach #3 (One Queue, push - O(n), pop O(1) )</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"summary\">Summary</h2> \n  <p>This article is for beginners. It introduces the following ideas: Stack, Queue.</p> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-two-queues-push-o1-pop-on\">Approach #1 (Two Queues, push - <script type=\"math/tex; mode=display\">O(1)</script>, pop <script type=\"math/tex; mode=display\">O(n)</script> )</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Stack is <strong>LIFO</strong> (last in - first out) data structure, in which elements are added and removed from the same end, called <code>top</code>. In general stack is implemented using array or linked list, but in the current article we will review a different approach for implementing stack using queues. In contrast queue is <strong>FIFO</strong> (first in - first out) data structure, in which elements are added only from the one side - <code>rear</code> and removed from the other - <code>front</code>. In order to implement stack using queues, we need to maintain two queues <code>q1</code> and <code>q2</code>. Also we will keep top stack element in a constant memory.</p> \n  <p><strong>Algorithm</strong></p> \n  <p><strong>Push</strong></p> \n  <p>The new element is always added to the rear of queue <code>q1</code> and it is kept as <code>top</code> stack element</p> \n  <p align=\"center\"><img alt=\"Push an element in stack\" src=\"https://leetcode.com/media/original_images/225_stack_using_queues_pushA.png\" width=\"539px\"></p> \n  <p align=\"center\"><em>Figure 1. Push an element in stack</em></p> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">private</span> <span class=\"n\">Queue</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">q1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">LinkedList</span><span class=\"o\">&lt;&gt;();</span>\n<span class=\"kd\">private</span> <span class=\"n\">Queue</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">q2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">LinkedList</span><span class=\"o\">&lt;&gt;();</span>\n<span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">top</span><span class=\"o\">;</span>\n\n<span class=\"c1\">// Push element x onto stack.</span>\n<span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">push</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">q1</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">);</span>\n    <span class=\"n\">top</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Queue is implemented as linked list and <code>add</code> operation has <script type=\"math/tex; mode=display\">O(1)</script> time complexity.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script> </p> </li> \n  </ul> \n  <p><strong>Pop</strong></p> \n  <p>We need to remove the element from the top of the stack. This is the last inserted element in <code>q1</code>. Because queue is FIFO (first in - first out) data structure, the last inserted element could be removed only after all elements, except it, have been removed. For this reason we need to maintain additional queue <code>q2</code>, which will serve as a temporary storage to enqueue the removed elements from q1. The last inserted element in <code>q2</code> is kept as top. Then the algorithm removes the last element in <code>q1</code>. We swap <code>q1</code> with <code>q2</code> to avoid copying all elements from <code>q2</code> to <code>q1</code>.</p> \n  <p align=\"center\"><img alt=\"Pop an element from stack\" src=\"https://leetcode.com/media/original_images/225_stack_using_queues_popA.png\" width=\"539px\"></p> \n  <p align=\"center\"><em>Figure 2. Pop an element from stack</em></p> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"c1\">// Removes the element on top of the stack.</span>\n<span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">pop</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">q1</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">()</span> <span class=\"o\">&gt;</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">top</span> <span class=\"o\">=</span> <span class=\"n\">q1</span><span class=\"o\">.</span><span class=\"na\">remove</span><span class=\"o\">();</span>\n        <span class=\"n\">q2</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">top</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n    <span class=\"n\">q1</span><span class=\"o\">.</span><span class=\"na\">remove</span><span class=\"o\">();</span>\n    <span class=\"n\">Queue</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">temp</span> <span class=\"o\">=</span> <span class=\"n\">q1</span><span class=\"o\">;</span>\n    <span class=\"n\">q1</span> <span class=\"o\">=</span> <span class=\"n\">q2</span><span class=\"o\">;</span>\n    <span class=\"n\">q2</span> <span class=\"o\">=</span> <span class=\"n\">temp</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The algorithm dequeues n elements from <code>q1</code> and enqueues <script type=\"math/tex; mode=display\">n - 1</script> elements to <code>q2</code>, where <script type=\"math/tex; mode=display\">n</script> is the stack size. This gives <script type=\"math/tex; mode=display\">2n - 1</script> operations.</li> \n   <li>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>.</li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-two-queues-push-on-pop-o1\">Approach #2 (Two Queues, push - <script type=\"math/tex; mode=display\">O(n)</script>, pop <script type=\"math/tex; mode=display\">O(1)</script> )</h4> \n  <p><strong>Algorithm</strong></p> \n  <p><strong>Push</strong></p> \n  <p>The algorithm inserts each new element to queue <code>q2</code> and keep it as the <code>top</code> element. In case queue <code>q1</code> is not empty (there are elements in the stack), we remove all elements from <code>q1</code> and add them to <code>q2</code>. In this way the new inserted element (<code>top</code> element in the stack) will be always positioned at the front of <code>q2</code>. We swap <code>q1</code> with <code>q2</code> to avoid copying all elements from <code>q2</code> to <code>q1</code>.</p> \n  <p align=\"center\"><img alt=\"Push an element in stack\" src=\"https://leetcode.com/media/original_images/225_stack_using_queues_pushB.png\" width=\"539px\"></p> \n  <p align=\"center\"><em>Figure 3. Push an element in stack</em></p> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">push</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">q2</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">);</span>\n    <span class=\"n\">top</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">(!</span><span class=\"n\">q1</span><span class=\"o\">.</span><span class=\"na\">isEmpty</span><span class=\"o\">())</span> <span class=\"o\">{</span>                \n        <span class=\"n\">q2</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">q1</span><span class=\"o\">.</span><span class=\"na\">remove</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n    <span class=\"n\">Queue</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">temp</span> <span class=\"o\">=</span> <span class=\"n\">q1</span><span class=\"o\">;</span>\n    <span class=\"n\">q1</span> <span class=\"o\">=</span> <span class=\"n\">q2</span><span class=\"o\">;</span>\n    <span class=\"n\">q2</span> <span class=\"o\">=</span> <span class=\"n\">temp</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The algorithm removes n elements from <code>q1</code> and inserts <script type=\"math/tex; mode=display\">n + 1</script> elements to <code>q2</code>, where n is the stack size. This gives <script type=\"math/tex; mode=display\">2n + 1</script> operations. The operations <code>add</code> and <code>remove</code> in linked lists has <script type=\"math/tex; mode=display\">O(1)</script> complexity.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n  </ul> \n  <p><strong>Pop</strong></p> \n  <p>The algorithm dequeues an element from queue <code>q1</code> and keeps front element of <code>q1</code> as <code>top</code>.</p> \n  <p align=\"center\"><img alt=\"Pop an element from stack\" src=\"https://leetcode.com/media/original_images/225_stack_using_queues_popB.png\" width=\"539px\"></p> \n  <p align=\"center\"><em>Figure 4. Pop an element from stack</em></p> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"c1\">// Removes the element on top of the stack.</span>\n<span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">pop</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"n\">q1</span><span class=\"o\">.</span><span class=\"na\">remove</span><span class=\"o\">();</span>\n    <span class=\"k\">if</span> <span class=\"o\">(!</span><span class=\"n\">q1</span><span class=\"o\">.</span><span class=\"na\">isEmpty</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n        <span class=\"n\">top</span> <span class=\"o\">=</span> <span class=\"n\">q1</span><span class=\"o\">.</span><span class=\"na\">peek</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time complexity : <script type=\"math/tex; mode=display\">O(1)</script>.</li> \n   <li>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>.</li> \n  </ul> \n  <p>In both approaches <code>empty</code> and <code>top</code> operations have the same implementation.</p> \n  <p><strong>Empty</strong></p> \n  <p>Queue <code>q1</code> always contains all stack elements, so the algorithm checks <code>q1</code> size to return if the stack is empty.</p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"c1\">// Return whether the stack is empty.</span>\n<span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">empty</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">q1</span><span class=\"o\">.</span><span class=\"na\">isEmpty</span><span class=\"o\">();</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p>Time complexity : <script type=\"math/tex; mode=display\">O(1)</script>.</p> \n  <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>.</p> \n  <p><strong>Top</strong></p> \n  <p>The <code>top</code> element is kept in constant memory and is modified each time when we push or pop an element.</p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"c1\">// Get the top element.</span>\n<span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">top</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">top</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p>Time complexity : <script type=\"math/tex; mode=display\">O(1)</script>. The <code>top</code> element has been calculated in advance and only returned in <code>top</code> operation.</p> \n  <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>.</p> \n  <hr> \n  <h4 id=\"approach-3-one-queue-push-on-pop-o1\">Approach #3 (One Queue, push - <script type=\"math/tex; mode=display\">O(n)</script>, pop <script type=\"math/tex; mode=display\">O(1)</script> )</h4> \n  <p>The mentioned above two approaches have one weakness, they use two queues. This could be optimized as we use only one queue, instead of two.</p> \n  <p><strong>Algorithm</strong></p> \n  <p><strong>Push</strong></p> \n  <p>When we push an element into a queue, it will be stored at back of the queue due to queue's properties. But we need to implement a stack, where last inserted element should be in the front of the queue, not at the back. To achieve this we can invert the order of queue elements when pushing a new element.</p> \n  <p align=\"center\"><img alt=\"Push an element in stack\" src=\"https://leetcode.com/media/original_images/225_stack_using_queues_pushC.png\" width=\"539px\"></p> \n  <p align=\"center\"><em>Figure 5. Push an element in stack</em></p> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">private</span> <span class=\"n\">LinkedList</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">q1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">LinkedList</span><span class=\"o\">&lt;&gt;();</span>\n\n<span class=\"c1\">// Push element x onto stack.</span>\n<span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">push</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">q1</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">);</span>\n    <span class=\"kt\">int</span> <span class=\"n\">sz</span> <span class=\"o\">=</span> <span class=\"n\">q1</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">();</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">sz</span> <span class=\"o\">&gt;</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">q1</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">q1</span><span class=\"o\">.</span><span class=\"na\">remove</span><span class=\"o\">());</span>\n        <span class=\"n\">sz</span><span class=\"o\">--;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The algorithm removes n elements and inserts <script type=\"math/tex; mode=display\">n + 1</script> elements to <code>q1</code> , where n is the stack size. This gives <script type=\"math/tex; mode=display\">2n + 1</script> operations. The operations <code>add</code> and <code>remove</code> in linked lists has <script type=\"math/tex; mode=display\">O(1)</script> complexity.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n  </ul> \n  <p><strong>Pop</strong></p> \n  <p>The last inserted element is always stored at the front of <code>q1</code> and we can pop it for constant time.</p> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"c1\">// Removes the element on top of the stack.</span>\n<span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">pop</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"n\">q1</span><span class=\"o\">.</span><span class=\"na\">remove</span><span class=\"o\">();</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time complexity : <script type=\"math/tex; mode=display\">O(1)</script>.</li> \n   <li>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>.</li> \n  </ul> \n  <p><strong>Empty</strong></p> \n  <p>Queue <code>q1</code> contains all stack elements, so the algorithm checks if <code>q1</code> is empty.</p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"c1\">// Return whether the stack is empty.</span>\n<span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">empty</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">q1</span><span class=\"o\">.</span><span class=\"na\">isEmpty</span><span class=\"o\">();</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p>Time complexity : <script type=\"math/tex; mode=display\">O(1)</script>.</p> \n  <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>.</p> \n  <p><strong>Top</strong></p> \n  <p>The <code>top</code> element is always positioned at the front of <code>q1</code>. Algorithm return it.</p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"c1\">// Get the top element.</span>\n<span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">top</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">q1</span><span class=\"o\">.</span><span class=\"na\">peek</span><span class=\"o\">();</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p>Time complexity : <script type=\"math/tex; mode=display\">O(1)</script>.</p> \n  <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>.</p> \n  <p>Analysis written by: @elmirap.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 224,
    "article_live": false,
    "title": "Basic Calculator",
    "title_slug": "basic-calculator",
    "content": "<p>Implement a basic calculator to evaluate a simple expression string.</p>\r\n\r\n<p>The expression string may contain open <code>(</code> and closing parentheses <code>)</code>, the plus <code>+</code> or minus sign <code>-</code>, <b>non-negative</b> integers and empty spaces <code> </code>.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> &quot;1 + 1&quot;\r\n<strong>Output:</strong> 2\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> &quot; 2-1 + 2 &quot;\r\n<strong>Output:</strong> 3</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> &quot;(1+(4+5+2)-3)+(6+8)&quot;\r\n<strong>Output:</strong> 23</pre>\r\n<b>Note:</b>\r\n\r\n<ul>\r\n\t<li>You may assume that the given expression is always valid.</li>\r\n\t<li><b>Do not</b> use the <code>eval</code> built-in library function.</li>\r\n</ul>\r\n",
    "tags": "Math, Stack",
    "difficulty": 3,
    "frontend_article_id": 224
},
{
    "frontend_question_id": 223,
    "article_live": false,
    "title": "Rectangle Area",
    "title_slug": "rectangle-area",
    "content": "<p>Find the total area covered by two <strong>rectilinear</strong> rectangles in a <strong>2D</strong> plane.</p>\r\n\r\n<p>Each rectangle is defined by its bottom left corner and top right corner as shown in the figure.</p>\r\n\r\n<p><img alt=\"Rectangle Area\" src=\"https://assets.leetcode.com/uploads/2018/10/22/rectangle_area.png\" style=\"width: 542px; height: 304px;\" /></p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>A = <span id=\"example-input-1-1\">-3</span>, B = <span id=\"example-input-1-2\">0</span>, C = <span id=\"example-input-1-3\">3</span>, D = <span id=\"example-input-1-4\">4</span>, E = <span id=\"example-input-1-5\">0</span>, F = <span id=\"example-input-1-6\">-1</span>, G = <span id=\"example-input-1-7\">9</span>, H = <span id=\"example-input-1-8\">2</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">45</span></pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<p>Assume that the total area is never beyond the maximum possible value of <strong>int</strong>.</p>\r\n",
    "tags": "Math",
    "difficulty": 2,
    "frontend_article_id": 223
},
{
    "frontend_question_id": 222,
    "article_live": false,
    "title": "Count Complete Tree Nodes",
    "title_slug": "count-complete-tree-nodes",
    "content": "<p>Given a <b>complete</b> binary tree, count the number of nodes.</p>\r\n\r\n<p><b>Note: </b></p>\r\n\r\n<p><b><u>Definition of a complete binary tree from <a href=\"http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees\" target=\"_blank\">Wikipedia</a>:</u></b><br />\r\nIn a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2<sup>h</sup> nodes inclusive at the last level h.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> \r\n    1\r\n   / \\\r\n  2   3\r\n / \\  /\r\n4  5 6\r\n\r\n<strong>Output:</strong> 6</pre>\r\n",
    "tags": "Binary Search, Tree",
    "difficulty": 2,
    "frontend_article_id": 222
},
{
    "frontend_question_id": 221,
    "article_live": true,
    "article_slug": "maximal-square",
    "title": "Maximal Square",
    "title_slug": "maximal-square",
    "content": "<p>Given a 2D binary matrix filled with 0&#39;s and 1&#39;s, find the largest square containing only 1&#39;s and return its area.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: \r\n</strong>\r\n1 0 1 0 0\r\n1 0 <font color=\"red\">1</font> <font color=\"red\">1</font> 1\r\n1 1 <font color=\"red\">1</font> <font color=\"red\">1</font> 1\r\n1 0 0 1 0\r\n\r\n<strong>Output: </strong>4\r\n</pre>",
    "tags": "Dynamic Programming",
    "difficulty": 2,
    "frontend_article_id": 221,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#summary\">Summary</a></li> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-accepted\">Approach #1 Brute Force [Accepted]</a></li> \n      <li><a href=\"#approach-2-dynamic-programming-accepted\">Approach #2 (Dynamic Programming) [Accepted]</a></li> \n      <li><a href=\"#approach-3-better-dynamic-programming-accepted\">Approach #3 (Better Dynamic Programming) [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"summary\">Summary</h2> \n  <p>We need to find the largest square comprising of all ones in the given <script type=\"math/tex; mode=display\">m \\times n</script> matrix. In other words we need to find the largest set of connected ones in the given matrix that forms a square.</p> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-accepted\">Approach #1 Brute Force [Accepted]</h4> \n  <p>The simplest approach consists of trying to find out every possible square of 1’s that can be formed from within the matrix. The question now is – how to go for it?</p> \n  <p>We use a variable to contain the size of the largest square found so far and another variable to store the size of the current, both initialized to 0. Starting from the left uppermost point in the matrix, we search for a 1. No operation needs to be done for a 0. Whenever a 1 is found, we try to find out the largest square that can be formed including that 1. For this, we move diagonally (right and downwards), i.e. we increment the row index and column index temporarily and then check whether all the elements of that row and column are 1 or not. If all the elements happen to be 1, we move diagonally further as previously. If even one element turns out to be 0, we stop this diagonal movement and update the size of the largest square. Now we, continue the traversal of the matrix from the element next to the initial 1 found, till all the elements of the matrix have been traversed.</p> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">maximalSquare</span><span class=\"o\">(</span><span class=\"kt\">char</span><span class=\"o\">[][]</span> <span class=\"n\">matrix</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">rows</span> <span class=\"o\">=</span> <span class=\"n\">matrix</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">,</span> <span class=\"n\">cols</span> <span class=\"o\">=</span> <span class=\"n\">rows</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span> <span class=\"o\">?</span> <span class=\"n\">matrix</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">].</span><span class=\"na\">length</span> <span class=\"o\">:</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n        <span class=\"kt\">int</span> <span class=\"n\">maxsqlen</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">rows</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;</span> <span class=\"n\">cols</span><span class=\"o\">;</span> <span class=\"n\">j</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n                <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">matrix</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">][</span><span class=\"n\">j</span><span class=\"o\">]</span> <span class=\"o\">==</span> <span class=\"sc\">'1'</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                    <span class=\"kt\">int</span> <span class=\"n\">sqlen</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"o\">;</span>\n                    <span class=\"kt\">boolean</span> <span class=\"n\">flag</span> <span class=\"o\">=</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n                    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">sqlen</span> <span class=\"o\">+</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">rows</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">sqlen</span> <span class=\"o\">+</span> <span class=\"n\">j</span> <span class=\"o\">&lt;</span> <span class=\"n\">cols</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">flag</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"n\">j</span><span class=\"o\">;</span> <span class=\"n\">k</span> <span class=\"o\">&lt;=</span> <span class=\"n\">sqlen</span> <span class=\"o\">+</span> <span class=\"n\">j</span><span class=\"o\">;</span> <span class=\"n\">k</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n                            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">matrix</span><span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"n\">sqlen</span><span class=\"o\">][</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">==</span> <span class=\"sc\">'0'</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                                <span class=\"n\">flag</span> <span class=\"o\">=</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n                                <span class=\"k\">break</span><span class=\"o\">;</span>\n                            <span class=\"o\">}</span>\n                        <span class=\"o\">}</span>\n                        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"n\">i</span><span class=\"o\">;</span> <span class=\"n\">k</span> <span class=\"o\">&lt;=</span> <span class=\"n\">sqlen</span> <span class=\"o\">+</span> <span class=\"n\">i</span><span class=\"o\">;</span> <span class=\"n\">k</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n                            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">matrix</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">][</span><span class=\"n\">j</span> <span class=\"o\">+</span> <span class=\"n\">sqlen</span><span class=\"o\">]</span> <span class=\"o\">==</span> <span class=\"sc\">'0'</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                                <span class=\"n\">flag</span> <span class=\"o\">=</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n                                <span class=\"k\">break</span><span class=\"o\">;</span>\n                            <span class=\"o\">}</span>\n                        <span class=\"o\">}</span>\n                        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">flag</span><span class=\"o\">)</span>\n                            <span class=\"n\">sqlen</span><span class=\"o\">++;</span>\n                    <span class=\"o\">}</span>\n                    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">maxsqlen</span> <span class=\"o\">&lt;</span> <span class=\"n\">sqlen</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                        <span class=\"n\">maxsqlen</span> <span class=\"o\">=</span> <span class=\"n\">sqlen</span><span class=\"o\">;</span>\n                    <span class=\"o\">}</span>\n                <span class=\"o\">}</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">maxsqlen</span> <span class=\"o\">*</span> <span class=\"n\">maxsqlen</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time complexity : <script type=\"math/tex; mode=display\">O\\big((mn)^2\\big)</script>. In worst case, we need to traverse the complete matrix for every 1.</li> \n   <li>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. No extra space is used.</li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-dynamic-programming-accepted\">Approach #2 (Dynamic Programming) [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>We will explain this approach with the help of an example.</p> \n  <div class=\"codehilite\">\n   <pre><span></span>0 1 1 1 0\n1 1 1 1 1\n0 1 1 1 1\n0 1 1 1 1\n0 0 1 1 1\n</pre>\n  </div> \n  <p>We initialize another matrix (dp) with the same dimensions as the original one initialized with all 0’s.</p> \n  <p>dp(i,j) represents the side length of the maximum square whose bottom right corner is the cell with index (i,j) in the original matrix. </p> \n  <p>Starting from index (0,0), for every 1 found in the original matrix, we update the value of the current element as </p> \n  <p> <script type=\"math/tex; mode=display\">\n\\text{dp}(i,\\  j) = \\min \\big( \\text{dp}(i-1,\\  j),\\  \\text{dp}(i-1,\\  j-1),\\  \\text{dp}(i,\\  j-1) \\big) + 1.\n</script> </p> \n  <p>We also remember the size of the largest square found so far. In this way, we traverse the original matrix once and find out the required maximum size. This gives the side length of the square (say <script type=\"math/tex; mode=display\">maxsqlen</script>). The required result is the area <script type=\"math/tex; mode=display\">maxsqlen^2</script>.</p> \n  <p>To understand how this solution works, see the figure below.</p> \n  <p><img alt=\"Max Square\" src=\"https://leetcode.com/media/original_images/221_Maximal_Square.PNG?raw=true\"></p> \n  <p>An entry 2 at <script type=\"math/tex; mode=display\">(1, 3)</script> implies that we have a square of side 2 up to that index in the original matrix. Similarly, a 2 at <script type=\"math/tex; mode=display\">(1, 2)</script> and <script type=\"math/tex; mode=display\">(2, 2)</script> implies that a square of side 2 exists up to that index in the original matrix. Now to make a square of side 3, only a single entry of 1 is pending at <script type=\"math/tex; mode=display\">(2, 3)</script>. So, we enter a 3 corresponding to that position in the dp array.</p> \n  <p>Now consider the case for the index <script type=\"math/tex; mode=display\">(3, 4)</script>. Here, the entries at index <script type=\"math/tex; mode=display\">(3, 3)</script> and <script type=\"math/tex; mode=display\">(2, 3)</script> imply that a square of side 3 is possible up to their indices. But, the entry 1 at index <script type=\"math/tex; mode=display\">(2, 4)</script> indicates that a square of side 1 only can be formed up to its index. Therefore, while making an entry at the index <script type=\"math/tex; mode=display\">(3, 4)</script>, this element obstructs the formation of a square having a side larger than 2. Thus, the maximum sized square that can be formed up to this index is of size <script type=\"math/tex; mode=display\">2\\times2</script>.</p> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">maximalSquare</span><span class=\"o\">(</span><span class=\"kt\">char</span><span class=\"o\">[][]</span> <span class=\"n\">matrix</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">rows</span> <span class=\"o\">=</span> <span class=\"n\">matrix</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">,</span> <span class=\"n\">cols</span> <span class=\"o\">=</span> <span class=\"n\">rows</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span> <span class=\"o\">?</span> <span class=\"n\">matrix</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">].</span><span class=\"na\">length</span> <span class=\"o\">:</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n        <span class=\"kt\">int</span><span class=\"o\">[][]</span> <span class=\"n\">dp</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">rows</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">][</span><span class=\"n\">cols</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">];</span>\n        <span class=\"kt\">int</span> <span class=\"n\">maxsqlen</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;=</span> <span class=\"n\">rows</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"o\">;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;=</span> <span class=\"n\">cols</span><span class=\"o\">;</span> <span class=\"n\">j</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n                <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">matrix</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"o\">][</span><span class=\"n\">j</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"o\">==</span> <span class=\"sc\">'1'</span><span class=\"o\">){</span>\n                    <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">][</span><span class=\"n\">j</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">min</span><span class=\"o\">(</span><span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">min</span><span class=\"o\">(</span><span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">][</span><span class=\"n\">j</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">],</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">][</span><span class=\"n\">j</span><span class=\"o\">]),</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">][</span><span class=\"n\">j</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">])</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">;</span>\n                    <span class=\"n\">maxsqlen</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">maxsqlen</span><span class=\"o\">,</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">][</span><span class=\"n\">j</span><span class=\"o\">]);</span>\n                <span class=\"o\">}</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">maxsqlen</span> <span class=\"o\">*</span> <span class=\"n\">maxsqlen</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(mn)</script>. Single pass.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(mn)</script>. Another matrix of same size is used for dp.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-better-dynamic-programming-accepted\">Approach #3 (Better Dynamic Programming) [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In the previous approach for calculating dp of <script type=\"math/tex; mode=display\">i^{th}</script> row we are using only the previous element and the <script type=\"math/tex; mode=display\">(i-1)^{th}</script> row. Therefore, we don't need 2D dp matrix as 1D dp array will be sufficient for this.</p> \n  <p>Initially the dp array contains all 0's. As we scan the elements of the original matrix across a row, we keep on updating the dp array as per the equation <script type=\"math/tex; mode=display\">dp[j]=min(dp[j-1],dp[j],prev)</script>, where prev refers to the old <script type=\"math/tex; mode=display\">dp[j-1]</script>. For every row, we repeat the same process and update in the same dp array.</p> \n  <p><img alt=\" Max Square \" src=\"https://leetcode.com/media/original_images/221_Maximal_Square1.png?raw=true\"></p> \n  <p><strong>java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">maximalSquare</span><span class=\"o\">(</span><span class=\"kt\">char</span><span class=\"o\">[][]</span> <span class=\"n\">matrix</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">rows</span> <span class=\"o\">=</span> <span class=\"n\">matrix</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">,</span> <span class=\"n\">cols</span> <span class=\"o\">=</span> <span class=\"n\">rows</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span> <span class=\"o\">?</span> <span class=\"n\">matrix</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">].</span><span class=\"na\">length</span> <span class=\"o\">:</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n        <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">dp</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">cols</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">];</span>\n        <span class=\"kt\">int</span> <span class=\"n\">maxsqlen</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">prev</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;=</span> <span class=\"n\">rows</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"o\">;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;=</span> <span class=\"n\">cols</span><span class=\"o\">;</span> <span class=\"n\">j</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n                <span class=\"kt\">int</span> <span class=\"n\">temp</span> <span class=\"o\">=</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">];</span>\n                <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">matrix</span><span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">][</span><span class=\"n\">j</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"o\">==</span> <span class=\"sc\">'1'</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                    <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">min</span><span class=\"o\">(</span><span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">min</span><span class=\"o\">(</span><span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">j</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">],</span> <span class=\"n\">prev</span><span class=\"o\">),</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">])</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">;</span>\n                    <span class=\"n\">maxsqlen</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">maxsqlen</span><span class=\"o\">,</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">]);</span>\n                <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>\n                    <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n                <span class=\"o\">}</span>\n                <span class=\"n\">prev</span> <span class=\"o\">=</span> <span class=\"n\">temp</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">maxsqlen</span> <span class=\"o\">*</span> <span class=\"n\">maxsqlen</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(mn)</script>. Single pass.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Another array which stores elements in a row is used for dp.</p> </li> \n  </ul> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 220,
    "article_live": true,
    "article_slug": "contains-duplicate-iii",
    "title": "Contains Duplicate III",
    "title_slug": "contains-duplicate-iii",
    "content": "<p>Given an array of integers, find out whether there are two distinct indices <i>i</i> and <i>j</i> in the array such that the <b>absolute</b> difference between <b>nums[i]</b> and <b>nums[j]</b> is at most <i>t</i> and the <b>absolute</b> difference between <i>i</i> and <i>j</i> is at most <i>k</i>.</p>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>nums = <span id=\"example-input-1-1\">[1,2,3,1]</span>, k = <span id=\"example-input-1-2\">3</span>, t = <span id=\"example-input-1-3\">0</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">true</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>nums = <span id=\"example-input-2-1\">[1,0,1,1]</span>, k = <span id=\"example-input-2-2\">1</span>, t = <span id=\"example-input-2-3\">2</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">true</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>nums = <span id=\"example-input-3-1\">[1,5,9,1,5,9]</span>, k = <span id=\"example-input-3-2\">2</span>, t = <span id=\"example-input-3-3\">3</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">false</span>\r\n</pre>\r\n</div>\r\n</div>\r\n</div>\r\n",
    "tags": "Binary Search Tree",
    "difficulty": 2,
    "frontend_article_id": 220,
    "article_content": ""
},
{
    "frontend_question_id": 219,
    "article_live": true,
    "article_slug": "contains-duplicate-ii",
    "title": "Contains Duplicate II",
    "title_slug": "contains-duplicate-ii",
    "content": "<p>Given an array of integers and an integer <i>k</i>, find out whether there are two distinct indices <i>i</i> and <i>j</i> in the array such that <b>nums[i] = nums[j]</b> and the <b>absolute</b> difference between <i>i</i> and <i>j</i> is at most <i>k</i>.</p>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>nums = <span id=\"example-input-1-1\">[1,2,3,1]</span>, k = <span id=\"example-input-1-2\">3</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">true</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>nums = <span id=\"example-input-2-1\">[1,0,1,1]</span>, k = <span id=\"example-input-2-2\">1</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">true</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>nums = <span id=\"example-input-3-1\">[1,2,3,1,2,3]</span>, k = <span id=\"example-input-3-2\">2</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">false</span>\r\n</pre>\r\n</div>\r\n</div>\r\n</div>\r\n",
    "tags": "Array, Hash Table",
    "difficulty": 1,
    "frontend_article_id": 219,
    "article_content": ""
},
{
    "frontend_question_id": 218,
    "article_live": false,
    "title": "The Skyline Problem",
    "title_slug": "the-skyline-problem",
    "content": "<p>A city&#39;s skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are <b>given the locations and height of all the buildings</b> as shown on a cityscape photo (Figure A), write a program to <b>output the skyline</b> formed by these buildings collectively (Figure B).</p>\r\n<a href=\"/static/images/problemset/skyline1.jpg\" target=\"_blank\"><img alt=\"Buildings\" src=\"https://assets.leetcode.com/uploads/2018/10/22/skyline1.png\" style=\"max-width: 45%; border-width: 0px; border-style: solid;\" /> </a> <a href=\"/static/images/problemset/skyline2.jpg\" target=\"_blank\"> <img alt=\"Skyline Contour\" src=\"https://assets.leetcode.com/uploads/2018/10/22/skyline2.png\" style=\"max-width: 45%; border-width: 0px; border-style: solid;\" /> </a>\r\n\r\n<p>The geometric information of each building is represented by a triplet of integers <code>[Li, Ri, Hi]</code>, where <code>Li</code> and <code>Ri</code> are the x coordinates of the left and right edge of the ith building, respectively, and <code>Hi</code> is its height. It is guaranteed that <code>0 &le; Li, Ri &le; INT_MAX</code>, <code>0 &lt; Hi &le; INT_MAX</code>, and <code>Ri - Li &gt; 0</code>. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.</p>\r\n\r\n<p>For instance, the dimensions of all buildings in Figure A are recorded as: <code>[ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] </code>.</p>\r\n\r\n<p>The output is a list of &quot;<b>key points</b>&quot; (red dots in Figure B) in the format of <code>[ [x1,y1], [x2, y2], [x3, y3], ... ]</code> that uniquely defines a skyline. <b>A key point is the left endpoint of a horizontal line segment</b>. Note that the last key point, where the rightmost building ends, is merely used to mark the termination of the skyline, and always has zero height. Also, the ground in between any two adjacent buildings should be considered part of the skyline contour.</p>\r\n\r\n<p>For instance, the skyline in Figure B should be represented as:<code>[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ]</code>.</p>\r\n\r\n<p><b>Notes:</b></p>\r\n\r\n<ul>\r\n\t<li>The number of buildings in any input list is guaranteed to be in the range <code>[0, 10000]</code>.</li>\r\n\t<li>The input list is already sorted in ascending order by the left x position <code>Li</code>.</li>\r\n\t<li>The output list must be sorted by the x position.</li>\r\n\t<li>There must be no consecutive horizontal lines of equal height in the output skyline. For instance, <code>[...[2 3], [4 5], [7 5], [11 5], [12 7]...]</code> is not acceptable; the three lines of height 5 should be merged into one in the final output as such: <code>[...[2 3], [4 5], [12 7], ...]</code></li>\r\n</ul>\r\n",
    "tags": "Divide and Conquer, Heap, Binary Indexed Tree, Segment Tree",
    "difficulty": 3,
    "frontend_article_id": 218
},
{
    "frontend_question_id": 217,
    "article_live": true,
    "article_slug": "contains-duplicate",
    "title": "Contains Duplicate",
    "title_slug": "contains-duplicate",
    "content": "<p>Given an array of integers, find if the array contains any duplicates.</p>\r\n\r\n<p>Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [1,2,3,1]\r\n<strong>Output:</strong> true</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>[1,2,3,4]\r\n<strong>Output:</strong> false</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>[1,1,1,3,3,4,3,2,4,2]\r\n<strong>Output:</strong> true</pre>\r\n",
    "tags": "Array, Hash Table",
    "difficulty": 1,
    "frontend_article_id": 217,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#summary\">Summary</a></li> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-naive-linear-search-time-limit-exceeded\">Approach #1 (Naive Linear Search) [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-sorting-accepted\">Approach #2 (Sorting) [Accepted]</a></li> \n      <li><a href=\"#approach-3-hash-table-accepted\">Approach #3 (Hash Table) [Accepted]</a></li> \n     </ul> </li> \n    <li><a href=\"#see-also\">See Also</a></li> \n   </ul> \n  </div> \n  <h2 id=\"summary\">Summary</h2> \n  <p>This article is for beginners. It introduces the following ideas: Loop Invariant, Linear Search, Sorting and Hash Table.</p> \n  <h2 id=\"solution\">Solution</h2> \n  <h4 id=\"approach-1-naive-linear-search-time-limit-exceeded\">Approach #1 (Naive Linear Search) [Time Limit Exceeded]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>For an array of <script type=\"math/tex; mode=display\">n</script> integers, there are <script type=\"math/tex; mode=display\">C(n,2) = \\frac{n(n+1)}{2}</script> pairs of integers. Thus, we may check all <script type=\"math/tex; mode=display\">\\frac{n(n+1)}{2}</script> pairs and see if there is any pair with duplicates.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>To apply this idea, we employ the linear search algorithm which is the simplest search algorithm. Linear search is a method of finding if a particular value is in a list by checking each of its elements, one at a time and in sequence until the desired one is found.</p> \n  <p>For our problem, we loop through all <script type=\"math/tex; mode=display\">n</script> integers. For the <script type=\"math/tex; mode=display\">i</script>th integer <code>nums[i]</code>, we search in the previous <code>i-1</code> integers for the duplicate of <code>nums[i]</code>. If we find one, we return true; if not, we continue. Return false at the end of the program.</p> \n  <p>To prove the correctness of the algorithm, we define the loop invariant. A loop invariant is a property that holds before (and after) each iteration. Knowing its invariant(s) is essential for understanding the effect of a loop. Here is the <em>loop invariant</em>:</p> \n  <blockquote> \n   <p>Before the next search, there are no duplicate integers in the searched integers.</p> \n  </blockquote> \n  <p>The loop invariant holds true before the loop because there is no searched integer. Each time through the loop we look for any any possible duplicate of the current element. If we found a duplicate, the function exits by returning true; If not, the invariant still holds true.</p> \n  <p>Therefore, if the loop finishes, the invariant tells us that there is no duplicate in all <script type=\"math/tex; mode=display\">n</script> integers.</p> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">containsDuplicate</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;</span> <span class=\"n\">i</span><span class=\"o\">;</span> <span class=\"o\">++</span><span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">]</span> <span class=\"o\">==</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">])</span> <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>  \n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n<span class=\"c1\">// Time Limit Exceeded</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^2)</script>. In the worst case, there are <script type=\"math/tex; mode=display\">\\frac{n(n+1)}{2}</script> pairs of integers to check. Therefore, the time complexity is <script type=\"math/tex; mode=display\">O(n^2)</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. We only used constant extra space.</p> </li> \n  </ul> \n  <p><strong>Note</strong></p> \n  <p>This approach will get Time Limit Exceeded on LeetCode. Usually, if an algorithm is <script type=\"math/tex; mode=display\">O(n^2)</script>, it can handle <script type=\"math/tex; mode=display\">n</script> up to around <script type=\"math/tex; mode=display\">10^4</script>. It gets Time Limit Exceeded when <script type=\"math/tex; mode=display\">n \\geq 10^5</script>.</p> \n  <hr> \n  <h4 id=\"approach-2-sorting-accepted\">Approach #2 (Sorting) [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>If there are any duplicate integers, they will be consecutive after sorting.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>This approach employs sorting algorithm. Since comparison sorting algorithm like <em>heapsort</em> is known to provide <script type=\"math/tex; mode=display\">O(n \\log n)</script> worst-case performance, sorting is often a good preprocessing step. After sorting, we can sweep the sorted array to find if there are any two consecutive duplicate elements.</p> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">containsDuplicate</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">Arrays</span><span class=\"o\">.</span><span class=\"na\">sort</span><span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">);</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">==</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">])</span> <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n \\log n)</script>. Sorting is <script type=\"math/tex; mode=display\">O(n \\log n)</script> and the sweeping is <script type=\"math/tex; mode=display\">O(n)</script>. The entire algorithm is dominated by the sorting step, which is <script type=\"math/tex; mode=display\">O(n \\log n)</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Space depends on the sorting implementation which, usually, costs <script type=\"math/tex; mode=display\">O(1)</script> auxiliary space if <code>heapsort</code> is used.</p> </li> \n  </ul> \n  <p><strong>Note</strong></p> \n  <p>The implementation here modifies the original array by sorting it. In general, it is not a good practice to modify the input unless it is clear to the caller that the input will be modified. One may make a copy of <code>nums</code> and operate on the copy instead.</p> \n  <hr> \n  <h4 id=\"approach-3-hash-table-accepted\">Approach #3 (Hash Table) [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Utilize a dynamic data structure that supports fast search and insert operations.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>From <a href=\"#approach-1-naive-linear-search-time-limit-exceeded\">Approach #1</a> we know that search operations is <script type=\"math/tex; mode=display\">O(n)</script> in an unsorted array and we did so repeatedly. Utilizing a data structure with faster search time will speed up the entire algorithm.</p> \n  <p>There are many data structures commonly used as dynamic sets such as Binary Search Tree and Hash Table. The operations we need to support here are <code>search()</code> and <code>insert()</code>. For a self-balancing Binary Search Tree (TreeSet or TreeMap in Java), <code>search()</code> and <code>insert()</code> are both <script type=\"math/tex; mode=display\">O(\\log n)</script> time. For a Hash Table (HashSet or HashMap in Java), <code>search()</code> and <code>insert()</code> are both <script type=\"math/tex; mode=display\">O(1)</script> on average. Therefore, by using hash table, we can achieve linear time complexity for finding the duplicate in an unsorted array.</p> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">containsDuplicate</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">Set</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">set</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HashSet</span><span class=\"o\">&lt;&gt;(</span><span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">);</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">nums</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"o\">.</span><span class=\"na\">contains</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n        <span class=\"n\">set</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. We do <code>search()</code> and <code>insert()</code> for <script type=\"math/tex; mode=display\">n</script> times and each operation takes constant time.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The space used by a hash table is linear with the number of elements in it.</p> </li> \n  </ul> \n  <p><strong>Note</strong></p> \n  <p>For certain test cases with not very large <script type=\"math/tex; mode=display\">n</script>, the runtime of this method can be slower than <a href=\"#approach-2-sorting-accepted\">Approach #2</a>. The reason is hash table has some overhead in maintaining its property. One should keep in mind that real world performance can be different from what the Big-O notation says. The Big-O notation only tells us that for <em>sufficiently</em> large input, one will be faster than the other. Therefore, when <script type=\"math/tex; mode=display\">n</script> is not sufficiently large, an <script type=\"math/tex; mode=display\">O(n)</script> algorithm can be slower than an <script type=\"math/tex; mode=display\">O(n \\log n)</script> algorithm.</p> \n  <h2 id=\"see-also\">See Also</h2> \n  <ul> \n   <li><a href=\"https://leetcode.com/articles/contains-duplicate-ii/\">Problem 219 Contains Duplicate II</a></li> \n   <li><a href=\"https://leetcode.com/articles/contains-duplicate-iii/\">Problem 220 Contains Duplicate III</a></li> \n  </ul> \n </div> \n</div>"
},
{
    "frontend_question_id": 216,
    "article_live": false,
    "title": "Combination Sum III",
    "title_slug": "combination-sum-iii",
    "content": "<div>\r\n<p>Find all possible combinations of <i><b>k</b></i> numbers that add up to a number <i><b>n</b></i>, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>All numbers will be positive integers.</li>\r\n\t<li>The solution set must not contain duplicate combinations.</li>\r\n</ul>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> <i><b>k</b></i> = 3, <i><b>n</b></i> = 7\r\n<strong>Output:</strong> [[1,2,4]]\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> <i><b>k</b></i> = 3, <i><b>n</b></i> = 9\r\n<strong>Output:</strong> [[1,2,6], [1,3,5], [2,3,4]]\r\n</pre>\r\n</div>",
    "tags": "Array, Backtracking",
    "difficulty": 2,
    "frontend_article_id": 216
},
{
    "frontend_question_id": 215,
    "article_live": false,
    "title": "Kth Largest Element in an Array",
    "title_slug": "kth-largest-element-in-an-array",
    "content": "<p>Find the <strong>k</strong>th largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> <code>[3,2,1,5,6,4] </code>and k = 2\r\n<strong>Output:</strong> 5\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> <code>[3,2,3,1,2,4,5,5,6] </code>and k = 4\r\n<strong>Output:</strong> 4</pre>\r\n\r\n<p><strong>Note: </strong><br />\r\nYou may assume k is always valid, 1 &le; k &le; array&#39;s length.</p>\r\n",
    "tags": "Divide and Conquer, Heap",
    "difficulty": 2,
    "frontend_article_id": 215
},
{
    "frontend_question_id": 214,
    "article_live": true,
    "article_slug": "shortest-palindrome",
    "title": "Shortest Palindrome",
    "title_slug": "shortest-palindrome",
    "content": "<p>Given a string <em><b>s</b></em>, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><code>&quot;aacecaaa&quot;</code>\r\n<strong>Output:</strong> <code>&quot;aaacecaaa&quot;</code>\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><code>&quot;abcd&quot;</code>\r\n<strong>Output:</strong> <code>&quot;dcbabcd&quot;</code></pre>",
    "tags": "String",
    "difficulty": 3,
    "frontend_article_id": 214,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-accepted\">Approach #1 Brute force [Accepted]</a></li> \n      <li><a href=\"#approach-2-two-pointers-and-recursion-accepted\">Approach #2 Two pointers and recursion [Accepted]</a></li> \n      <li><a href=\"#approach-3-kmp-accepted\">Approach #3 KMP [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-accepted\">Approach #1 Brute force [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>According to the question, we are allowed to insert the characters only at the beginning of the string. Hence, we can find the largest segment from the beginning that is a palindrome, and we can then easily reverse the remaining segment and append to the beginning. This must be the required answer as no shorter palindrome could be found than this by just appending at the beginning.</p> \n  <p>For example: Take the string <script type=\"math/tex; mode=display\">\\text{\"abcbabcab\"}</script>. Here, the largest palindrome segment from beginning is <script type=\"math/tex; mode=display\">\\text{\"abcba\"}</script>, and the remaining segment is <script type=\"math/tex; mode=display\">\\text{\"bcab\"}</script>. Hence the required string is reverse of <script type=\"math/tex; mode=display\">\\text{\"bcab\"}</script>( = <script type=\"math/tex; mode=display\">\\text{\"bacb\"}</script>) + original string( = <script type=\"math/tex; mode=display\">\\text{\"abcbabcab\"}</script>) = <script type=\"math/tex; mode=display\">\\text{\"bacbabcbabcab\"}</script>.</p> \n  <p><strong>Algorithm</strong></p> \n  <ul> \n   <li>Create the reverse of the original string <script type=\"math/tex; mode=display\">s</script>, say <script type=\"math/tex; mode=display\">\\text{rev}</script>. This is used for comparison to find the largest palindrome segment from the front.</li> \n   <li>Iterate over the variable <script type=\"math/tex; mode=display\">i</script> from 0 to the <script type=\"math/tex; mode=display\">\\text{size(s)}-1</script>:\n    <ul> \n     <li>If <script type=\"math/tex; mode=display\">s[0:n-i] == rev[i:]</script> (i.e. substring of <script type=\"math/tex; mode=display\">s</script> from <script type=\"math/tex; mode=display\">0</script> to <script type=\"math/tex; mode=display\">n-i</script> is equal to the substring of <script type=\"math/tex; mode=display\">\\text{rev}</script> from <script type=\"math/tex; mode=display\">i</script> to the end of string). This essentially means that that substring from <script type=\"math/tex; mode=display\">0</script> to <script type=\"math/tex; mode=display\">n-i</script> is a palindrome, as <script type=\"math/tex; mode=display\">\\text{rev}</script> is the reverse of <script type=\"math/tex; mode=display\">s</script>.</li> \n     <li>Since, we find the larger palindromes first, we can return reverse of largest palindrome + <script type=\"math/tex; mode=display\">s</script> as soon as we get it.</li> \n    </ul> </li> \n  </ul> \n  <iframe src=\"https://leetcode.com/playground/ofq6FrQW/shared\" frameborder=\"0\" name=\"ofq6FrQW\" width=\"100%\" height=\"258\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity: <script type=\"math/tex; mode=display\">O(n^2)</script>.</p> \n    <ul> \n     <li>We iterate over the entire length of string <script type=\"math/tex; mode=display\">s</script>.</li> \n     <li>In each iteration, we compare the substrings which is linear in size of substrings to be compared.</li> \n     <li>Hence, the total time complexity is <script type=\"math/tex; mode=display\">O(n*n) = O(n^2)</script>.</li> \n    </ul> </li> \n   <li> <p>Space complexity: <script type=\"math/tex; mode=display\">O(n)</script> extra space for the reverse string <script type=\"math/tex; mode=display\">\\text{rev}</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-two-pointers-and-recursion-accepted\">Approach #2 Two pointers and recursion [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>In Approach #1, we found the largest palindrome substring from the string using substring matching which is <script type=\"math/tex; mode=display\">O(n)</script> in length of substring. We could make the process more efficient if we could reduce the size of string to search for the substring without checking the complete substring each time.</p> \n  <p>Lets take a string <script type=\"math/tex; mode=display\">\\text{\"abcbabcaba\"}</script>. Let us consider 2 pointers <script type=\"math/tex; mode=display\">i</script> and <script type=\"math/tex; mode=display\">j</script>. Initialize <script type=\"math/tex; mode=display\">i = 0</script>. Iterate over <script type=\"math/tex; mode=display\">j</script> from <script type=\"math/tex; mode=display\">n-1</script> to <script type=\"math/tex; mode=display\">0</script>, incrementing <script type=\"math/tex; mode=display\">i</script> each time <script type=\"math/tex; mode=display\">\\text{s[i]==s[j]}</script>. Now, we just need to search in range <script type=\"math/tex; mode=display\">\\text[0,i)</script>. This way, we have reduced the size of string to search for the largest palindrome substring from the beginning. The range <script type=\"math/tex; mode=display\">\\text{[0,i)}</script> must always contain the largest palindrome substring. The proof of correction is that: Say the string was a perfect palindrome, <script type=\"math/tex; mode=display\">i</script> would be incremented <script type=\"math/tex; mode=display\">n</script> times. Had there been other characters at the end, <script type=\"math/tex; mode=display\">i</script> would still be incremented by the size of the palindrome. Hence, even though there is a chance that the range <script type=\"math/tex; mode=display\">\\text{[0,i)}</script> is not always tight, it is ensured that it will always contain the longest palindrome from the beginning. </p> \n  <p>The best case for the algorithm is when the entire string is palindrome and the worst case is string like <script type=\"math/tex; mode=display\">\\text{\"aababababababa\"}</script>, wherein <script type=\"math/tex; mode=display\">i</script> first becomes <script type=\"math/tex; mode=display\">12</script>(check by doing on paper), and we need to recheck in [0,12) corresponding to string <script type=\"math/tex; mode=display\">\\text{\"aabababababa\"}</script>. Again continuing in the same way, we get <script type=\"math/tex; mode=display\">{i=10}</script>. In such a case, the string is reduced only by as few as 2 elements at each step. Hence, the number of steps in such cases is linear(<script type=\"math/tex; mode=display\">n/2</script>).</p> \n  <p>This reduction of length could be easily done with the help of a recursive routine, as shown in the algorithm section.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>The routine <script type=\"math/tex; mode=display\">\\text{shortestPalindrome}</script> is recursive and takes string <script type=\"math/tex; mode=display\">s</script> as parameter:</p> \n  <ul> \n   <li>Initialize <script type=\"math/tex; mode=display\">i=0</script> </li> \n   <li>Iterate over <script type=\"math/tex; mode=display\">j</script> from <script type=\"math/tex; mode=display\">n-1</script> to <script type=\"math/tex; mode=display\">0</script>:\n    <ul> \n     <li>If <script type=\"math/tex; mode=display\">\\text{s[i]==s[j]}</script>, increase <script type=\"math/tex; mode=display\">i</script> by <script type=\"math/tex; mode=display\">1</script> </li> \n    </ul> </li> \n   <li>If <script type=\"math/tex; mode=display\">i</script> equals the size of <script type=\"math/tex; mode=display\">s</script>, the entire string is palindrome, and hence return the entire string <script type=\"math/tex; mode=display\">s</script>.</li> \n   <li>Else:\n    <ul> \n     <li>Return reverse of remaining substring after <script type=\"math/tex; mode=display\">i</script> to the end of string + <script type=\"math/tex; mode=display\">\\text{shortestPalindrome}</script> routine on substring from start to index <script type=\"math/tex; mode=display\">i-1</script> + remaining substring after <script type=\"math/tex; mode=display\">i</script> to the end of string.</li> \n    </ul> </li> \n  </ul> \n  <iframe src=\"https://leetcode.com/playground/zeLz2M4w/shared\" frameborder=\"0\" name=\"zeLz2M4w\" width=\"100%\" height=\"292\"></iframe> \n  <p><strong>Complexity analysis</strong></p> \n  <ul> \n   <li>Time complexity: <script type=\"math/tex; mode=display\">O(n^2)</script>.\n    <ul> \n     <li>Each iteration of <script type=\"math/tex; mode=display\">\\text{shortestPalindrome}</script> is linear in size of substring and the maximum number of recursive calls can be <script type=\"math/tex; mode=display\">n/2</script> times as shown in the Intuition section.</li> \n     <li>Let the time complexity of the algorithm be T(n). Since, at the each step for the worst case, the string can be divide into 2 parts and we require only one part for further computation. Hence, the time complexity for the worst case can be represented as : <script type=\"math/tex; mode=display\">T(n)=T(n-2)+O(n)</script>. So, <script type=\"math/tex; mode=display\">T(n) = O(n) + O(n-2) + O(n-4) + ... + O(1)</script> which is <script type=\"math/tex; mode=display\">O(n^2)</script>.</li> \n    </ul> </li> \n  </ul> \n  <p>Thanks @CONOVER for the time complexity analysis.</p> \n  <ul> \n   <li>Space complexity: <script type=\"math/tex; mode=display\">O(n)</script> extra space for <script type=\"math/tex; mode=display\">\\text{remain_rev}</script> string.</li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-kmp-accepted\">Approach #3 KMP [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>We have seen that the question boils down to finding the largest palindrome substring from the beginning.</p> \n  <p>The people familiar with KMP(Knuth–Morris–Pratt) algorithm may wonder that the task at hand can be easily be compared with the concept of the lookup table in KMP.</p> \n  <p><em>KMP Overview:</em></p> \n  <p>KMP is a string matching algorithm that runs in <script type=\"math/tex; mode=display\">O(n+m)</script> times, where <script type=\"math/tex; mode=display\">n</script> and <script type=\"math/tex; mode=display\">m</script> are sizes of the text and string to be searched respectively. The key component of KMP is the failure function lookup table,say <script type=\"math/tex; mode=display\">f(s)</script>. The purpose of the lookup table is to store the length of the proper prefix of the string <script type=\"math/tex; mode=display\">b_{1}b_{2}...b_{s}</script> that is also a suffix of <script type=\"math/tex; mode=display\">b_{1}b_{2}...b_{s}</script>. This table is important because if we are trying to match a text string for <script type=\"math/tex; mode=display\">b_{1}b_{2}...b_{n}</script>, and we have matched the first <script type=\"math/tex; mode=display\">s</script> positions, but when we fail, then the value of lookup table for <script type=\"math/tex; mode=display\">s</script> is the longest prefix of <script type=\"math/tex; mode=display\">b_{1}b_{2}...b_{n}</script> that could possibly match the text string upto the point we are at. Thus, we don't need to start all over again, and can resume searching from the matching prefix.</p> \n  <p>The algorithm to generate the lookup table is easy and inutitive, as given below:</p> \n  <div class=\"codehilite\">\n   <pre><span></span>f(0) = 0\nfor(i = 1; i &lt; n; i++)\n{\n    t = f(i-1)\n    while(t &gt; 0 &amp;&amp; b[i] != b[t])\n        t = f(t-1)\n    if(b[i] == b[t]){\n        ++t\n    f(i) = t\n}\n</pre>\n  </div> \n  <ul> \n   <li>Here, we first set f(0)=0 since, no proper prefix is available.</li> \n   <li>Next, iterate over <script type=\"math/tex; mode=display\">i</script> from <script type=\"math/tex; mode=display\">1</script> to <script type=\"math/tex; mode=display\">n-1</script>:\n    <ul> \n     <li>Set <script type=\"math/tex; mode=display\">t=f(i-1)</script> </li> \n     <li>While t&gt;0 and char at <script type=\"math/tex; mode=display\">i</script> doesn't match the char at <script type=\"math/tex; mode=display\">t</script> position, set <script type=\"math/tex; mode=display\">t=f(t)</script>, which essentially means that we have problem matching and must consider a shorter prefix, which will be <script type=\"math/tex; mode=display\">b_{f(t-1)}</script>, until we find a match or t becomes 0.</li> \n     <li>If <script type=\"math/tex; mode=display\">b_{i}==b_{t}</script>, add 1 to t</li> \n     <li>Set <script type=\"math/tex; mode=display\">f(i)=t</script> </li> \n    </ul> </li> \n  </ul> \n  <p>The lookup table generation is as illustrated below:</p> \n  <p align=\"center\"><img alt=\"KMP\" src=\"../Figures/214/shortest_palindrome.png\" width=\"600px\"></p> \n  <p><em>Wait! I get it!!</em></p> \n  <p>In Approach #1, we reserved the original string <script type=\"math/tex; mode=display\">s</script> and stored it as <script type=\"math/tex; mode=display\">\\text{rev}</script>. We iterate over <script type=\"math/tex; mode=display\">i</script> from <script type=\"math/tex; mode=display\">0</script> to <script type=\"math/tex; mode=display\">n-1</script> and check for <script type=\"math/tex; mode=display\">s[0:n-i] == rev[i:]</script>. Pondering over this statement, had the <script type=\"math/tex; mode=display\">\\text{rev}</script> been concatenated to <script type=\"math/tex; mode=display\">s</script>, this statement is just finding the longest prefix that is equal to the suffix. Voila!</p> \n  <p><strong>Algorithm</strong></p> \n  <ul> \n   <li>We use the KMP lookup table generation</li> \n   <li>Create <script type=\"math/tex; mode=display\">\\text{new_s}</script> as <script type=\"math/tex; mode=display\">s + \\text{\"#\"} + \\text{reverse(s)}</script> and use the string in the lookup-generation algorithm\n    <ul> \n     <li>The \"#\" in the middle is required, since without the #, the 2 strings could mix with each ther, producing wrong answer. For example, take the string <script type=\"math/tex; mode=display\">\\text{\"aaaa\"}</script>. Had we not inserted \"#\" in the middle, the new string would be <script type=\"math/tex; mode=display\">\\text{\"aaaaaaaa\"}</script> and the largest prefix size would be 7 corresponding to \"aaaaaaa\" which would be obviously wrong. Hence, a delimiter is required at the middle.</li> \n    </ul> </li> \n   <li>Return reversed string after the largest palindrome from beginning length(given by <script type=\"math/tex; mode=display\">n-\\text{f[n_new-1]}</script>) + original string <script type=\"math/tex; mode=display\">s</script> </li> \n  </ul> \n  <iframe src=\"https://leetcode.com/playground/Uu5sN23P/shared\" frameborder=\"0\" name=\"Uu5sN23P\" width=\"100%\" height=\"360\"></iframe> \n  <p><strong>Complexity analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity: <script type=\"math/tex; mode=display\">O(n)</script>.</p> \n    <ul> \n     <li>In every iteration of the inner while loop, <script type=\"math/tex; mode=display\">t</script> decreases until it reaches 0 or until it matches. After that, it is incremented by one. Therefore, in the worst case, <script type=\"math/tex; mode=display\">t</script> can only be decreased up to <script type=\"math/tex; mode=display\">n</script> times and increased up to <script type=\"math/tex; mode=display\">n</script> times.</li> \n     <li>Hence, the algorithm is linear with maximum <script type=\"math/tex; mode=display\">(2 * n) * 2</script> iterations.</li> \n    </ul> </li> \n   <li> <p>Space complexity: <script type=\"math/tex; mode=display\">O(n)</script>. Additional space for the reverse string and the concatenated string.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis written by <a href=\"https://leetcode.com/abhinavbansal0\">@abhinavbansal0</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 213,
    "article_live": false,
    "title": "House Robber II",
    "title_slug": "house-robber-ii",
    "content": "<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are <strong>arranged in a circle.</strong> That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and&nbsp;<b>it will automatically contact the police if two adjacent houses were broken into on the same night</b>.</p>\r\n\r\n<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight <strong>without alerting the police</strong>.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [2,3,2]\r\n<strong>Output:</strong> 3\r\n<strong>Explanation:</strong> You cannot rob house 1 (money = 2) and then rob house 3 (money = 2),\r\n&nbsp;            because they are adjacent houses.\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [1,2,3,1]\r\n<strong>Output:</strong> 4\r\n<strong>Explanation:</strong> Rob house 1 (money = 1) and then rob house 3 (money = 3).\r\n&nbsp;            Total amount you can rob = 1 + 3 = 4.</pre>\r\n",
    "tags": "Dynamic Programming",
    "difficulty": 2,
    "frontend_article_id": 213
},
{
    "frontend_question_id": 212,
    "article_live": false,
    "title": "Word Search II",
    "title_slug": "word-search-ii",
    "content": "<p>Given a 2D board and a list of words from the dictionary, find all words in the board.</p>\r\n\r\n<p>Each word must be constructed from letters of sequentially adjacent cell, where &quot;adjacent&quot; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> \r\n<b>words</b> = <code>[&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]</code> and <b>board </b>=\r\n[\r\n  [&#39;<span style=\"color:#d70\">o</span>&#39;,&#39;<span style=\"color:#d70\">a</span>&#39;,&#39;a&#39;,&#39;n&#39;],\r\n  [&#39;e&#39;,&#39;<span style=\"color:#d30\">t</span>&#39;,&#39;<span style=\"color:#d00\">a</span>&#39;,&#39;<span style=\"color:#d00\">e</span>&#39;],\r\n  [&#39;i&#39;,&#39;<span style=\"color:#d70\">h</span>&#39;,&#39;k&#39;,&#39;r&#39;],\r\n  [&#39;i&#39;,&#39;f&#39;,&#39;l&#39;,&#39;v&#39;]\r\n]\r\n\r\n<strong>Output:&nbsp;</strong><code>[&quot;eat&quot;,&quot;oath&quot;]</code>\r\n</pre>\r\n\r\n<p><b>Note:</b><br />\r\nYou may assume that all inputs are consist of lowercase letters <code>a-z</code>.</p>",
    "tags": "Backtracking, Trie",
    "difficulty": 3,
    "frontend_article_id": 212
},
{
    "frontend_question_id": 211,
    "article_live": false,
    "title": "Add and Search Word - Data structure design",
    "title_slug": "add-and-search-word-data-structure-design",
    "content": "<p>Design a data structure that supports the following two operations:</p>\r\n\r\n<pre>\r\nvoid addWord(word)\r\nbool search(word)\r\n</pre>\r\n\r\n<p>search(word) can search a literal word or a regular expression string containing only letters <code>a-z</code> or <code>.</code>. A <code>.</code> means it can represent any one letter.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\naddWord(&quot;bad&quot;)\r\naddWord(&quot;dad&quot;)\r\naddWord(&quot;mad&quot;)\r\nsearch(&quot;pad&quot;) -&gt; false\r\nsearch(&quot;bad&quot;) -&gt; true\r\nsearch(&quot;.ad&quot;) -&gt; true\r\nsearch(&quot;b..&quot;) -&gt; true\r\n</pre>\r\n\r\n<p><b>Note:</b><br />\r\nYou may assume that all words are consist of lowercase letters <code>a-z</code>.</p>\r\n",
    "tags": "Backtracking, Design, Trie",
    "difficulty": 2,
    "frontend_article_id": 211
},
{
    "frontend_question_id": 210,
    "article_live": false,
    "title": "Course Schedule II",
    "title_slug": "course-schedule-ii",
    "content": "<p>There are a total of <em>n</em> courses you have to take, labeled from <code>0</code> to <code>n-1</code>.</p>\r\n\r\n<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: <code>[0,1]</code></p>\r\n\r\n<p>Given the total number of courses and a list of prerequisite <strong>pairs</strong>, return the ordering of courses you should take to finish all courses.</p>\r\n\r\n<p>There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 2, [[1,0]] \r\n<strong>Output: </strong><code>[0,1]</code>\r\n<strong>Explanation:</strong>&nbsp;There are a total of 2 courses to take. To take course 1 you should have finished   \r\n&nbsp;            course 0. So the correct course order is <code>[0,1] .</code></pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 4, [[1,0],[2,0],[3,1],[3,2]]\r\n<strong>Output: </strong><code>[0,1,2,3] or [0,2,1,3]</code>\r\n<strong>Explanation:</strong>&nbsp;There are a total of 4 courses to take. To take course 3 you should have finished both     \r\n             courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. \r\n&nbsp;            So one correct course order is <code>[0,1,2,3]</code>. Another correct ordering is <code>[0,2,1,3] .</code></pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li>The input prerequisites is a graph represented by <strong>a list of edges</strong>, not adjacency matrices. Read more about <a href=\"https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs\" target=\"_blank\">how a graph is represented</a>.</li>\r\n\t<li>You may assume that there are no duplicate edges in the input prerequisites.</li>\r\n</ol>\r\n",
    "tags": "Depth-first Search, Breadth-first Search, Graph, Topological Sort",
    "difficulty": 2,
    "frontend_article_id": 210
},
{
    "frontend_question_id": 209,
    "article_live": true,
    "article_slug": "minimum-size-subarray-sum",
    "title": "Minimum Size Subarray Sum",
    "title_slug": "minimum-size-subarray-sum",
    "content": "<p>Given an array of <strong>n</strong> positive integers and a positive integer <strong>s</strong>, find the minimal length of a <b>contiguous</b> subarray of which the sum &ge; <strong>s</strong>. If there isn&#39;t one, return 0 instead.</p>\r\n\r\n<p><strong>Example:&nbsp;</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> <code>s = 7, nums = [2,3,1,2,4,3]</code>\r\n<strong>Output:</strong> 2\r\n<strong>Explanation: </strong>the subarray <code>[4,3]</code> has the minimal length under the problem constraint.</pre>\r\n\r\n<div class=\"spoilers\"><b>Follow up:</b></div>\r\n\r\n<div class=\"spoilers\">If you have figured out the <i>O</i>(<i>n</i>) solution, try coding another solution of which the time complexity is <i>O</i>(<i>n</i> log <i>n</i>).&nbsp;</div>\r\n",
    "tags": "Array, Two Pointers, Binary Search",
    "difficulty": 2,
    "frontend_article_id": 209,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute force [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-a-better-brute-force-accepted\">Approach #2 A better brute force [Accepted]</a></li> \n      <li><a href=\"#approach-3-using-binary-search-accepted\">Approach #3 Using Binary search [Accepted]</a></li> \n      <li><a href=\"#approach-4-using-2-pointers-accepted\">Approach #4 Using 2 pointers [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute force [Time Limit Exceeded]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Do as directed in question. Find the sum for all the possible subarrays and update the <script type=\"math/tex; mode=display\">\\text{ans}</script> as and when we get a better subarray that fulfill the requirements (<script type=\"math/tex; mode=display\">\\text{sum} \\geq \\text{s}</script>).</p> \n  <p><strong>Algorithm</strong></p> \n  <ul> \n   <li>Initialize <script type=\"math/tex; mode=display\">\\text{ans}=\\text{INT_MAX}</script> </li> \n   <li>Iterate the array from left to right using <script type=\"math/tex; mode=display\">i</script>:\n    <ul> \n     <li>Iterate from the current element to the end of vector using <script type=\"math/tex; mode=display\">j</script>:\n      <ul> \n       <li>Find the <script type=\"math/tex; mode=display\">\\text{sum}</script> of elements from index <script type=\"math/tex; mode=display\">i</script> to <script type=\"math/tex; mode=display\">j</script> </li> \n       <li>If sum is greater then <script type=\"math/tex; mode=display\">s</script>:\n        <ul> \n         <li>Update <script type=\"math/tex; mode=display\">\\text{ans} = \\min(\\text{ans}, (j - i + 1))</script> </li> \n         <li>Start the next <script type=\"math/tex; mode=display\">i</script>th iteration, since, we got the smallest subarray with <script type=\"math/tex; mode=display\">\\text{sum} \\geq s</script> starting from the current index.</li> \n        </ul> </li> \n      </ul> </li> \n    </ul> </li> \n  </ul> \n  <iframe src=\"https://leetcode.com/playground/VzAVPq7w/shared\" frameborder=\"0\" name=\"VzAVPq7w\" width=\"100%\" height=\"360\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity: <script type=\"math/tex; mode=display\">O(n^3)</script>.</p> \n    <ul> \n     <li>For each element of array, we find all the subarrays starting from that index which is <script type=\"math/tex; mode=display\">O(n^2)</script>.</li> \n     <li>Time complexity to find the sum of each subarray is <script type=\"math/tex; mode=display\">O(n)</script>.</li> \n     <li>Thus, the total time complexity : <script type=\"math/tex; mode=display\">O(n^2 * n) = O(n^3)</script> </li> \n    </ul> </li> \n   <li> <p>Space complexity: <script type=\"math/tex; mode=display\">O(1)</script> extra space.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-a-better-brute-force-accepted\">Approach #2 A better brute force [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>In Approach #1, you may notice that the sum is calculated for every surarray in <script type=\"math/tex; mode=display\">O(n)</script> time. But, we could easily find the sum in O(1) time by storing the cumulative sum from the beginning(Memoization). After we have stored the cumulative sum in <script type=\"math/tex; mode=display\">\\text{sums}</script>, we could easily find the sum of any subarray from <script type=\"math/tex; mode=display\">i</script> to <script type=\"math/tex; mode=display\">j</script>.</p> \n  <p><strong>Algorithm</strong></p> \n  <ul> \n   <li>The algorithm is similar to Approach #1.</li> \n   <li>The only difference is in the way of finding the sum of subarrays:\n    <ul> \n     <li>Create a vector <script type=\"math/tex; mode=display\">\\text{sums}</script> of size of <script type=\"math/tex; mode=display\">\\text{nums}</script> </li> \n     <li>Initialize <script type=\"math/tex; mode=display\">\\text{sums}[0]=\\text{nums}[0]</script> </li> \n     <li>Iterate over the <script type=\"math/tex; mode=display\">\\text{sums}</script> vector:\n      <ul> \n       <li>Update <script type=\"math/tex; mode=display\">\\text{sums}[i] = \\text{sums}[i-1] + \\text{nums}[i]</script> </li> \n      </ul> </li> \n     <li>Sum of subarray from <script type=\"math/tex; mode=display\">i</script> to <script type=\"math/tex; mode=display\">j</script> is calculated as: <script type=\"math/tex; mode=display\">\\text{sum}=\\text{sums}[j] - \\text{sums}[i] +\\text{nums}[i]</script>, , wherein <script type=\"math/tex; mode=display\">\\text{sums}[j] - \\text{sums}[i]</script> is the sum from (<script type=\"math/tex; mode=display\">i+1</script>)th element to the <script type=\"math/tex; mode=display\">j</script>th element.</li> \n    </ul> </li> \n  </ul> \n  <iframe src=\"https://leetcode.com/playground/zpQxiiBt/shared\" frameborder=\"0\" name=\"zpQxiiBt\" width=\"100%\" height=\"411\"></iframe> \n  <p><strong>Complexity analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity: <script type=\"math/tex; mode=display\">O(n^2)</script>.</p> \n    <ul> \n     <li>Time complexity to find all the subarrays is <script type=\"math/tex; mode=display\">O(n^2)</script>.</li> \n     <li>Sum of the subarrays is calculated in <script type=\"math/tex; mode=display\">O(1)</script> time.</li> \n     <li>Thus, the total time complexity: <script type=\"math/tex; mode=display\">O(n^2 * 1) = O(n^2)</script> </li> \n    </ul> </li> \n   <li> <p>Space complexity: <script type=\"math/tex; mode=display\">O(n)</script> extra space.</p> \n    <ul> \n     <li>Additional <script type=\"math/tex; mode=display\">O(n)</script> space for <script type=\"math/tex; mode=display\">\\text{sums}</script> vector than in Approach #1.</li> \n    </ul> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-using-binary-search-accepted\">Approach #3 Using Binary search [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>We could further improve the Approach #2 using the binary search. Notice that we find the subarray with <script type=\"math/tex; mode=display\">\\text{sum} >=\\text{s}</script> starting with an index <script type=\"math/tex; mode=display\">i</script> in <script type=\"math/tex; mode=display\">O(n)</script> time. But, we could reduce the time to <script type=\"math/tex; mode=display\">O(\\log(n))</script> using binary search. Note that in Approach #2, we search for subarray starting with index <script type=\"math/tex; mode=display\">i</script>, until we find <script type=\"math/tex; mode=display\">\\text{sum}=\\text{sums}[j] - \\text{sums}[i] +\\text{nums}[i]</script> that is greater than <script type=\"math/tex; mode=display\">\\text{s}</script>. So, instead of iterating linearly to find the sum, we could use binary search to find the index that is not lower than <script type=\"math/tex; mode=display\">\\text{s}-\\text{sums[i]}</script> in the <script type=\"math/tex; mode=display\">\\text{sums}</script>, which can be done using <script type=\"math/tex; mode=display\">\\text{lower_bound}</script> function in C++ STL or could be implemented manually.</p> \n  <p><strong>Algorithm</strong></p> \n  <ul> \n   <li> <p>Create vector <script type=\"math/tex; mode=display\">sums</script> of size <script type=\"math/tex; mode=display\">n+1</script> with : <script type=\"math/tex; mode=display\">\\text{sums}[0]=0\\text{, }\\text{sums}[i]=\\text{sums}[i-1]+\\text{nums}[i-1]</script> </p> </li> \n   <li> <p>Iterate from <script type=\"math/tex; mode=display\">i=1</script> to <script type=\"math/tex; mode=display\">n</script>:</p> \n    <ul> \n     <li>Find the value <script type=\"math/tex; mode=display\">\\text{to_find}</script> in <script type=\"math/tex; mode=display\">\\text{sum}</script> required for minimum subarray starting from index <script type=\"math/tex; mode=display\">i</script> to have sum greater than <script type=\"math/tex; mode=display\">s</script>, that is: <script type=\"math/tex; mode=display\">\\text{to_find}=\\text{s}+\\text{sums}[i-1]</script> </li> \n     <li>Find the index in <script type=\"math/tex; mode=display\">\\text{sums}</script> such that value at that index is not lower than the <script type=\"math/tex; mode=display\">\\text{to_find}</script> value, say <script type=\"math/tex; mode=display\">\\text{bound}</script> </li> \n     <li>If we find the <script type=\"math/tex; mode=display\">\\text{to_find}</script> in <script type=\"math/tex; mode=display\">\\text{sums}</script>, then:\n      <ul> \n       <li>Size of current subarray is given by: <script type=\"math/tex; mode=display\">\\text{bound} - (\\text{sums.begin}()+i-1)</script> </li> \n       <li>Compare <script type=\"math/tex; mode=display\">ans</script> with the current subarray size and store minimum in <script type=\"math/tex; mode=display\">ans</script> </li> \n      </ul> </li> \n    </ul> </li> \n  </ul> \n  <iframe src=\"https://leetcode.com/playground/hVhQq7az/shared\" frameborder=\"0\" name=\"hVhQq7az\" width=\"100%\" height=\"411\"></iframe> \n  <p><strong>Complexity analysis</strong></p> \n  <ul> \n   <li>Time complexity: <script type=\"math/tex; mode=display\">O(n\\log(n))</script>.\n    <ul> \n     <li>For each element in the vector, find the subarray starting from that index, and having sum greater than <script type=\"math/tex; mode=display\">s</script> using binary search. Hence, the time required is <script type=\"math/tex; mode=display\">O(n)</script> for iteration over the vector and <script type=\"math/tex; mode=display\">O(\\log(n))</script> for finding the subarray for each index using binary search.</li> \n     <li>Therefore, total time complexity = <script type=\"math/tex; mode=display\">O(n*\\log(n))</script> </li> \n    </ul> </li> \n   <li>Space complexity: <script type=\"math/tex; mode=display\">O(n)</script>. Additional <script type=\"math/tex; mode=display\">O(n)</script> space for <script type=\"math/tex; mode=display\">\\text{sums}</script> vector</li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-4-using-2-pointers-accepted\">Approach #4 Using 2 pointers [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Until now, we have kept the starting index of subarray fixed, and found the last position. Instead, we could move the starting index of the current subarray as soon as we know that no better could be done with this index as the starting index. We could keep 2 pointer,one for the start and another for the end of the current subarray, and make optimal moves so as to keep the <script type=\"math/tex; mode=display\">\\text{sum}</script> greater than <script type=\"math/tex; mode=display\">s</script> as well as maintain the lowest size possible.</p> \n  <p><strong>Algorithm</strong></p> \n  <ul> \n   <li>Initialize <script type=\"math/tex; mode=display\">\\text{left}</script> pointer to 0 and <script type=\"math/tex; mode=display\">\\text{sum}</script> to 0</li> \n   <li>Iterate over the <script type=\"math/tex; mode=display\">\\text{nums}</script>:\n    <ul> \n     <li>Add <script type=\"math/tex; mode=display\">\\text{nums}[i]</script> to <script type=\"math/tex; mode=display\">\\text{sum}</script> </li> \n     <li>While <script type=\"math/tex; mode=display\">\\text{sum}</script> is greater than or equal to <script type=\"math/tex; mode=display\">s</script>:\n      <ul> \n       <li>Update <script type=\"math/tex; mode=display\">\\text{ans}=\\min(\\text{ans},i+1-\\text{left})</script>, where <script type=\"math/tex; mode=display\">i+1-\\text{left}</script> is the size of current subarray</li> \n       <li>It means that the first index can safely be incremented, since, the minimum subarray starting with this index with <script type=\"math/tex; mode=display\">\\text{sum} \\geq s</script> has been achieved</li> \n       <li>Subtract <script type=\"math/tex; mode=display\">\\text{nums[left]}</script> from <script type=\"math/tex; mode=display\">\\text{sum}</script> and increment <script type=\"math/tex; mode=display\">\\text{left}</script> </li> \n      </ul> </li> \n    </ul> </li> \n  </ul> \n  <iframe src=\"https://leetcode.com/playground/TxnK5kAo/shared\" frameborder=\"0\" name=\"TxnK5kAo\" width=\"100%\" height=\"309\"></iframe> \n  <p><strong>Complexity analysis</strong></p> \n  <ul> \n   <li>Time complexity: <script type=\"math/tex; mode=display\">O(n)</script>. Single iteration of <script type=\"math/tex; mode=display\">O(n)</script>.\n    <ul> \n     <li>Each element can be visited atmost twice, once by the right pointer(<script type=\"math/tex; mode=display\">i</script>) and (atmost)once by the <script type=\"math/tex; mode=display\">\\text{left}</script> pointer.</li> \n    </ul> </li> \n   <li>Space complexity: <script type=\"math/tex; mode=display\">O(1)</script> extra space. Only constant space required for <script type=\"math/tex; mode=display\">\\text{left}</script>, <script type=\"math/tex; mode=display\">\\text{sum}</script>, <script type=\"math/tex; mode=display\">\\text{ans}</script> and <script type=\"math/tex; mode=display\">i</script>.</li> \n  </ul> \n  <hr> \n  <p>Analysis written by <a href=\"https://leetcode.com/abhinavbansal0\">@abhinavbansal0</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 208,
    "article_live": true,
    "article_slug": "implement-trie-prefix-tree",
    "title": "Implement Trie (Prefix Tree)",
    "title_slug": "implement-trie-prefix-tree",
    "content": "<p>Implement a trie with <code>insert</code>, <code>search</code>, and <code>startsWith</code> methods.</p>\r\n\r\n<p><b>Example:</b></p>\r\n\r\n<pre>\r\nTrie trie = new Trie();\r\n\r\ntrie.insert(&quot;apple&quot;);\r\ntrie.search(&quot;apple&quot;);   // returns true\r\ntrie.search(&quot;app&quot;);     // returns false\r\ntrie.startsWith(&quot;app&quot;); // returns true\r\ntrie.insert(&quot;app&quot;);   \r\ntrie.search(&quot;app&quot;);     // returns true\r\n</pre>\r\n\r\n<p><b>Note:</b></p>\r\n\r\n<ul>\r\n\t<li>You may assume that all inputs are consist of lowercase letters <code>a-z</code>.</li>\r\n\t<li>All inputs are guaranteed to be non-empty strings.</li>\r\n</ul>\r\n",
    "tags": "Design, Trie",
    "difficulty": 2,
    "frontend_article_id": 208,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#summary\">Summary</a></li> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#applications\">Applications</a>\n       <ul> \n        <li><a href=\"#1-autocomplete\">1. Autocomplete</a></li> \n        <li><a href=\"#2-spell-checker\">2. Spell checker</a></li> \n        <li><a href=\"#3-ip-routing-longest-prefix-matching\">3. IP routing (Longest prefix matching)</a></li> \n        <li><a href=\"#4-t9-predictive-text\">4. T9 predictive text</a></li> \n        <li><a href=\"#5-solving-word-games\">5. Solving word games</a></li> \n       </ul> </li> \n      <li><a href=\"#trie-node-structure\">Trie node structure</a></li> \n      <li><a href=\"#insertion-of-a-key-to-a-trie\">Insertion of a key to a trie</a></li> \n      <li><a href=\"#search-for-a-key-in-a-trie\">Search for a key in a trie</a></li> \n      <li><a href=\"#search-for-a-key-prefix-in-a-trie\">Search for a key prefix in a trie</a></li> \n     </ul> </li> \n    <li><a href=\"#practice-problems\">Practice Problems</a></li> \n   </ul> \n  </div> \n  <h2 id=\"summary\">Summary</h2> \n  <p>This article is for intermediate level users. It introduces the following ideas: The data structure Trie (Prefix tree) and most common operations with it.</p> \n  <h2 id=\"solution\">Solution</h2> \n  <h4 id=\"applications\">Applications</h4> \n  <p>Trie (we pronounce \"try\") or prefix tree is a tree data structure, which is used for retrieval of a key in a dataset of strings. There are various applications of this very efficient data structure such as :</p> \n  <h5 id=\"1-autocomplete\">1. <a href=\"https://en.wikipedia.org/wiki/Autocomplete\">Autocomplete</a></h5> \n  <p align=\"center\"><img alt=\"Google Suggest\" src=\"https://leetcode.com/media/original_images/208_GoogleSuggest.png\" width=\"539px\"></p> \n  <p align=\"center\"><em>Figure 1. Google Suggest in action.</em></p> \n  <h5 id=\"2-spell-checker\">2. <a href=\"https://en.wikipedia.org/wiki/Spell_checker\">Spell checker</a></h5> \n  <p align=\"center\"><img alt=\"Spell Checker\" src=\"https://leetcode.com/media/original_images/208_SpellCheck.png\" width=\"400px\"></p> \n  <p align=\"center\"><em>Figure 2. A spell checker used in word processor.</em></p> \n  <h5 id=\"3-ip-routing-longest-prefix-matching\">3. <a href=\"https://en.wikipedia.org/wiki/Longest_prefix_match\">IP routing (Longest prefix matching)</a></h5> \n  <p align=\"center\"><img alt=\"IP Routing\" src=\"https://leetcode.com/media/original_images/208_IPRouting.gif\" width=\"539px\"></p> \n  <p align=\"center\"><em>Figure 3. Longest prefix matching algorithm uses Tries in Internet Protocol (IP) routing to select an entry from a forwarding table.</em></p> \n  <h5 id=\"4-t9-predictive-text\">4. <a href=\"https://en.wikipedia.org/wiki/T9_(predictive_text)\">T9 predictive text</a></h5> \n  <p align=\"center\"><img alt=\"T9 Predictive Text\" src=\"https://leetcode.com/media/original_images/208_T9.jpg\"></p> \n  <p align=\"center\"><em>Figure 4. T9 which stands for Text on 9 keys, was used on phones to input texts during the late 1990s.</em></p> \n  <h5 id=\"5-solving-word-games\">5. <a href=\"https://en.wikipedia.org/wiki/Boggle\">Solving word games</a></h5> \n  <p align=\"center\"><img alt=\"Boggle\" src=\"https://leetcode.com/media/original_images/208_Boggle.png\" width=\"350px\"></p> \n  <p align=\"center\"><em>Figure 5. Tries is used to solve Boggle efficiently by pruning the search space.</em></p> \n  <p>There are several other data structures, like balanced trees and hash tables, which give us the possibility to search for a word in a dataset of strings. Then why do we need trie? Although hash table has <script type=\"math/tex; mode=display\">O(1)</script> time complexity for looking for a key, it is not efficient in the following operations :</p> \n  <ul> \n   <li>Finding all keys with a common prefix.</li> \n   <li>Enumerating a dataset of strings in lexicographical order.</li> \n  </ul> \n  <p>Another reason why trie outperforms hash table, is that as hash table increases in size, there are lots of hash collisions and the search time complexity could deteriorate to <script type=\"math/tex; mode=display\">O(n)</script>, where <script type=\"math/tex; mode=display\">n</script> is the number of keys inserted. Trie could use less space compared to Hash Table when storing many keys with the same prefix. In this case using trie has only <script type=\"math/tex; mode=display\">O(m)</script> time complexity, where <script type=\"math/tex; mode=display\">m</script> is the key length. Searching for a key in a balanced tree costs <script type=\"math/tex; mode=display\">O(m \\log n)</script> time complexity.</p> \n  <h4 id=\"trie-node-structure\">Trie node structure</h4> \n  <p>Trie is a rooted tree. Its nodes have the following fields:</p> \n  <ul> \n   <li>Maximum of <script type=\"math/tex; mode=display\">R</script> links to its children, where each link corresponds to one of <script type=\"math/tex; mode=display\">R</script> character values from dataset alphabet. In this article we assume that <script type=\"math/tex; mode=display\">R</script> is 26, the number of lowercase latin letters.</li> \n   <li>Boolean field which specifies whether the node corresponds to the end of the key, or is just a key prefix.</li> \n  </ul> \n  <p align=\"center\"><img alt=\"Representation of a key in trie\" src=\"https://leetcode.com/media/original_images/208_Node.png\" width=\"539px\"></p> \n  <p align=\"center\"><em>Figure 6. Representation of a key \"leet\" in trie.</em></p> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">class</span> <span class=\"nc\">TrieNode</span> <span class=\"o\">{</span>\n\n    <span class=\"c1\">// R links to node children</span>\n    <span class=\"kd\">private</span> <span class=\"n\">TrieNode</span><span class=\"o\">[]</span> <span class=\"n\">links</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">R</span> <span class=\"o\">=</span> <span class=\"mi\">26</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">private</span> <span class=\"kt\">boolean</span> <span class=\"n\">isEnd</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"nf\">TrieNode</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">links</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">TrieNode</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">];</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">containsKey</span><span class=\"o\">(</span><span class=\"kt\">char</span> <span class=\"n\">ch</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">links</span><span class=\"o\">[</span><span class=\"n\">ch</span> <span class=\"o\">-</span><span class=\"sc\">'a'</span><span class=\"o\">]</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"kd\">public</span> <span class=\"n\">TrieNode</span> <span class=\"nf\">get</span><span class=\"o\">(</span><span class=\"kt\">char</span> <span class=\"n\">ch</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">links</span><span class=\"o\">[</span><span class=\"n\">ch</span> <span class=\"o\">-</span><span class=\"sc\">'a'</span><span class=\"o\">];</span>\n    <span class=\"o\">}</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">put</span><span class=\"o\">(</span><span class=\"kt\">char</span> <span class=\"n\">ch</span><span class=\"o\">,</span> <span class=\"n\">TrieNode</span> <span class=\"n\">node</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">links</span><span class=\"o\">[</span><span class=\"n\">ch</span> <span class=\"o\">-</span><span class=\"sc\">'a'</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">node</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">setEnd</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">isEnd</span> <span class=\"o\">=</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">isEnd</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">isEnd</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p>Two of the most common operations in a trie are insertion of a key and search for a key.</p> \n  <h4 id=\"insertion-of-a-key-to-a-trie\">Insertion of a key to a trie</h4> \n  <p>We insert a key by searching into the trie. We start from the root and search a link, which corresponds to the first key character. There are two cases :</p> \n  <ul> \n   <li>A link exists. Then we move down the tree following the link to the next child level. The algorithm continues with searching for the next key character.</li> \n   <li>A link does not exist. Then we create a new node and link it with the parent's link matching the current key character. We repeat this step until we encounter the last character of the key, then we mark the current node as an end node and the algorithm finishes.</li> \n  </ul> \n  <p align=\"center\"><img alt=\"Insertion of keys into a trie\" src=\"https://leetcode.com/media/original_images/208_TrieInsert.png\" width=\"539px\"></p> \n  <p align=\"center\"><em>Figure 7. Insertion of keys into a trie.</em></p> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">class</span> <span class=\"nc\">Trie</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"n\">TrieNode</span> <span class=\"n\">root</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"nf\">Trie</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">root</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">TrieNode</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"c1\">// Inserts a word into the trie.</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">insert</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">word</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">TrieNode</span> <span class=\"n\">node</span> <span class=\"o\">=</span> <span class=\"n\">root</span><span class=\"o\">;</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">word</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">();</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"kt\">char</span> <span class=\"n\">currentChar</span> <span class=\"o\">=</span> <span class=\"n\">word</span><span class=\"o\">.</span><span class=\"na\">charAt</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">);</span>\n            <span class=\"k\">if</span> <span class=\"o\">(!</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">containsKey</span><span class=\"o\">(</span><span class=\"n\">currentChar</span><span class=\"o\">))</span> <span class=\"o\">{</span>\n                <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"n\">currentChar</span><span class=\"o\">,</span> <span class=\"k\">new</span> <span class=\"n\">TrieNode</span><span class=\"o\">());</span>\n            <span class=\"o\">}</span>\n            <span class=\"n\">node</span> <span class=\"o\">=</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">currentChar</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n        <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">setEnd</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time complexity : <script type=\"math/tex; mode=display\">O(m)</script>, where m is the key length.</li> \n  </ul> \n  <p>In each iteration of the algorithm, we either examine or create a node in the trie till we reach the end of the key. This takes only <script type=\"math/tex; mode=display\">m</script> operations.</p> \n  <ul> \n   <li>Space complexity : <script type=\"math/tex; mode=display\">O(m)</script>.</li> \n  </ul> \n  <p>In the worst case newly inserted key doesn't share a prefix with the the keys already inserted in the trie. We have to add <script type=\"math/tex; mode=display\">m</script> new nodes, which takes us <script type=\"math/tex; mode=display\">O(m)</script> space.</p> \n  <h4 id=\"search-for-a-key-in-a-trie\">Search for a key in a trie</h4> \n  <p>Each key is represented in the trie as a path from the root to the internal node or leaf. We start from the root with the first key character. We examine the current node for a link corresponding to the key character. There are two cases :</p> \n  <ul> \n   <li>A link exist. We move to the next node in the path following this link, and proceed searching for the next key character.</li> \n   <li> <p>A link does not exist. If there are no available key characters and current node is marked as <code>isEnd</code> we return true. Otherwise there are possible two cases in each of them we return false :</p> \n    <ul> \n     <li>There are key characters left, but it is impossible to follow the key path in the trie, and the key is missing.</li> \n     <li>No key characters left, but current node is not marked as <code>isEnd</code>. Therefore the search key is only a prefix of another key in the trie.</li> \n    </ul> </li> \n  </ul> \n  <p align=\"center\"><img alt=\"Search of a key in a trie\" src=\"https://leetcode.com/media/original_images/208_TrieSearchKey.png\" width=\"539px\"></p> \n  <p align=\"center\"><em>Figure 8. Search for a key in a trie.</em></p> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">class</span> <span class=\"nc\">Trie</span> <span class=\"o\">{</span>\n    <span class=\"o\">...</span>\n\n    <span class=\"c1\">// search a prefix or whole key in trie and</span>\n    <span class=\"c1\">// returns the node where search ends</span>\n    <span class=\"kd\">private</span> <span class=\"n\">TrieNode</span> <span class=\"nf\">searchPrefix</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">word</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">TrieNode</span> <span class=\"n\">node</span> <span class=\"o\">=</span> <span class=\"n\">root</span><span class=\"o\">;</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">word</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">();</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n           <span class=\"kt\">char</span> <span class=\"n\">curLetter</span> <span class=\"o\">=</span> <span class=\"n\">word</span><span class=\"o\">.</span><span class=\"na\">charAt</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">);</span>\n           <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">containsKey</span><span class=\"o\">(</span><span class=\"n\">curLetter</span><span class=\"o\">))</span> <span class=\"o\">{</span>\n               <span class=\"n\">node</span> <span class=\"o\">=</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">curLetter</span><span class=\"o\">);</span>\n           <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>\n               <span class=\"k\">return</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n           <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">node</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"c1\">// Returns if the word is in the trie.</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">search</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">word</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n       <span class=\"n\">TrieNode</span> <span class=\"n\">node</span> <span class=\"o\">=</span> <span class=\"n\">searchPrefix</span><span class=\"o\">(</span><span class=\"n\">word</span><span class=\"o\">);</span>\n       <span class=\"k\">return</span> <span class=\"n\">node</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">isEnd</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(m)</script> In each step of the algorithm we search for the next key character. In the worst case the algorithm performs <script type=\"math/tex; mode=display\">m</script> operations.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script> </p> </li> \n  </ul> \n  <h4 id=\"search-for-a-key-prefix-in-a-trie\">Search for a key prefix in a trie</h4> \n  <p>The approach is very similar to the one we used for searching a key in a trie. We traverse the trie from the root, till there are no characters left in key prefix or it is impossible to continue the path in the trie with the current key character. The only difference with the mentioned above <code>search for a key</code> algorithm is that when we come to an end of the key prefix, we always return true. We don't need to consider the <code>isEnd</code> mark of the current trie node, because we are searching for a prefix of a key, not for a whole key.</p> \n  <p align=\"center\"><img alt=\"Search of a key prefix in a trie\" src=\"https://leetcode.com/media/original_images/208_TrieSearchPrefix.png\" width=\"539px\"></p> \n  <p align=\"center\"><em>Figure 9. Search for a key prefix in a trie.</em></p> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">class</span> <span class=\"nc\">Trie</span> <span class=\"o\">{</span>\n    <span class=\"o\">...</span>\n\n    <span class=\"c1\">// Returns if there is any word in the trie</span>\n    <span class=\"c1\">// that starts with the given prefix.</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">startsWith</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">prefix</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">TrieNode</span> <span class=\"n\">node</span> <span class=\"o\">=</span> <span class=\"n\">searchPrefix</span><span class=\"o\">(</span><span class=\"n\">prefix</span><span class=\"o\">);</span>\n        <span class=\"k\">return</span> <span class=\"n\">node</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(m)</script> </p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script> </p> </li> \n  </ul> \n  <h2 id=\"practice-problems\">Practice Problems</h2> \n  <p>Here are some wonderful problems for you to practice which uses the Trie data structure.</p> \n  <ol> \n   <li><a href=\"https://leetcode.com/problems/add-and-search-word-data-structure-design/\">Add and Search Word - Data structure design</a> - Pretty much a direct application of Trie.</li> \n   <li><a href=\"https://leetcode.com/problems/word-search-ii/\">Word Search II</a> - Similar to Boggle.</li> \n  </ol> \n  <p>Analysis written by: @elmirap.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 207,
    "article_live": false,
    "title": "Course Schedule",
    "title_slug": "course-schedule",
    "content": "<p>There are a total of <i>n</i> courses you have to take, labeled from <code>0</code> to <code>n-1</code>.</p>\r\n\r\n<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: <code>[0,1]</code></p>\r\n\r\n<p>Given the total number of courses and a list of prerequisite <b>pairs</b>, is it possible for you to finish all courses?</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 2, [[1,0]] \r\n<strong>Output: </strong>true\r\n<strong>Explanation:</strong>&nbsp;There are a total of 2 courses to take. \r\n&nbsp;            To take course 1 you should have finished course 0. So it is possible.</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 2, [[1,0],[0,1]]\r\n<strong>Output: </strong>false\r\n<strong>Explanation:</strong>&nbsp;There are a total of 2 courses to take. \r\n&nbsp;            To take course 1 you should have finished course 0, and to take course 0 you should\r\n&nbsp;            also have finished course 1. So it is impossible.\r\n</pre>\r\n\r\n<p><b>Note:</b></p>\r\n\r\n<ol>\r\n\t<li>The input prerequisites is a graph represented by <b>a list of edges</b>, not adjacency matrices. Read more about <a href=\"https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs\" target=\"_blank\">how a graph is represented</a>.</li>\r\n\t<li>You may assume that there are no duplicate edges in the input prerequisites.</li>\r\n</ol>\r\n",
    "tags": "Depth-first Search, Breadth-first Search, Graph, Topological Sort",
    "difficulty": 2,
    "frontend_article_id": 207
},
{
    "frontend_question_id": 206,
    "article_live": true,
    "article_slug": "reverse-linked-list",
    "title": "Reverse Linked List",
    "title_slug": "reverse-linked-list",
    "content": "<p>Reverse a singly linked list.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL\r\n<strong>Output:</strong> 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL\r\n</pre>\r\n\r\n<p><b>Follow up:</b></p>\r\n\r\n<p>A linked list can be reversed either iteratively or recursively. Could you implement both?</p>\r\n",
    "tags": "Linked List",
    "difficulty": 1,
    "frontend_article_id": 206,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-iterative-accepted\">Approach #1 (Iterative) [Accepted]</a></li> \n      <li><a href=\"#approach-2-recursive-accepted\">Approach #2 (Recursive) [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-iterative-accepted\">Approach #1 (Iterative) [Accepted]</h4> \n  <p>Assume that we have linked list <code>1 → 2 → 3 → Ø</code>, we would like to change it to <code>Ø ← 1 ← 2 ← 3</code>.</p> \n  <p>While you are traversing the list, change the current node's next pointer to point to its previous element. Since a node does not have reference to its previous node, you must store its previous element beforehand. You also need another pointer to store the next node before changing the reference. Do not forget to return the new head reference at the end!</p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">public</span> <span class=\"n\">ListNode</span> <span class=\"nf\">reverseList</span><span class=\"o\">(</span><span class=\"n\">ListNode</span> <span class=\"n\">head</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">ListNode</span> <span class=\"n\">prev</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n    <span class=\"n\">ListNode</span> <span class=\"n\">curr</span> <span class=\"o\">=</span> <span class=\"n\">head</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">curr</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">ListNode</span> <span class=\"n\">nextTemp</span> <span class=\"o\">=</span> <span class=\"n\">curr</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n        <span class=\"n\">curr</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"n\">prev</span><span class=\"o\">;</span>\n        <span class=\"n\">prev</span> <span class=\"o\">=</span> <span class=\"n\">curr</span><span class=\"o\">;</span>\n        <span class=\"n\">curr</span> <span class=\"o\">=</span> <span class=\"n\">nextTemp</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">prev</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Assume that <script type=\"math/tex; mode=display\">n</script> is the list's length, the time complexity is <script type=\"math/tex; mode=display\">O(n)</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-recursive-accepted\">Approach #2 (Recursive) [Accepted]</h4> \n  <p>The recursive version is slightly trickier and the key is to work backwards. Assume that the rest of the list had already been reversed, now how do I reverse the front part? Let's assume the list is: n<sub>1</sub> → … → n<sub>k-1</sub> → n<sub>k</sub> → n<sub>k+1</sub> → … → n<sub>m</sub> → Ø</p> \n  <p>Assume from node n<sub>k+1</sub> to n<sub>m</sub> had been reversed and you are at node n<sub>k</sub>.</p> \n  <p>n<sub>1</sub> → … → n<sub>k-1</sub> → <b>n<sub>k</sub></b> → n<sub>k+1</sub> ← … ← n<sub>m</sub></p> \n  <p>We want n<sub>k+1</sub>’s next node to point to n<sub>k</sub>.</p> \n  <p>So,</p> \n  <p>n<sub>k</sub>.next.next = n<sub>k</sub>;</p> \n  <p>Be very careful that n<sub>1</sub>'s next must point to Ø. If you forget about this, your linked list has a cycle in it. This bug could be caught if you test your code with a linked list of size 2.</p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">public</span> <span class=\"n\">ListNode</span> <span class=\"nf\">reverseList</span><span class=\"o\">(</span><span class=\"n\">ListNode</span> <span class=\"n\">head</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">head</span> <span class=\"o\">==</span> <span class=\"kc\">null</span> <span class=\"o\">||</span> <span class=\"n\">head</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"n\">head</span><span class=\"o\">;</span>\n    <span class=\"n\">ListNode</span> <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">reverseList</span><span class=\"o\">(</span><span class=\"n\">head</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">);</span>\n    <span class=\"n\">head</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"n\">head</span><span class=\"o\">;</span>\n    <span class=\"n\">head</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n    <span class=\"k\">return</span> <span class=\"n\">p</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Assume that <script type=\"math/tex; mode=display\">n</script> is the list's length, the time complexity is <script type=\"math/tex; mode=display\">O(n)</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The extra space comes from implicit stack space due to recursion. The recursion could go up to <script type=\"math/tex; mode=display\">n</script> levels deep.</p> </li> \n  </ul> \n </div> \n</div>"
},
{
    "frontend_question_id": 205,
    "article_live": false,
    "title": "Isomorphic Strings",
    "title_slug": "isomorphic-strings",
    "content": "<p>Given two strings <b><i>s</i></b> and <b><i>t</i></b>, determine if they are isomorphic.</p>\r\n\r\n<p>Two strings are isomorphic if the characters in <b><i>s</i></b> can be replaced to get <b><i>t</i></b>.</p>\r\n\r\n<p>All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> <b><i>s</i></b> = <code>&quot;egg&quot;, </code><b><i>t = </i></b><code>&quot;add&quot;</code>\r\n<strong>Output:</strong> true\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> <b><i>s</i></b> = <code>&quot;foo&quot;, </code><b><i>t = </i></b><code>&quot;bar&quot;</code>\r\n<strong>Output:</strong> false</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> <b><i>s</i></b> = <code>&quot;paper&quot;, </code><b><i>t = </i></b><code>&quot;title&quot;</code>\r\n<strong>Output:</strong> true</pre>\r\n\r\n<p><b>Note:</b><br />\r\nYou may assume both <b><i>s&nbsp;</i></b>and <b><i>t&nbsp;</i></b>have the same length.</p>\r\n",
    "tags": "Hash Table",
    "difficulty": 1,
    "frontend_article_id": 205
},
{
    "frontend_question_id": 204,
    "article_live": false,
    "title": "Count Primes",
    "title_slug": "count-primes",
    "content": "<p>Count the number of prime numbers less than a non-negative number, <b><i>n</i></b>.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 10\r\n<strong>Output:</strong> 4\r\n<strong>Explanation:</strong> There are 4 prime numbers less than 10, they are 2, 3, 5, 7.\r\n</pre>",
    "tags": "Hash Table, Math",
    "difficulty": 1,
    "frontend_article_id": 204
},
{
    "frontend_question_id": 203,
    "article_live": false,
    "title": "Remove Linked List Elements",
    "title_slug": "remove-linked-list-elements",
    "content": "<p>Remove all elements from a linked list of integers that have value <b><i>val</i></b>.</p>\r\n\r\n<p><b>Example:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b>  1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, <em><b>val</b></em> = 6\r\n<b>Output:</b> 1-&gt;2-&gt;3-&gt;4-&gt;5\r\n</pre>\r\n",
    "tags": "Linked List",
    "difficulty": 1,
    "frontend_article_id": 203
},
{
    "frontend_question_id": 202,
    "article_live": false,
    "title": "Happy Number",
    "title_slug": "happy-number",
    "content": "<p>Write an algorithm to determine if a number is &quot;happy&quot;.</p>\r\n\r\n<p>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</p>\r\n\r\n<p><strong>Example:&nbsp;</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 19\r\n<strong>Output:</strong> true\r\n<strong>Explanation: \r\n</strong>1<sup>2</sup> + 9<sup>2</sup> = 82\r\n8<sup>2</sup> + 2<sup>2</sup> = 68\r\n6<sup>2</sup> + 8<sup>2</sup> = 100\r\n1<sup>2</sup> + 0<sup>2</sup> + 0<sup>2</sup> = 1\r\n</pre>",
    "tags": "Hash Table, Math",
    "difficulty": 1,
    "frontend_article_id": 202
},
{
    "frontend_question_id": 201,
    "article_live": false,
    "title": "Bitwise AND of Numbers Range",
    "title_slug": "bitwise-and-of-numbers-range",
    "content": "<p>Given a range [m, n] where 0 &lt;= m &lt;= n &lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [5,7]\r\n<strong>Output:</strong> 4\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [0,1]\r\n<strong>Output:</strong> 0</pre>",
    "tags": "Bit Manipulation",
    "difficulty": 2,
    "frontend_article_id": 201
},
{
    "frontend_question_id": 200,
    "article_live": true,
    "article_slug": "number-of-islands",
    "title": "Number of Islands",
    "title_slug": "number-of-islands",
    "content": "<p>Given a 2d grid map of <code>&#39;1&#39;</code>s (land) and <code>&#39;0&#39;</code>s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>\r\n11110\r\n11010\r\n11000\r\n00000\r\n\r\n<strong>Output:</strong>&nbsp;1\r\n</pre>\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>\r\n11000\r\n11000\r\n00100\r\n00011\r\n\r\n<strong>Output: </strong>3\r\n</pre>",
    "tags": "Depth-first Search, Breadth-first Search, Union Find",
    "difficulty": 2,
    "frontend_article_id": 200,
    "article_content": ""
},
{
    "frontend_question_id": 199,
    "article_live": true,
    "article_slug": "binary-tree-right-side-view",
    "title": "Binary Tree Right Side View",
    "title_slug": "binary-tree-right-side-view",
    "content": "<p>Given a binary tree, imagine yourself standing on the <em>right</em> side of it, return the values of the nodes you can see ordered from top to bottom.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>&nbsp;[1,2,3,null,5,null,4]\r\n<strong>Output:</strong>&nbsp;[1, 3, 4]\r\n<strong>Explanation:\r\n</strong>\r\n   1            &lt;---\r\n /   \\\r\n2     3         &lt;---\r\n \\     \\\r\n  5     4       &lt;---\r\n</pre>",
    "tags": "Tree, Depth-first Search, Breadth-first Search",
    "difficulty": 2,
    "frontend_article_id": 199,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#initial-thoughts\">Initial Thoughts</a></li> \n    <li><a href=\"#approach-1-depth-first-search-accepted\">Approach #1 Depth-First Search [Accepted]</a></li> \n    <li><a href=\"#approach-2-breadth-first-search-accepted\">Approach #2 Breadth-First Search [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"initial-thoughts\">Initial Thoughts</h4> \n  <p>Because the tree topography is unknown ahead of time, it is not possible to design an algorithm that visits asymptotically fewer than <script type=\"math/tex; mode=display\">n</script> nodes. Therefore, we should try to aim for a linear time solution. With that in mind, let's consider a few equally-efficient solutions.</p> \n  <h4 id=\"approach-1-depth-first-search-accepted\">Approach #1 Depth-First Search [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>We can efficiently obtain the right-hand view of the binary tree if we visit each node in the proper order.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>One of the aforementioned orderings is defined by a depth-first search in which we always visit the right subtree first. This guarantees that the first time we visit a particular depth of the tree, the node that we are visiting is the rightmost node at that depth. Therefore, we can store the value of the first node that we visit at each depth, ultimately generating a final array of values once we know exactly how many layers are in the tree.</p> \n  <p align=\"center\"><img alt=\"Depth-First Search\" src=\"../Figures/199/199_depth_first.png\"></p> \n  <p>The figure above illustrates one instance of the problem. The red nodes compose the solution from top to bottom, and the edges are labelled in order of visitation.</p> \n  <iframe src=\"https://leetcode.com/playground/U8377M7P/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"U8377M7P\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>.</p> <p>Because a binary tree with only child pointers is <em>directed acyclic graph</em> with only one source node, a traversal of the tree from the root will visit each node exactly once (plus a sublinear amount of leaves, represented as <code>None</code>). Each visitation requires only <script type=\"math/tex; mode=display\">O(1)</script> work, so the while loop runs in linear time. Finally, building the array of rightmost values is <script type=\"math/tex; mode=display\">O(</script>height of the tree<script type=\"math/tex; mode=display\">) = O(n)</script> because it is not possible for a right-hand view of the tree to contain more nodes than the tree itself.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>.</p> <p>At worst, our stack will contain a number of nodes close to the height of the tree. Because we are exploring the tree in a depth-first order, there are never two nodes from different subtrees of the same parent node on the stack at once. Said another way, the entire right subtree of a node will be visited before any nodes of the left subtree are pushed onto the stack. If this logic is applied recursively down the tree, it follows that the stack will be largest when we have reached the end of the tree's longest path (the height of the tree). However, because we know nothing about the tree's topography, the height of the tree may be equivalent to <script type=\"math/tex; mode=display\">n</script>, causing the space complexity to degrade to <script type=\"math/tex; mode=display\">O(n)</script>.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-breadth-first-search-accepted\">Approach #2 Breadth-First Search [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Much like depth-first search can guarantee that we visit a depth's rightmost node first, breadth-first search can guarantee that we visit it <em>last</em>.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>By performing a breadth-first search that enqueues the left child before the right child, we visit each node in each layer from left to right. Therefore, by retaining only the most recently visited node per depth, we will have the rightmost node for each depth once we finish the tree traversal. The algorithm is unchanged, other than swapping out the stack for a <code>deque</code><sup id=\"fnref:1\"><a class=\"footnote-ref\" href=\"#fn:1\" rel=\"footnote\">1</a></sup> and removing the containment check before assigning into <code>rightmost_value_at_depth</code>.</p> \n  <p align=\"center\"><img alt=\"Breadth-first Search Example\" src=\"../Figures/199/199_breadth_first.png\"></p> \n  <p>The figure above illustrates the same instance as before, but solved via breadth-first search. The red nodes compose the solution from top to bottom, and the edges are labelled in order of visitation.</p> \n  <iframe src=\"https://leetcode.com/playground/9Aia2BUi/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"9Aia2BUi\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>.</p> <p>The differences itemized in the <strong>Algorithm</strong> section do not admit differences in the time complexity analysis between the bread-first and depth-first search approaches.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>.</p> <p>Because breadth-first search visits the tree layer-by-layer, the queue will be at its largest immediately before visiting the largest layer. The size of this layer is <script type=\"math/tex; mode=display\">0.5n = O(n)</script> in the worst case (a complete binary tree).</p> </li> \n  </ul> \n  <hr> \n  <p><strong>Footnotes</strong></p> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/emptyset\">@emptyset</a></p> \n  <div class=\"footnote\"> \n   <hr> \n   <ol> \n    <li id=\"fn:1\"> <p>The <a href=\"https://docs.python.org/3/library/collections.html#collections.deque\"><code>deque</code></a> datatype from the <a href=\"https://docs.python.org/3/library/collections.html\"><code>collections</code></a> module supports constant time append/pop from both the head and the tail. If we were to use a Python <code>list</code>, it would cost us <script type=\"math/tex; mode=display\">O(n)</script> time to remove its head via <code>list.pop(0)</code>.&nbsp;<a class=\"footnote-backref\" href=\"#fnref:1\" rev=\"footnote\" title=\"Jump back to footnote 1 in the text\">↩</a></p> </li> \n   </ol> \n  </div> \n </div> \n</div>"
},
{
    "frontend_question_id": 198,
    "article_live": true,
    "article_slug": "house-robber",
    "title": "House Robber",
    "title_slug": "house-robber",
    "content": "<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and <b>it will automatically contact the police if two adjacent houses were broken into on the same night</b>.</p>\r\n\r\n<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight <b>without alerting the police</b>.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [1,2,3,1]\r\n<strong>Output:</strong> 4\r\n<strong>Explanation:</strong> Rob house 1 (money = 1) and then rob house 3 (money = 3).\r\n&nbsp;            Total amount you can rob = 1 + 3 = 4.</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [2,7,9,3,1]\r\n<strong>Output:</strong> 12\r\n<strong>Explanation:</strong> Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\r\n&nbsp;            Total amount you can rob = 2 + 9 + 1 = 12.\r\n</pre>\r\n",
    "tags": "Dynamic Programming",
    "difficulty": 1,
    "frontend_article_id": 198,
    "article_content": ""
},
{
    "frontend_question_id": 191,
    "article_live": true,
    "article_slug": "number-1-bits",
    "title": "Number of 1 Bits",
    "title_slug": "number-of-1-bits",
    "content": "<p>Write a function that takes an unsigned integer and returns the number of &#39;1&#39;&nbsp;bits it has (also known as the <a href=\"http://en.wikipedia.org/wiki/Hamming_weight\">Hamming weight</a>).</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 11\r\n<strong>Output:</strong> 3\r\n<strong>Explanation: </strong>Integer 11 has binary representation <code><strong>00000000000000000000000000001011 </strong></code>\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 128\r\n<strong>Output:</strong> 1\r\n<strong>Explanation: </strong>Integer 128 has binary representation <strong>00000000000000000000000010000000</strong>\r\n</pre>\r\n",
    "tags": "Bit Manipulation",
    "difficulty": 1,
    "frontend_article_id": 191,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-loop-and-flip-accepted\">Approach #1 (Loop and Flip) [Accepted]</h4> \n  <p><strong> Algorithm</strong></p> \n  <p>The solution is straight-forward. We check each of the <script type=\"math/tex; mode=display\">32</script> bits of the number. If the bit is <script type=\"math/tex; mode=display\">1</script>, we add one to the number of <script type=\"math/tex; mode=display\">1</script>-bits.</p> \n  <p>We can check the <script type=\"math/tex; mode=display\">i^{th}</script> bit of a number using a <em>bit mask</em>. We start with a mask <script type=\"math/tex; mode=display\">m=1</script>, because the binary representation of <script type=\"math/tex; mode=display\">1</script> is,</p> \n  <p> <script type=\"math/tex; mode=display\">\n0000\\ 0000\\ 0000\\ 0000\\ 0000\\ 0000\\ 0000\\ 0001\n</script> Clearly, a logical AND between any number and the mask <script type=\"math/tex; mode=display\">1</script> gives us the least significant bit of this number. To check the next bit, we shift the mask to the left by one.</p> \n  <p> <script type=\"math/tex; mode=display\">\n0000\\ 0000\\ 0000\\ 0000\\ 0000\\ 0000\\ 0000\\ 0010\n</script> </p> \n  <p>And so on.</p> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">hammingWeight</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">bits</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">mask</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"o\">;</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"mi\">32</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">((</span><span class=\"n\">n</span> <span class=\"o\">&amp;</span> <span class=\"n\">mask</span><span class=\"o\">)</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">bits</span><span class=\"o\">++;</span>\n        <span class=\"o\">}</span>\n        <span class=\"n\">mask</span> <span class=\"o\">&lt;&lt;=</span> <span class=\"mi\">1</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">bits</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <p>The run time depends on the number of bits in <script type=\"math/tex; mode=display\">n</script>. Because <script type=\"math/tex; mode=display\">n</script> in this piece of code is a 32-bit integer, the time complexity is <script type=\"math/tex; mode=display\">O(1)</script>.</p> \n  <p>The space complexity is <script type=\"math/tex; mode=display\">O(1)</script>, since no additional space is allocated.</p> \n  <hr> \n  <h4 id=\"approach-2-bit-manipulation-trick-accepted\">Approach #2 (Bit Manipulation Trick) [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>We can make the previous algorithm simpler and a little faster. Instead of checking every bit of the number, we repeatedly flip the least-significant <script type=\"math/tex; mode=display\">1</script>-bit of the number to <script type=\"math/tex; mode=display\">0</script>, and add <script type=\"math/tex; mode=display\">1</script> to the sum. As soon as the number becomes <script type=\"math/tex; mode=display\">0</script>, we know that it does not have any more <script type=\"math/tex; mode=display\">1</script>-bits, and we return the sum.</p> \n  <p>The key idea here is to realize that for any number <script type=\"math/tex; mode=display\">n</script>, doing a bit-wise AND of <script type=\"math/tex; mode=display\">n</script> and <script type=\"math/tex; mode=display\">n - 1</script> flips the least-significant <script type=\"math/tex; mode=display\">1</script>-bit in <script type=\"math/tex; mode=display\">n</script> to <script type=\"math/tex; mode=display\">0</script>. Why? Consider the binary representations of <script type=\"math/tex; mode=display\">n</script> and <script type=\"math/tex; mode=display\">n - 1</script>.</p> \n  <p align=\"center\"><img alt=\"Number of 1 Bits\" src=\"https://leetcode.com/media/original_images/191_Number_Of_Bits.png\" width=\"400px\"></p> \n  <p align=\"center\"><em>Figure 1. AND-ing <script type=\"math/tex; mode=display\">n</script> and <script type=\"math/tex; mode=display\">n-1</script> flips the least-significant <script type=\"math/tex; mode=display\">1</script>-bit to 0.</em></p> \n  <p>In the binary representation, the least significant <script type=\"math/tex; mode=display\">1</script>-bit in <script type=\"math/tex; mode=display\">n</script> always corresponds to a <script type=\"math/tex; mode=display\">0</script>-bit in <script type=\"math/tex; mode=display\">n - 1</script>. Therefore, anding the two numbers <script type=\"math/tex; mode=display\">n</script> and <script type=\"math/tex; mode=display\">n - 1</script> always flips the least significant <script type=\"math/tex; mode=display\">1</script>-bit in <script type=\"math/tex; mode=display\">n</script> to <script type=\"math/tex; mode=display\">0</script>, and keeps all other bits the same.</p> \n  <p>Using this trick, the code becomes very simple.</p> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">hammingWeight</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">sum</span><span class=\"o\">++;</span>\n        <span class=\"n\">n</span> <span class=\"o\">&amp;=</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">sum</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <p>The run time depends on the number of <script type=\"math/tex; mode=display\">1</script>-bits in <script type=\"math/tex; mode=display\">n</script>. In the worst case, all bits in <script type=\"math/tex; mode=display\">n</script> are <script type=\"math/tex; mode=display\">1</script>-bits. In case of a 32-bit integer, the run time is <script type=\"math/tex; mode=display\">O(1)</script>.</p> \n  <p>The space complexity is <script type=\"math/tex; mode=display\">O(1)</script>, since no additional space is allocated.</p> \n  <p>Analysis written by: @noran.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 190,
    "article_live": false,
    "title": "Reverse Bits",
    "title_slug": "reverse-bits",
    "content": "<p>Reverse bits of a given 32 bits unsigned integer.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 43261596\r\n<strong>Output:</strong> 964176192\r\n<strong>Explanation: </strong>43261596 represented in binary as <b>00000010100101000001111010011100</b>, \r\n&nbsp;            return 964176192 represented in binary as <b>00111001011110000010100101000000</b>.\r\n</pre>\r\n\r\n<p><b>Follow up</b>:<br />\r\nIf this function is called many times, how would you optimize it?</p>",
    "tags": "Bit Manipulation",
    "difficulty": 1,
    "frontend_article_id": 190
},
{
    "frontend_question_id": 189,
    "article_live": true,
    "article_slug": "rotate-array",
    "title": "Rotate Array",
    "title_slug": "rotate-array",
    "content": "<p>Given an array, rotate the array to the right by <em>k</em> steps, where&nbsp;<em>k</em>&nbsp;is non-negative.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> <code>[1,2,3,4,5,6,7]</code> and <em>k</em> = 3\r\n<strong>Output:</strong> <code>[5,6,7,1,2,3,4]</code>\r\n<strong>Explanation:</strong>\r\nrotate 1 steps to the right: <code>[7,1,2,3,4,5,6]</code>\r\nrotate 2 steps to the right: <code>[6,7,1,2,3,4,5]\r\n</code>rotate 3 steps to the right: <code>[5,6,7,1,2,3,4]</code>\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> <code>[-1,-100,3,99]</code> and <em>k</em> = 2\r\n<strong>Output:</strong> [3,99,-1,-100]\r\n<strong>Explanation:</strong> \r\nrotate 1 steps to the right: [99,-1,-100,3]\r\nrotate 2 steps to the right: [3,99,-1,-100]\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.</li>\r\n\t<li>Could you do it in-place with O(1) extra space?</li>\r\n</ul>",
    "tags": "Array",
    "difficulty": 1,
    "frontend_article_id": 189,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#summary\">Summary</a></li> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</a></li> \n      <li><a href=\"#approach-2-using-extra-array-accepted\">Approach #2 Using Extra Array [Accepted]</a></li> \n      <li><a href=\"#approach-3-using-cyclic-replacements-accepted\">Approach #3 Using Cyclic Replacements [Accepted]</a></li> \n      <li><a href=\"#approach-4-using-reverse-accepted\">Approach #4 Using Reverse [Accepted]</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"summary\">Summary</h2> \n  <p>We have to rotate the elements of the given array k times to the right.</p> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force-time-limit-exceeded\">Approach #1 Brute Force [Time Limit Exceeded]</h4> \n  <p>The simplest approach is to rotate all the elements of the array in k steps by rotating the elements by 1 unit in each step.</p> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">rotate</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">temp</span><span class=\"o\">,</span> <span class=\"n\">previous</span><span class=\"o\">;</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">k</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"n\">previous</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">];</span>\n            <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">j</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n                <span class=\"n\">temp</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">];</span>\n                <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">previous</span><span class=\"o\">;</span>\n                <span class=\"n\">previous</span> <span class=\"o\">=</span> <span class=\"n\">temp</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time complexity : <script type=\"math/tex; mode=display\">O(n*k)</script>. All the numbers are shifted by one step(<script type=\"math/tex; mode=display\">O(n)</script>) k times(<script type=\"math/tex; mode=display\">O(k)</script>).</li> \n   <li>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. No extra space is used.</li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-using-extra-array-accepted\">Approach #2 Using Extra Array [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>We use an extra array in which we place every element of the array at its correct position i.e. the number at index <script type=\"math/tex; mode=display\">i</script> in the original array is placed at the index <script type=\"math/tex; mode=display\">(i+k)%(length of array)</script>. Then, we copy the new array to the original one.</p> \n  <p><strong>Java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">rotate</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">];</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"n\">a</span><span class=\"o\">[(</span><span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">%</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">];</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">];</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. One pass is used to put the numbers in the new array. And another pass to copy the new array to the original one.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Another array of the same size is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-using-cyclic-replacements-accepted\">Approach #3 Using Cyclic Replacements [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>We can directly place every number of the array at its required correct position. But if we do that, we will destroy the original element. Thus, we need to store the number being replaced in a <script type=\"math/tex; mode=display\">temp</script> variable. Then, we can place the replaced number(<script type=\"math/tex; mode=display\">temp</script>) at its correct position and so on, <script type=\"math/tex; mode=display\">n</script> times, where <script type=\"math/tex; mode=display\">n</script> is the length of array. We have chosen <script type=\"math/tex; mode=display\">n</script> to be the number of replacements since we have to shift all the elements of the array(which is <script type=\"math/tex; mode=display\">n</script>). But, there could be a problem with this method, if <script type=\"math/tex; mode=display\">n%k=0</script> where <script type=\"math/tex; mode=display\">k = k%n</script>(since a value of <script type=\"math/tex; mode=display\">k</script> larger than <script type=\"math/tex; mode=display\">n</script> eventually leads to a <script type=\"math/tex; mode=display\">k</script> equivalent to <script type=\"math/tex; mode=display\">k%n</script>). In this case, while picking up numbers to be placed at the correct position, we will eventually reach the number from which we originally started. Thus, in such a case, when we hit the original number's index again, we start the same process with the number following it.</p> \n  <p>Now let's look at the proof of how the above method works. Suppose, we have <script type=\"math/tex; mode=display\">n</script> as the number of elements in the array and <script type=\"math/tex; mode=display\">k</script> is the number of shifts required. Further, assume <script type=\"math/tex; mode=display\">n%k=0</script>. Now, when we start placing the elements at their correct position, in the first cycle all the numbers with their index <script type=\"math/tex; mode=display\">i</script> satisfying <script type=\"math/tex; mode=display\">i%k=0</script> get placed at their required position. This happens because when we jump k steps every time, we will only hit the numbers k steps apart. We start with index <script type=\"math/tex; mode=display\">i=0</script>, having <script type=\"math/tex; mode=display\">i%k=0</script>. Thus, we hit all the numbers satisfying the above condition in the first cycle. When we reach back the original index, we have placed <script type=\"math/tex; mode=display\">\\frac{n}{k}</script> elements at their correct position, since we hit only that many elements in the first cycle. Now, we increment the index for replacing the numbers. This time, we place other <script type=\"math/tex; mode=display\">\\frac{n}{k}</script> elements at their correct position, different from the ones placed correctly in the first cycle, because this time we hit all the numbers satisfy the condition <script type=\"math/tex; mode=display\">i%k=1</script>. When we hit the starting number again, we increment the index and repeat the same process from <script type=\"math/tex; mode=display\">i=1</script> for all the indices satisfying <script type=\"math/tex; mode=display\">i%k==1</script>. This happens till we reach the number with the index <script type=\"math/tex; mode=display\">i%k=0</script> again, which occurs for <script type=\"math/tex; mode=display\">i=k</script>. We will reach such a number after a total of k cycles. Now, the total count of numbers exclusive numbers placed at their correct position will be <script type=\"math/tex; mode=display\">k \\times \\frac{n}{k}=n</script>. Thus, all the numbers will be placed at their correct position.</p> \n  <p>Look at the following example to clarify the process: <code>nums: [1, 2, 3, 4, 5, 6] k: 2</code></p> \n  <p><img alt=\"Rotate Array\" src=\"https://leetcode.com/media/original_images/189_Rotate_Array.png\"></p> \n  <p><strong>java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">rotate</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"n\">k</span> <span class=\"o\">%</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span>\n        <span class=\"kt\">int</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">start</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">count</span> <span class=\"o\">&lt;</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">start</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"kt\">int</span> <span class=\"n\">current</span> <span class=\"o\">=</span> <span class=\"n\">start</span><span class=\"o\">;</span>\n            <span class=\"kt\">int</span> <span class=\"n\">prev</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">start</span><span class=\"o\">];</span>\n            <span class=\"k\">do</span> <span class=\"o\">{</span>\n                <span class=\"kt\">int</span> <span class=\"n\">next</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">current</span> <span class=\"o\">+</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">%</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span>\n                <span class=\"kt\">int</span> <span class=\"n\">temp</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">next</span><span class=\"o\">];</span>\n                <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">next</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">prev</span><span class=\"o\">;</span>\n                <span class=\"n\">prev</span> <span class=\"o\">=</span> <span class=\"n\">temp</span><span class=\"o\">;</span>\n                <span class=\"n\">current</span> <span class=\"o\">=</span> <span class=\"n\">next</span><span class=\"o\">;</span>\n                <span class=\"n\">count</span><span class=\"o\">++;</span>\n            <span class=\"o\">}</span> <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">start</span> <span class=\"o\">!=</span> <span class=\"n\">current</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Only one pass is used.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant extra space is used.</p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-4-using-reverse-accepted\">Approach #4 Using Reverse [Accepted]</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>This approach is based on the fact that when we rotate the array k times, <script type=\"math/tex; mode=display\">k%n</script> elements from the back end of the array come to the front and the rest of the elements from the front shift backwards.</p> \n  <p>In this approach, we firstly reverse all the elements of the array. Then, reversing the first k elements followed by reversing the rest <script type=\"math/tex; mode=display\">n-k</script> elements gives us the required result.</p> \n  <p>Let <script type=\"math/tex; mode=display\">n=7</script> and <script type=\"math/tex; mode=display\">k=3</script>.</p> \n  <div class=\"codehilite\">\n   <pre><span></span>Original List                   : 1 2 3 4 5 6 7\nAfter reversing all numbers     : 7 6 5 4 3 2 1\nAfter reversing first k numbers : 5 6 7 4 3 2 1\nAfter revering last n-k numbers : 5 6 7 1 2 3 4 --&gt; Result\n</pre>\n  </div> \n  <p><strong>java</strong></p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">rotate</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">k</span> <span class=\"o\">%=</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span>\n        <span class=\"n\">reverse</span><span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n        <span class=\"n\">reverse</span><span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">k</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n        <span class=\"n\">reverse</span><span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">reverse</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">start</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">end</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">start</span> <span class=\"o\">&lt;</span> <span class=\"n\">end</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kt\">int</span> <span class=\"n\">temp</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">start</span><span class=\"o\">];</span>\n            <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">start</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">end</span><span class=\"o\">];</span>\n            <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">end</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">temp</span><span class=\"o\">;</span>\n            <span class=\"n\">start</span><span class=\"o\">++;</span>\n            <span class=\"n\">end</span><span class=\"o\">--;</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre>\n  </div> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. <script type=\"math/tex; mode=display\">n</script> elements are reversed a total of three times.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. No extra space is used.</p> </li> \n  </ul> \n  <p>Analysis written by: <a href=\"https://leetcode.com/vinod23\">@vinod23</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 188,
    "article_live": false,
    "title": "Best Time to Buy and Sell Stock IV",
    "title_slug": "best-time-to-buy-and-sell-stock-iv",
    "content": "<p>Say you have an array for which the <i>i</i><sup>th</sup> element is the price of a given stock on day <i>i</i>.</p>\r\n\r\n<p>Design an algorithm to find the maximum profit. You may complete at most <b>k</b> transactions.</p>\r\n\r\n<p><b>Note:</b><br />\r\nYou may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [2,4,1], k = 2\r\n<strong>Output:</strong> 2\r\n<strong>Explanation:</strong> Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [3,2,6,5,0,3], k = 2\r\n<strong>Output:</strong> 7\r\n<strong>Explanation:</strong> Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4.\r\n&nbsp;            Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\r\n</pre>",
    "tags": "Dynamic Programming",
    "difficulty": 3,
    "frontend_article_id": 188
},
{
    "frontend_question_id": 187,
    "article_live": false,
    "title": "Repeated DNA Sequences",
    "title_slug": "repeated-dna-sequences",
    "content": "<p>All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: &quot;ACGAATTCCG&quot;. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.</p>\r\n\r\n<p>Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> s = &quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;\r\n\r\n<strong>Output:</strong> [&quot;AAAAACCCCC&quot;, &quot;CCCCCAAAAA&quot;]\r\n</pre>\r\n",
    "tags": "Hash Table, Bit Manipulation",
    "difficulty": 2,
    "frontend_article_id": 187
},
{
    "frontend_question_id": 186,
    "article_live": false,
    "title": "Reverse Words in a String II",
    "title_slug": "reverse-words-in-a-string-ii",
    "tags": "String",
    "difficulty": 2,
    "frontend_article_id": 186
},
{
    "frontend_question_id": 179,
    "article_live": true,
    "article_slug": "largest-number",
    "title": "Largest Number",
    "title_slug": "largest-number",
    "content": "<p>Given a list of non negative integers, arrange them such that they form the largest number.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> <code>[10,2]</code>\r\n<strong>Output:</strong> &quot;<code>210&quot;</code></pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> <code>[3,30,34,5,9]</code>\r\n<strong>Output:</strong> &quot;<code>9534330&quot;</code>\r\n</pre>\r\n\r\n<p><strong>Note:</strong> The result may be very large, so you need to return a string instead of an integer.</p>\r\n",
    "tags": "Sort",
    "difficulty": 2,
    "frontend_article_id": 179,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-sorting-via-custom-comparator-accepted\">Approach #1 Sorting via Custom Comparator [Accepted]</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-sorting-via-custom-comparator-accepted\">Approach #1 Sorting via Custom Comparator [Accepted]</h4> \n  <p><strong>Intuition</strong></p> \n  <p>To construct the largest number, we want to ensure that the most significant digits are occupied by the largest digits.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>First, we convert each integer to a string. Then, we sort the array of strings.</p> \n  <p>While it might be tempting to simply sort the numbers in descending order, this causes problems for sets of numbers with the same leading digit. For example, sorting the problem example in descending order would produce the number <script type=\"math/tex; mode=display\">9534303</script>, while the correct answer can be achieved by transposing the <script type=\"math/tex; mode=display\">3</script> and the <script type=\"math/tex; mode=display\">30</script>. Therefore, for each pairwise comparison during the sort, we compare the numbers achieved by concatenating the pair in both orders. We can prove that this sorts into the proper order as follows: </p> \n  <p>Assume that (without loss of generality), for some pair of integers <script type=\"math/tex; mode=display\">a</script> and <script type=\"math/tex; mode=display\">b</script>, our comparator dictates that <script type=\"math/tex; mode=display\">a</script> should precede <script type=\"math/tex; mode=display\">b</script> in sorted order. This means that <script type=\"math/tex; mode=display\">a\\frown b > b\\frown a</script> (where <script type=\"math/tex; mode=display\">\\frown</script> represents concatenation). For the sort to produce an incorrect ordering, there must be some <script type=\"math/tex; mode=display\">c</script> for which <script type=\"math/tex; mode=display\">b</script> precedes <script type=\"math/tex; mode=display\">c</script> and <script type=\"math/tex; mode=display\">c</script> precedes <script type=\"math/tex; mode=display\">a</script>. This is a contradiction because <script type=\"math/tex; mode=display\">a\\frown b > b\\frown a</script> and <script type=\"math/tex; mode=display\">b\\frown c > c\\frown b</script> implies <script type=\"math/tex; mode=display\">a\\frown c > c\\frown a</script>. In other words, our custom comparator preserves transitivity, so the sort is correct.</p> \n  <p>Once the array is sorted, the most \"signficant\" number will be at the front. There is a minor edge case that comes up when the array consists of only zeroes, so if the most significant number is <script type=\"math/tex; mode=display\">0</script>, we can simply return <script type=\"math/tex; mode=display\">0</script>. Otherwise, we build a string out of the sorted array and return it.</p> \n  <iframe src=\"https://leetcode.com/playground/wVZb2DmS/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"wVZb2DmS\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">\\mathcal{O}(nlgn)</script> </p> <p>Although we are doing extra work in our comparator, it is only by a constant factor. Therefore, the overall runtime is dominated by the complexity of <code>sort</code>, which is <script type=\"math/tex; mode=display\">\\mathcal{O}(nlgn)</script> in Python and Java.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">\\mathcal{O}(n)</script> </p> <p>Here, we allocate <script type=\"math/tex; mode=display\">\\mathcal{O}(n)</script> additional space to store the copy of <code>nums</code>. Although we could do that work in place (if we decide that it is okay to modify <code>nums</code>), we must allocate <script type=\"math/tex; mode=display\">\\mathcal{O}(n)</script> space for the final return string. Therefore, the overall memory footprint is linear in the length of <code>nums</code>.</p> </li> \n  </ul> \n  <hr> \n  <p>Analysis and solutions written by: <a href=\"https://leetcode.com/emptyset\">@emptyset</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 174,
    "article_live": false,
    "title": "Dungeon Game",
    "title_slug": "dungeon-game",
    "content": "<style type=\"text/css\">table.dungeon, .dungeon th, .dungeon td {\r\n  border:3px solid black;\r\n}\r\n\r\n .dungeon th, .dungeon td {\r\n    text-align: center;\r\n    height: 70px;\r\n    width: 70px;\r\n}\r\n</style>\r\n<p>The demons had captured the princess (<strong>P</strong>) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (<strong>K</strong>) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess.</p>\r\n\r\n<p>The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.</p>\r\n\r\n<p>Some of the rooms are guarded by demons, so the knight loses health (<em>negative</em> integers) upon entering these rooms; other rooms are either empty (<em>0&#39;s</em>) or contain magic orbs that increase the knight&#39;s health (<em>positive</em> integers).</p>\r\n\r\n<p>In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Write a function to determine the knight&#39;s minimum initial health so that he is able to rescue the princess.</strong></p>\r\n\r\n<p>For example, given the dungeon below, the initial health of the knight must be at least <strong>7</strong> if he follows the optimal path <code>RIGHT-&gt; RIGHT -&gt; DOWN -&gt; DOWN</code>.</p>\r\n\r\n<table class=\"dungeon\">\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<td>-2 (K)</td>\r\n\t\t\t<td>-3</td>\r\n\t\t\t<td>3</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td>-5</td>\r\n\t\t\t<td>-10</td>\r\n\t\t\t<td>1</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td>10</td>\r\n\t\t\t<td>30</td>\r\n\t\t\t<td>-5 (P)</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>The knight&#39;s health has no upper bound.</li>\r\n\t<li>Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.</li>\r\n</ul>\r\n",
    "tags": "Binary Search, Dynamic Programming",
    "difficulty": 3,
    "frontend_article_id": 174
},
{
    "frontend_question_id": 173,
    "article_live": false,
    "title": "Binary Search Tree Iterator",
    "title_slug": "binary-search-tree-iterator",
    "content": "<p>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.</p>\r\n\r\n<p>Calling <code>next()</code> will return the next smallest number in the BST.</p>\r\n\r\n<p><b>Note: </b><code>next()</code> and <code>hasNext()</code> should run in average O(1) time and uses O(<i>h</i>) memory, where <i>h</i> is the height of the tree. </p>\r\n\r\n<p><b>Credits:</b><br />Special thanks to <a href=\"https://oj.leetcode.com/discuss/user/ts\">@ts</a> for adding this problem and creating all test cases.</p>",
    "tags": "Stack, Tree, Design",
    "difficulty": 2,
    "frontend_article_id": 173
},
{
    "frontend_question_id": 172,
    "article_live": false,
    "title": "Factorial Trailing Zeroes",
    "title_slug": "factorial-trailing-zeroes",
    "content": "<p>Given an integer <i>n</i>, return the number of trailing zeroes in <i>n</i>!.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 3\r\n<strong>Output:</strong> 0\r\n<strong>Explanation:</strong>&nbsp;3! = 6, no trailing zero.</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 5\r\n<strong>Output:</strong> 1\r\n<strong>Explanation:</strong>&nbsp;5! = 120, one trailing zero.</pre>\r\n\r\n<p><b>Note: </b>Your solution should be in logarithmic time complexity.</p>\r\n",
    "tags": "Math",
    "difficulty": 1,
    "frontend_article_id": 172
},
{
    "frontend_question_id": 171,
    "article_live": false,
    "title": "Excel Sheet Column Number",
    "title_slug": "excel-sheet-column-number",
    "content": "<p>Given a column title as appear in an Excel sheet, return its corresponding column number.</p>\r\n\r\n<p>For example:</p>\r\n\r\n<pre>\r\n    A -&gt; 1\r\n    B -&gt; 2\r\n    C -&gt; 3\r\n    ...\r\n    Z -&gt; 26\r\n    AA -&gt; 27\r\n    AB -&gt; 28 \r\n    ...\r\n</pre>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> &quot;A&quot;\r\n<strong>Output:</strong> 1\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>&quot;AB&quot;\r\n<strong>Output:</strong> 28\r\n</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>&quot;ZY&quot;\r\n<strong>Output:</strong> 701\r\n</pre>",
    "tags": "Math",
    "difficulty": 1,
    "frontend_article_id": 171
},
{
    "frontend_question_id": 170,
    "article_live": false,
    "title": "Two Sum III - Data structure design",
    "title_slug": "two-sum-iii-data-structure-design",
    "tags": "Hash Table, Design",
    "difficulty": 1,
    "frontend_article_id": 170
},
{
    "frontend_question_id": 169,
    "article_live": true,
    "article_slug": "majority-element",
    "title": "Majority Element",
    "title_slug": "majority-element",
    "content": "<p>Given an array of size <i>n</i>, find the majority element. The majority element is the element that appears <b>more than</b> <code>&lfloor; n/2 &rfloor;</code> times.</p>\r\n\r\n<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [3,2,3]\r\n<strong>Output:</strong> 3</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [2,2,1,1,1,2,2]\r\n<strong>Output:</strong> 2\r\n</pre>\r\n",
    "tags": "Array, Divide and Conquer, Bit Manipulation",
    "difficulty": 1,
    "frontend_article_id": 169,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-brute-force\">Approach 1: Brute Force</a></li> \n    <li><a href=\"#approach-2-hashmap\">Approach 2: HashMap</a></li> \n    <li><a href=\"#approach-3-sorting\">Approach 3: Sorting</a></li> \n    <li><a href=\"#approach-4-randomization\">Approach 4: Randomization</a></li> \n    <li><a href=\"#approach-5-divide-and-conquer\">Approach 5: Divide and Conquer</a></li> \n    <li><a href=\"#approach-6-boyer-moore-voting-algorithm\">Approach 6: Boyer-Moore Voting Algorithm</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-brute-force\">Approach 1: Brute Force</h4> \n  <p><strong>Intuition</strong></p> \n  <p>We can exhaust the search space in quadratic time by checking whether each element is the majority element.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>The brute force algorithm iterates over the array, and then iterates again for each number to count its occurrences. As soon as a number is found to have appeared more than any other can possibly have appeared, return it.</p> \n  <iframe src=\"https://leetcode.com/playground/TXAGvfu4/shared\" frameborder=\"0\" width=\"100%\" height=\"412\" name=\"TXAGvfu4\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^2)</script> </p> <p>The brute force algorithm contains two nested <code>for</code> loops that each run for <script type=\"math/tex; mode=display\">n</script> iterations, adding up to quadratic time complexity.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script> </p> <p>The brute force solution does not allocate additional space proportional to the input size.</p> </li> \n  </ul> \n  <p><br></p> \n  <hr> \n  <h4 id=\"approach-2-hashmap\">Approach 2: HashMap</h4> \n  <p><strong>Intuition</strong></p> \n  <p>We know that the majority element occurs more than <script type=\"math/tex; mode=display\">\\lfloor \\dfrac{n}{2} \\rfloor</script> times, and a <code>HashMap</code> allows us to count element occurrences efficiently.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>We can use a <code>HashMap</code> that maps elements to counts in order to count occurrences in linear time by looping over <code>nums</code>. Then, we simply return the key with maximum value.</p> \n  <iframe src=\"https://leetcode.com/playground/8UD2i82e/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"8UD2i82e\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script> </p> <p>We iterate over <code>nums</code> once and make a constant time <code>HashMap</code> insertion on each iteration. Therefore, the algorithm runs in <script type=\"math/tex; mode=display\">O(n)</script> time.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script> </p> <p>At most, the <code>HashMap</code> can contain <script type=\"math/tex; mode=display\">n - \\lfloor \\dfrac{n}{2} \\rfloor</script> associations, so it occupies <script type=\"math/tex; mode=display\">O(n)</script> space. This is because an arbitrary array of length <script type=\"math/tex; mode=display\">n</script> can contain <script type=\"math/tex; mode=display\">n</script> distinct values, but <code>nums</code> is guaranteed to contain a majority element, which will occupy (at minimum) <script type=\"math/tex; mode=display\">\\lfloor \\dfrac{n}{2} \\rfloor + 1</script> array indices. Therefore, <script type=\"math/tex; mode=display\">n - (\\lfloor \\dfrac{n}{2} \\rfloor + 1)</script> indices can be occupied by distinct, non-majority elements (plus 1 for the majority element itself), leaving us with (at most) <script type=\"math/tex; mode=display\">n - \\lfloor \\dfrac{n}{2} \\rfloor</script> distinct elements.</p> </li> \n  </ul> \n  <p><br></p> \n  <hr> \n  <h4 id=\"approach-3-sorting\">Approach 3: Sorting</h4> \n  <p><strong>Intuition</strong></p> \n  <p>If the elements are sorted in monotonically increasing (or decreasing) order, the majority element can be found at index <script type=\"math/tex; mode=display\">\\lfloor \\dfrac{n}{2} \\rfloor</script> (and <script type=\"math/tex; mode=display\">\\lfloor \\dfrac{n}{2} \\rfloor + 1</script>, incidentally, if <script type=\"math/tex; mode=display\">n</script> is even).</p> \n  <p><strong>Algorithm</strong></p> \n  <p>For this algorithm, we simply do exactly what is described: sort <code>nums</code>, and return the element in question. To see why this will always return the majority element (given that the array has one), consider the figure below (the top example is for an odd-length array and the bottom is for an even-length array):</p> \n  <p align=\"center\"><img alt=\"Sorting middle index overlap\" src=\"../Figures/169/sorting.png\"></p> \n  <p>For each example, the line below the array denotes the range of indices that are covered by a majority element that happens to be the array minimum. As you might expect, the line above the array is similar, but for the case where the majority element is also the array maximum. In all other cases, this line will lie somewhere between these two, but notice that even in these two most extreme cases, they overlap at index <script type=\"math/tex; mode=display\">\\lfloor \\dfrac{n}{2} \\rfloor</script> for both even- and odd-length arrays. Therefore, no matter what value the majority element has in relation to the rest of the array, returning the value at <script type=\"math/tex; mode=display\">\\lfloor \\dfrac{n}{2} \\rfloor</script> will never be wrong.</p> \n  <iframe src=\"https://leetcode.com/playground/863hrGWL/shared\" frameborder=\"0\" width=\"100%\" height=\"157\" name=\"863hrGWL\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(nlgn)</script> </p> <p>Sorting the array costs <script type=\"math/tex; mode=display\">O(nlgn)</script> time in Python and Java, so it dominates the overall runtime.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script> or (<script type=\"math/tex; mode=display\">O(n)</script>)</p> <p>We sorted <code>nums</code> in place here - if that is not allowed, then we must spend linear additional space on a copy of <code>nums</code> and sort the copy instead.</p> </li> \n  </ul> \n  <p><br></p> \n  <hr> \n  <h4 id=\"approach-4-randomization\">Approach 4: Randomization</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Because more than <script type=\"math/tex; mode=display\">\\lfloor \\dfrac{n}{2} \\rfloor</script> array indices are occupied by the majority element, a random array index is likely to contain the majority element.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Because a given index is likely to have the majority element, we can just select a random index, check whether its value is the majority element, return if it is, and repeat if it is not. The algorithm is verifiably correct because we ensure that the randomly chosen value is the majority element before ever returning.</p> \n  <iframe src=\"https://leetcode.com/playground/hUXRqk6X/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"hUXRqk6X\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(\\infty)</script> </p> <p>It is technically possible for this algorithm to run indefinitely (if we never manage to randomly select the majority element), so the worst possible runtime is unbounded. However, the expected runtime is far better - linear, in fact. For ease of analysis, convince yourself that because the majority element is guaranteed to occupy <em>more</em> than half of the array, the expected number of iterations will be less than it would be if the element we sought occupied exactly <em>half</em> of the array. Therefore, we can calculate the expected number of iterations for this modified version of the problem and assert that our version is easier.</p> <p> <script type=\"math/tex; mode=display\">\n\\begin{aligned}\n    EV(iters_{prob}) &\\leq EV(iters_{mod}) \\\\\n                     &= \\lim_{n\\to\\infty} \\sum_{i=1}^{n} i \\cdot \\frac{1}{2^i} \\\\\n                     &= 2\n\\end{aligned}\n</script> </p> <p>Because the series converges, the expected number of iterations for the modified problem is constant. Based on an expected-constant number of iterations in which we perform linear work, the expected runtime is linear for the modifed problem. Therefore, the expected runtime for our problem is also linear, as the runtime of the modifed problem serves as an upper bound for it.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script> </p> <p>Much like the brute force solution, the randomized approach runs with constant additional space.</p> </li> \n  </ul> \n  <p><br></p> \n  <hr> \n  <h4 id=\"approach-5-divide-and-conquer\">Approach 5: Divide and Conquer</h4> \n  <p><strong>Intuition</strong></p> \n  <p>If we know the majority element in the left and right halves of an array, we can determine which is the global majority element in linear time.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Here, we apply a classical divide &amp; conquer approach that recurses on the left and right halves of an array until an answer can be trivially achieved for a length-1 array. Note that because actually passing copies of subarrays costs time and space, we instead pass <code>lo</code> and <code>hi</code> indices that describe the relevant slice of the overall array. In this case, the majority element for a length-1 slice is trivially its only element, so the recursion stops there. If the current slice is longer than length-1, we must combine the answers for the slice's left and right halves. If they agree on the majority element, then the majority element for the overall slice is obviously the same<sup id=\"fnref:1\"><a class=\"footnote-ref\" href=\"#fn:1\" rel=\"footnote\">1</a></sup>. If they disagree, only one of them can be \"right\", so we need to count the occurrences of the left and right majority elements to determine which subslice's answer is globally correct. The overall answer for the array is thus the majority element between indices 0 and <script type=\"math/tex; mode=display\">n</script>.</p> \n  <iframe src=\"https://leetcode.com/playground/C722UMRw/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"C722UMRw\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(nlgn)</script> </p> <p>Each recursive call to <code>majority_element_rec</code> performs two recursive calls on subslices of size <script type=\"math/tex; mode=display\">\\frac{n}{2}</script> and two linear scans of length <script type=\"math/tex; mode=display\">n</script>. Therefore, the time complexity of the divide &amp; conquer approach can be represented by the following recurrence relation:</p> <p> <script type=\"math/tex; mode=display\">\n    T(n) = 2T(\\frac{n}{2}) + 2n\n</script> </p> <p>By the <a href=\"https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)\">master theorem</a>, the recurrence satisfies case 2, so the complexity can be analyzed as such:</p> <p> <script type=\"math/tex; mode=display\">\n\\begin{aligned}\n    T(n) &= \\Theta(n^{log_{b}a}\\log n) \\\\\n         &= \\Theta(n^{log_{2}2}\\log n) \\\\\n         &= \\Theta(n \\log n) \\\\\n\\end{aligned}\n</script> </p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(lgn)</script> </p> <p>Although the divide &amp; conquer does not explicitly allocate any additional memory, it uses a non-constant amount of additional memory in stack frames due to recursion. Because the algorithm \"cuts\" the array in half at each level of recursion, it follows that there can only be <script type=\"math/tex; mode=display\">O(lgn)</script> \"cuts\" before the base case of 1 is reached. It follows from this fact that the resulting recursion tree is balanced, and therefore all paths from the root to a leaf are of length <script type=\"math/tex; mode=display\">O(lgn)</script>. Because the recursion tree is traversed in a depth-first manner, the space complexity is therefore equivalent to the length of the longest path, which is, of course, <script type=\"math/tex; mode=display\">O(lgn)</script>.</p> </li> \n  </ul> \n  <p><br></p> \n  <hr> \n  <h4 id=\"approach-6-boyer-moore-voting-algorithm\">Approach 6: Boyer-Moore Voting Algorithm</h4> \n  <p><strong>Intuition</strong></p> \n  <p>If we had some way of counting instances of the majority element as <script type=\"math/tex; mode=display\">+1</script> and instances of any other element as <script type=\"math/tex; mode=display\">-1</script>, summing them would make it obvious that the majority element is indeed the majority element.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Essentially, what Boyer-Moore does is look for a suffix <script type=\"math/tex; mode=display\">suf</script> of <code>nums</code> where <script type=\"math/tex; mode=display\">suf[0]</script> is the majority element in that suffix. To do this, we maintain a count, which is incremented whenever we see an instance of our current candidate for majority element and decremented whenever we see anything else. Whenever <code>count</code> equals 0, we effectively forget about everything in <code>nums</code> up to the current index and consider the current number as the candidate for majority element. It is not immediately obvious why we can get away with forgetting prefixes of <code>nums</code> - consider the following examples (pipes are inserted to separate runs of nonzero <code>count</code>).</p> \n  <p>[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]</p> \n  <p>Here, the <code>7</code> at index 0 is selected to be the first candidate for majority element. <code>count</code> will eventually reach 0 after index 5 is processed, so the <code>5</code> at index 6 will be the next candidate. In this case, <code>7</code> is the true majority element, so by disregarding this prefix, we are ignoring an equal number of majority and minority elements - therefore, <code>7</code> will still be the majority element in the suffix formed by throwing away the first prefix.</p> \n  <p>[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | <strong>5, 5, 5, 5</strong>]</p> \n  <p>Now, the majority element is <code>5</code> (we changed the last run of the array from <code>7</code>s to <code>5</code>s), but our first candidate is still <code>7</code>. In this case, our candidate is not the true majority element, but we still cannot discard more majority elements than minority elements (this would imply that <code>count</code> could reach -1 before we reassign <code>candidate</code>, which is obviously false).</p> \n  <p>Therefore, given that it is impossible (in both cases) to discard more majority elements than minority elements, we are safe in discarding the prefix and attempting to recursively solve the majority element problem for the suffix. Eventually, a suffix will be found for which <code>count</code> does not hit <code>0</code>, and the majority element of that suffix will necessarily be the same as the majority element of the overall array.</p> \n  <iframe src=\"https://leetcode.com/playground/TdqCU8YV/shared\" frameborder=\"0\" width=\"100%\" height=\"310\" name=\"TdqCU8YV\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script> </p> <p>Boyer-Moore performs constant work exactly <script type=\"math/tex; mode=display\">n</script> times, so the algorithm runs in linear time.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script> </p> <p>Boyer-Moore allocates only constant additional memory.</p> </li> \n  </ul> \n  <p><br></p> \n  <p><strong>Footnotes</strong></p> \n  <div class=\"footnote\"> \n   <hr> \n   <ol> \n    <li id=\"fn:1\"> <p>This is a constant optimization that could be excluded without hurting our overall runtime.&nbsp;<a class=\"footnote-backref\" href=\"#fnref:1\" rev=\"footnote\" title=\"Jump back to footnote 1 in the text\">↩</a></p> </li> \n   </ol> \n  </div> \n </div> \n</div>"
},
{
    "frontend_question_id": 168,
    "article_live": false,
    "title": "Excel Sheet Column Title",
    "title_slug": "excel-sheet-column-title",
    "content": "<p>Given a positive integer, return its corresponding column title as appear in an Excel sheet.</p>\r\n\r\n<p>For example:</p>\r\n\r\n<pre>\r\n    1 -&gt; A\r\n    2 -&gt; B\r\n    3 -&gt; C\r\n    ...\r\n    26 -&gt; Z\r\n    27 -&gt; AA\r\n    28 -&gt; AB \r\n    ...\r\n</pre>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 1\r\n<strong>Output:</strong> &quot;A&quot;\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 28\r\n<strong>Output:</strong> &quot;AB&quot;\r\n</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 701\r\n<strong>Output:</strong> &quot;ZY&quot;\r\n</pre>",
    "tags": "Math",
    "difficulty": 1,
    "frontend_article_id": 168
},
{
    "frontend_question_id": 167,
    "article_live": true,
    "article_slug": "two-sum-ii-input-array-is-sorted",
    "title": "Two Sum II - Input array is sorted",
    "title_slug": "two-sum-ii-input-array-is-sorted",
    "content": "<p>Given an array of integers that is already <strong><em>sorted in ascending order</em></strong>, find two numbers such that they add up to a specific target number.</p>\r\n\r\n<p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>Your returned answers (both index1 and index2) are not zero-based.</li>\r\n\t<li>You may assume that each input would have <em>exactly</em> one solution and you may not use the <em>same</em> element twice.</li>\r\n</ul>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> numbers = [2,7,11,15], target = 9\r\n<strong>Output:</strong> [1,2]\r\n<strong>Explanation:</strong> The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.</pre>\r\n",
    "tags": "Array, Two Pointers, Binary Search",
    "difficulty": 1,
    "frontend_article_id": 167,
    "article_content": ""
},
{
    "frontend_question_id": 166,
    "article_live": true,
    "article_slug": "fraction-to-recurring-decimal",
    "title": "Fraction to Recurring Decimal",
    "title_slug": "fraction-to-recurring-decimal",
    "content": "<p>Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.</p>\r\n\r\n<p>If the fractional part is repeating, enclose the repeating part in parentheses.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> numerator = 1, denominator = 2\r\n<strong>Output:</strong> &quot;0.5&quot;\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> numerator = 2, denominator = 1\r\n<strong>Output:</strong> &quot;2&quot;</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> numerator = 2, denominator = 3\r\n<strong>Output: </strong>&quot;0.(6)&quot;\r\n</pre>\r\n",
    "tags": "Hash Table, Math",
    "difficulty": 2,
    "frontend_article_id": 166,
    "article_content": ""
},
{
    "frontend_question_id": 165,
    "article_live": false,
    "title": "Compare Version Numbers",
    "title_slug": "compare-version-numbers",
    "content": "<p>Compare two version numbers <em>version1</em> and <em>version2</em>.<br />\r\nIf <code><em>version1</em> &gt; <em>version2</em></code> return <code>1;</code>&nbsp;if <code><em>version1</em> &lt; <em>version2</em></code> return <code>-1;</code>otherwise return <code>0</code>.</p>\r\n\r\n<p>You may assume that the version strings are non-empty and contain only digits and the <code>.</code> character.<br />\r\nThe <code>.</code> character does not represent a decimal point and is used to separate number sequences.<br />\r\nFor instance, <code>2.5</code> is not &quot;two and a half&quot; or &quot;half way to version three&quot;, it is the fifth second-level revision of the second first-level revision.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> <code><em>version1</em></code> = &quot;0.1&quot;, <code><em>version2</em></code> = &quot;1.1&quot;\r\n<strong>Output:</strong> -1</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><code><em>version1</em></code> = &quot;1.0.1&quot;, <code><em>version2</em></code> = &quot;1&quot;\r\n<strong>Output:</strong> 1</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> <code><em>version1</em></code> = &quot;7.5.2.4&quot;, <code><em>version2</em></code> = &quot;7.5.3&quot;\r\n<strong>Output:</strong> -1</pre>\r\n",
    "tags": "String",
    "difficulty": 2,
    "frontend_article_id": 165
},
{
    "frontend_question_id": 164,
    "article_live": true,
    "article_slug": "maximum-gap",
    "title": "Maximum Gap",
    "title_slug": "maximum-gap",
    "content": "<p>Given an unsorted array, find the maximum difference between the successive elements in its sorted form.</p>\r\n\r\n<p>Return 0 if the array contains less than 2 elements.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [3,6,9,1]\r\n<strong>Output:</strong> 3\r\n<strong>Explanation:</strong> The sorted form of the array is [1,3,6,9], either\r\n&nbsp;            (3,6) or (6,9) has the maximum difference 3.</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [10]\r\n<strong>Output:</strong> 0\r\n<strong>Explanation:</strong> The array contains less than 2 elements, therefore return 0.</pre>\r\n\r\n<p><b>Note:</b></p>\r\n\r\n<ul>\r\n\t<li>You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.</li>\r\n\t<li>Try to solve it in linear time/space.</li>\r\n</ul>\r\n",
    "tags": "Sort",
    "difficulty": 3,
    "frontend_article_id": 164,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-comparison-sorting\">Approach 1: Comparison Sorting</a></li> \n      <li><a href=\"#approach-2-radix-sort\">Approach 2: Radix Sort</a></li> \n      <li><a href=\"#approach-3-buckets-and-the-pigeonhole-principle\">Approach 3: Buckets and The Pigeonhole Principle</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-comparison-sorting\">Approach 1: Comparison Sorting</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Do what the question says.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Sort the entire array. Then iterate over it to find the maximum gap between two successive elements.</p> \n  <iframe src=\"https://leetcode.com/playground/a4t7NiXg/shared\" frameborder=\"0\" width=\"100%\" height=\"293\" name=\"a4t7NiXg\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity: <script type=\"math/tex; mode=display\">O(nlog(n))</script>.</p> <p>Time taken to sort the array is <script type=\"math/tex; mode=display\">O(nlog(n))</script> (average case). Time taken for linear iteration through the array is of <script type=\"math/tex; mode=display\">O(n)</script> complexity. Hence overall time complexity is <script type=\"math/tex; mode=display\">O(nlog(n))</script>.</p> </li> \n   <li> <p>Space complexity: No extra space needed, other than the input array (since sorting can usually be done in-place). <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-radix-sort\">Approach 2: Radix Sort</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>This approach is similar to <a href=\"#approach-1-comparison-sorting\">Approach 1</a>, except we use <a href=\"https://en.wikipedia.org/wiki/Radix_sort\">Radix Sort</a> instead of a traditional comparison sort.</p> \n  <iframe src=\"https://leetcode.com/playground/wgpxfHTh/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"wgpxfHTh\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity: <script type=\"math/tex; mode=display\">O(d \\cdot (n + k)) \\approx O(n)</script>.</p> <p>Since a linear iteration over the array (once it is sorted) is of linear (i.e. <script type=\"math/tex; mode=display\">O(n)</script>) complexity, the performance of this approach is limited by the performance of Radix sort.</p> <p>Radix sort uses <a href=\"https://en.wikipedia.org/wiki/Counting_sort\">Counting sort</a> as a subroutine.</p> \n    <ul> \n     <li> <p>Counting sort runs in <script type=\"math/tex; mode=display\">O(n + k)</script> time (where <script type=\"math/tex; mode=display\">k</script> is the radix or base of the digits comprising the <script type=\"math/tex; mode=display\">n</script> elements in the array). If <script type=\"math/tex; mode=display\">k \\leq O(n)</script>, Counting sort would run in linear time. In our case, the radix is fixed (i.e. <script type=\"math/tex; mode=display\">k = 10</script>). Hence our Counting sort subroutine runs in <script type=\"math/tex; mode=display\">O(n)</script> linear time.</p> </li> \n     <li> <p>Radix sort works by running <script type=\"math/tex; mode=display\">d</script> passes of the Counting sort subroutine (where the elements are composed of, maximally, <script type=\"math/tex; mode=display\">d</script> digits). Hence effective runtime of Radix sort would be <script type=\"math/tex; mode=display\">O(d \\cdot (n + k))</script>. However, in our case an element can, maximally, be the maximum 32-bit signed integer <code>2,147,483,647</code>. Hence <script type=\"math/tex; mode=display\">d \\leq 10</script> is a constant.</p> </li> \n    </ul> <p>Thus Radix sort has a runtime performance complexity of about <script type=\"math/tex; mode=display\">O(n)</script> for reasonably large input.</p> </li> \n   <li> <p>Space complexity: <script type=\"math/tex; mode=display\">O(n + k) \\approx O(n)</script> extra space.</p> <p>Counting sort requires <script type=\"math/tex; mode=display\">O(k)</script> extra space. Radix sort requires an auxiliary array of the same size as input array. However given that <script type=\"math/tex; mode=display\">k</script> is a small fixed constant, the space required by Counting sort can be ignored for reasonably large input.</p> </li> \n  </ul> \n  <p><br></p> \n  <hr> \n  <h4 id=\"approach-3-buckets-and-the-pigeonhole-principle\">Approach 3: Buckets and The Pigeonhole Principle</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Sorting an entire array can be costly. At worst, it requires comparing each element with <em>every</em> other element. What if we didn't need to compare all pairs of elements? That would be possible if we could somehow divide the elements into representative groups, or rather, <em>buckets</em>. Then we would only need to compare these buckets.</p> \n  <blockquote> \n   <p><strong>Digression: The Pigeonhole Principle</strong> The <a href=\"https://en.wikipedia.org/wiki/Pigeonhole_principle\">Pigeonhole Principle</a> states that if <script type=\"math/tex; mode=display\">n</script> items are put into <script type=\"math/tex; mode=display\">m</script> containers, with <script type=\"math/tex; mode=display\">n > m</script>, then at least one container must contain more than one item.</p> \n  </blockquote> \n  <p>Suppose for each of the <script type=\"math/tex; mode=display\">n</script> elements in our array, there was a bucket. Then each element would occupy one bucket. Now what if we reduced, the number of buckets? Some buckets would have to accommodate more than one element.</p> \n  <p>Now let's talk about the gaps between the elements. Let's take the best case, where all elements of the array are sorted and have a uniform gap between them. This means every adjacent pair of elements differ by the same constant value. So for <script type=\"math/tex; mode=display\">n</script> elements of the array, there are <script type=\"math/tex; mode=display\">n-1</script> gaps, each of width, say, <script type=\"math/tex; mode=display\">t</script>. It is trivial to deduce that <script type=\"math/tex; mode=display\">t = (max - min)/(n-1)</script> (where <script type=\"math/tex; mode=display\">max</script> and <script type=\"math/tex; mode=display\">min</script> are the minimum and maximum elements of the array). This width is the maximal width/gap between two adjacent elements in the array; precisely the quantity we are looking for!</p> \n  <p>One can safely argue that this value of <script type=\"math/tex; mode=display\">t</script>, is in fact, the smallest value that <script type=\"math/tex; mode=display\">t</script> can ever accomplish of any array with the same number of elements (i.e. <script type=\"math/tex; mode=display\">n</script>) and the same range (i.e. <script type=\"math/tex; mode=display\">(max - min)</script>). To test this fact, you can start with a uniform width array (as described above) and try to reduce the gap between any two adjacent elements. If you reduce the gap between <script type=\"math/tex; mode=display\">arr[i-1]</script> and <script type=\"math/tex; mode=display\">arr[i]</script> to some value <script type=\"math/tex; mode=display\">t - p</script>, then you will notice that the gap between <script type=\"math/tex; mode=display\">arr[i]</script> and <script type=\"math/tex; mode=display\">arr[i+1]</script> would have increased to <script type=\"math/tex; mode=display\">t + p</script>. Hence the maximum attainable gap would have become <script type=\"math/tex; mode=display\">t + p</script> from <script type=\"math/tex; mode=display\">t</script>. Thus the value of the <strong>maximum gap</strong> <script type=\"math/tex; mode=display\">t</script> can only increase.</p> \n  <p><strong>Buckets!</strong></p> \n  <p>Coming back to our problem, we have already established by application of the Pigeonhole Principle, that if we used <em>buckets</em> instead of individual elements as our base for comparison, the number of comparisons would reduce if we could accommodate more than one element in a single bucket. That does not immediately solve the problem though. What if we had to compare elements <em>within</em> a bucket? We would end up no better.</p> \n  <p>So the current motivation remains: somehow, if we only had to compare among the buckets, and <em>not</em> the elements <em>within</em> the buckets, we would be good. It would also solve our sorting problem: we would just distribute the elements to the right buckets. Since the buckets can be already ordered, and we only compare among buckets, we wouldn't have to compare all elements to sort them!</p> \n  <p>But if we only had buckets to compare, we would have to <em>ensure</em>, that the gap between the buckets itself represent the maximal gap in the input array. How do we go about doing that?</p> \n  <p>We could do that just by setting the buckets to be smaller than <script type=\"math/tex; mode=display\">t = (max - min)/(n-1)</script> (as described above). Since the gaps (between elements) within the same bucket would only be <script type=\"math/tex; mode=display\">\\leq t</script>, we could deduce that the maximal gap would <em>indeed</em> occur <strong>only between two adjacent buckets</strong>.</p> \n  <p>Hence by setting bucket size <script type=\"math/tex; mode=display\">b</script> to be <script type=\"math/tex; mode=display\">1 < b \\leq (max - min)/(n-1)</script>, we can ensure that at least one of the gaps between adjacent buckets would serve as the <strong>maximal gap.</strong></p> \n  <p><strong>Clarifications</strong></p> \n  <p>A few clarifications are in order:</p> \n  <ul> \n   <li> <p><strong>Would the buckets be of uniform size?</strong> Yes. Each of them would be of the same size <script type=\"math/tex; mode=display\">b</script>.</p> </li> \n   <li> <p><strong>But, then wouldn't the gap between them be uniform/constant as well?</strong> Yes it would be. The gap between them would be <script type=\"math/tex; mode=display\">1</script> integer unit wide. That means a two adjacent buckets of size <script type=\"math/tex; mode=display\">3</script> could hold integers with values, say, <script type=\"math/tex; mode=display\">3 - 6</script> and <script type=\"math/tex; mode=display\">7 - 9</script>. We avoid overlapping buckets.</p> </li> \n   <li> <p><strong>Then what are you talking about when you say the gap between two adjacent buckets could be the maximal gap?</strong> When we are talking about the size of a bucket, we are talking about its holding capacity. That is the range of values the bucket can represent (or <em>hold</em>). However the actual extent of the bucket are determined by the values of the maximum and minimum element a bucket holds. For example a bucket of size <script type=\"math/tex; mode=display\">5</script> could have a capacity to hold values between <script type=\"math/tex; mode=display\">6 - 10</script>. However, if it only holds the elements <script type=\"math/tex; mode=display\">7, 8</script> and <script type=\"math/tex; mode=display\">9</script>, then its actual extent is only <script type=\"math/tex; mode=display\">(9 - 7) + 1 = 3</script> which is not the same as the capacity of the bucket.</p> </li> \n   <li> <p><strong>Then how do you compare adjacent buckets?</strong> We do that by comparing their extents. Thus we compare the minimum element of the next bucket to the maximum element of the current bucket. For example: if we have two buckets of size <script type=\"math/tex; mode=display\">5</script> each, holding elements <script type=\"math/tex; mode=display\">[1, 2, 3]</script> and <script type=\"math/tex; mode=display\">[9, 10]</script> respectively, then the gap between the buckets would essentially refer to the value <script type=\"math/tex; mode=display\">9 - 3 = 6</script> (which is larger than the size of either bucket).</p> </li> \n   <li> <p><strong>But then aren't we comparing elements again?!</strong> We are, yes! But only compare about twice the elements as the number of buckets (i.e. the minimum and maximum elements of each bucket). If you followed the above, you would realize that this amount is certainly less than the actual number of elements in the array, given a suitable bucket size was chosen.</p> </li> \n  </ul> \n  <p><strong>Algorithm</strong></p> \n  <ul> \n   <li> <p>We choose a bucket size <script type=\"math/tex; mode=display\">b</script> such that <script type=\"math/tex; mode=display\">1 < b \\leq (max - min)/(n-1)</script>. Let's just choose <script type=\"math/tex; mode=display\">b = \\lfloor (max - min)/(n-1) \\rfloor</script>.</p> </li> \n   <li> <p>Thus all the <script type=\"math/tex; mode=display\">n</script> elements would be divided among <script type=\"math/tex; mode=display\">k = \\lceil (max - min)/b \\rceil</script> buckets.</p> </li> \n   <li> <p>Hence the <script type=\"math/tex; mode=display\">i^{th}</script> bucket would hold the range of values: <script type=\"math/tex; mode=display\">\\bigg [min + (i-1) * b, \\space min + i*b \\bigg )</script> (<code>1</code>-based indexing).</p> </li> \n   <li> <p>It is trivial to calculate the index of the bucket to which a particular element belongs. That is given by <script type=\"math/tex; mode=display\">\\lfloor (num - min)/b \\rfloor</script> (<code>0</code>-based indexing) where <script type=\"math/tex; mode=display\">num</script> is the element in question.</p> </li> \n   <li> <p>Once all <script type=\"math/tex; mode=display\">n</script> elements have been distributed, we compare <script type=\"math/tex; mode=display\">k-1</script> adjacent bucket pairs to find the maximum gap.</p> </li> \n  </ul> \n  <iframe src=\"https://leetcode.com/playground/dox2x4ko/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"dox2x4ko\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity: <script type=\"math/tex; mode=display\">O(n + b) \\approx O(n)</script>.</p> <p>Distributing the elements of the array takes one linear pass (i.e. <script type=\"math/tex; mode=display\">O(n)</script> complexity). Finding the maximum gap among the buckets takes a linear pass over the bucket storage (i.e. <script type=\"math/tex; mode=display\">O(b)</script> complexity). Hence overall process takes linear runtime.</p> </li> \n   <li> <p>Space complexity: <script type=\"math/tex; mode=display\">O(2 \\cdot b) \\approx O(b)</script> extra space.</p> <p>Each bucket stores a maximum and a minimum element. Hence extra space linear to the number of buckets is required.</p> </li> \n  </ul> \n </div> \n</div>"
},
{
    "frontend_question_id": 163,
    "article_live": false,
    "title": "Missing Ranges",
    "title_slug": "missing-ranges",
    "tags": "Array",
    "difficulty": 2,
    "frontend_article_id": 163
},
{
    "frontend_question_id": 162,
    "article_live": true,
    "article_slug": "find-peak-element",
    "title": "Find Peak Element",
    "title_slug": "find-peak-element",
    "content": "<p>A peak element is an element that is greater than its neighbors.</p>\r\n\r\n<p>Given an input array <code>nums</code>, where <code>nums[i] &ne; nums[i+1]</code>, find a peak element and return its index.</p>\r\n\r\n<p>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</p>\r\n\r\n<p>You may imagine that <code>nums[-1] = nums[n] = -&infin;</code>.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> <strong>nums</strong> = <code>[1,2,3,1]</code>\r\n<strong>Output:</strong> 2\r\n<strong>Explanation:</strong> 3 is a peak element and your function should return the index number 2.</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> <strong>nums</strong> = <code>[</code>1,2,1,3,5,6,4]\r\n<strong>Output:</strong> 1 or 5 \r\n<strong>Explanation:</strong> Your function can return either index number 1 where the peak element is 2, \r\n&nbsp;            or index number 5 where the peak element is 6.\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<p>Your solution should be in logarithmic complexity.</p>\r\n",
    "tags": "Array, Binary Search",
    "difficulty": 2,
    "frontend_article_id": 162,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-linear-scan\">Approach 1: Linear Scan</a></li> \n      <li><a href=\"#approach-2-recursive-binary-search\">Approach 2: Recursive Binary Search</a></li> \n      <li><a href=\"#approach-3-iterative-binary-search\">Approach 3: Iterative Binary Search</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-linear-scan\">Approach 1: Linear Scan</h4> \n  <p>In this approach, we make use of the fact that two consecutive numbers <script type=\"math/tex; mode=display\">nums[j]</script> and <script type=\"math/tex; mode=display\">nums[j + 1]</script> are never equal. Thus, we can traverse over the <script type=\"math/tex; mode=display\">nums</script> array starting from the beginning. Whenever, we find a number <script type=\"math/tex; mode=display\">nums[i]</script>, we only need to check if it is larger than the next number <script type=\"math/tex; mode=display\">nums[i+1]</script> for determining if <script type=\"math/tex; mode=display\">nums[i]</script> is the peak element. The reasoning behind this can be understood by taking the following three cases which cover every case into which any problem can be divided.</p> \n  <p>Case 1. All the numbers appear in a descending order. In this case, the first element corresponds to the peak element. We start off by checking if the current element is larger than the next one. The first element satisfies this criteria, and is hence identified as the peak correctly. In this case, we didn't reach a point where we needed to compare <script type=\"math/tex; mode=display\">nums[i]</script> with <script type=\"math/tex; mode=display\">nums[i-1]</script> also, to determine if it is the peak element or not.</p> \n  <p align=\"center\"><img alt=\"Graph\" src=\"../Figures/162/Find_Peak_Case1.PNG\"></p> \n  <p>Case 2. All the elements appear in ascending order. In this case, we keep on comparing <script type=\"math/tex; mode=display\">nums[i]</script> with <script type=\"math/tex; mode=display\">nums[i+1]</script> to determine if <script type=\"math/tex; mode=display\">nums[i]</script> is the peak element or not. None of the elements satisfy this criteria, indicating that we are currently on a rising slope and not on a peak. Thus, at the end, we need to return the last element as the peak element, which turns out to be correct. In this case also, we need not compare <script type=\"math/tex; mode=display\">nums[i]</script> with <script type=\"math/tex; mode=display\">nums[i-1]</script>, since being on the rising slope is a sufficient condition to ensure that <script type=\"math/tex; mode=display\">nums[i]</script> isn't the peak element.</p> \n  <p align=\"center\"><img alt=\"Graph\" src=\"../Figures/162/Find_Peak_Case2.PNG\"></p> \n  <p>Case 3. The peak appears somewhere in the middle. In this case, when we are traversing on the rising edge, as in Case 2, none of the elements will satisfy <script type=\"math/tex; mode=display\">nums[i] > nums[i + 1]</script>. We need not compare <script type=\"math/tex; mode=display\">nums[i]</script> with <script type=\"math/tex; mode=display\">nums[i-1]</script> on the rising slope as discussed above. When we finally reach the peak element, the condition <script type=\"math/tex; mode=display\">nums[i] > nums[i + 1]</script> is satisfied. We again, need not compare <script type=\"math/tex; mode=display\">nums[i]</script> with <script type=\"math/tex; mode=display\">nums[i-1]</script>. This is because, we could reach <script type=\"math/tex; mode=display\">nums[i]</script> as the current element only when the check <script type=\"math/tex; mode=display\">nums[i] > nums[i + 1]</script> failed for the previous(<script type=\"math/tex; mode=display\">(i-1)^{th}</script> element, indicating that <script type=\"math/tex; mode=display\">nums[i-1] < nums[i]</script>. Thus, we are able to identify the peak element correctly in this case as well.</p> \n  <p align=\"center\"><img alt=\"Graph\" src=\"../Figures/162/Find_Peak_Case3.PNG\"></p> \n  <iframe src=\"https://leetcode.com/playground/MLfS4Quj/shared\" frameborder=\"0\" width=\"100%\" height=\"208\" name=\"MLfS4Quj\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. We traverse the <script type=\"math/tex; mode=display\">nums</script> array of size <script type=\"math/tex; mode=display\">n</script> once only.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant extra space is used. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-recursive-binary-search\">Approach 2: Recursive Binary Search</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>We can view any given sequence in <script type=\"math/tex; mode=display\">nums</script> array as alternating ascending and descending sequences. By making use of this, and the fact that we can return any peak as the result, we can make use of Binary Search to find the required peak element.</p> \n  <p>In case of simple Binary Search, we work on a sorted sequence of numbers and try to find out the required number by reducing the search space at every step. In this case, we use a modification of this simple Binary Search to our advantage. We start off by finding the middle element, <script type=\"math/tex; mode=display\">mid</script> from the given <script type=\"math/tex; mode=display\">nums</script> array. If this element happens to be lying in a descending sequence of numbers. or a local falling slope(found by comparing <script type=\"math/tex; mode=display\">nums[i]</script> to its right neighbour), it means that the peak will always lie towards the left of this element. Thus, we reduce the search space to the left of <script type=\"math/tex; mode=display\">mid</script>(including itself) and perform the same process on left subarray.</p> \n  <p>If the middle element, <script type=\"math/tex; mode=display\">mid</script> lies in an ascending sequence of numbers, or a rising slope(found by comparing <script type=\"math/tex; mode=display\">nums[i]</script> to its right neighbour), it obviously implies that the peak lies towards the right of this element. Thus, we reduce the search space to the right of <script type=\"math/tex; mode=display\">mid</script> and perform the same process on the right subarray.</p> \n  <p>In this way, we keep on reducing the search space till we eventually reach a state where only one element is remaining in the search space. This single element is the peak element.</p> \n  <p>To see how it works, let's consider the three cases discussed above again.</p> \n  <p>Case 1. In this case, we firstly find <script type=\"math/tex; mode=display\">3</script> as the middle element. Since it lies on a falling slope, we reduce the search space to <code>[1, 2, 3]</code>. For this subarray, <script type=\"math/tex; mode=display\">2</script> happens to be the middle element, which again lies on a falling slope, reducing the search space to <code>[1, 2]</code>. Now, <script type=\"math/tex; mode=display\">1</script> acts as the middle element and it lies on a falling slope, reducing the search space to <code>[1]</code> only. Thus, <script type=\"math/tex; mode=display\">1</script> is returned as the peak correctly.</p> \n  <p>!?!../Documents/Find_Peak_Case1.json:1000,563!?!</p> \n  <p>Case 2. In this case, we firstly find <script type=\"math/tex; mode=display\">3</script> as the middle element. Since it lies on a rising slope, we reduce the search space to <code>[4, 5]</code>. Now, <script type=\"math/tex; mode=display\">4</script> acts as the middle element for this subarray and it lies on a rising slope, reducing the search space to <code>[5]</code> only. Thus, <script type=\"math/tex; mode=display\">5</script> is returned as the peak correctly.</p> \n  <p>!?!../Documents/Find_Peak_Case2.json:1000,563!?!</p> \n  <p>Case 3. In this case, the peak lies somewhere in the middle. The first middle element is <script type=\"math/tex; mode=display\">4</script>. It lies on a rising slope, indicating that the peak lies towards its right. Thus, the search space is reduced to <code>[5, 1]</code>. Now, <script type=\"math/tex; mode=display\">5</script> happens to be the on a falling slope(relative to its right neighbour), reducing the search space to <code>[5]</code> only. Thus, <script type=\"math/tex; mode=display\">5</script> is identified as the peak element correctly.</p> \n  <p>!?!../Documents/Find_Peak_Case3.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/3MGjFqJ4/shared\" frameborder=\"0\" width=\"100%\" height=\"276\" name=\"3MGjFqJ4\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O\\big(log_2(n)\\big)</script>. We reduce the search space in half at every step. Thus, the total search space will be consumed in <script type=\"math/tex; mode=display\">log_2(n)</script> steps. Here, <script type=\"math/tex; mode=display\">n</script> refers to the size of <script type=\"math/tex; mode=display\">nums</script> array.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O\\big(log_2(n)\\big)</script>. We reduce the search space in half at every step. Thus, the total search space will be consumed in <script type=\"math/tex; mode=display\">log_2(n)</script> steps. Thus, the depth of recursion tree will go upto <script type=\"math/tex; mode=display\">log_2(n)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-iterative-binary-search\">Approach 3: Iterative Binary Search</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>The binary search discussed in the previous approach used a recursive method. We can do the same process in an iterative fashion also. This is done in the current approach.</p> \n  <iframe src=\"https://leetcode.com/playground/EnevWycv/shared\" frameborder=\"0\" width=\"100%\" height=\"276\" name=\"EnevWycv\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O\\big(log_2(n)\\big)</script>. We reduce the search space in half at every step. Thus, the total search space will be consumed in <script type=\"math/tex; mode=display\">log_2(n)</script> steps. Here, <script type=\"math/tex; mode=display\">n</script> refers to the size of <script type=\"math/tex; mode=display\">nums</script> array.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant extra space is used.</p> </li> \n  </ul> \n </div> \n</div>"
},
{
    "frontend_question_id": 161,
    "article_live": false,
    "title": "One Edit Distance",
    "title_slug": "one-edit-distance",
    "tags": "String",
    "difficulty": 2,
    "frontend_article_id": 161
},
{
    "frontend_question_id": 160,
    "article_live": true,
    "article_slug": "intersection-of-two-linked-lists",
    "title": "Intersection of Two Linked Lists",
    "title_slug": "intersection-of-two-linked-lists",
    "content": "<p>Write a program to find the node at which the intersection of two singly linked lists begins.</p>\r\n</br>\r\n<p>For example, the following two linked lists: </p>\r\n<pre>\r\nA:          a1 → a2\r\n                   ↘\r\n                     c1 → c2 → c3\r\n                   ↗            \r\nB:     b1 → b2 → b3\r\n</pre>\r\n<p>begin to intersect at node c1.</p>\r\n</br>\r\n<p><b>Notes:</b>\r\n<ul>\r\n<li>If the two linked lists have no intersection at all, return <code>null</code>.</li>\r\n<li>The linked lists must retain their original structure after the function returns. </li>\r\n<li>You may assume there are no cycles anywhere in the entire linked structure.</li>\r\n<li>Your code should preferably run in O(n) time and use only O(1) memory.</li>\r\n</ul>\r\n</p>\r\n\r\n<p><b>Credits:</b><br />Special thanks to <a href=\"https://oj.leetcode.com/discuss/user/stellari\">@stellari</a> for adding this problem and creating all test cases.</p>",
    "tags": "Linked List",
    "difficulty": 1,
    "frontend_article_id": 160,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force\">Approach 1: Brute Force</a></li> \n      <li><a href=\"#approach-2-hash-table\">Approach 2: Hash Table</a></li> \n      <li><a href=\"#approach-3-two-pointers\">Approach 3: Two Pointers</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force\">Approach 1: Brute Force</h4> \n  <p>For each node a<sub>i</sub> in list A, traverse the entire list B and check if any node in list B coincides with a<sub>i</sub>.</p> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(mn)</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-hash-table\">Approach 2: Hash Table</h4> \n  <p>Traverse list A and store the address / reference to each node in a hash set. Then check every node b<sub>i</sub> in list B: if b<sub>i</sub> appears in the hash set, then b<sub>i</sub> is the intersection node.</p> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(m+n)</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(m)</script> or <script type=\"math/tex; mode=display\">O(n)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-two-pointers\">Approach 3: Two Pointers</h4> \n  <ul> \n   <li>Maintain two pointers <script type=\"math/tex; mode=display\">pA</script> and <script type=\"math/tex; mode=display\">pB</script> initialized at the head of A and B, respectively. Then let them both traverse through the lists, one node at a time.</li> \n   <li>When <script type=\"math/tex; mode=display\">pA</script> reaches the end of a list, then redirect it to the head of B (yes, B, that's right.); similarly when <script type=\"math/tex; mode=display\">pB</script> reaches the end of a list, redirect it the head of A.</li> \n   <li>If at any point <script type=\"math/tex; mode=display\">pA</script> meets <script type=\"math/tex; mode=display\">pB</script>, then <script type=\"math/tex; mode=display\">pA</script>/<script type=\"math/tex; mode=display\">pB</script> is the intersection node.</li> \n   <li>To see why the above trick would work, consider the following two lists: A = {1,3,5,7,9,11} and B = {2,4,9,11}, which are intersected at node '9'. Since B.length (=4) &lt; A.length (=6), <script type=\"math/tex; mode=display\">pB</script> would reach the end of the merged list first, because <script type=\"math/tex; mode=display\">pB</script> traverses exactly 2 nodes less than <script type=\"math/tex; mode=display\">pA</script> does. By redirecting <script type=\"math/tex; mode=display\">pB</script> to head A, and <script type=\"math/tex; mode=display\">pA</script> to head B, we now ask <script type=\"math/tex; mode=display\">pB</script> to travel exactly 2 more nodes than <script type=\"math/tex; mode=display\">pA</script> would. So in the second iteration, they are guaranteed to reach the intersection node at the same time.</li> \n   <li>If two lists have intersection, then their last nodes must be the same one. So when <script type=\"math/tex; mode=display\">pA</script>/<script type=\"math/tex; mode=display\">pB</script> reaches the end of a list, record the last element of A/B respectively. If the two last elements are not the same one, then the two lists have no intersections.</li> \n  </ul> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(m+n)</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n  </ul> \n </div> \n</div>"
},
{
    "frontend_question_id": 159,
    "article_live": false,
    "title": "Longest Substring with At Most Two Distinct Characters",
    "title_slug": "longest-substring-with-at-most-two-distinct-characters",
    "tags": "Hash Table, Two Pointers, String",
    "difficulty": 3,
    "frontend_article_id": 159
},
{
    "frontend_question_id": 158,
    "article_live": false,
    "title": "Read N Characters Given Read4 II - Call multiple times",
    "title_slug": "read-n-characters-given-read4-ii-call-multiple-times",
    "tags": "String",
    "difficulty": 3,
    "frontend_article_id": 158
},
{
    "frontend_question_id": 157,
    "article_live": false,
    "title": "Read N Characters Given Read4",
    "title_slug": "read-n-characters-given-read4",
    "tags": "String",
    "difficulty": 1,
    "frontend_article_id": 157
},
{
    "frontend_question_id": 156,
    "article_live": false,
    "title": "Binary Tree Upside Down",
    "title_slug": "binary-tree-upside-down",
    "tags": "Tree",
    "difficulty": 2,
    "frontend_article_id": 156
},
{
    "frontend_question_id": 155,
    "article_live": false,
    "title": "Min Stack",
    "title_slug": "min-stack",
    "content": "<p>\r\nDesign a stack that supports push, pop, top, and retrieving the minimum element in constant time.\r\n<ul>\r\n<li>\r\npush(x) -- Push element x onto stack.\r\n</li>\r\n<li>\r\npop() -- Removes the element on top of the stack.\r\n</li>\r\n<li>\r\ntop() -- Get the top element.\r\n</li>\r\n<li>\r\ngetMin() -- Retrieve the minimum element in the stack.\r\n</li>\r\n</ul>\r\n</p>\r\n\r\n<p><b>Example:</b><br />\r\n<pre>\r\nMinStack minStack = new MinStack();\r\nminStack.push(-2);\r\nminStack.push(0);\r\nminStack.push(-3);\r\nminStack.getMin();   --> Returns -3.\r\nminStack.pop();\r\nminStack.top();      --> Returns 0.\r\nminStack.getMin();   --> Returns -2.\r\n</pre>\r\n</p>",
    "tags": "Stack, Design",
    "difficulty": 1,
    "frontend_article_id": 155
},
{
    "frontend_question_id": 154,
    "article_live": false,
    "title": "Find Minimum in Rotated Sorted Array II",
    "title_slug": "find-minimum-in-rotated-sorted-array-ii",
    "content": "<p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>\r\n\r\n<p>(i.e., &nbsp;<code>[0,1,2,4,5,6,7]</code>&nbsp;might become &nbsp;<code>[4,5,6,7,0,1,2]</code>).</p>\r\n\r\n<p>Find the minimum element.</p>\r\n\r\n<p>The array may contain duplicates.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [1,3,5]\r\n<strong>Output:</strong> 1</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [2,2,2,0,1]\r\n<strong>Output:</strong> 0</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>This is a follow up problem to&nbsp;<a href=\"https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/\">Find Minimum in Rotated Sorted Array</a>.</li>\r\n\t<li>Would allow duplicates affect the run-time complexity? How and why?</li>\r\n</ul>\r\n",
    "tags": "Array, Binary Search",
    "difficulty": 3,
    "frontend_article_id": 154
},
{
    "frontend_question_id": 153,
    "article_live": true,
    "article_slug": "find-minimum-in-rotated-sorted-array",
    "title": "Find Minimum in Rotated Sorted Array",
    "title_slug": "find-minimum-in-rotated-sorted-array",
    "content": "<p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>\r\n\r\n<p>(i.e., &nbsp;<code>[0,1,2,4,5,6,7]</code>&nbsp;might become &nbsp;<code>[4,5,6,7,0,1,2]</code>).</p>\r\n\r\n<p>Find the minimum element.</p>\r\n\r\n<p>You may assume no duplicate exists in the array.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [3,4,5,1,2] \r\n<strong>Output:</strong> 1\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [4,5,6,7,0,1,2]\r\n<strong>Output:</strong> 0\r\n</pre>\r\n",
    "tags": "Array, Binary Search",
    "difficulty": 2,
    "frontend_article_id": 153,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-binary-search\">Approach 1: Binary Search</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-binary-search\">Approach 1: Binary Search</h4> \n  <p><strong>Intuition</strong></p> \n  <p>A very brute way of solving this question is to search the entire array and find the minimum element. The time complexity for that would be <script type=\"math/tex; mode=display\">O(N)</script> given that <code>N</code> is the size of the array.</p> \n  <p>A very cool way of solving this problem is using the <code>Binary Search</code> algorithm. In binary search we find out the mid point and decide to either search on the left or right depending on some condition.</p> \n  <p>Since the given array is sorted, we can make use of binary search. However, the array is rotated. So simply applying the binary search won't work here.</p> \n  <p>In this question we would essentially apply a modified version of binary search where the <code>condition</code> that decides the search direction would be different than in a standard binary search.</p> \n  <p>We want to find the smallest element in a rotated sorted array. What if the array is not rotated? How do we check that?</p> \n  <p>If the array is not rotated and the array is in ascending order, then <code>last element &gt; first element</code>.</p> \n  <p></p>\n  <center> \n   <img src=\"../Figures/153/153_Minimum_Rotated_Sorted_Array_1.png\" width=\"500\"> \n  </center>\n  <p></p> \n  <p>In the above example <code>7 &gt; 2</code>. This means that the array is still sorted and has no rotation.</p> \n  <p></p>\n  <center> \n   <img src=\"../Figures/153/153_Minimum_Rotated_Sorted_Array_2.png\" width=\"500\"> \n  </center>\n  <p></p> \n  <p>In the above example <code>3 &lt; 4</code>. Hence the array is rotated. This happens because the array was initially <code>[2, 3 ,4 ,5 ,6 ,7]</code>. But after the rotation the smaller elements<code>[2,3]</code> go at the back. i.e. [4, 5, 6, 7, <code>2, 3]</code>. Because of this the first element <code>[4]</code> in the rotated array becomes greater than the last element.</p> \n  <p>This means there is a point in the array at which you would notice a change. This is the point which would help us in this question. We call this the <code>Inflection Point</code>.</p> \n  <p></p>\n  <center> \n   <img src=\"../Figures/153/153_Minimum_Rotated_Sorted_Array_3.png\" width=\"500\"> \n  </center>\n  <p></p> \n  <p>In this modified version of binary search algorithm, we are looking for this point. In the above example notice the <code>Inflection Point</code> .</p> \n  <blockquote> \n   <p>All the elements to the left of inflection point &gt; first element of the array.<br> All the elements to the right of inflection point &lt; first element of the array.</p> \n  </blockquote> \n  <p><strong>Algorithm</strong></p> \n  <ol> \n   <li> <p>Find the <code>mid</code> element of the array.</p> </li> \n   <li> <p>If <code>mid element &gt; first element of array</code> this means that we need to look for the inflection point on the right of <code>mid</code>.</p> </li> \n   <li>If <code>mid element &lt; first element of array</code> this that we need to look for the inflection point on the left of <code>mid</code>.</li> \n  </ol> \n  <p></p>\n  <center> \n   <img src=\"../Figures/153/153_Minimum_Rotated_Sorted_Array_4.png\" width=\"500\"> \n  </center>\n  <p></p> \n  <p>In the above example mid element <code>6</code> is greater than first element <code>4</code>. Hence we continue our search for the inflection point to the right of mid.</p> \n  <p>4 . We stop our search when we find the inflection point, when either of the two conditions is satisfied:</p> \n  <p><code>nums[mid] &gt; nums[mid + 1]</code> Hence, <strong>mid+1</strong> is the smallest.</p> \n  <p><code>nums[mid - 1] &gt; nums[mid]</code> Hence, <strong>mid</strong> is the smallest.</p> \n  <p></p>\n  <center> \n   <img src=\"../Figures/153/153_Minimum_Rotated_Sorted_Array_5.png\" width=\"500\"> \n  </center>\n  <p></p> \n  <p>In the above example. With the marked left and right pointers. The mid element is <code>2</code>. The element just before <code>2</code> is <code>7</code> and <code>7&gt;2</code> i.e. <code>nums[mid - 1] &gt; nums[mid]</code>. Thus we have found the point of inflection and <code>2</code> is the smallest element.</p> \n  <iframe src=\"https://leetcode.com/playground/XNZpTnhk/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"XNZpTnhk\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time Complexity : Same as Binary Search <script type=\"math/tex; mode=display\">O(logN)</script> </li> \n   <li>Space Complexity : <script type=\"math/tex; mode=display\">O(1)</script> <br><br></li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/godayaldivya/\">@godayaldivya</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 152,
    "article_live": false,
    "title": "Maximum Product Subarray",
    "title_slug": "maximum-product-subarray",
    "content": "<p>Given an integer array&nbsp;<code>nums</code>, find the contiguous subarray within an array (containing at least one number) which has the largest product.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [2,3,-2,4]\r\n<strong>Output:</strong> <code>6</code>\r\n<strong>Explanation:</strong>&nbsp;[2,3] has the largest product 6.\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [-2,0,-1]\r\n<strong>Output:</strong> 0\r\n<strong>Explanation:</strong>&nbsp;The result cannot be 2, because [-2,-1] is not a subarray.</pre>\r\n",
    "tags": "Array, Dynamic Programming",
    "difficulty": 2,
    "frontend_article_id": 152
},
{
    "frontend_question_id": 151,
    "article_live": false,
    "title": "Reverse Words in a String",
    "title_slug": "reverse-words-in-a-string",
    "content": "<p>Given an input string, reverse the string word by word.</p>\r\n\r\n<p><strong>Example:&nbsp;&nbsp;</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> &quot;<code>the sky is blue</code>&quot;,\r\n<strong>Output:&nbsp;</strong>&quot;<code>blue is sky the</code>&quot;.\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>A word is defined as a sequence of non-space characters.</li>\r\n\t<li>Input string may contain leading or trailing spaces. However, your reversed string should not contain leading or trailing spaces.</li>\r\n\t<li>You need to reduce multiple spaces between two words to a single space in the reversed string.</li>\r\n</ul>\r\n\r\n<p><strong>Follow up:&nbsp;</strong>For C programmers, try to solve it <em>in-place</em> in <em>O</em>(1) space.</p>\r\n",
    "tags": "String",
    "difficulty": 2,
    "frontend_article_id": 151
},
{
    "frontend_question_id": 150,
    "article_live": false,
    "title": "Evaluate Reverse Polish Notation",
    "title_slug": "evaluate-reverse-polish-notation",
    "content": "<p>Evaluate the value of an arithmetic expression in <a href=\"http://en.wikipedia.org/wiki/Reverse_Polish_notation\" target=\"_blank\">Reverse Polish Notation</a>.</p>\r\n\r\n<p>Valid operators are <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>. Each operand may be an integer or another expression.</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>Division between two integers should truncate toward zero.</li>\r\n\t<li>The given RPN expression is always valid. That means the expression would always evaluate to a result and there won&#39;t&nbsp;be any&nbsp;divide&nbsp;by zero operation.</li>\r\n</ul>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]\r\n<strong>Output:</strong> 9\r\n<strong>Explanation:</strong> ((2 + 1) * 3) = 9\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]\r\n<strong>Output:</strong> 6\r\n<strong>Explanation:</strong> (4 + (13 / 5)) = 6\r\n</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]\r\n<strong>Output:</strong> 22\r\n<strong>Explanation:</strong> \r\n  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\r\n= ((10 * (6 / (12 * -11))) + 17) + 5\r\n= ((10 * (6 / -132)) + 17) + 5\r\n= ((10 * 0) + 17) + 5\r\n= (0 + 17) + 5\r\n= 17 + 5\r\n= 22\r\n</pre>\r\n",
    "tags": "Stack",
    "difficulty": 2,
    "frontend_article_id": 150
},
{
    "frontend_question_id": 149,
    "article_live": false,
    "title": "Max Points on a Line",
    "title_slug": "max-points-on-a-line",
    "content": "<p>Given <em>n</em> points on a 2D plane, find the maximum number of points that lie on the same straight line.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [[1,1],[2,2],[3,3]]\r\n<strong>Output:</strong> 3\r\n<strong>Explanation:</strong>\r\n^\r\n|\r\n| &nbsp; &nbsp; &nbsp; &nbsp;o\r\n| &nbsp; &nbsp; o\r\n| &nbsp;o &nbsp;\r\n+-------------&gt;\r\n0 &nbsp;1 &nbsp;2 &nbsp;3  4\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]\r\n<strong>Output:</strong> 4\r\n<strong>Explanation:</strong>\r\n^\r\n|\r\n|  o\r\n| &nbsp;&nbsp;&nbsp;&nbsp;o&nbsp;&nbsp;      o\r\n| &nbsp;&nbsp;&nbsp;&nbsp;   o\r\n| &nbsp;o &nbsp;      o\r\n+-------------------&gt;\r\n0 &nbsp;1 &nbsp;2 &nbsp;3 &nbsp;4 &nbsp;5 &nbsp;6\r\n</pre>\r\n",
    "tags": "Hash Table, Math",
    "difficulty": 3,
    "frontend_article_id": 149
},
{
    "frontend_question_id": 148,
    "article_live": false,
    "title": "Sort List",
    "title_slug": "sort-list",
    "content": "<p>Sort a linked list in <em>O</em>(<em>n</em> log <em>n</em>) time using constant space complexity.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 4-&gt;2-&gt;1-&gt;3\r\n<strong>Output:</strong> 1-&gt;2-&gt;3-&gt;4\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> -1-&gt;5-&gt;3-&gt;4-&gt;0\r\n<strong>Output:</strong> -1-&gt;0-&gt;3-&gt;4-&gt;5</pre>\r\n",
    "tags": "Linked List, Sort",
    "difficulty": 2,
    "frontend_article_id": 148
},
{
    "frontend_question_id": 147,
    "article_live": false,
    "title": "Insertion Sort List",
    "title_slug": "insertion-sort-list",
    "content": "<p>Sort a linked list using insertion sort.</p>\r\n\r\n<ol>\r\n</ol>\r\n\r\n<p><img alt=\"\" src=\"https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif\" style=\"height:180px; width:300px\" /><br />\r\n<small>A graphical example of insertion sort. The partial sorted list (black) initially contains only the first element in the list.<br />\r\nWith each iteration one element (red) is removed from the input data and inserted in-place into the sorted list</small><br />\r\n&nbsp;</p>\r\n\r\n<ol>\r\n</ol>\r\n\r\n<p><strong>Algorithm of Insertion Sort:</strong></p>\r\n\r\n<ol>\r\n\t<li>Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list.</li>\r\n\t<li>At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there.</li>\r\n\t<li>It repeats until no input elements remain.</li>\r\n</ol>\r\n\r\n<p><br />\r\n<strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 4-&gt;2-&gt;1-&gt;3\r\n<strong>Output:</strong> 1-&gt;2-&gt;3-&gt;4\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> -1-&gt;5-&gt;3-&gt;4-&gt;0\r\n<strong>Output:</strong> -1-&gt;0-&gt;3-&gt;4-&gt;5\r\n</pre>\r\n",
    "tags": "Linked List, Sort",
    "difficulty": 2,
    "frontend_article_id": 147
},
{
    "frontend_question_id": 146,
    "article_live": false,
    "title": "LRU Cache",
    "title_slug": "lru-cache",
    "content": "<p>\r\nDesign and implement a data structure for <a href=\"https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU\" target=\"_blank\">Least Recently Used (LRU) cache</a>. It should support the following operations: <code>get</code> and <code>put</code>.\r\n</p>\r\n\r\n<p>\r\n<code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br>\r\n<code>put(key, value)</code> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.\r\n</p>\r\n\r\n<p><b>Follow up:</b><br />\r\nCould you do both operations in <b>O(1)</b> time complexity?</p>\r\n\r\n<p><b>Example:</b>\r\n<pre>\r\nLRUCache cache = new LRUCache( 2 /* capacity */ );\r\n\r\ncache.put(1, 1);\r\ncache.put(2, 2);\r\ncache.get(1);       // returns 1\r\ncache.put(3, 3);    // evicts key 2\r\ncache.get(2);       // returns -1 (not found)\r\ncache.put(4, 4);    // evicts key 1\r\ncache.get(1);       // returns -1 (not found)\r\ncache.get(3);       // returns 3\r\ncache.get(4);       // returns 4\r\n</pre>\r\n</p>",
    "tags": "Design",
    "difficulty": 3,
    "frontend_article_id": 146
},
{
    "frontend_question_id": 145,
    "article_live": true,
    "article_slug": "binary-tree-postorder-transversal",
    "title": "Binary Tree Postorder Traversal",
    "title_slug": "binary-tree-postorder-traversal",
    "content": "<p>Given a binary tree, return the <em>postorder</em> traversal of its nodes&#39; values.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>&nbsp;<code>[1,null,2,3]</code>\r\n   1\r\n    \\\r\n     2\r\n    /\r\n   3\r\n\r\n<strong>Output:</strong>&nbsp;<code>[3,2,1]</code>\r\n</pre>\r\n\r\n<p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p>\r\n",
    "tags": "Stack, Tree",
    "difficulty": 3,
    "frontend_article_id": 145,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#how-to-transverse-the-tree\">How to transverse the tree</a></li> \n      <li><a href=\"#approach-1-iterations\">Approach 1: Iterations</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"how-to-transverse-the-tree\">How to transverse the tree</h4> \n  <p>There are two general strategies to transverse a tree:</p> \n  <ul> \n   <li> <p><em>Breadth First Search</em> (<code>BFS</code>)</p> <p>We scan through the tree level by level, following the order of height, from top to bottom. The nodes on higher level would be visited before the ones with lower levels.</p> </li> \n   <li> <p><em>Depth First Search</em> (<code>DFS</code>)</p> <p>In this strategy, we adopt the <code>depth</code> as the priority, so that one would start from a root and reach all the way down to certain leaf, and then back to root to reach another branch.</p> <p>The DFS strategy can further be distinguished as <code>preorder</code>, <code>inorder</code>, and <code>postorder</code> depending on the relative order among the root node, left node and right node.</p> </li> \n  </ul> \n  <p>On the following figure the nodes are numerated in the order you visit them, please follow <code>1-2-3-4-5</code> to compare different strategies.</p> \n  <p></p>\n  <center>\n   <img src=\"../Figures/145_transverse.png\" width=\"550px\">\n  </center>\n  <p></p> \n  <p>Here the problem is to implement postorder transversal using iterations. <br> <br></p> \n  <hr> \n  <h4 id=\"approach-1-iterations\">Approach 1: Iterations</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>First of all, here is the definition of the <code>TreeNode</code> which we would use in the following implementation.</p> \n  <iframe src=\"https://leetcode.com/playground/FwYBqSpE/shared\" frameborder=\"0\" width=\"100%\" height=\"225\" name=\"FwYBqSpE\"></iframe> \n  <p>Let's start from the root and then at each iteration pop the current node out of the stack and push its child nodes. In the implemented strategy we push nodes into stack following the order <code>Top-&gt;Bottom</code> and <code>Left-&gt;Right</code>. Since DFS postorder transversal is <code>Bottom-&gt;Top</code> and <code>Left-&gt;Right</code> the output list should be reverted after the end of loop.</p> \n  <iframe src=\"https://leetcode.com/playground/cukUvB5i/shared\" frameborder=\"0\" width=\"100%\" height=\"429\" name=\"cukUvB5i\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : we visit each node exactly once, thus the time complexity is <script type=\"math/tex; mode=display\">\\mathcal{O}(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of nodes, <em>i.e.</em> the size of tree.</p> </li> \n   <li> <p>Space complexity : depending on the tree structure, we could keep up to the entire tree, therefore, the space complexity is <script type=\"math/tex; mode=display\">\\mathcal{O}(N)</script>.</p> </li> \n  </ul> \n  <p>Analysis written by @<a href=\"https://leetcode.com/liaison/\">liaison</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 144,
    "article_live": true,
    "article_slug": "binary-tree-preorder-transversal",
    "title": "Binary Tree Preorder Traversal",
    "title_slug": "binary-tree-preorder-traversal",
    "content": "<p>Given a binary tree, return the <em>preorder</em> traversal of its nodes&#39; values.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>&nbsp;<code>[1,null,2,3]</code>\r\n   1\r\n    \\\r\n     2\r\n    /\r\n   3\r\n\r\n<strong>Output:</strong>&nbsp;<code>[1,2,3]</code>\r\n</pre>\r\n\r\n<p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p>\r\n",
    "tags": "Stack, Tree",
    "difficulty": 2,
    "frontend_article_id": 144,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#how-to-traverse-the-tree\">How to traverse the tree</a></li> \n      <li><a href=\"#approach-1-iterations\">Approach 1: Iterations</a></li> \n      <li><a href=\"#approach-2-morris-traversal\">Approach 2: Morris traversal</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"how-to-traverse-the-tree\">How to traverse the tree</h4> \n  <p>There are two general strategies to traverse a tree:</p> \n  <ul> \n   <li> <p><em>Breadth First Search</em> (<code>BFS</code>)</p> <p>We scan through the tree level by level, following the order of height, from top to bottom. The nodes on higher level would be visited before the ones with lower levels.</p> </li> \n   <li> <p><em>Depth First Search</em> (<code>DFS</code>)</p> <p>In this strategy, we adopt the <code>depth</code> as the priority, so that one would start from a root and reach all the way down to certain leaf, and then back to root to reach another branch.</p> <p>The DFS strategy can further be distinguished as <code>preorder</code>, <code>inorder</code>, and <code>postorder</code> depending on the relative order among the root node, left node and right node.</p> </li> \n  </ul> \n  <p>On the following figure the nodes are numerated in the order you visit them, please follow <code>1-2-3-4-5</code> to compare different strategies.</p> \n  <p><img alt=\"postorder\" src=\"../Figures/145_transverse.png\"></p> \n  <p>Here the problem is to implement postorder traversal using iterations. <br> <br></p> \n  <hr> \n  <h4 id=\"approach-1-iterations\">Approach 1: Iterations</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>First of all, here is the definition of the <code>TreeNode</code> which we would use in the following implementation.</p> \n  <iframe src=\"https://leetcode.com/playground/tXtrJwT2/shared\" frameborder=\"0\" width=\"100%\" height=\"225\" name=\"tXtrJwT2\"></iframe> \n  <p>Let's start from the root and then at each iteration pop the current node out of the stack and push its child nodes. In the implemented strategy we push nodes into output list following the order <code>Top-&gt;Bottom</code> and <code>Left-&gt;Right</code>, that naturally reproduces preorder traversal.</p> \n  <iframe src=\"https://leetcode.com/playground/BRAuDZUW/shared\" frameborder=\"0\" width=\"100%\" height=\"429\" name=\"BRAuDZUW\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : we visit each node exactly once, thus the time complexity is <script type=\"math/tex; mode=display\">\\mathcal{O}(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of nodes, <em>i.e.</em> the size of tree.</p> </li> \n   <li> <p>Space complexity : depending on the tree structure, we could keep up to the entire tree, therefore, the space complexity is <script type=\"math/tex; mode=display\">\\mathcal{O}(N)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-morris-traversal\">Approach 2: Morris traversal</h4> \n  <p>This approach is based on <a href=\"https://www.sciencedirect.com/science/article/pii/0020019079900681\">Morris's article</a> which is intended to optimize the space complexity. The algorithm does not use additional space for the computation, and the memory is only used to keep the output. If one prints the output directly along the computation, the space complexity would be <script type=\"math/tex; mode=display\">\\mathcal{O}(1)</script>.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Here the idea is to go down from the node to its predecessor, and each predecessor will be visited twice. For this go one step left if possible and then always right till the end. When we visit a leaf (node's predecessor) first time, it has a zero right child, so we update output and establish the pseudo link <code>predecessor.right = root</code> to mark the fact the predecessor is visited. When we visit the same predecessor the second time, it already points to the current node, thus we remove pseudo link and move right to the next node.</p> \n  <p>If the first one step left is impossible, update output and move right to next node.</p> \n  <!--![LIS](../Figures/144/144_gif.gif)--> \n  <p>!?!../Documents/144_LIS.json:1000,582!?!</p> \n  <iframe src=\"https://leetcode.com/playground/YX2Q6eH4/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"YX2Q6eH4\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : we visit each predecessor exactly twice descending down from the node, thus the time complexity is <script type=\"math/tex; mode=display\">\\mathcal{O}(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of nodes, <em>i.e.</em> the size of tree.</p> </li> \n   <li> <p>Space complexity : we use no additional memory for the computation itself, but output list contains <script type=\"math/tex; mode=display\">N</script> elements, and thus space complexity is <script type=\"math/tex; mode=display\">\\mathcal{O}(N)</script>.</p> </li> \n  </ul> \n  <p>Analysis written by @<a href=\"https://leetcode.com/liaison/\">liaison</a> and @<a href=\"https://leetcode.com/andvary/\">andvary</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 143,
    "article_live": false,
    "title": "Reorder List",
    "title_slug": "reorder-list",
    "content": "<p>Given a singly linked list <em>L</em>: <em>L</em><sub>0</sub>&rarr;<em>L</em><sub>1</sub>&rarr;&hellip;&rarr;<em>L</em><sub><em>n</em>-1</sub>&rarr;<em>L</em><sub>n</sub>,<br />\r\nreorder it to: <em>L</em><sub>0</sub>&rarr;<em>L</em><sub><em>n</em></sub>&rarr;<em>L</em><sub>1</sub>&rarr;<em>L</em><sub><em>n</em>-1</sub>&rarr;<em>L</em><sub>2</sub>&rarr;<em>L</em><sub><em>n</em>-2</sub>&rarr;&hellip;</p>\r\n\r\n<p>You may <strong>not</strong> modify the values in the list&#39;s nodes, only nodes itself may be changed.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\nGiven 1-&gt;2-&gt;3-&gt;4, reorder it to 1-&gt;4-&gt;2-&gt;3.</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\nGiven 1-&gt;2-&gt;3-&gt;4-&gt;5, reorder it to 1-&gt;5-&gt;2-&gt;4-&gt;3.\r\n</pre>\r\n",
    "tags": "Linked List",
    "difficulty": 2,
    "frontend_article_id": 143
},
{
    "frontend_question_id": 142,
    "article_live": true,
    "article_slug": "linked-list-cycle-ii",
    "title": "Linked List Cycle II",
    "title_slug": "linked-list-cycle-ii",
    "content": "<p>\r\nGiven a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.\r\n</p>\r\n\r\n<p>\r\n<b>Note:</b> Do not modify the linked list.</p>\r\n\r\n<p>\r\n<b>Follow up</b>:<br>\r\nCan you solve it without using extra space?\r\n</p>",
    "tags": "Linked List, Two Pointers",
    "difficulty": 2,
    "frontend_article_id": 142,
    "article_content": ""
},
{
    "frontend_question_id": 141,
    "article_live": true,
    "article_slug": "linked-list-cycle",
    "title": "Linked List Cycle",
    "title_slug": "linked-list-cycle",
    "content": "<p>\r\nGiven a linked list, determine if it has a cycle in it.\r\n</p>\r\n\r\n<p>\r\nFollow up:<br />\r\nCan you solve it without using extra space?\r\n</p>",
    "tags": "Linked List, Two Pointers",
    "difficulty": 1,
    "frontend_article_id": 141,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#summary\">Summary</a></li> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-hash-table\">Approach 1: Hash Table</a></li> \n      <li><a href=\"#approach-2-two-pointers\">Approach 2: Two Pointers</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"summary\">Summary</h2> \n  <p>This article is for beginners. It introduces the following ideas: Linked List, Hash Table and Two Pointers.</p> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-hash-table\">Approach 1: Hash Table</h4> \n  <p><strong>Intuition</strong></p> \n  <p>To detect if a list is cyclic, we can check whether a node had been visited before. A natural way is to use a hash table.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>We go through each node one by one and record each node's reference (or memory address) in a hash table. If the current node is <code>null</code>, we have reached the end of the list and it must not be cyclic. If current node’s reference is in the hash table, then return true.</p> \n  <iframe src=\"https://leetcode.com/playground/3tqYc6gz/shared\" frameborder=\"0\" width=\"100%\" height=\"259\" name=\"3tqYc6gz\"></iframe> \n  <p><strong>Complexity analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. We visit each of the <script type=\"math/tex; mode=display\">n</script> elements in the list at most once. Adding a node to the hash table costs only <script type=\"math/tex; mode=display\">O(1)</script> time.</p> </li> \n   <li> <p>Space complexity: <script type=\"math/tex; mode=display\">O(n)</script>. The space depends on the number of elements added to the hash table, which contains at most <script type=\"math/tex; mode=display\">n</script> elements. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-two-pointers\">Approach 2: Two Pointers</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Imagine two runners running on a track at different speed. What happens when the track is actually a circle?</p> \n  <p><strong>Algorithm</strong></p> \n  <p>The space complexity can be reduced to <script type=\"math/tex; mode=display\">O(1)</script> by considering two pointers at <strong>different speed</strong> - a slow pointer and a fast pointer. The slow pointer moves one step at a time while the fast pointer moves two steps at a time.</p> \n  <p>If there is no cycle in the list, the fast pointer will eventually reach the end and we can return false in this case.</p> \n  <p>Now consider a cyclic list and imagine the slow and fast pointers are two runners racing around a circle track. The fast runner will eventually meet the slow runner. Why? Consider this case (we name it case A) - The fast runner is just one step behind the slow runner. In the next iteration, they both increment one and two steps respectively and meet each other.</p> \n  <p>How about other cases? For example, we have not considered cases where the fast runner is two or three steps behind the slow runner yet. This is simple, because in the next or next's next iteration, this case will be reduced to case A mentioned above.</p> \n  <iframe src=\"https://leetcode.com/playground/B6ffJ2Xk/shared\" frameborder=\"0\" width=\"100%\" height=\"310\" name=\"B6ffJ2Xk\"></iframe> \n  <p><strong>Complexity analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Let us denote <script type=\"math/tex; mode=display\">n</script> as the total number of nodes in the linked list. To analyze its time complexity, we consider the following two cases separately.</p> \n    <ul> \n     <li> <p><strong><em>List has no cycle:</em></strong><br> The fast pointer reaches the end first and the run time depends on the list's length, which is <script type=\"math/tex; mode=display\">O(n)</script>.</p> </li> \n     <li> <p><strong><em>List has a cycle:</em></strong><br> We break down the movement of the slow pointer into two steps, the non-cyclic part and the cyclic part:</p> \n      <ol> \n       <li> <p>The slow pointer takes \"non-cyclic length\" steps to enter the cycle. At this point, the fast pointer has already reached the cycle. <script type=\"math/tex; mode=display\">\\text{Number of iterations} = \\text{non-cyclic length} = N</script> </p> </li> \n       <li> <p>Both pointers are now in the cycle. Consider two runners running in a cycle - the fast runner moves 2 steps while the slow runner moves 1 steps at a time. Since the speed difference is 1, it takes <script type=\"math/tex; mode=display\">\\dfrac{\\text{distance between the 2 runners}}{\\text{difference of speed}}</script> loops for the fast runner to catch up with the slow runner. As the distance is at most \"<script type=\"math/tex; mode=display\">\\text{cyclic length K}</script>\" and the speed difference is 1, we conclude that <br> <script type=\"math/tex; mode=display\">\\text{Number of iterations} = \\text{almost}</script> \"<script type=\"math/tex; mode=display\">\\text{cyclic length K}</script>\".</p> </li> \n      </ol> </li> \n    </ul> <p>Therefore, the worst case time complexity is <script type=\"math/tex; mode=display\">O(N+K)</script>, which is <script type=\"math/tex; mode=display\">O(n)</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. We only use two nodes (slow and fast) so the space complexity is <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n  </ul> \n </div> \n</div>"
},
{
    "frontend_question_id": 140,
    "article_live": true,
    "article_slug": "word-break-ii",
    "title": "Word Break II",
    "title_slug": "word-break-ii",
    "content": "<p>Given a <strong>non-empty</strong> string <em>s</em> and a dictionary <em>wordDict</em> containing a list of <strong>non-empty</strong> words, add spaces in <em>s</em> to construct a sentence where each word is a valid dictionary word.&nbsp;Return all such possible sentences.</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>The same word in the dictionary may be reused multiple times in the segmentation.</li>\r\n\t<li>You may assume the dictionary does not contain duplicate words.</li>\r\n</ul>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:\r\n</strong>s = &quot;<code>catsanddog</code>&quot;\r\nwordDict = <code>[&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;]</code>\r\n<strong>Output:\r\n</strong><code>[\r\n&nbsp; &quot;cats and dog&quot;,\r\n&nbsp; &quot;cat sand dog&quot;\r\n]</code>\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:\r\n</strong>s = &quot;pineapplepenapple&quot;\r\nwordDict = [&quot;apple&quot;, &quot;pen&quot;, &quot;applepen&quot;, &quot;pine&quot;, &quot;pineapple&quot;]\r\n<strong>Output:\r\n</strong>[\r\n&nbsp; &quot;pine apple pen apple&quot;,\r\n&nbsp; &quot;pineapple pen apple&quot;,\r\n&nbsp; &quot;pine applepen apple&quot;\r\n]\r\n<strong>Explanation:</strong> Note that you are allowed to reuse a dictionary word.\r\n</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:\r\n</strong>s = &quot;catsandog&quot;\r\nwordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]\r\n<strong>Output:\r\n</strong>[]</pre>\r\n",
    "tags": "Dynamic Programming, Backtracking",
    "difficulty": 3,
    "frontend_article_id": 140,
    "article_content": ""
},
{
    "frontend_question_id": 139,
    "article_live": true,
    "article_slug": "word-break",
    "title": "Word Break",
    "title_slug": "word-break",
    "content": "<p>Given a <strong>non-empty</strong> string <em>s</em> and a dictionary <em>wordDict</em> containing a list of <strong>non-empty</strong> words, determine if <em>s</em> can be segmented into a space-separated sequence of one or more dictionary words.</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>The same word in the dictionary may be reused multiple times in the segmentation.</li>\r\n\t<li>You may assume the dictionary does not contain duplicate words.</li>\r\n</ul>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]\r\n<strong>Output:</strong> true\r\n<strong>Explanation:</strong> Return true because <code>&quot;leetcode&quot;</code> can be segmented as <code>&quot;leet code&quot;</code>.\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]\r\n<strong>Output:</strong> true\r\n<strong>Explanation:</strong> Return true because <code>&quot;</code>applepenapple<code>&quot;</code> can be segmented as <code>&quot;</code>apple pen apple<code>&quot;</code>.\r\n&nbsp;            Note that you are allowed to reuse a dictionary word.\r\n</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]\r\n<strong>Output:</strong> false\r\n</pre>\r\n",
    "tags": "Dynamic Programming",
    "difficulty": 2,
    "frontend_article_id": 139,
    "article_content": ""
},
{
    "frontend_question_id": 138,
    "article_live": true,
    "article_slug": "copy-list-with-random-pointer",
    "title": "Copy List with Random Pointer",
    "title_slug": "copy-list-with-random-pointer",
    "content": "<p>\r\nA linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.\r\n</p>\r\n\r\n<p>\r\nReturn a deep copy of the list.\r\n</p>",
    "tags": "Hash Table, Linked List",
    "difficulty": 2,
    "frontend_article_id": 138,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-recursive\">Approach 1: Recursive</a></li> \n      <li><a href=\"#approach-2-iterative-with-on-space\">Approach 2: Iterative with O(N) Space</a></li> \n      <li><a href=\"#approach-3-iterative-with-o1-space\">Approach 3: Iterative with O(1) Space</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <p>Lets first look at how the linked list looks like </p>\n  <center> \n   <img src=\"../Figures/138/138_Copy_List_Random_1.png\" width=\"500\"> \n  </center>\n  <p></p> \n  <p>In the above diagram, for a given node the <code>next</code> pointer points to the next node in the linked list. The <code>next</code> pointer is something standard for a linked list and this is what <strong><em>links</em></strong> the nodes together. What is interesting about the diagram and this problem is the <code>random</code> pointer which, as the name suggests can point to any node in the linked list or can be a null.</p> \n  <h4 id=\"approach-1-recursive\">Approach 1: Recursive</h4> \n  <p><strong>Intuition</strong></p> \n  <p>The basic idea behind the recursive solution is to consider the linked list like a graph. Every node of the Linked List has 2 pointers (edges in a graph). Since, random pointers add the randomness to the structure we might visit the same node again leading to cycles.</p> \n  <p></p>\n  <center> \n   <img src=\"../Figures/138/138_Copy_List_Random_2.png\" width=\"500\"> \n  </center>\n  <p></p> \n  <p>In the diagram above we can see the random pointer points back to the previously seen node hence leading to a cycle. We need to take care of these cycles in the implementation.</p> \n  <p>All we do in this approach is to just traverse the graph and clone it. Cloning essentially means creating a new node for every unseen node you encounter. The traversal part will happen recursively in a depth first manner. Note that we have to keep track of nodes already processed because, as pointed out earlier, we can have cycles because of the random pointers.</p> \n  <p><strong>Algorithm</strong></p> \n  <ol> \n   <li> <p>Start traversing the graph from <code>head</code> node.</p> <p>Lets see the linked structure as a graph. Below is the graph representation of the above linked list example. </p>\n    <center> \n     <img src=\"../Figures/138/138_Copy_List_Random_7.png\" width=\"500\"> \n    </center><p></p> <p>In the above example <code>head</code> is where we begin our graph traversal.</p> </li> \n   <li> <p>If we already have a cloned copy of the current node in the visited dictionary, we use the cloned node reference. </p> </li> \n   <li>If we don't have a cloned copy in the visited dictionary, we create a new node and add it to the visited dictionary. <code>visited_dictionary[current_node] = cloned_node_for_current_node.</code></li> \n   <li>We then make two recursive calls, one using the <code>random</code> pointer and the other using <code>next</code> pointer. The diagram from step 1, shows <code>random</code> and <code>next</code> pointers in red and blue color respectively. Essentially we are making recursive calls for the children of the current node. In this implementation, the children are the nodes pointed by the <code>random</code> and the <code>next</code> pointers. <pre>cloned_node_for_current_node.next = copyRandomList(current_node.next);\ncloned_node_for_current_node.random = copyRandomList(current_node.random);\n</pre></li> \n  </ol> \n  <p><br></p> \n  <iframe src=\"https://leetcode.com/playground/96D2TpUH/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"96D2TpUH\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script> where N is the number of nodes in the linked list.</li> \n   <li>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>. If we look closely, we have the recursion stack and we also have the space complexity to keep track of nodes already cloned i.e. using the visited dictionary. But asymptotically, the complexity is <script type=\"math/tex; mode=display\">O(N)</script>. <br> <br></li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-iterative-with-on-space\">Approach 2: Iterative with <script type=\"math/tex; mode=display\">O(N)</script> Space</h4> \n  <p><strong>Intuition</strong></p> \n  <p>The iterative solution to this problem does not model it as a graph, instead simply treats it as a LinkedList. When we are iterating over the list, we can create new nodes via the random pointer or the next pointer whichever points to a node that doesn't exist in our old --&gt; new dictionary.</p> \n  <p><strong>Algorithm</strong></p> \n  <ol> \n   <li> <p>Traverse the linked list starting at <code>head</code> of the linked list. </p>\n    <center> \n     <img src=\"../Figures/138/138_Copy_List_Random_3.png\" width=\"600\"> \n    </center><p></p> <p>In the above diagram we create a new cloned <code>head</code> node. The cloned node is shown using dashed lines. In the implementation we would even store the reference of this newly created node in a visited dictionary.</p> </li> \n   <li> <p>Random Pointer</p> \n    <ul> \n     <li>If the <code>random</code> pointer of the current node <script type=\"math/tex; mode=display\">i</script> points to the a node <script type=\"math/tex; mode=display\">j</script> and a clone of <script type=\"math/tex; mode=display\">j</script> already exists in the visited dictionary, we will simply use the cloned node reference from the visited dictionary.</li> \n     <li>If the <code>random</code> pointer of the current node <script type=\"math/tex; mode=display\">i</script> points to the a node <script type=\"math/tex; mode=display\">j</script> which has not been created yet, we create a new node corresponding to <script type=\"math/tex; mode=display\">j</script> and add it to the visited dictionary.</li> \n    </ul> <p></p>\n    <center> \n     <img src=\"../Figures/138/138_Copy_List_Random_4.png\" width=\"600\"> \n    </center><p></p> <p>In the above diagram the <code>random</code> pointer of node <script type=\"math/tex; mode=display\">A</script> points to a node <script type=\"math/tex; mode=display\">C</script>. Node <script type=\"math/tex; mode=display\">C</script> which was not visited yet as we can see from the previous diagram. Hence we create a new cloned <script type=\"math/tex; mode=display\">C'</script> node corresponding to node <script type=\"math/tex; mode=display\">C</script> and add it to visited dictionary.</p> </li> \n   <li> <p>Next Pointer</p> \n    <ul> \n     <li>If the <code>next</code> pointer of the current node <script type=\"math/tex; mode=display\">i</script> points to the a node <script type=\"math/tex; mode=display\">j</script> and a clone of <script type=\"math/tex; mode=display\">j</script> already exists in the visited dictionary, we will simply use the cloned node reference from the visited dictionary.</li> \n     <li>If the <code>next</code> pointer of the current node <script type=\"math/tex; mode=display\">i</script> points to the a node <script type=\"math/tex; mode=display\">j</script> which has not been created yet, we create a new node corresponding to <script type=\"math/tex; mode=display\">j</script> and add it to the visited dictionary.</li> \n    </ul> <p></p>\n    <center> \n     <img src=\"../Figures/138/138_Copy_List_Random_5.png\" width=\"600\"> \n    </center><p></p> <p>In the above diagram the <code>next</code> pointer of node <script type=\"math/tex; mode=display\">A</script> points to a node <script type=\"math/tex; mode=display\">B</script>. Node <script type=\"math/tex; mode=display\">B</script> which was not visited yet as we can see from the previous diagram. Hence we create a new cloned <script type=\"math/tex; mode=display\">B'</script> node corresponding to node <script type=\"math/tex; mode=display\">B</script> and add it to visited dictionary.</p> </li> \n   <li> <p>We repeat steps 2 and 3 until we reach the end of the linked list.</p> <p></p>\n    <center> \n     <img src=\"../Figures/138/138_Copy_List_Random_6.png\" width=\"600\"> \n    </center><p></p> <p>In the above diagram, the <code>random</code> pointer of node <script type=\"math/tex; mode=display\">B</script> points to an already visited node <script type=\"math/tex; mode=display\">A</script>. Hence in step 2, we don't create a new copy for the clone. Instead we point <code>random</code> pointer of cloned node <script type=\"math/tex; mode=display\">B'</script> to already existing cloned node <script type=\"math/tex; mode=display\">A'</script>.</p> <p>Also, the <code>next</code> pointer of node <script type=\"math/tex; mode=display\">B</script> points to an already visited node <script type=\"math/tex; mode=display\">C</script>. Hence in step 3, we don't create a new copy for the clone. Instead we point <code>next</code> pointer of cloned node <script type=\"math/tex; mode=display\">B'</script> to already existing cloned node <script type=\"math/tex; mode=display\">C'</script>.</p> </li> \n  </ol> \n  <iframe src=\"https://leetcode.com/playground/JGmLY3Tk/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"JGmLY3Tk\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time Complexity : <script type=\"math/tex; mode=display\">O(N)</script> because we make one pass over the original linked list.</li> \n   <li>Space Complexity : <script type=\"math/tex; mode=display\">O(N)</script> as we have a dictionary containing mapping from old list nodes to new list nodes. Since there are <script type=\"math/tex; mode=display\">N</script> nodes, we have <script type=\"math/tex; mode=display\">O(N)</script> space complexity. <br> <br></li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-iterative-with-o1-space\">Approach 3: Iterative with <script type=\"math/tex; mode=display\">O(1)</script> Space</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Instead of a separate dictionary to keep the old node --&gt; new node mapping, we can tweak the original linked list and keep every cloned node next to its original node. This interleaving of old and new nodes allows us to solve this problem without any extra space. Lets look at how the algorithm works.</p> \n  <p><strong>Algorithm</strong></p> \n  <ol> \n   <li> <p>Traverse the original list and clone the nodes as you go and place the cloned copy next to its original node. This new linked list is essentially a interweaving of original and cloned nodes.</p> <p></p>\n    <center> \n     <img src=\"../Figures/138/138_Copy_List_Random_8_1.png\" width=\"800\"> \n    </center> \n    <center> \n     <img src=\"../Figures/138/138_Copy_List_Random_8_2.png\" width=\"800\"> \n    </center><p></p> <p>As you can see we just use the value of original node to create the cloned copy. The <code>next</code> pointer is used to create the weaving. Note that this operation ends up modifying the original linked list. </p><pre>cloned_node.next = original_node.next\noriginal_node.next = cloned_node\n</pre><p></p> </li> \n   <li> <p>Iterate the list having both the new and old nodes intertwined with each other and use the original nodes' random pointers to assign references to random pointers for cloned nodes. For eg. If <code>B</code> has a random pointer to <code>A</code>, this means <code>B'</code> has a random pointer to <code>A'</code>.</p> <p></p>\n    <center> \n     <img src=\"../Figures/138/138_Copy_List_Random_9_1.png\" width=\"800\"> \n    </center><p></p> </li> \n   <li> <p>Now that the <code>random</code> pointers are assigned to the correct node, the <code>next</code> pointers need to be correctly assigned to unweave the current linked list and get back the original list and the cloned list.</p> <p></p>\n    <center> \n     <img src=\"../Figures/138/138_Copy_List_Random_10.png\" width=\"800\"> \n    </center><p></p> </li> \n  </ol> \n  <iframe src=\"https://leetcode.com/playground/Jevr9QjW/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"Jevr9QjW\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time Complexity : <script type=\"math/tex; mode=display\">O(N)</script> </li> \n   <li>Space Complexity : <script type=\"math/tex; mode=display\">O(1)</script> <br><br></li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/godayaldivya/\">@godayaldivya</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 137,
    "article_live": false,
    "title": "Single Number II",
    "title_slug": "single-number-ii",
    "content": "<p>Given a <strong>non-empty</strong>&nbsp;array of integers, every element appears <em>three</em> times except for one, which appears exactly once. Find that single one.</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<p>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [2,2,3,2]\r\n<strong>Output:</strong> 3\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [0,1,0,1,0,1,99]\r\n<strong>Output:</strong> 99</pre>\r\n",
    "tags": "Bit Manipulation",
    "difficulty": 2,
    "frontend_article_id": 137
},
{
    "frontend_question_id": 136,
    "article_live": true,
    "article_slug": "single-number",
    "title": "Single Number",
    "title_slug": "single-number",
    "content": "<p>Given a <strong>non-empty</strong>&nbsp;array of integers, every element appears <em>twice</em> except for one. Find that single one.</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<p>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [2,2,1]\r\n<strong>Output:</strong> 1\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [4,1,2,1,2]\r\n<strong>Output:</strong> 4\r\n</pre>\r\n",
    "tags": "Hash Table, Bit Manipulation",
    "difficulty": 1,
    "frontend_article_id": 136,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-list-operation\">Approach 1: List operation</a></li> \n      <li><a href=\"#approach-2-hash-table\">Approach 2: Hash Table</a></li> \n      <li><a href=\"#approach-3-math\">Approach 3: Math</a></li> \n      <li><a href=\"#approach-4-bit-manipulation\">Approach 4: Bit Manipulation</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-list-operation\">Approach 1: List operation</h4> \n  <p><strong>Algorithm</strong></p> \n  <ol> \n   <li>Iterate over all the elements in <script type=\"math/tex; mode=display\">\\text{nums}</script> </li> \n   <li>If some number in <script type=\"math/tex; mode=display\">\\text{nums}</script> is new to array, append it</li> \n   <li>If some number is already in the array, remove it</li> \n  </ol> \n  <iframe src=\"https://leetcode.com/playground/bCj3rwUg/shared\" frameborder=\"0\" width=\"100%\" height=\"276\" name=\"bCj3rwUg\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^2)</script>. We iterate through <script type=\"math/tex; mode=display\">\\text{nums}</script>, taking <script type=\"math/tex; mode=display\">O(n)</script> time. We search the whole list to find whether there is duplicate number, taking <script type=\"math/tex; mode=display\">O(n)</script> time. Because search is in the <code>for</code> loop, so we have to multiply both time complexities which is <script type=\"math/tex; mode=display\">O(n^2)</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. We need a list of size <script type=\"math/tex; mode=display\">n</script> to contain elements in <script type=\"math/tex; mode=display\">\\text{nums}</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-hash-table\">Approach 2: Hash Table</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>We use hash table to avoid the <script type=\"math/tex; mode=display\">O(n)</script> time required for searching the elements.</p> \n  <ol> \n   <li>Iterate through all elements in <script type=\"math/tex; mode=display\">\\text{nums}</script> </li> \n   <li>Try if <script type=\"math/tex; mode=display\">hash\\_table</script> has the key for <code>pop</code></li> \n   <li>If not, set up key/value pair</li> \n   <li>In the end, there is only one element in <script type=\"math/tex; mode=display\">hash\\_table</script>, so use <code>popitem</code> to get it</li> \n  </ol> \n  <iframe src=\"https://leetcode.com/playground/ebzkQT6R/shared\" frameborder=\"0\" width=\"100%\" height=\"276\" name=\"ebzkQT6R\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n \\cdot 1) = O(n)</script>. Time complexity of <code>for</code> loop is <script type=\"math/tex; mode=display\">O(n)</script>. Time complexity of hash table(dictionary in python) operation <code>pop</code> is <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The space required by <script type=\"math/tex; mode=display\">hash\\_table</script> is equal to the number of elements in <script type=\"math/tex; mode=display\">\\text{nums}</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-math\">Approach 3: Math</h4> \n  <p><strong>Concept</strong></p> \n  <p> <script type=\"math/tex; mode=display\">2 * (a + b + c) - (a + a + b + b + c) = c</script> </p> \n  <iframe src=\"https://leetcode.com/playground/hQwrqahc/shared\" frameborder=\"0\" width=\"100%\" height=\"174\" name=\"hQwrqahc\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n + n) = O(n)</script>. <code>sum</code> will call <code>next</code> to iterate through <script type=\"math/tex; mode=display\">\\text{nums}</script>. We can see it as <code>sum(list(i, for i in nums))</code> which means the time complexity is <script type=\"math/tex; mode=display\">O(n)</script> because of the number of elements(<script type=\"math/tex; mode=display\">n</script>) in <script type=\"math/tex; mode=display\">\\text{nums}</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n + n) = O(n)</script>. <code>set</code> needs space for the elements in <code>nums</code> <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-4-bit-manipulation\">Approach 4: Bit Manipulation</h4> \n  <p><strong>Concept</strong></p> \n  <ul> \n   <li>If we take XOR of zero and some bit, it will return that bit\n    <ul> \n     <li> <script type=\"math/tex; mode=display\">a \\oplus 0 = a</script> </li> \n    </ul> </li> \n   <li>If we take XOR of two same bits, it will return 0\n    <ul> \n     <li> <script type=\"math/tex; mode=display\">a \\oplus a = 0</script> </li> \n    </ul> </li> \n   <li> <script type=\"math/tex; mode=display\">a \\oplus b \\oplus a = (a \\oplus a) \\oplus b = 0 \\oplus b = b</script> </li> \n  </ul> \n  <p>So we can XOR all bits together to find the unique number.</p> \n  <iframe src=\"https://leetcode.com/playground/3TAX3mmj/shared\" frameborder=\"0\" width=\"100%\" height=\"225\" name=\"3TAX3mmj\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. We only iterate through <script type=\"math/tex; mode=display\">\\text{nums}</script>, so the time complexity is the number of elements in <script type=\"math/tex; mode=display\">\\text{nums}</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n  </ul> \n </div> \n</div>"
},
{
    "frontend_question_id": 135,
    "article_live": true,
    "article_slug": "candy",
    "title": "Candy",
    "title_slug": "candy",
    "content": "<p>There are <em>N</em> children standing in a line. Each child is assigned a rating value.</p>\r\n\r\n<p>You are giving candies to these children subjected to the following requirements:</p>\r\n\r\n<ul>\r\n\t<li>Each child must have at least one candy.</li>\r\n\t<li>Children with a higher rating get more candies than their neighbors.</li>\r\n</ul>\r\n\r\n<p>What is the minimum candies you must give?</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [1,0,2]\r\n<strong>Output:</strong> 5\r\n<strong>Explanation:</strong> You can allocate to the first, second and third child with 2, 1, 2 candies respectively.\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [1,2,2]\r\n<strong>Output:</strong> 4\r\n<strong>Explanation:</strong> You can allocate to the first, second and third child with 1, 2, 1 candies respectively.\r\n             The third child gets 1 candy because it satisfies the above two conditions.\r\n</pre>\r\n",
    "tags": "Greedy",
    "difficulty": 3,
    "frontend_article_id": 135,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force\">Approach 1: Brute Force</a></li> \n      <li><a href=\"#approach-2-using-two-arrays\">Approach 2: Using two arrays</a></li> \n      <li><a href=\"#approach-3-using-one-array\">Approach 3: Using one array</a></li> \n      <li><a href=\"#approach-4-single-pass-approach-with-constant-space\">Approach 4: Single Pass Approach with Constant Space</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force\">Approach 1: Brute Force</h4> \n  <p>The simplest approach makes use of a 1-d array, <script type=\"math/tex; mode=display\">candies</script> to keep a track of the candies given to the students. Firstly, we give 1 candy to each student. Then, we start scanning the array from left-to-right. At every element encountered, firstly, if the current element's ratings, <script type=\"math/tex; mode=display\">ratings[i]</script>, is larger than the previous element <script type=\"math/tex; mode=display\">ratings[i-1]</script> and <script type=\"math/tex; mode=display\">candies[i]<=candies[i-1]</script>, then we update <script type=\"math/tex; mode=display\">candies[i]</script> as <script type=\"math/tex; mode=display\">candies[i]=candies[i-1] + 1</script>. Thus, now the candy distribution for these two elements <script type=\"math/tex; mode=display\">candies[i-1]</script> and <script type=\"math/tex; mode=display\">candies[i]</script> becomes correct for the time being(locally). In the same step, we also check if the current element's ratings, <script type=\"math/tex; mode=display\">ratings[i]</script>, is larger than the next element's ratings, i.e. <script type=\"math/tex; mode=display\">ratings[i]>ratings[i+1]</script>. If so, we again update <script type=\"math/tex; mode=display\">candies[i]=candies[i+1] + 1</script>. We continue this process for the whole <script type=\"math/tex; mode=display\">ratings</script> array. If in any traversal, no updation of the <script type=\"math/tex; mode=display\">candies</script> array occurs, it means we've reached at the final required distribution of the candies and we can stop the traversals. To keep a track of this we make use of a <script type=\"math/tex; mode=display\">flag</script> which is set to <script type=\"math/tex; mode=display\">\\text{True}</script> if any updation occurs in a traversal.</p> \n  <p>At the end, we can sum up all the elements of the <script type=\"math/tex; mode=display\">candies</script> array to obtain the required minimum number of candies.</p> \n  <iframe src=\"https://leetcode.com/playground/gpKEkWCp/shared\" frameborder=\"0\" width=\"100%\" height=\"480\" name=\"gpKEkWCp\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^2)</script>. We need to traverse the array at most <script type=\"math/tex; mode=display\">n</script> times.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. One <script type=\"math/tex; mode=display\">candies</script> array of size <script type=\"math/tex; mode=display\">n</script> is used. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-using-two-arrays\">Approach 2: Using two arrays</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In this approach, we make use of two 1-d arrays <script type=\"math/tex; mode=display\">left2right</script> and <script type=\"math/tex; mode=display\">right2left</script>. The <script type=\"math/tex; mode=display\">left2right</script> array is used to store the number of candies required by the current student taking care of the distribution relative to the left neighbours only. i.e. Assuming the distribution rule is: The student with a higher ratings than its left neighbour should always get more candies than its left neighbour. Similarly, the <script type=\"math/tex; mode=display\">right2left</script> array is used to store the number of candies candies required by the current student taking care of the distribution relative to the right neighbours only. i.e. Assuming the distribution rule to be: The student with a higher ratings than its right neighbour should always get more candies than its right neighbour. To do so, firstly we assign 1 candy to each student in both <script type=\"math/tex; mode=display\">left2right</script> and <script type=\"math/tex; mode=display\">right2left</script> array. Then, we traverse the array from left-to-right and whenever the current element's ratings is larger than the left neighbour we update the current element's candies in the <script type=\"math/tex; mode=display\">left2right</script> array as <script type=\"math/tex; mode=display\">left2right[i] = left2right[i-1] + 1</script>, since the current element's candies are always less than or equal candies than its left neighbour before updation. After the forward traversal, we traverse the array from left-to-right and update <script type=\"math/tex; mode=display\">right2left[i]</script> as <script type=\"math/tex; mode=display\">right2left[i] = right2left[i + 1] + 1</script>, whenever the current ( <script type=\"math/tex; mode=display\">i^{th}</script> ) element has a higher ratings than the right ( <script type=\"math/tex; mode=display\">(i+1)^{th}</script> ) element.</p> \n  <p>Now, for the <script type=\"math/tex; mode=display\">i^{th}</script> student in the array, we need to give <script type=\"math/tex; mode=display\">\\text{max}(left2right[i], right2left[i])</script> to it, in order to satisfy both the left and the right neighbour relationship. Thus, at the end, we obtain the minimum number of candies required as:</p> \n  <p> <script type=\"math/tex; mode=display\">\n\\text{minimum_candies}=\\sum_{i=0}^{n-1} \\text{max}(left2right[i], right2left[i]), \\text{where } n = \\text{length of the ratings array.}\n</script> </p> \n  <p>The following animation illustrates the method:</p> \n  <p><img alt=\"Candy_Two_Arrays\" src=\"../Figures/135_Candy_Two_Pass.gif\"></p> \n  <iframe src=\"https://leetcode.com/playground/ZJvLfBzc/shared\" frameborder=\"0\" width=\"100%\" height=\"446\" name=\"ZJvLfBzc\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. <script type=\"math/tex; mode=display\">left2right</script> and <script type=\"math/tex; mode=display\">right2left</script> arrays are traversed thrice.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Two arrays <script type=\"math/tex; mode=display\">left2right</script> and <script type=\"math/tex; mode=display\">right2left</script> of size <script type=\"math/tex; mode=display\">n</script> are used. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-using-one-array\">Approach 3: Using one array</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In the previous approach, we used two arrays to keep track of the left neighbour and the right neighbour relation individually and later on combined these two. Instead of this, we can make use of a single array <script type=\"math/tex; mode=display\">candies</script> to keep the count of the number of candies to be allocated to the current student. In order to do so, firstly we assign 1 candy to each student. Then, we traverse the array from left-to-right and distribute the candies following only the left neighbour relation i.e. whenever the current element's ratings is larger than the left neighbour and has less than or equal candies than its left neighbour, we update the current element's candies in the <script type=\"math/tex; mode=display\">candies</script> array as <script type=\"math/tex; mode=display\">candies[i] = candies[i-1] + 1</script>. While updating we need not compare <script type=\"math/tex; mode=display\">candies[i]</script> and <script type=\"math/tex; mode=display\">candies[i - 1]</script>, since <script type=\"math/tex; mode=display\">candies[i] \\leq candies[i - 1]</script> before updation. After this, we traverse the array from right-to-left. Now, we need to update the <script type=\"math/tex; mode=display\">i^{th}</script> element's candies in order to satisfy both the left neighbour and the right neighbour relation. Now, during the backward traversal, if <script type=\"math/tex; mode=display\">ratings[i]>ratings[i + 1]</script>, considering only the right neighbour criteria, we could've updated <script type=\"math/tex; mode=display\">candies[i]</script> as <script type=\"math/tex; mode=display\">candies[i] = candies[i + 1] + 1</script>. But, this time we need to update the <script type=\"math/tex; mode=display\">candies[i]</script> only if <script type=\"math/tex; mode=display\">candies[i] \\leq candies[i + 1]</script>. This happens because, this time we've already altered the <script type=\"math/tex; mode=display\">candies</script> array during the forward traversal and thus <script type=\"math/tex; mode=display\">candies[i]</script> isn't necessarily less than or equal to <script type=\"math/tex; mode=display\">candies[i + 1]</script>. Thus, if <script type=\"math/tex; mode=display\">ratings[i] > ratings[i + 1]</script>, we can update <script type=\"math/tex; mode=display\">candies[i]</script> as <script type=\"math/tex; mode=display\">candies[i] = \\text{max}(candies[i], candies[i + 1] + 1)</script>, which makes <script type=\"math/tex; mode=display\">candies[i]</script> satisfy both the left neighbour and the right neighbour criteria.</p> \n  <p>Again, we need sum up all the elements of the <script type=\"math/tex; mode=display\">candies</script> array to obtain the required result.</p> \n  <p> <script type=\"math/tex; mode=display\">\n\\text{minimum_candies} = \\sum_{i=0}^{n-1} candies[i], \\text{where } n = \\text{length of the ratings array.}\n</script> </p> \n  <iframe src=\"https://leetcode.com/playground/U4XtvyuF/shared\" frameborder=\"0\" width=\"100%\" height=\"378\" name=\"U4XtvyuF\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The array <script type=\"math/tex; mode=display\">candies</script> of size <script type=\"math/tex; mode=display\">n</script> is traversed thrice.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. An array <script type=\"math/tex; mode=display\">candies</script> of size <script type=\"math/tex; mode=display\">n</script> is used. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-4-single-pass-approach-with-constant-space\">Approach 4: Single Pass Approach with Constant Space</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>This approach relies on the observation(as demonstrated in the figure below as well) that in order to distribute the candies as per the given criteria using the minimum number of candies, the candies are always distributed in terms of increments of 1. Further, while distributing the candies, the local minimum number of candies given to a student is 1. Thus, the sub-distributions always take the form: <script type=\"math/tex; mode=display\">\\text{1, 2, 3, ..., n}</script> or <script type=\"math/tex; mode=display\">\\text{n,..., 2, 1}</script>, whose sum is simply given by <script type=\"math/tex; mode=display\">n(n+1)/2</script>.</p> \n  <p>Now, we can view the given <script type=\"math/tex; mode=display\">rankings</script> as some rising and falling slopes. Whenever the slope is rising, the distribution takes the form: <script type=\"math/tex; mode=display\">\\text{1, 2, 3, ..., m}</script>. Similarly, a falling slope takes the form: <script type=\"math/tex; mode=display\">\\text{k,..., 2, 1}</script>. An issue that arises now is that the local peak point can be included in only one of the slopes. Whether to include the local peak point(<script type=\"math/tex; mode=display\">\\text{n}</script>) in the rising slope or the falling slope?</p> \n  <p>In order to decide it, we can observe that in order to satisfy both the right neighbour and the left neighbour criteria, the peak point's count needs to be the max. of the counts determined by the rising and the falling slopes. Thus, in order to determine the number of candies required, the peak point needs to be included in the slope which contains more number of points. The local valley point can also be included in only one of the slopes, but this issue can be resolved easily, since the local valley point will always be assigned a candy count of 1(which can be subtracted from the next slope's count calculations).</p> \n  <p>Coming to the implementation, we maintain two variables <script type=\"math/tex; mode=display\">old\\_slope</script> and <script type=\"math/tex; mode=display\">new\\_slope</script> to determine the occurence of a peak or a valley. We also use <script type=\"math/tex; mode=display\">up</script> and <script type=\"math/tex; mode=display\">down</script> variables to keep a track of the count of elements on the rising slope and on the falling slope respectively(without including the peak element). We always update the total count of <script type=\"math/tex; mode=display\">candies</script> at the end of a falling slope following a rising slope (or a mountain). The leveling of the points in <script type=\"math/tex; mode=display\">rankings</script> also works as the end of a mountain. At the end of the mountain, we determine whether to include the peak point in the rising slope or in the falling slope by comparing the <script type=\"math/tex; mode=display\">up</script> and <script type=\"math/tex; mode=display\">down</script> variables up to that point. Thus, the count assigned to the peak element becomes: <script type=\"math/tex; mode=display\">\\text{max}(up, down) + 1</script>. At this point, we can reset the <script type=\"math/tex; mode=display\">up</script> and <script type=\"math/tex; mode=display\">down</script> variables indicating the start of a new mountain.</p> \n  <p>The following figure shows the cases that need to be handled for this example:</p> \n  <p><code>rankings: [1 2 3 4 5 3 2 1 2 6 5 4 3 3 2 1 1 3 3 3 4 2]</code></p> \n  <p><img alt=\"Candy_Two_Arrays\" src=\"../Figures/135_Candy_Constant_Space.PNG\"></p> \n  <p>From this figure, we can see that the candy distributions in the subregions always take the form <script type=\"math/tex; mode=display\">\\text{1, 2, ...n}</script> or <script type=\"math/tex; mode=display\">\\text{n, ..., 2, 1}</script>. For the first mountain comprised by the regions <script type=\"math/tex; mode=display\">a</script> and <script type=\"math/tex; mode=display\">b</script>, while assigning candies to the local peak point (<script type=\"math/tex; mode=display\">pt. 5</script>), it needs to be included in <script type=\"math/tex; mode=display\">a</script> to satisfy the left neighbour criteria. The local valley point at the end of region <script type=\"math/tex; mode=display\">b</script> (<script type=\"math/tex; mode=display\">pt. 8</script>) marks the end of the first mountain (region <script type=\"math/tex; mode=display\">c</script>). While performing the calculations, we can include this point in either the current or the following mountain. The <script type=\"math/tex; mode=display\">pt. 13</script> marks the end of the second mountain due to levelling of the <script type=\"math/tex; mode=display\">pt. 13</script> and <script type=\"math/tex; mode=display\">pt. 14</script>. Since, region <script type=\"math/tex; mode=display\">e</script> has more points than region <script type=\"math/tex; mode=display\">d</script>, the local peak (<script type=\"math/tex; mode=display\">pt. 10</script>) needs to be included in region <script type=\"math/tex; mode=display\">e</script> to satisfy the right neighbour criteria. Now, the third mountain <script type=\"math/tex; mode=display\">f</script> can be considered as a mountian with no rising slope (<script type=\"math/tex; mode=display\">up=0</script>) but only a falling slope. Similarly, <script type=\"math/tex; mode=display\">pt. 16, 18, 19</script> also act as the mountain ends due to the levelling of the points.</p> \n  <iframe src=\"https://leetcode.com/playground/9nSyErSr/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"9nSyErSr\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. We traverse the <script type=\"math/tex; mode=display\">rankings</script> array once only.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant Extra Space is used.</p> </li> \n  </ul> \n </div> \n</div>"
},
{
    "frontend_question_id": 134,
    "article_live": false,
    "title": "Gas Station",
    "title_slug": "gas-station",
    "content": "<p>There are <em>N</em> gas stations along a circular route, where the amount of gas at station <em>i</em> is <code>gas[i]</code>.</p>\r\n\r\n<p>You have a car with an unlimited gas tank and it costs <code>cost[i]</code> of gas to travel from station <em>i</em> to its next station (<em>i</em>+1). You begin the journey with an empty tank at one of the gas stations.</p>\r\n\r\n<p>Return the starting gas station&#39;s index if you can travel around the circuit once in the clockwise direction, otherwise return -1.</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>If there exists a&nbsp;solution, it is guaranteed to be unique.</li>\r\n\t<li>Both input arrays are non-empty and have the same length.</li>\r\n\t<li>Each element in the input arrays is a non-negative integer.</li>\r\n</ul>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> \r\ngas  = [1,2,3,4,5]\r\ncost = [3,4,5,1,2]\r\n\r\n<strong>Output:</strong> 3\r\n\r\n<strong>Explanation:\r\n</strong>Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\r\nTravel to station 4. Your tank = 4 - 1 + 5 = 8\r\nTravel to station 0. Your tank = 8 - 2 + 1 = 7\r\nTravel to station 1. Your tank = 7 - 3 + 2 = 6\r\nTravel to station 2. Your tank = 6 - 4 + 3 = 5\r\nTravel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.\r\nTherefore, return 3 as the starting index.\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> \r\ngas  = [2,3,4]\r\ncost = [3,4,3]\r\n\r\n<strong>Output:</strong> -1\r\n\r\n<strong>Explanation:\r\n</strong>You can&#39;t start at station 0 or 1, as there is not enough gas to travel to the next station.\r\nLet&#39;s start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\r\nTravel to station 0. Your tank = 4 - 3 + 2 = 3\r\nTravel to station 1. Your tank = 3 - 3 + 3 = 3\r\nYou cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.\r\nTherefore, you can&#39;t travel around the circuit once no matter where you start.\r\n</pre>\r\n",
    "tags": "Greedy",
    "difficulty": 2,
    "frontend_article_id": 134
},
{
    "frontend_question_id": 133,
    "article_live": false,
    "title": "Clone Graph",
    "title_slug": "clone-graph",
    "content": "<p>Given the head of a&nbsp;graph, return a deep copy (clone) of the graph. Each node in the graph contains a <code>label</code>&nbsp;(<code>int</code>) and a list (<code>List[UndirectedGraphNode]</code>) of its <code>neighbors</code>. There is an edge between the given node and each of the nodes in its neighbors.</p>\r\n\r\n<div><br />\r\n<b>OJ&#39;s undirected graph serialization (so you can understand error output):</b>\r\n\r\n<p>Nodes are labeled uniquely.</p>\r\nWe use <code>#</code> as a separator for each node, and <code>,</code> as a separator for node label and each neighbor of the node.\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>As an example, consider the serialized graph <code><font color=\"red\">{<font color=\"black\">0</font>,1,2#</font><font color=\"blue\"><font color=\"black\">1</font>,2#</font><font color=\"green\"><font color=\"black\">2</font>,2}</font></code>.</p>\r\n\r\n<p>The graph has a total of three nodes, and therefore contains three parts as separated by <code>#</code>.</p>\r\n\r\n<ol>\r\n\t<li>First node is labeled as <code><font color=\"black\">0</font></code>. Connect node <code><font color=\"black\">0</font></code> to both nodes <code><font color=\"red\">1</font></code> and <code><font color=\"red\">2</font></code>.</li>\r\n\t<li>Second node is labeled as <code><font color=\"black\">1</font></code>. Connect node <code><font color=\"black\">1</font></code> to node <code><font color=\"blue\">2</font></code>.</li>\r\n\t<li>Third node is labeled as <code><font color=\"black\">2</font></code>. Connect node <code><font color=\"black\">2</font></code> to node <code><font color=\"green\">2</font></code> (itself), thus forming a self-cycle.</li>\r\n</ol>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Visually, the graph looks like the following:</p>\r\n\r\n<pre>\r\n       1\r\n      / \\\r\n     /   \\\r\n    0 --- 2\r\n         / \\\r\n         \\_/\r\n</pre>\r\n\r\n<p><strong>Note</strong>: The information about the tree serialization is only meant so that you can understand error output if you get a wrong answer. You don&#39;t need to understand the serialization to solve the problem.</p>\r\n</div>\r\n",
    "tags": "Depth-first Search, Breadth-first Search, Graph",
    "difficulty": 2,
    "frontend_article_id": 133
},
{
    "frontend_question_id": 132,
    "article_live": false,
    "title": "Palindrome Partitioning II",
    "title_slug": "palindrome-partitioning-ii",
    "content": "<p>Given a string <em>s</em>, partition <em>s</em> such that every substring of the partition is a palindrome.</p>\r\n\r\n<p>Return the minimum cuts needed for a palindrome partitioning of <em>s</em>.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>&nbsp;&quot;aab&quot;\r\n<strong>Output:</strong> 1\r\n<strong>Explanation:</strong> The palindrome partitioning [&quot;aa&quot;,&quot;b&quot;] could be produced using 1 cut.\r\n</pre>\r\n",
    "tags": "Dynamic Programming",
    "difficulty": 3,
    "frontend_article_id": 132
},
{
    "frontend_question_id": 131,
    "article_live": false,
    "title": "Palindrome Partitioning",
    "title_slug": "palindrome-partitioning",
    "content": "<p>Given a string <em>s</em>, partition <em>s</em> such that every substring of the partition is a palindrome.</p>\r\n\r\n<p>Return all possible palindrome partitioning of <em>s</em>.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>&nbsp;&quot;aab&quot;\r\n<strong>Output:</strong>\r\n[\r\n  [&quot;aa&quot;,&quot;b&quot;],\r\n  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]\r\n]\r\n</pre>\r\n",
    "tags": "Backtracking",
    "difficulty": 2,
    "frontend_article_id": 131
},
{
    "frontend_question_id": 130,
    "article_live": false,
    "title": "Surrounded Regions",
    "title_slug": "surrounded-regions",
    "content": "<p>Given a 2D board containing <code>&#39;X&#39;</code> and <code>&#39;O&#39;</code> (<strong>the letter O</strong>), capture all regions surrounded by <code>&#39;X&#39;</code>.</p>\r\n\r\n<p>A region is captured by flipping all <code>&#39;O&#39;</code>s into <code>&#39;X&#39;</code>s in that surrounded region.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\nX X X X\r\nX O O X\r\nX X O X\r\nX O X X\r\n</pre>\r\n\r\n<p>After running your function, the board should be:</p>\r\n\r\n<pre>\r\nX X X X\r\nX X X X\r\nX X X X\r\nX O X X\r\n</pre>\r\n\r\n<p><strong>Explanation:</strong></p>\r\n\r\n<p>Surrounded regions shouldn&rsquo;t be on the border, which means that any <code>&#39;O&#39;</code>&nbsp;on the border of the board are not flipped to <code>&#39;X&#39;</code>. Any <code>&#39;O&#39;</code>&nbsp;that is not on the border and it is not connected to an <code>&#39;O&#39;</code>&nbsp;on the border will be flipped to <code>&#39;X&#39;</code>. Two cells are connected if they are adjacent cells connected horizontally or vertically.</p>\r\n",
    "tags": "Depth-first Search, Breadth-first Search, Union Find",
    "difficulty": 2,
    "frontend_article_id": 130
},
{
    "frontend_question_id": 129,
    "article_live": false,
    "title": "Sum Root to Leaf Numbers",
    "title_slug": "sum-root-to-leaf-numbers",
    "content": "<p>Given a binary tree containing digits from <code>0-9</code> only, each root-to-leaf path could represent a number.</p>\r\n\r\n<p>An example is the root-to-leaf path <code>1-&gt;2-&gt;3</code> which represents the number <code>123</code>.</p>\r\n\r\n<p>Find the total sum of all root-to-leaf numbers.</p>\r\n\r\n<p><strong>Note:</strong>&nbsp;A leaf is a node with no children.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [1,2,3]\r\n    1\r\n   / \\\r\n  2   3\r\n<strong>Output:</strong> 25\r\n<strong>Explanation:</strong>\r\nThe root-to-leaf path <code>1-&gt;2</code> represents the number <code>12</code>.\r\nThe root-to-leaf path <code>1-&gt;3</code> represents the number <code>13</code>.\r\nTherefore, sum = 12 + 13 = <code>25</code>.</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [4,9,0,5,1]\r\n    4\r\n   / \\\r\n  9   0\r\n&nbsp;/ \\\r\n5   1\r\n<strong>Output:</strong> 1026\r\n<strong>Explanation:</strong>\r\nThe root-to-leaf path <code>4-&gt;9-&gt;5</code> represents the number 495.\r\nThe root-to-leaf path <code>4-&gt;9-&gt;1</code> represents the number 491.\r\nThe root-to-leaf path <code>4-&gt;0</code> represents the number 40.\r\nTherefore, sum = 495 + 491 + 40 = <code>1026</code>.</pre>\r\n",
    "tags": "Tree, Depth-first Search",
    "difficulty": 2,
    "frontend_article_id": 129
},
{
    "frontend_question_id": 128,
    "article_live": true,
    "article_slug": "longest-consecutive-sequence",
    "title": "Longest Consecutive Sequence",
    "title_slug": "longest-consecutive-sequence",
    "content": "<p>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</p>\r\n\r\n<p>Your algorithm should run in O(<em>n</em>) complexity.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>&nbsp;[100, 4, 200, 1, 3, 2]\r\n<strong>Output:</strong> 4\r\n<strong>Explanation:</strong> The longest consecutive elements sequence is <code>[1, 2, 3, 4]</code>. Therefore its length is 4.\r\n</pre>\r\n",
    "tags": "Array, Union Find",
    "difficulty": 3,
    "frontend_article_id": 128,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-brute-force\">Approach 1: Brute Force</a></li> \n    <li><a href=\"#approach-2-sorting\">Approach 2: Sorting</a></li> \n    <li><a href=\"#approach-3-hashset-and-intelligent-sequence-building\">Approach 3: HashSet and Intelligent Sequence Building</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-brute-force\">Approach 1: Brute Force</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Because a sequence could start at any number in <code>nums</code>, we can exhaust the entire search space by building as long a sequence as possible from every number.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>The brute force algorithm does not do anything clever - it just considers each number in <code>nums</code>, attempting to count as high as possible from that number using only numbers in <code>nums</code>. After it counts too high (i.e. <code>currentNum</code> refers to a number that <code>nums</code> does not contain), it records the length of the sequence if it is larger than the current best. The algorithm is necessarily optimal because it explores every possibility.</p> \n  <iframe src=\"https://leetcode.com/playground/puxLaX5E/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"puxLaX5E\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^3)</script>.</p> <p>The outer loop runs exactly <script type=\"math/tex; mode=display\">n</script> times, and because <code>currentNum</code> increments by 1 during each iteration of the <code>while</code> loop, it runs in <script type=\"math/tex; mode=display\">O(n)</script> time. Then, on each iteration of the <code>while</code> loop, an <script type=\"math/tex; mode=display\">O(n)</script> lookup in the array is performed. Therefore, this brute force algorithm is really three nested <script type=\"math/tex; mode=display\">O(n)</script> loops, which compound multiplicatively to a cubic runtime.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>.</p> <p>The brute force algorithm only allocates a handful of integers, so it uses constant additional space.</p> </li> \n  </ul> \n  <p><br></p> \n  <hr> \n  <h4 id=\"approach-2-sorting\">Approach 2: Sorting</h4> \n  <p><strong>Intuition</strong></p> \n  <p>If we can iterate over the numbers in ascending order, then it will be easy to find sequences of consecutive numbers. To do so, we can sort the array.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Before we do anything, we check for the base case input of the empty array. The longest sequence in an empty array is, of course, 0, so we can simply return that. For all other cases, we sort <code>nums</code> and consider each number after the first (because we need to compare each number to its previous number). If the current number and the previous are equal, then our current sequence is neither extended nor broken, so we simply move on to the next number. If they are unequal, then we must check whether the current number extends the sequence (i.e. <code>nums[i] == nums[i-1] + 1</code>). If it does, then we add to our current count and continue. Otherwise, the sequence is broken, so we record our current sequence and reset it to 1 (to include the number that broke the sequence). It is possible that the last element of <code>nums</code> is part of the longest sequence, so we return the maximum of the current sequence and the longest one.</p> \n  <p align=\"center\"><img alt=\"Sorting Example\" src=\"../Figures/128/sorting.png\"></p> \n  <p>Here, an example array is sorted before the linear scan identifies all consecutive sequences. The longest sequence is colored in red.</p> \n  <iframe src=\"https://leetcode.com/playground/M9Rxw5qk/shared\" frameborder=\"0\" width=\"100%\" height=\"497\" name=\"M9Rxw5qk\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(nlgn)</script>.</p> <p>The main <code>for</code> loop does constant work <script type=\"math/tex; mode=display\">n</script> times, so the algorithm's time complexity is dominated by the invocation of <code>sort</code>, which will run in <script type=\"math/tex; mode=display\">O(nlgn)</script> time for any sensible implementation.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script> (or <script type=\"math/tex; mode=display\">O(n)</script>).</p> <p>For the implementations provided here, the space complexity is constant because we sort the input array in place. If we are not allowed to modify the input array, we must spend linear space to store a sorted copy.</p> </li> \n  </ul> \n  <p><br></p> \n  <hr> \n  <h4 id=\"approach-3-hashset-and-intelligent-sequence-building\">Approach 3: HashSet and Intelligent Sequence Building</h4> \n  <p><strong>Intuition</strong></p> \n  <p>It turns out that our initial brute force solution was on the right track, but missing a few optimizations necessary to reach <script type=\"math/tex; mode=display\">O(n)</script> time complexity.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>This optimized algorithm contains only two changes from the brute force approach: the numbers are stored in a <code>HashSet</code> (or <code>Set</code>, in Python) to allow <script type=\"math/tex; mode=display\">O(1)</script> lookups, and we only attempt to build sequences from numbers that are not already part of a longer sequence. This is accomplished by first ensuring that the number that would immediately precede the current number in a sequence is not present, as that number would necessarily be part of a longer sequence.</p> \n  <iframe src=\"https://leetcode.com/playground/KbUGJ84k/shared\" frameborder=\"0\" width=\"100%\" height=\"497\" name=\"KbUGJ84k\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>.</p> <p>Although the time complexity appears to be quadratic due to the <code>while</code> loop nested within the <code>for</code> loop, closer inspection reveals it to be linear. Because the <code>while</code> loop is reached only when <code>currentNum</code> marks the beginning of a sequence (i.e. <code>currentNum-1</code> is not present in <code>nums</code>), the <code>while</code> loop can only run for <script type=\"math/tex; mode=display\">n</script> iterations throughout the entire runtime of the algorithm. This means that despite looking like <script type=\"math/tex; mode=display\">O(n \\cdot n)</script> complexity, the nested loops actually run in <script type=\"math/tex; mode=display\">O(n + n) = O(n)</script> time. All other computations occur in constant time, so the overall runtime is linear.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>.</p> <p>In order to set up <script type=\"math/tex; mode=display\">O(1)</script> containment lookups, we allocate linear space for a hash table to store the <script type=\"math/tex; mode=display\">O(n)</script> numbers in <code>nums</code>. Other than that, the space complexity is identical to that of the brute force solution.</p> </li> \n  </ul> \n </div> \n</div>"
},
{
    "frontend_question_id": 127,
    "article_live": false,
    "title": "Word Ladder",
    "title_slug": "word-ladder",
    "content": "<p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary&#39;s word list, find the length of shortest transformation sequence from <em>beginWord</em> to <em>endWord</em>, such that:</p>\r\n\r\n<ol>\r\n\t<li>Only one letter can be changed at a time.</li>\r\n\t<li>Each transformed word must exist in the word list. Note that <em>beginWord</em> is <em>not</em> a transformed word.</li>\r\n</ol>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>Return 0 if there is no such transformation sequence.</li>\r\n\t<li>All words have the same length.</li>\r\n\t<li>All words contain only lowercase alphabetic characters.</li>\r\n\t<li>You may assume no duplicates in the word list.</li>\r\n\t<li>You may assume <em>beginWord</em> and <em>endWord</em> are non-empty and are not the same.</li>\r\n</ul>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>\r\nbeginWord = &quot;hit&quot;,\r\nendWord = &quot;cog&quot;,\r\nwordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]\r\n\r\n<strong>Output: </strong>5\r\n\r\n<strong>Explanation:</strong> As one shortest transformation is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,\r\nreturn its length 5.\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>\r\nbeginWord = &quot;hit&quot;\r\nendWord = &quot;cog&quot;\r\nwordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]\r\n\r\n<strong>Output:</strong>&nbsp;0\r\n\r\n<strong>Explanation:</strong>&nbsp;The endWord &quot;cog&quot; is not in wordList, therefore no possible<strong>&nbsp;</strong>transformation.\r\n</pre>\r\n\r\n<ul>\r\n</ul>\r\n",
    "tags": "Breadth-first Search",
    "difficulty": 2,
    "frontend_article_id": 127
},
{
    "frontend_question_id": 126,
    "article_live": false,
    "title": "Word Ladder II",
    "title_slug": "word-ladder-ii",
    "content": "<p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary&#39;s word list, find all shortest transformation sequence(s) from <em>beginWord</em> to <em>endWord</em>, such that:</p>\r\n\r\n<ol>\r\n\t<li>Only one letter can be changed at a time</li>\r\n\t<li>Each transformed word must exist in the word list. Note that <em>beginWord</em> is <em>not</em> a transformed word.</li>\r\n</ol>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>Return an empty list if there is no such transformation sequence.</li>\r\n\t<li>All words have the same length.</li>\r\n\t<li>All words contain only lowercase alphabetic characters.</li>\r\n\t<li>You may assume no duplicates in the word list.</li>\r\n\t<li>You may assume <em>beginWord</em> and <em>endWord</em> are non-empty and are not the same.</li>\r\n</ul>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>\r\nbeginWord = &quot;hit&quot;,\r\nendWord = &quot;cog&quot;,\r\nwordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]\r\n\r\n<strong>Output:</strong>\r\n[\r\n  [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],\r\n&nbsp; [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]\r\n]\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>\r\nbeginWord = &quot;hit&quot;\r\nendWord = &quot;cog&quot;\r\nwordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]\r\n\r\n<strong>Output: </strong>[]\r\n\r\n<strong>Explanation:</strong>&nbsp;The endWord &quot;cog&quot; is not in wordList, therefore no possible<strong>&nbsp;</strong>transformation.\r\n</pre>\r\n\r\n<ul>\r\n</ul>\r\n",
    "tags": "Array, String, Backtracking, Breadth-first Search",
    "difficulty": 3,
    "frontend_article_id": 126
},
{
    "frontend_question_id": 125,
    "article_live": false,
    "title": "Valid Palindrome",
    "title_slug": "valid-palindrome",
    "content": "<p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p>\r\n\r\n<p><strong>Note:</strong>&nbsp;For the purpose of this problem, we define empty string as valid palindrome.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> &quot;A man, a plan, a canal: Panama&quot;\r\n<strong>Output:</strong> true\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> &quot;race a car&quot;\r\n<strong>Output:</strong> false\r\n</pre>\r\n",
    "tags": "Two Pointers, String",
    "difficulty": 1,
    "frontend_article_id": 125
},
{
    "frontend_question_id": 124,
    "article_live": false,
    "title": "Binary Tree Maximum Path Sum",
    "title_slug": "binary-tree-maximum-path-sum",
    "content": "<p>Given a <strong>non-empty</strong> binary tree, find the maximum path sum.</p>\r\n\r\n<p>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain <strong>at least one node</strong> and does not need to go through the root.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [1,2,3]\r\n\r\n       <strong>1</strong>\r\n      <strong>/ \\</strong>\r\n     <strong>2</strong>   <strong>3</strong>\r\n\r\n<strong>Output:</strong> 6\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [-10,9,20,null,null,15,7]\r\n\r\n&nbsp;  -10\r\n&nbsp; &nbsp;/ \\\r\n&nbsp; 9 &nbsp;<strong>20</strong>\r\n&nbsp; &nbsp; <strong>/ &nbsp;\\</strong>\r\n&nbsp; &nbsp;<strong>15 &nbsp; 7</strong>\r\n\r\n<strong>Output:</strong> 42\r\n</pre>\r\n",
    "tags": "Tree, Depth-first Search",
    "difficulty": 3,
    "frontend_article_id": 124
},
{
    "frontend_question_id": 123,
    "article_live": false,
    "title": "Best Time to Buy and Sell Stock III",
    "title_slug": "best-time-to-buy-and-sell-stock-iii",
    "content": "<p>Say you have an array for which the <em>i</em><sup>th</sup> element is the price of a given stock on day <em>i</em>.</p>\r\n\r\n<p>Design an algorithm to find the maximum profit. You may complete at most <em>two</em> transactions.</p>\r\n\r\n<p><strong>Note:&nbsp;</strong>You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [3,3,5,0,0,3,1,4]\r\n<strong>Output:</strong> 6\r\n<strong>Explanation:</strong> Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\r\n&nbsp;            Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [1,2,3,4,5]\r\n<strong>Output:</strong> 4\r\n<strong>Explanation:</strong> Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\r\n&nbsp;            Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are\r\n&nbsp;            engaging multiple transactions at the same time. You must sell before buying again.\r\n</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [7,6,4,3,1]\r\n<strong>Output:</strong> 0\r\n<strong>Explanation:</strong> In this case, no transaction is done, i.e. max profit = 0.</pre>\r\n",
    "tags": "Array, Dynamic Programming",
    "difficulty": 3,
    "frontend_article_id": 123
},
{
    "frontend_question_id": 122,
    "article_live": true,
    "article_slug": "best-time-to-buy-and-sell-stock-ii",
    "title": "Best Time to Buy and Sell Stock II",
    "title_slug": "best-time-to-buy-and-sell-stock-ii",
    "content": "<p>Say you have an array for which the <em>i</em><sup>th</sup> element is the price of a given stock on day <em>i</em>.</p>\r\n\r\n<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).</p>\r\n\r\n<p><strong>Note:</strong> You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [7,1,5,3,6,4]\r\n<strong>Output:</strong> 7\r\n<strong>Explanation:</strong> Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\r\n&nbsp;            Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [1,2,3,4,5]\r\n<strong>Output:</strong> 4\r\n<strong>Explanation:</strong> Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\r\n&nbsp;            Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are\r\n&nbsp;            engaging multiple transactions at the same time. You must sell before buying again.\r\n</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [7,6,4,3,1]\r\n<strong>Output:</strong> 0\r\n<strong>Explanation:</strong> In this case, no transaction is done, i.e. max profit = 0.</pre>\r\n",
    "tags": "Array, Greedy",
    "difficulty": 1,
    "frontend_article_id": 122,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#summary\">Summary</a></li> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force\">Approach 1: Brute Force</a></li> \n      <li><a href=\"#approach-2-peak-valley-approach\">Approach 2: Peak Valley Approach</a></li> \n      <li><a href=\"#approach-3-simple-one-pass\">Approach 3: Simple One Pass</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"summary\">Summary</h2> \n  <p>We have to determine the maximum profit that can be obtained by making the transactions (no limit on the number of transactions done). For this we need to find out those sets of buying and selling prices which together lead to the maximization of profit.</p> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force\">Approach 1: Brute Force</h4> \n  <p>In this case, we simply calculate the profit corresponding to all the possible sets of transactions and find out the maximum profit out of them.</p> \n  <iframe src=\"https://leetcode.com/playground/DQfAGPiL/shared\" frameborder=\"0\" width=\"100%\" height=\"463\" name=\"DQfAGPiL\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^n)</script>. Recursive function is called <script type=\"math/tex; mode=display\">n^n</script> times.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Depth of recursion is <script type=\"math/tex; mode=display\">n</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-peak-valley-approach\">Approach 2: Peak Valley Approach</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Say the given array is:</p> \n  <p>[7, 1, 5, 3, 6, 4].</p> \n  <p>If we plot the numbers of the given array on a graph, we get:</p> \n  <p align=\"center\"><img alt=\"Profit Graph\" src=\"https://leetcode.com/media/original_images/122_maxprofit_1.PNG\" width=\"539px\"></p> \n  <p>If we analyze the graph, we notice that the points of interest are the consecutive valleys and peaks.</p> \n  <p>Mathematically speaking: <script type=\"math/tex; mode=display\">\nTotal Profit= \\sum_{i}(height(peak_i)-height(valley_i))\n</script> </p> \n  <p>The key point is we need to consider every peak immediately following a valley to maximize the profit. In case we skip one of the peaks (trying to obtain more profit), we will end up losing the profit over one of the transactions leading to an overall lesser profit.</p> \n  <p>For example, in the above case, if we skip <script type=\"math/tex; mode=display\">peak_i</script> and <script type=\"math/tex; mode=display\">valley_j</script> trying to obtain more profit by considering points with more difference in heights, the net profit obtained will always be lesser than the one obtained by including them, since <script type=\"math/tex; mode=display\">C</script> will always be lesser than <script type=\"math/tex; mode=display\">A+B</script>.</p> \n  <iframe src=\"https://leetcode.com/playground/Yrs8F9na/shared\" frameborder=\"0\" width=\"100%\" height=\"361\" name=\"Yrs8F9na\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Single pass.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant space required. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-simple-one-pass\">Approach 3: Simple One Pass</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>This solution follows the logic used in <a href=\"#approach-2-peak-valley-approach\">Approach 2</a> itself, but with only a slight variation. In this case, instead of looking for every peak following a valley, we can simply go on crawling over the slope and keep on adding the profit obtained from every consecutive transaction. In the end,we will be using the peaks and valleys effectively, but we need not track the costs corresponding to the peaks and valleys along with the maximum profit, but we can directly keep on adding the difference between the consecutive numbers of the array if the second number is larger than the first one, and at the total sum we obtain will be the maximum profit. This approach will simplify the solution. This can be made clearer by taking this example:</p> \n  <p>[1, 7, 2, 3, 6, 7, 6, 7]</p> \n  <p>The graph corresponding to this array is:</p> \n  <p align=\"center\"><img alt=\"Profit Graph\" src=\"https://leetcode.com/media/original_images/122_maxprofit_2.PNG\" width=\"539px\"></p> \n  <p>From the above graph, we can observe that the sum <script type=\"math/tex; mode=display\">A+B+C</script> is equal to the difference <script type=\"math/tex; mode=display\">D</script> corresponding to the difference between the heights of the consecutive peak and valley.</p> \n  <iframe src=\"https://leetcode.com/playground/ppWUGTaj/shared\" frameborder=\"0\" width=\"100%\" height=\"225\" name=\"ppWUGTaj\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Single pass.</p> </li> \n   <li> <p>Space complexity: <script type=\"math/tex; mode=display\">O(1)</script>. Constant space needed.</p> </li> \n  </ul> \n </div> \n</div>"
},
{
    "frontend_question_id": 121,
    "article_live": true,
    "article_slug": "best-time-to-buy-and-sell-stock",
    "title": "Best Time to Buy and Sell Stock",
    "title_slug": "best-time-to-buy-and-sell-stock",
    "content": "<p>Say you have an array for which the <em>i</em><sup>th</sup> element is the price of a given stock on day <em>i</em>.</p>\r\n\r\n<p>If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>\r\n\r\n<p>Note that you cannot sell a stock before you buy one.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [7,1,5,3,6,4]\r\n<strong>Output:</strong> 5\r\n<strong>Explanation:</strong> Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\r\n&nbsp;            Not 7-1 = 6, as selling price needs to be larger than buying price.\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [7,6,4,3,1]\r\n<strong>Output:</strong> 0\r\n<strong>Explanation:</strong> In this case, no transaction is done, i.e. max profit = 0.\r\n</pre>\r\n",
    "tags": "Array, Dynamic Programming",
    "difficulty": 1,
    "frontend_article_id": 121,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force\">Approach 1: Brute Force</a></li> \n      <li><a href=\"#approach-2-one-pass\">Approach 2: One Pass</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <p>We need to find out the maximum difference (which will be the maximum profit) between two numbers in the given array. Also, the second number (selling price) must be larger than the first one (buying price).</p> \n  <p>In formal terms, we need to find <script type=\"math/tex; mode=display\">\\max(prices[j] - prices[i])</script>, for every <script type=\"math/tex; mode=display\">i</script> and <script type=\"math/tex; mode=display\">j</script> such that <script type=\"math/tex; mode=display\">j > i</script>.</p> \n  <hr> \n  <h4 id=\"approach-1-brute-force\">Approach 1: Brute Force</h4> \n  <iframe src=\"https://leetcode.com/playground/enjmphvG/shared\" frameborder=\"0\" width=\"100%\" height=\"276\" name=\"enjmphvG\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^2)</script>. Loop runs <script type=\"math/tex; mode=display\">\\dfrac{n (n-1)}{2}</script> times.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Only two variables - <script type=\"math/tex; mode=display\">\\text{maxprofit}</script> and <script type=\"math/tex; mode=display\">\\text{profit}</script> are used. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-one-pass\">Approach 2: One Pass</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Say the given array is:</p> \n  <p>[7, 1, 5, 3, 6, 4]</p> \n  <p>If we plot the numbers of the given array on a graph, we get:</p> \n  <p><img alt=\"Profit Graph\" src=\"https://leetcode.com/media/original_images/121_profit_graph.png\"></p> \n  <p>The points of interest are the peaks and valleys in the given graph. We need to find the largest peak following the smallest valley. We can maintain two variables - minprice and maxprofit corresponding to the smallest valley and maximum profit (maximum difference between selling price and minprice) obtained so far respectively.</p> \n  <iframe src=\"https://leetcode.com/playground/G8wkXsyB/shared\" frameborder=\"0\" width=\"100%\" height=\"276\" name=\"G8wkXsyB\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Only a single pass is needed.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Only two variables are used.</p> </li> \n  </ul> \n </div> \n</div>"
},
{
    "frontend_question_id": 120,
    "article_live": false,
    "title": "Triangle",
    "title_slug": "triangle",
    "content": "<p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p>\r\n\r\n<p>For example, given the following triangle</p>\r\n\r\n<pre>\r\n[\r\n     [<strong>2</strong>],\r\n    [<strong>3</strong>,4],\r\n   [6,<strong>5</strong>,7],\r\n  [4,<strong>1</strong>,8,3]\r\n]\r\n</pre>\r\n\r\n<p>The minimum path sum from top to bottom is <code>11</code> (i.e., <strong>2</strong> + <strong>3</strong> + <strong>5</strong> + <strong>1</strong> = 11).</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<p>Bonus point if you are able to do this using only <em>O</em>(<em>n</em>) extra space, where <em>n</em> is the total number of rows in the triangle.</p>\r\n",
    "tags": "Array, Dynamic Programming",
    "difficulty": 2,
    "frontend_article_id": 120
},
{
    "frontend_question_id": 119,
    "article_live": false,
    "title": "Pascal's Triangle II",
    "title_slug": "pascals-triangle-ii",
    "content": "<p>Given a non-negative&nbsp;index <em>k</em>&nbsp;where <em>k</em> &le;&nbsp;33, return the <em>k</em><sup>th</sup>&nbsp;index row of the Pascal&#39;s triangle.</p>\r\n\r\n<p>Note that the row index starts from&nbsp;0.</p>\r\n\r\n<p><img alt=\"\" src=\"https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif\" /><br />\r\n<small>In Pascal&#39;s triangle, each number is the sum of the two numbers directly above it.</small></p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 3\r\n<strong>Output:</strong> [1,3,3,1]\r\n</pre>\r\n\r\n<p><strong>Follow up:</strong></p>\r\n\r\n<p>Could you optimize your algorithm to use only <em>O</em>(<em>k</em>) extra space?</p>\r\n",
    "tags": "Array",
    "difficulty": 1,
    "frontend_article_id": 119
},
{
    "frontend_question_id": 118,
    "article_live": true,
    "article_slug": "pascals-triangle",
    "title": "Pascal's Triangle",
    "title_slug": "pascals-triangle",
    "content": "<p>Given a non-negative integer&nbsp;<em>numRows</em>, generate the first <em>numRows</em> of Pascal&#39;s triangle.</p>\r\n\r\n<p><img alt=\"\" src=\"https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif\" style=\"height:240px; width:260px\" /><br />\r\n<small>In Pascal&#39;s triangle, each number is the sum of the two numbers directly above it.</small></p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 5\r\n<strong>Output:</strong>\r\n[\r\n     [1],\r\n    [1,1],\r\n   [1,2,1],\r\n  [1,3,3,1],\r\n [1,4,6,4,1]\r\n]\r\n</pre>\r\n",
    "tags": "Array",
    "difficulty": 1,
    "frontend_article_id": 118,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-dynamic-programming\">Approach 1: Dynamic Programming</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-dynamic-programming\">Approach 1: Dynamic Programming</h4> \n  <p><strong>Intuition</strong></p> \n  <p>If we have the a row of Pascal's triangle, we can easily compute the next row by each pair of adjacent values.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Although the algorithm is very simple, the iterative approach to constructing Pascal's triangle can be classified as dynamic programming because we construct each row based on the previous row.</p> \n  <p>First, we generate the overall <code>triangle</code> list, which will store each row as a sublist. Then, we check for the special case of <script type=\"math/tex; mode=display\">0</script>, as we would otherwise return <script type=\"math/tex; mode=display\">[1]</script>. If <script type=\"math/tex; mode=display\">numRows > 0</script>, then we initialize <code>triangle</code> with <script type=\"math/tex; mode=display\">[1]</script> as its first row, and proceed to fill the rows as follows:</p> \n  <p>!?!../Documents/118_Pascals_Triangle.json:1280,720!?!</p> \n  <iframe src=\"https://leetcode.com/playground/idrxbCSN/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"idrxbCSN\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(numRows^2)</script> </p> <p>Although updating each value of <code>triangle</code> happens in constant time, it is performed <script type=\"math/tex; mode=display\">O(numRows^2)</script> times. To see why, consider how many overall loop iterations there are. The outer loop obviously runs <script type=\"math/tex; mode=display\">numRows</script> times, but for each iteration of the outer loop, the inner loop runs <script type=\"math/tex; mode=display\">rowNum</script> times. Therefore, the overall number of <code>triangle</code> updates that occur is <script type=\"math/tex; mode=display\">1 + 2 + 3 + \\ldots + numRows</script>, which, according to Gauss' formula, is</p> <p> <script type=\"math/tex; mode=display\">\n\\begin{aligned}\n    \\frac{numRows(numRows+1)}{2} &= \\frac{numRows^2 + numRows}{2} \\\\\n    &= \\frac{numRows^2}{2} + \\frac{numRows}{2} \\\\\n    &= O(numRows^2)\n\\end{aligned}\n</script> </p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(numRows^2)</script> </p> <p>Because we need to store each number that we update in <code>triangle</code>, the space requirement is the same as the time complexity.</p> </li> \n  </ul> \n </div> \n</div>"
},
{
    "frontend_question_id": 117,
    "article_live": false,
    "title": "Populating Next Right Pointers in Each Node II",
    "title_slug": "populating-next-right-pointers-in-each-node-ii",
    "content": "<p>Given a binary tree</p>\r\n\r\n<pre>\r\nstruct TreeLinkNode {\r\n  TreeLinkNode *left;\r\n  TreeLinkNode *right;\r\n  TreeLinkNode *next;\r\n}\r\n</pre>\r\n\r\n<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>\r\n\r\n<p>Initially, all next pointers are set to <code>NULL</code>.</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>You may only use constant extra space.</li>\r\n\t<li>Recursive approach is fine, implicit stack space does not count as extra space for this problem.</li>\r\n</ul>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<p>Given the following binary tree,</p>\r\n\r\n<pre>\r\n     1\r\n   /  \\\r\n  2    3\r\n / \\    \\\r\n4   5    7\r\n</pre>\r\n\r\n<p>After calling your function, the tree should look like:</p>\r\n\r\n<pre>\r\n     1 -&gt; NULL\r\n   /  \\\r\n  2 -&gt; 3 -&gt; NULL\r\n / \\    \\\r\n4-&gt; 5 -&gt; 7 -&gt; NULL\r\n</pre>\r\n",
    "tags": "Tree, Depth-first Search",
    "difficulty": 2,
    "frontend_article_id": 117
},
{
    "frontend_question_id": 116,
    "article_live": false,
    "title": "Populating Next Right Pointers in Each Node",
    "title_slug": "populating-next-right-pointers-in-each-node",
    "content": "<p>Given a binary tree</p>\r\n\r\n<pre>\r\nstruct TreeLinkNode {\r\n  TreeLinkNode *left;\r\n  TreeLinkNode *right;\r\n  TreeLinkNode *next;\r\n}\r\n</pre>\r\n\r\n<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>\r\n\r\n<p>Initially, all next pointers are set to <code>NULL</code>.</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>You may only use constant extra space.</li>\r\n\t<li>Recursive approach is fine, implicit stack space does not count as extra space for this problem.</li>\r\n\t<li>You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).</li>\r\n</ul>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<p>Given the following perfect binary tree,</p>\r\n\r\n<pre>\r\n     1\r\n   /  \\\r\n  2    3\r\n / \\  / \\\r\n4  5  6  7\r\n</pre>\r\n\r\n<p>After calling your function, the tree should look like:</p>\r\n\r\n<pre>\r\n     1 -&gt; NULL\r\n   /  \\\r\n  2 -&gt; 3 -&gt; NULL\r\n / \\  / \\\r\n4-&gt;5-&gt;6-&gt;7 -&gt; NULL\r\n</pre>\r\n",
    "tags": "Tree, Depth-first Search",
    "difficulty": 2,
    "frontend_article_id": 116
},
{
    "frontend_question_id": 115,
    "article_live": false,
    "title": "Distinct Subsequences",
    "title_slug": "distinct-subsequences",
    "content": "<p>Given a string <strong>S</strong> and a string <strong>T</strong>, count the number of distinct subsequences of <strong>S</strong> which equals <strong>T</strong>.</p>\r\n\r\n<p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, <code>&quot;ACE&quot;</code> is a subsequence of <code>&quot;ABCDE&quot;</code> while <code>&quot;AEC&quot;</code> is not).</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>S = <code>&quot;rabbbit&quot;</code>, T = <code>&quot;rabbit&quot;\r\n<strong>Output:</strong>&nbsp;3\r\n</code><strong>Explanation:\r\n</strong>\r\nAs shown below, there are 3 ways you can generate &quot;rabbit&quot; from S.\r\n(The caret symbol ^ means the chosen letters)\r\n\r\n<code>rabbbit</code>\r\n^^^^ ^^\r\n<code>rabbbit</code>\r\n^^ ^^^^\r\n<code>rabbbit</code>\r\n^^^ ^^^\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>S = <code>&quot;babgbag&quot;</code>, T = <code>&quot;bag&quot;\r\n<strong>Output:</strong>&nbsp;5\r\n</code><strong>Explanation:\r\n</strong>\r\nAs shown below, there are 5 ways you can generate &quot;bag&quot; from S.\r\n(The caret symbol ^ means the chosen letters)\r\n\r\n<code>babgbag</code>\r\n^^ ^\r\n<code>babgbag</code>\r\n^^    ^\r\n<code>babgbag</code>\r\n^    ^^\r\n<code>babgbag</code>\r\n  ^  ^^\r\n<code>babgbag</code>\r\n    ^^^\r\n</pre>\r\n",
    "tags": "String, Dynamic Programming",
    "difficulty": 3,
    "frontend_article_id": 115
},
{
    "frontend_question_id": 114,
    "article_live": false,
    "title": "Flatten Binary Tree to Linked List",
    "title_slug": "flatten-binary-tree-to-linked-list",
    "content": "<p>Given a binary tree, flatten it to a linked list in-place.</p>\r\n\r\n<p>For example, given the following tree:</p>\r\n\r\n<pre>\r\n    1\r\n   / \\\r\n  2   5\r\n / \\   \\\r\n3   4   6\r\n</pre>\r\n\r\n<p>The flattened tree should look like:</p>\r\n\r\n<pre>\r\n1\r\n \\\r\n  2\r\n   \\\r\n    3\r\n     \\\r\n      4\r\n       \\\r\n        5\r\n         \\\r\n          6\r\n</pre>\r\n",
    "tags": "Tree, Depth-first Search",
    "difficulty": 2,
    "frontend_article_id": 114
},
{
    "frontend_question_id": 113,
    "article_live": false,
    "title": "Path Sum II",
    "title_slug": "path-sum-ii",
    "content": "<p>Given a binary tree and a sum, find all root-to-leaf paths where each path&#39;s sum equals the given sum.</p>\r\n\r\n<p><strong>Note:</strong>&nbsp;A leaf is a node with no children.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<p>Given the below binary tree and <code>sum = 22</code>,</p>\r\n\r\n<pre>\r\n      <strong>5</strong>\r\n     <strong>/ \\</strong>\r\n    <strong>4   8</strong>\r\n   <strong>/</strong>   / <strong>\\</strong>\r\n  <strong>11</strong>  13  <strong>4</strong>\r\n /  <strong>\\</strong>    <strong>/</strong> \\\r\n7    <strong>2</strong>  <strong>5</strong>   1\r\n</pre>\r\n\r\n<p>Return:</p>\r\n\r\n<pre>\r\n[\r\n   [5,4,11,2],\r\n   [5,8,4,5]\r\n]\r\n</pre>\r\n",
    "tags": "Tree, Depth-first Search",
    "difficulty": 2,
    "frontend_article_id": 113
},
{
    "frontend_question_id": 112,
    "article_live": false,
    "title": "Path Sum",
    "title_slug": "path-sum",
    "content": "<p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p>\r\n\r\n<p><strong>Note:</strong>&nbsp;A leaf is a node with no children.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<p>Given the below binary tree and <code>sum = 22</code>,</p>\r\n\r\n<pre>\r\n      <strong>5</strong>\r\n     <strong>/</strong> \\\r\n    <strong>4</strong>   8\r\n   <strong>/</strong>   / \\\r\n  <strong>11</strong>  13  4\r\n /  <strong>\\</strong>      \\\r\n7    <strong>2</strong>      1\r\n</pre>\r\n\r\n<p>return true, as there exist a root-to-leaf path <code>5-&gt;4-&gt;11-&gt;2</code> which sum is 22.</p>\r\n",
    "tags": "Tree, Depth-first Search",
    "difficulty": 1,
    "frontend_article_id": 112
},
{
    "frontend_question_id": 111,
    "article_live": true,
    "article_slug": "minimum-depth-of-binary-tree",
    "title": "Minimum Depth of Binary Tree",
    "title_slug": "minimum-depth-of-binary-tree",
    "content": "<p>Given a binary tree, find its minimum depth.</p>\r\n\r\n<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>\r\n\r\n<p><strong>Note:</strong>&nbsp;A leaf is a node with no children.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<p>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>\r\n\r\n<pre>\r\n    3\r\n   / \\\r\n  9  20\r\n    /  \\\r\n   15   7</pre>\r\n\r\n<p>return its minimum&nbsp;depth = 2.</p>\r\n",
    "tags": "Tree, Depth-first Search, Breadth-first Search",
    "difficulty": 1,
    "frontend_article_id": 111,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-recursion\">Approach 1: Recursion</a></li> \n      <li><a href=\"#approach-2-dfs-iteration\">Approach 2: DFS Iteration</a></li> \n      <li><a href=\"#approach-3-bfs-iteration\">Approach 3: BFS Iteration</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <p><strong>Tree definition</strong></p> \n  <p>First of all, here is the definition of the <code>TreeNode</code> which we would use.</p> \n  <iframe src=\"https://leetcode.com/playground/42eFhXEs/shared\" frameborder=\"0\" width=\"100%\" height=\"225\" name=\"42eFhXEs\"></iframe> \n  <p><br> <br></p> \n  <hr> \n  <h4 id=\"approach-1-recursion\">Approach 1: Recursion</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>The intuitive approach is to solve the problem by recursion. Here we demonstrate an example with the DFS (Depth First Search) strategy. </p> \n  <iframe src=\"https://leetcode.com/playground/RuBTnmW3/shared\" frameborder=\"0\" width=\"100%\" height=\"412\" name=\"RuBTnmW3\"></iframe> \n  <p><strong>Complexity analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : we visit each node exactly once, thus the time complexity is <script type=\"math/tex; mode=display\">\\mathcal{O}(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of nodes.</p> </li> \n   <li> <p>Space complexity : in the worst case, the tree is completely unbalanced, <em>e.g.</em> each node has only one child node, the recursion call would occur <script type=\"math/tex; mode=display\">N</script> times (the height of the tree), therefore the storage to keep the call stack would be <script type=\"math/tex; mode=display\">\\mathcal{O}(N)</script>. But in the best case (the tree is completely balanced), the height of the tree would be <script type=\"math/tex; mode=display\">\\log(N)</script>. Therefore, the space complexity in this case would be <script type=\"math/tex; mode=display\">\\mathcal{O}(\\log(N))</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-dfs-iteration\">Approach 2: DFS Iteration</h4> \n  <p>We could also convert the above recursion into iteration, with the help of stack.</p> \n  <blockquote> \n   <p>The idea is to visit each leaf with the DFS strategy, while updating the minimum depth when we reach the leaf node.</p> \n  </blockquote> \n  <p>So we start from a stack which contains the root node and the corresponding depth which is <code>1</code>. Then we proceed to the iterations: pop the current node out of the stack and push the child nodes. The minimum depth is updated at each leaf node. </p> \n  <iframe src=\"https://leetcode.com/playground/qGDnLgYs/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"qGDnLgYs\"></iframe> \n  <p><strong>Complexity analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : each node is visited exactly once and time complexity is <script type=\"math/tex; mode=display\">\\mathcal{O}(N)</script>.</p> </li> \n   <li> <p>Space complexity : in the worst case we could keep up to the entire tree, that results in <script type=\"math/tex; mode=display\">\\mathcal{O}(N)</script> space complexity. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-bfs-iteration\">Approach 3: BFS Iteration</h4> \n  <p>The drawback of the DFS approach in this case is that all nodes should be visited to ensure that the minimum depth would be found. Therefore, this results in a <script type=\"math/tex; mode=display\">\\mathcal{O}(N)</script> complexity. One way to optimize the complexity is to use the BFS strategy. We iterate the tree level by level, and the first leaf we reach corresponds to the minimum depth. As a result, we do not need to iterate all nodes.</p> \n  <iframe src=\"https://leetcode.com/playground/C5HyFNMJ/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"C5HyFNMJ\"></iframe> \n  <p><strong>Complexity analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : in the worst case for a balanced tree we need to visit all nodes level by level up to the tree height, that excludes the bottom level only. This way we visit <script type=\"math/tex; mode=display\">N/2</script> nodes, and thus the time complexity is <script type=\"math/tex; mode=display\">\\mathcal{O}(N)</script>.</p> </li> \n   <li> <p>Space complexity : is the same as time complexity here <script type=\"math/tex; mode=display\">\\mathcal{O}(N)</script>.</p> </li> \n  </ul> \n  <p>Analysis written by @<a href=\"https://leetcode.com/liaison/\">liaison</a> and @<a href=\"https://leetcode.com/andvary/\">andvary</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 110,
    "article_live": false,
    "title": "Balanced Binary Tree",
    "title_slug": "balanced-binary-tree",
    "content": "<p>Given a binary tree, determine if it is height-balanced.</p>\r\n\r\n<p>For this problem, a height-balanced binary tree is defined as:</p>\r\n\r\n<blockquote>\r\n<p>a binary tree in which the depth of the two subtrees of <em>every</em> node never differ by more than 1.</p>\r\n</blockquote>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<p>Given the following tree <code>[3,9,20,null,null,15,7]</code>:</p>\r\n\r\n<pre>\r\n    3\r\n   / \\\r\n  9  20\r\n    /  \\\r\n   15   7</pre>\r\n\r\n<p>Return true.<br />\r\n<br />\r\n<strong>Example 2:</strong></p>\r\n\r\n<p>Given the following tree <code>[1,2,2,3,3,null,null,4,4]</code>:</p>\r\n\r\n<pre>\r\n       1\r\n      / \\\r\n     2   2\r\n    / \\\r\n   3   3\r\n  / \\\r\n 4   4\r\n</pre>\r\n\r\n<p>Return false.</p>\r\n",
    "tags": "Tree, Depth-first Search",
    "difficulty": 1,
    "frontend_article_id": 110
},
{
    "frontend_question_id": 109,
    "article_live": false,
    "title": "Convert Sorted List to Binary Search Tree",
    "title_slug": "convert-sorted-list-to-binary-search-tree",
    "content": "<p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</p>\r\n\r\n<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of <em>every</em> node never differ by more than 1.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\nGiven the sorted linked list: [-10,-3,0,5,9],\r\n\r\nOne possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:\r\n\r\n      0\r\n     / \\\r\n   -3   9\r\n   /   /\r\n -10  5\r\n</pre>\r\n",
    "tags": "Linked List, Depth-first Search",
    "difficulty": 2,
    "frontend_article_id": 109
},
{
    "frontend_question_id": 108,
    "article_live": false,
    "title": "Convert Sorted Array to Binary Search Tree",
    "title_slug": "convert-sorted-array-to-binary-search-tree",
    "content": "<p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p>\r\n\r\n<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of <em>every</em> node never differ by more than 1.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\nGiven the sorted array: [-10,-3,0,5,9],\r\n\r\nOne possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:\r\n\r\n      0\r\n     / \\\r\n   -3   9\r\n   /   /\r\n -10  5\r\n</pre>\r\n",
    "tags": "Tree, Depth-first Search",
    "difficulty": 1,
    "frontend_article_id": 108
},
{
    "frontend_question_id": 107,
    "article_live": false,
    "title": "Binary Tree Level Order Traversal II",
    "title_slug": "binary-tree-level-order-traversal-ii",
    "content": "<p>Given a binary tree, return the <i>bottom-up level order</i> traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).</p>\r\n\r\n<p>\r\nFor example:<br />\r\nGiven binary tree <code>[3,9,20,null,null,15,7]</code>,<br />\r\n<pre>\r\n    3\r\n   / \\\r\n  9  20\r\n    /  \\\r\n   15   7\r\n</pre>\r\n</p>\r\n<p>\r\nreturn its bottom-up level order traversal as:<br />\r\n<pre>\r\n[\r\n  [15,7],\r\n  [9,20],\r\n  [3]\r\n]\r\n</pre>\r\n</p>",
    "tags": "Tree, Breadth-first Search",
    "difficulty": 1,
    "frontend_article_id": 107
},
{
    "frontend_question_id": 106,
    "article_live": false,
    "title": "Construct Binary Tree from Inorder and Postorder Traversal",
    "title_slug": "construct-binary-tree-from-inorder-and-postorder-traversal",
    "content": "<p>Given inorder and postorder traversal of a tree, construct the binary tree.</p>\r\n\r\n<p><strong>Note:</strong><br />\r\nYou may assume that duplicates do not exist in the tree.</p>\r\n\r\n<p>For example, given</p>\r\n\r\n<pre>\r\ninorder =&nbsp;[9,3,15,20,7]\r\npostorder = [9,15,7,20,3]</pre>\r\n\r\n<p>Return the following binary tree:</p>\r\n\r\n<pre>\r\n    3\r\n   / \\\r\n  9  20\r\n    /  \\\r\n   15   7\r\n</pre>\r\n",
    "tags": "Array, Tree, Depth-first Search",
    "difficulty": 2,
    "frontend_article_id": 106
},
{
    "frontend_question_id": 105,
    "article_live": false,
    "title": "Construct Binary Tree from Preorder and Inorder Traversal",
    "title_slug": "construct-binary-tree-from-preorder-and-inorder-traversal",
    "content": "<p>Given preorder and inorder traversal of a tree, construct the binary tree.</p>\r\n\r\n<p><strong>Note:</strong><br />\r\nYou may assume that duplicates do not exist in the tree.</p>\r\n\r\n<p>For example, given</p>\r\n\r\n<pre>\r\npreorder =&nbsp;[3,9,20,15,7]\r\ninorder = [9,3,15,20,7]</pre>\r\n\r\n<p>Return the following binary tree:</p>\r\n\r\n<pre>\r\n    3\r\n   / \\\r\n  9  20\r\n    /  \\\r\n   15   7</pre>\r\n",
    "tags": "Array, Tree, Depth-first Search",
    "difficulty": 2,
    "frontend_article_id": 105
},
{
    "frontend_question_id": 104,
    "article_live": true,
    "article_slug": "maximum-depth-of-binary-tree",
    "title": "Maximum Depth of Binary Tree",
    "title_slug": "maximum-depth-of-binary-tree",
    "content": "<p>Given a binary tree, find its maximum depth.</p>\r\n\r\n<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>\r\n\r\n<p><strong>Note:</strong>&nbsp;A leaf is a node with no children.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<p>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>\r\n\r\n<pre>\r\n    3\r\n   / \\\r\n  9  20\r\n    /  \\\r\n   15   7</pre>\r\n\r\n<p>return its depth = 3.</p>\r\n",
    "tags": "Tree, Depth-first Search",
    "difficulty": 1,
    "frontend_article_id": 104,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-recursion\">Approach 1: Recursion</a></li> \n      <li><a href=\"#approach-2-iteration\">Approach 2: Iteration</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <p><strong>Tree definition</strong></p> \n  <p>First of all, here is the definition of the <code>TreeNode</code> which we would use.</p> \n  <iframe src=\"https://leetcode.com/playground/86utoL8n/shared\" frameborder=\"0\" width=\"100%\" height=\"225\" name=\"86utoL8n\"></iframe> \n  <p><br> <br></p> \n  <hr> \n  <h4 id=\"approach-1-recursion\">Approach 1: Recursion</h4> \n  <p><strong>Algorithm</strong></p> \n  <!--![LIS](../Figures/104/104_tr.gif)--> \n  <p>!?!../Documents/104_LIS.json:1000,500!?!</p> \n  <p>The intuitive approach is to solve the problem by recursion. Here we demonstrate an example with the DFS (Depth First Search) strategy. </p> \n  <iframe src=\"https://leetcode.com/playground/WKL7hjpZ/shared\" frameborder=\"0\" width=\"100%\" height=\"259\" name=\"WKL7hjpZ\"></iframe> \n  <p><strong>Complexity analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : we visit each node exactly once, thus the time complexity is <script type=\"math/tex; mode=display\">\\mathcal{O}(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the number of nodes.</p> </li> \n   <li> <p>Space complexity : in the worst case, the tree is completely unbalanced, <em>e.g.</em> each node has only left child node, the recursion call would occur <script type=\"math/tex; mode=display\">N</script> times (the height of the tree), therefore the storage to keep the call stack would be <script type=\"math/tex; mode=display\">\\mathcal{O}(N)</script>. But in the best case (the tree is completely balanced), the height of the tree would be <script type=\"math/tex; mode=display\">\\log(N)</script>. Therefore, the space complexity in this case would be <script type=\"math/tex; mode=display\">\\mathcal{O}(\\log(N))</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-iteration\">Approach 2: Iteration</h4> \n  <p>We could also convert the above recursion into iteration, with the help of stack.</p> \n  <blockquote> \n   <p>The idea is to visit each node with the DFS strategy, while updating the max depth at each visit.</p> \n  </blockquote> \n  <p>So we start from a stack which contains the root node and the corresponding depth which is <code>1</code>. Then we proceed to the iterations: pop the current node out of the stack and push the child nodes. The depth is updated at each step. </p> \n  <iframe src=\"https://leetcode.com/playground/JimDbcoc/shared\" frameborder=\"0\" width=\"100%\" height=\"463\" name=\"JimDbcoc\"></iframe> \n  <p><strong>Complexity analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">\\mathcal{O}(N)</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">\\mathcal{O}(N)</script>.</p> </li> \n  </ul> \n  <p>Analysis written by @<a href=\"https://leetcode.com/liaison/\">liaison</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 103,
    "article_live": false,
    "title": "Binary Tree Zigzag Level Order Traversal",
    "title_slug": "binary-tree-zigzag-level-order-traversal",
    "content": "<p>Given a binary tree, return the <i>zigzag level order</i> traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).</p>\r\n\r\n<p>\r\nFor example:<br />\r\nGiven binary tree <code>[3,9,20,null,null,15,7]</code>,<br />\r\n<pre>\r\n    3\r\n   / \\\r\n  9  20\r\n    /  \\\r\n   15   7\r\n</pre>\r\n</p>\r\n<p>\r\nreturn its zigzag level order traversal as:<br />\r\n<pre>\r\n[\r\n  [3],\r\n  [20,9],\r\n  [15,7]\r\n]\r\n</pre>\r\n</p>",
    "tags": "Stack, Tree, Breadth-first Search",
    "difficulty": 2,
    "frontend_article_id": 103
},
{
    "frontend_question_id": 102,
    "article_live": false,
    "title": "Binary Tree Level Order Traversal",
    "title_slug": "binary-tree-level-order-traversal",
    "content": "<p>Given a binary tree, return the <i>level order</i> traversal of its nodes' values. (ie, from left to right, level by level).</p>\r\n\r\n<p>\r\nFor example:<br />\r\nGiven binary tree <code>[3,9,20,null,null,15,7]</code>,<br />\r\n<pre>\r\n    3\r\n   / \\\r\n  9  20\r\n    /  \\\r\n   15   7\r\n</pre>\r\n</p>\r\n<p>\r\nreturn its level order traversal as:<br />\r\n<pre>\r\n[\r\n  [3],\r\n  [9,20],\r\n  [15,7]\r\n]\r\n</pre>\r\n</p>",
    "tags": "Tree, Breadth-first Search",
    "difficulty": 2,
    "frontend_article_id": 102
},
{
    "frontend_question_id": 101,
    "article_live": true,
    "article_slug": "symmetric-tree",
    "title": "Symmetric Tree",
    "title_slug": "symmetric-tree",
    "content": "<p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>\r\n\r\n<p>\r\nFor example, this binary tree <code>[1,2,2,3,4,4,3]</code> is symmetric:\r\n<pre>\r\n    1\r\n   / \\\r\n  2   2\r\n / \\ / \\\r\n3  4 4  3\r\n</pre>\r\n</p>\r\n<p>\r\nBut the following <code>[1,2,2,null,3,null,3]</code>  is not:<br />\r\n<pre>\r\n    1\r\n   / \\\r\n  2   2\r\n   \\   \\\r\n   3    3\r\n</pre>\r\n</p>\r\n\r\n<p>\r\n<b>Note:</b><br />\r\nBonus points if you could solve it both recursively and iteratively.\r\n</p>",
    "tags": "Tree, Depth-first Search, Breadth-first Search",
    "difficulty": 1,
    "frontend_article_id": 101,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-recursive\">Approach 1: Recursive</h4> \n  <p>A tree is symmetric if the left subtree is a mirror reflection of the right subtree.</p> \n  <p align=\"center\"><img alt=\"Push an element in stack\" src=\"https://leetcode.com/media/original_images/101_Symmetric.png\" width=\"200px\"></p> \n  <p>Therefore, the question is: when are two trees a mirror reflection of each other?</p> \n  <p>Two trees are a mirror reflection of each other if:</p> \n  <ol> \n   <li>Their two roots have the same value.</li> \n   <li>The right subtree of each tree is a mirror reflection of the left subtree of the other tree.</li> \n  </ol> \n  <p align=\"center\"><img alt=\"Push an element in stack\" src=\"https://leetcode.com/media/original_images/101_Symmetric_Mirror.png\" width=\"400px\"></p> \n  <p>This is like a person looking at a mirror. The reflection in the mirror has the same head, but the reflection's right arm corresponds to the actual person's left arm, and vice versa.</p> \n  <p>The explanation above translates naturally to a recursive function as follows.</p> \n  <iframe src=\"https://leetcode.com/playground/bQ9ZjXvv/shared\" frameborder=\"0\" width=\"100%\" height=\"242\" name=\"bQ9ZjXvv\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Because we traverse the entire input tree once, the total run time is <script type=\"math/tex; mode=display\">O(n)</script>, where <script type=\"math/tex; mode=display\">n</script> is the total number of nodes in the tree.</p> </li> \n   <li> <p>Space complexity : The number of recursive calls is bound by the height of the tree. In the worst case, the tree is linear and the height is in <script type=\"math/tex; mode=display\">O(n)</script>. Therefore, space complexity due to recursive calls on the stack is <script type=\"math/tex; mode=display\">O(n)</script> in the worst case. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-iterative\">Approach 2: Iterative</h4> \n  <p>Instead of recursion, we can also use iteration with the aid of a queue. Each two consecutive nodes in the queue should be equal, and their subtrees a mirror of each other. Initially, the queue contains <code>root</code> and <code>root</code>. Then the algorithm works similarly to BFS, with some key differences. Each time, two nodes are extracted and their values compared. Then, the right and left children of the two nodes are inserted in the queue in opposite order. The algorithm is done when either the queue is empty, or we detect that the tree is not symmetric (i.e. we pull out two consecutive nodes from the queue that are unequal).</p> \n  <iframe src=\"https://leetcode.com/playground/n5mXkUjQ/shared\" frameborder=\"0\" width=\"100%\" height=\"344\" name=\"n5mXkUjQ\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Because we traverse the entire input tree once, the total run time is <script type=\"math/tex; mode=display\">O(n)</script>, where <script type=\"math/tex; mode=display\">n</script> is the total number of nodes in the tree.</p> </li> \n   <li> <p>Space complexity : There is additional space required for the search queue. In the worst case, we have to insert <script type=\"math/tex; mode=display\">O(n)</script> nodes in the queue. Therefore, space complexity is <script type=\"math/tex; mode=display\">O(n)</script>.</p> </li> \n  </ul> \n </div> \n</div>"
},
{
    "frontend_question_id": 100,
    "article_live": false,
    "title": "Same Tree",
    "title_slug": "same-tree",
    "content": "<p>Given two binary trees, write a function to check if they are the same or not.</p>\r\n\r\n<p>Two binary trees are considered the same if they are structurally identical and the nodes have the same value.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>     1         1\r\n          / \\       / \\\r\n         2   3     2   3\r\n\r\n        [1,2,3],   [1,2,3]\r\n\r\n<strong>Output:</strong> true\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>     1         1\r\n          /           \\\r\n         2             2\r\n\r\n        [1,2],     [1,null,2]\r\n\r\n<strong>Output:</strong> false\r\n</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>     1         1\r\n          / \\       / \\\r\n         2   1     1   2\r\n\r\n        [1,2,1],   [1,1,2]\r\n\r\n<strong>Output:</strong> false\r\n</pre>\r\n",
    "tags": "Tree, Depth-first Search",
    "difficulty": 1,
    "frontend_article_id": 100
},
{
    "frontend_question_id": 99,
    "article_live": false,
    "title": "Recover Binary Search Tree",
    "title_slug": "recover-binary-search-tree",
    "content": "<p>Two elements of a binary search tree (BST) are swapped by mistake.</p>\r\n\r\n<p>Recover the tree without changing its structure.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [1,3,null,null,2]\r\n\r\n&nbsp;  1\r\n&nbsp; /\r\n&nbsp;3\r\n&nbsp; \\\r\n&nbsp;  2\r\n\r\n<strong>Output:</strong> [3,1,null,null,2]\r\n\r\n&nbsp;  3\r\n&nbsp; /\r\n&nbsp;1\r\n&nbsp; \\\r\n&nbsp;  2\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [3,1,4,null,null,2]\r\n\r\n  3\r\n / \\\r\n1   4\r\n&nbsp;  /\r\n&nbsp; 2\r\n\r\n<strong>Output:</strong> [2,1,4,null,null,3]\r\n\r\n  2\r\n / \\\r\n1   4\r\n&nbsp;  /\r\n &nbsp;3\r\n</pre>\r\n\r\n<p><strong>Follow up:</strong></p>\r\n\r\n<ul>\r\n\t<li>A solution using O(<em>n</em>) space is pretty straight forward.</li>\r\n\t<li>Could you devise a constant space solution?</li>\r\n</ul>\r\n",
    "tags": "Tree, Depth-first Search",
    "difficulty": 3,
    "frontend_article_id": 99
},
{
    "frontend_question_id": 98,
    "article_live": false,
    "title": "Validate Binary Search Tree",
    "title_slug": "validate-binary-search-tree",
    "content": "<p>Given a binary tree, determine if it is a valid binary search tree (BST).</p>\r\n\r\n<p>Assume a BST is defined as follows:</p>\r\n\r\n<ul>\r\n\t<li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node&#39;s key.</li>\r\n\t<li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node&#39;s key.</li>\r\n\t<li>Both the left and right subtrees must also be binary search trees.</li>\r\n</ul>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>\r\n    2\r\n   / \\\r\n  1   3\r\n<strong>Output:</strong> true\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n    5\r\n   / \\\r\n  1   4\r\n&nbsp;    / \\\r\n&nbsp;   3   6\r\n<strong>Output:</strong> false\r\n<strong>Explanation:</strong> The input is: [5,1,4,null,null,3,6]. The root node&#39;s value\r\n&nbsp;            is 5 but its right child&#39;s value is 4.\r\n</pre>\r\n",
    "tags": "Tree, Depth-first Search",
    "difficulty": 2,
    "frontend_article_id": 98
},
{
    "frontend_question_id": 97,
    "article_live": true,
    "article_slug": "interleaving-strings",
    "title": "Interleaving String",
    "title_slug": "interleaving-string",
    "content": "<p>Given <em>s1</em>, <em>s2</em>, <em>s3</em>, find whether <em>s3</em> is formed by the interleaving of <em>s1</em> and <em>s2</em>.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, <em>s3</em> = &quot;aadbbcbcac&quot;\r\n<strong>Output:</strong> true\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, <em>s3</em> = &quot;aadbbbaccc&quot;\r\n<strong>Output:</strong> false\r\n</pre>\r\n",
    "tags": "String, Dynamic Programming",
    "difficulty": 3,
    "frontend_article_id": 97,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#summary\">Summary</a></li> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force\">Approach 1: Brute Force</a></li> \n      <li><a href=\"#approach-2-recursion-with-memoization\">Approach 2: Recursion with memoization</a></li> \n      <li><a href=\"#approach-3-using-2d-dynamic-programming\">Approach 3: Using 2D Dynamic Programming</a></li> \n      <li><a href=\"#approach-4-using-1d-dynamic-programming\">Approach 4: Using 1D Dynamic Programming</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"summary\">Summary</h2> \n  <p>We need to determine whether a given string can be formed by interleaving the other two strings.</p> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force\">Approach 1: Brute Force</h4> \n  <p>The most basic idea is to find every string possible by all interleavings of the two given strings <script type=\"math/tex; mode=display\">s1</script> and <script type=\"math/tex; mode=display\">s2</script>. In order to implement this method, we are using recursion. We start by taking the current character of the first string <script type=\"math/tex; mode=display\">s1</script> and then appending all possible interleavings of the remaining portion of the first string <script type=\"math/tex; mode=display\">s1</script> and the second string <script type=\"math/tex; mode=display\">s2</script> and comparing each result formed with the required interleaved string <script type=\"math/tex; mode=display\">s3</script>. Similarly, we choose one character from the second string <script type=\"math/tex; mode=display\">s2</script> and form all the interleavings with the remaining portion of <script type=\"math/tex; mode=display\">s2</script> and <script type=\"math/tex; mode=display\">s1</script> to check if the required string <script type=\"math/tex; mode=display\">s1</script> can be formed.</p> \n  <p>For implementing the recursive function, we make the function call recursively as <script type=\"math/tex; mode=display\">is\\_Interleave(s1,i+1,s2,j,res+s1.charAt(i),s3)</script>, in which we have chosen the current character from <script type=\"math/tex; mode=display\">s1</script> and then make another function call <script type=\"math/tex; mode=display\">is\\_Interleave(s1,i,s2,j+1,res+s2.charAt(j),s3)</script>, in which the current character of <script type=\"math/tex; mode=display\">s2</script> is chosen. Here, <script type=\"math/tex; mode=display\">res</script> refers to that portion(interleaved) of <script type=\"math/tex; mode=display\">s1</script> and <script type=\"math/tex; mode=display\">s2</script> which has already been processed. If anyone of these calls return the result as <script type=\"math/tex; mode=display\">True</script>, it means that atleast one interleaving gives the required result <script type=\"math/tex; mode=display\">s3</script>. The recursive calls end when both the strings <script type=\"math/tex; mode=display\">s1</script> and <script type=\"math/tex; mode=display\">s2</script> have been fully processed.</p> \n  <p>Let's look at a small example to see how the execution proceeds.</p> \n  <div class=\"codehilite\">\n   <pre><span></span>s1=\"abc\"\ns2=\"bcd\"\ns3=\"abcbdc\"\n</pre>\n  </div> \n  <p>Firstly we choose 'a' of <script type=\"math/tex; mode=display\">s1</script> as the processed part i.e. res and call the recursive function considering the new strings as <script type=\"math/tex; mode=display\">s1</script>=\"bc\", <script type=\"math/tex; mode=display\">s2</script>=\"bcd\", <script type=\"math/tex; mode=display\">s3</script>=\"abcbdc\". When this function returns a result, we again call the recursive function but with the new strings as <script type=\"math/tex; mode=display\">s1</script>=\"abc\", <script type=\"math/tex; mode=display\">s2</script>=\"cd\", <script type=\"math/tex; mode=display\">s3</script>=\"abcbdc\"</p> \n  <iframe src=\"https://leetcode.com/playground/ZTCN5kfu/shared\" frameborder=\"0\" width=\"100%\" height=\"344\" name=\"ZTCN5kfu\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(2^{m+n})</script>. <script type=\"math/tex; mode=display\">m</script> is the length of <script type=\"math/tex; mode=display\">s1</script> and <script type=\"math/tex; mode=display\">n</script> is the length of <script type=\"math/tex; mode=display\">s2</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(m+n)</script>. The size of stack for recursive calls can go upto <script type=\"math/tex; mode=display\">m+n</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-recursion-with-memoization\">Approach 2: Recursion with memoization</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In the recursive approach discussed above, we are considering every possible string formed by interleaving the two given strings. But, there will be cases encountered in which, the same portion of <script type=\"math/tex; mode=display\">s1</script> and <script type=\"math/tex; mode=display\">s2</script> would have been processed already but in different orders(permutations). But irrespective of the order of processing, if the resultant string formed till now is matching with the required string(<script type=\"math/tex; mode=display\">s3</script>), the final result is dependent only on the remaining portions of <script type=\"math/tex; mode=display\">s1</script> and <script type=\"math/tex; mode=display\">s2</script>, but not on the already processed portion. Thus, the recursive approach leads to redundant computations.</p> \n  <p>This redundancy can be removed by making use of memoization along with recursion. For this, we maitain 3 pointers <script type=\"math/tex; mode=display\">i, j, k</script> which correspond to the index of the current character of <script type=\"math/tex; mode=display\">s1, s2, s3</script> respectively. Also, we maintain a 2D memo array to keep a track of the substrings processed so far. <script type=\"math/tex; mode=display\">memo[i][j]</script> stores a 1/0 or -1 depending on whether the current portion of strings i.e. upto <script type=\"math/tex; mode=display\">i^{th}</script> index for <script type=\"math/tex; mode=display\">s1</script> and upto <script type=\"math/tex; mode=display\">j^{th}</script> index for s2 has already been evaluated. Again, we start by selecting the current character of <script type=\"math/tex; mode=display\">s1</script> (pointed by $$i$). If it matches the current character of <script type=\"math/tex; mode=display\">s3</script> (pointed by <script type=\"math/tex; mode=display\">k</script>), we include it in the processed string and call the same function recurively as: <script type=\"math/tex; mode=display\">is\\_Interleave(s1, i+1, s2, j, s3, k+1,memo)</script> </p> \n  <p>Thus, here we have called the function by incrementing the pointers <script type=\"math/tex; mode=display\">i</script> and <script type=\"math/tex; mode=display\">k</script> since the portion of strings upto those indices has already been processed. Similarly, we choose one character from the second string and continue. The recursive function ends when either of the two strings <script type=\"math/tex; mode=display\">s1</script> or <script type=\"math/tex; mode=display\">s2</script> has been fully processed. If, let's say, the string <script type=\"math/tex; mode=display\">s1</script> has been fully processed, we directly compare the remaining portion of <script type=\"math/tex; mode=display\">s2</script> with the remaining portion of <script type=\"math/tex; mode=display\">s3</script>. When the backtrack occurs from the recursive calls, we store the value returned by the recursive functions in the memoization array memo appropriatelys so that when it is encountered the next time, the recursive function won't be called, but the memoization array itself will return the previous generated result.</p> \n  <p><iframe src=\"https://leetcode.com/playground/ZFvDAuA6/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"ZFvDAuA6\"></iframe></p> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(2^{m+n})</script>. <script type=\"math/tex; mode=display\">m</script> is the length of <script type=\"math/tex; mode=display\">s1</script> and <script type=\"math/tex; mode=display\">n</script> is the length of <script type=\"math/tex; mode=display\">s2</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(m+n)</script>. The size of stack for recursive calls can go upto <script type=\"math/tex; mode=display\">m+n</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-using-2d-dynamic-programming\">Approach 3: Using 2D Dynamic Programming</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>The recursive approach discussed in above solution included a character from one of the strings <script type=\"math/tex; mode=display\">s1</script> or <script type=\"math/tex; mode=display\">s2</script> in the resultant interleaved string and called a recursive function to check whether the remaining portions of <script type=\"math/tex; mode=display\">s1</script> and <script type=\"math/tex; mode=display\">s2</script> can be interleaved to form the remaining portion of <script type=\"math/tex; mode=display\">s3</script>. In the current approach, we look at the same problem the other way around. Here, we include one character from <script type=\"math/tex; mode=display\">s1</script> or <script type=\"math/tex; mode=display\">s2</script> and check whether the resultant string formed so far by one particular interleaving of the the current prefix of <script type=\"math/tex; mode=display\">s1</script> and <script type=\"math/tex; mode=display\">s2</script> form a prefix of <script type=\"math/tex; mode=display\">s3</script>.</p> \n  <p>Thus, this approach relies on the fact that the in order to determine whether a substring of <script type=\"math/tex; mode=display\">s3</script>(upto index <script type=\"math/tex; mode=display\">k</script>), can be formed by interleaving strings <script type=\"math/tex; mode=display\">s1</script> and <script type=\"math/tex; mode=display\">s2</script> upto indices <script type=\"math/tex; mode=display\">i</script> and <script type=\"math/tex; mode=display\">j</script> respectively, solely depends on the characters of <script type=\"math/tex; mode=display\">s1</script> and <script type=\"math/tex; mode=display\">s2</script> upto indices <script type=\"math/tex; mode=display\">i</script> and <script type=\"math/tex; mode=display\">j</script> only and not on the characters coming afterwards.</p> \n  <p>To implement this method, we'll make use of a 2D boolean array <script type=\"math/tex; mode=display\">dp</script>. In this array <script type=\"math/tex; mode=display\">dp[i][j]</script> implies if it is possible to obtain a substring of length <script type=\"math/tex; mode=display\">(i+j+2)</script> which is a prefix of <script type=\"math/tex; mode=display\">s3</script> by some interleaving of prefixes of strings <script type=\"math/tex; mode=display\">s1</script> and <script type=\"math/tex; mode=display\">s2</script> having lengths <script type=\"math/tex; mode=display\">(i+1)</script> and <script type=\"math/tex; mode=display\">(j+1)</script> respectively. For filling in the entry of <script type=\"math/tex; mode=display\">dp[i][j]</script>, we need to consider two cases:</p> \n  <ol> \n   <li> <p>The character just included i.e. either at <script type=\"math/tex; mode=display\">i^{th}</script> index of <script type=\"math/tex; mode=display\">s1</script> or at <script type=\"math/tex; mode=display\">j^{th}</script> index of <script type=\"math/tex; mode=display\">s2</script> doesn't match the character at <script type=\"math/tex; mode=display\">k^{th}</script> index of <script type=\"math/tex; mode=display\">s3</script>, where <script type=\"math/tex; mode=display\">k=i+j+1</script>. In this case, the resultant string formed using some interleaving of prefixes of <script type=\"math/tex; mode=display\">s1</script> and <script type=\"math/tex; mode=display\">s2</script> can never result in a prefix of length <script type=\"math/tex; mode=display\">k+1</script> in <script type=\"math/tex; mode=display\">s3</script>. Thus, we enter <script type=\"math/tex; mode=display\">False</script> at the character <script type=\"math/tex; mode=display\">dp[i][j]</script>.</p> </li> \n   <li> <p>The character just included i.e. either at <script type=\"math/tex; mode=display\">i^{th}</script> index of <script type=\"math/tex; mode=display\">s1</script> or at <script type=\"math/tex; mode=display\">j^{th}</script> index of <script type=\"math/tex; mode=display\">s2</script> matches the character at <script type=\"math/tex; mode=display\">k^{th}</script> index of <script type=\"math/tex; mode=display\">s3</script>, where <script type=\"math/tex; mode=display\">k=i+j+1</script>. Now, if the character just included(say <script type=\"math/tex; mode=display\">x</script>) which matches the character at <script type=\"math/tex; mode=display\">k^{th}</script> index of <script type=\"math/tex; mode=display\">s3</script>, is the character at <script type=\"math/tex; mode=display\">i^{th}</script> index of <script type=\"math/tex; mode=display\">s1</script>, we need to keep <script type=\"math/tex; mode=display\">x</script> at the last position in the resultant interleaved string formed so far. Thus, in order to use string <script type=\"math/tex; mode=display\">s1</script> and <script type=\"math/tex; mode=display\">s2</script> upto indices <script type=\"math/tex; mode=display\">i</script> and <script type=\"math/tex; mode=display\">j</script> to form a resultant string of length <script type=\"math/tex; mode=display\">(i+j+2)</script> which is a prefix of <script type=\"math/tex; mode=display\">s3</script>, we need to ensure that the strings <script type=\"math/tex; mode=display\">s1</script> and <script type=\"math/tex; mode=display\">s2</script> upto indices <script type=\"math/tex; mode=display\">(i-1)</script> and <script type=\"math/tex; mode=display\">j</script> respectively obey the same property.</p> </li> \n  </ol> \n  <p>Similarly, if we just included the <script type=\"math/tex; mode=display\">j^{th}</script> character of <script type=\"math/tex; mode=display\">s2</script>, which matches with the <script type=\"math/tex; mode=display\">k^{th}</script> character of <script type=\"math/tex; mode=display\">s3</script>, we need to ensure that the strings <script type=\"math/tex; mode=display\">s1</script> and <script type=\"math/tex; mode=display\">s2</script> upto indices <script type=\"math/tex; mode=display\">i</script> and <script type=\"math/tex; mode=display\">(j-1)</script> also obey the same property to enter a <script type=\"math/tex; mode=display\">true</script> at <script type=\"math/tex; mode=display\">dp[i][j]</script>.</p> \n  <p>This can be made clear with the following example:</p> \n  <div class=\"codehilite\">\n   <pre><span></span>s1=\"aabcc\"\ns2=\"dbbca\"\ns3=\"aadbbcbcac\"\n</pre>\n  </div> \n  <!--![97_Interleaving](../Figures/97_Interleaving.gif)--> \n  <p>!?!../Documents/97_Interleaving.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/32m6Egap/shared\" frameborder=\"0\" width=\"100%\" height=\"429\" name=\"32m6Egap\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(m \\cdot n)</script>. dp array of size <script type=\"math/tex; mode=display\">m*n</script> is filled.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(m \\cdot n)</script>. 2D dp of size <script type=\"math/tex; mode=display\">(m+1)*(n+1)</script> is required. <script type=\"math/tex; mode=display\">m</script> and <script type=\"math/tex; mode=display\">n</script> are the lengths of strings <script type=\"math/tex; mode=display\">s1</script> and <script type=\"math/tex; mode=display\">s2</script> respectively. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-4-using-1d-dynamic-programming\">Approach 4: Using 1D Dynamic Programming</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>This approach is the same as the previous approach except that we have used only 1D <script type=\"math/tex; mode=display\">dp</script> array to store the results of the prefixes of the strings processed so far. Instead of maintaining a 2D array, we can maintain a 1D array only and update the array's element <script type=\"math/tex; mode=display\">dp[i]</script> when needed using <script type=\"math/tex; mode=display\">dp[i-1]</script> and the previous value of <script type=\"math/tex; mode=display\">dp[i]</script>.</p> \n  <p><iframe src=\"https://leetcode.com/playground/PDQAgWnV/shared\" frameborder=\"0\" width=\"100%\" height=\"429\" name=\"PDQAgWnV\"></iframe></p> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(m \\cdot n)</script>. dp array of size <script type=\"math/tex; mode=display\">n</script> is filled <script type=\"math/tex; mode=display\">m</script> times.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. <script type=\"math/tex; mode=display\">n</script> is the length of the string <script type=\"math/tex; mode=display\">s1</script>.</p> </li> \n  </ul> \n </div> \n</div>"
},
{
    "frontend_question_id": 96,
    "article_live": true,
    "article_slug": "unique-binary-search-trees",
    "title": "Unique Binary Search Trees",
    "title_slug": "unique-binary-search-trees",
    "content": "<p>Given <em>n</em>, how many structurally unique <strong>BST&#39;s</strong> (binary search trees) that store values 1 ...&nbsp;<em>n</em>?</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 3\r\n<strong>Output:</strong> 5\r\n<strong>Explanation:\r\n</strong>Given <em>n</em> = 3, there are a total of 5 unique BST&#39;s:\r\n\r\n   1         3     3      2      1\r\n    \\       /     /      / \\      \\\r\n     3     2     1      1   3      2\r\n    /     /       \\                 \\\r\n   2     1         2                 3\r\n</pre>\r\n",
    "tags": "Dynamic Programming, Tree",
    "difficulty": 2,
    "frontend_article_id": 96,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-dynamic-programming\">Approach 1: Dynamic Programming</a></li> \n      <li><a href=\"#approach-2-mathematical-deduction\">Approach 2: Mathematical Deduction</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-dynamic-programming\">Approach 1: Dynamic Programming</h4> \n  <p><strong>Intuition</strong></p> \n  <p>The problem can be solved in a dynamic programming way.</p> \n  <p>Given a sorted sequence <code>1 ... n</code>, to construct a Binary Search Tree (BST) out of the sequence, we could enumerate each number <code>i</code> in the sequence, and use the number as the root, then, the subsequence <code>1 ... (i-1)</code> on its left side would lay on the left branch of the root, and similarly the right subsequence <code>(i+1) ... n</code> lay on the right branch of the root. We then can construct the subtree from the subsequence recursively. Through the above approach, we could be assured that the BST that we construct are all unique, since they start from unique roots.</p> \n  <p>As we can see, the problem can be reduced into problems with smaller sizes, instead of recursively (also repeatedly) solve the subproblems, we can store the solution of subproblems and reuse them later, <em>i.e.</em> the dynamic programming way.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>The problem is to calculate the number of unique BST. To do so, we can define two functions:</p> \n  <ol> \n   <li> <p> <script type=\"math/tex; mode=display\">G(n)</script>: the number of unique BST for a sequence of length <code>n</code>.</p> </li> \n   <li> <p> <script type=\"math/tex; mode=display\">F(i, n)</script>: the number of unique BST, where the number <code>i</code> is served as the root of BST (<script type=\"math/tex; mode=display\">1 \\leq i \\leq n</script>).</p> </li> \n  </ol> \n  <p>As we can see,</p> \n  <blockquote> \n   <p> <script type=\"math/tex; mode=display\">G(n)</script> is actually the desired function we need in order to solve the problem.</p> \n  </blockquote> \n  <p><em>Later we would see that <script type=\"math/tex; mode=display\">G(n)</script> can be deducted from <script type=\"math/tex; mode=display\">F(i, n)</script>, which at the end, would recursively refers to <script type=\"math/tex; mode=display\">G(n)</script>.</em></p> \n  <p>First of all, following the idea in the section of intuition, we can see that the total number of unique BST <script type=\"math/tex; mode=display\">G(n)</script>, is the sum of BST <script type=\"math/tex; mode=display\">F(i, n)</script> enumerating each number <code>i</code> (<code>1 &lt;= i &lt;= n</code>) as a root. <em>i.e.</em></p> \n  <p> <script type=\"math/tex; mode=display\">\nG(n) = \\sum_{i=1}^{n} F(i, n) \\qquad  \\qquad (1)\n</script> </p> \n  <p>Particularly, for the bottom cases, there is only one combination to construct a BST out of a sequence of length 1 (only a root) or nothing (empty tree). <em>i.e.</em></p> \n  <p> <script type=\"math/tex; mode=display\">\nG(0) = 1, \\qquad G(1) = 1\n</script> </p> \n  <p>Given a sequence <code>1 ... n</code>, we pick a number <code>i</code> out of the sequence as the root, then the number of unique BST with the specified root defined as <script type=\"math/tex; mode=display\">F(i, n)</script>, is the <strong>cartesian product</strong> of the number of BST for its left and right subtrees, as illustrated below:</p> \n  <p></p>\n  <center>\n   <img src=\"../Figures/96_BST.png\" width=\"550px\">\n  </center>\n  <p></p> \n  <p>For example, <script type=\"math/tex; mode=display\">F(3, 7)</script>, the number of unique BST tree with the number <code>3</code> as its root. To construct an unique BST out of the entire sequence <code>[1, 2, 3, 4, 5, 6, 7]</code> with <code>3</code> as the root, which is to say, we need to construct a subtree out of its left subsequence <code>[1, 2]</code> and another subtree out of the right subsequence <code>[4, 5, 6, 7]</code>, and then combine them together (<em>i.e.</em> cartesian product). Now the tricky part is that we could consider the number of unique BST out of sequence <code>[1,2]</code> as <script type=\"math/tex; mode=display\">G(2)</script>, and the number of of unique BST out of sequence <code>[4, 5, 6, 7]</code> as <script type=\"math/tex; mode=display\">G(4)</script>. For <script type=\"math/tex; mode=display\">G(n)</script>, it does not matter the content of the sequence, but the length of the sequence. Therefore, <script type=\"math/tex; mode=display\">F(3,7) = G(2) \\cdot G(4)</script>. To generalise from the example, we could derive the following formula:</p> \n  <p> <script type=\"math/tex; mode=display\">\nF(i, n) = G(i-1) \\cdot G(n-i) \\qquad  \\qquad (2)\n</script> </p> \n  <p>By combining the formulas (1), (2), we obtain a recursive formula for <script type=\"math/tex; mode=display\">G(n)</script>, <em>i.e.</em></p> \n  <p> <script type=\"math/tex; mode=display\">\nG(n) = \\sum_{i=1}^{n}G(i-1) \\cdot G(n-i) \\qquad  \\qquad (3)\n</script> </p> \n  <p>To calculate the result of function, we start with the lower number, since the value of <script type=\"math/tex; mode=display\">G(n)</script> depends on the values of <script type=\"math/tex; mode=display\">G(0) … G(n-1)</script>.</p> \n  <p>With the above explanation and formulas, one can easily implement an algorithm to calculate the <script type=\"math/tex; mode=display\">G(n)</script>. Here are some examples:</p> \n  <iframe src=\"https://leetcode.com/playground/CM3KHdwE/shared\" frameborder=\"0\" width=\"100%\" height=\"293\" name=\"CM3KHdwE\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : the main computation of the algorithm is done at the statement with <code>G[i]</code>. So the time complexity is essentially the number of iterations for the statement, which is <script type=\"math/tex; mode=display\">\\sum_{i=2}^{n} i = \\frac{(2+n)(n-1)}{2}</script>, to be exact, therefore the time complexity is <script type=\"math/tex; mode=display\">O(N^2)</script> </p> </li> \n   <li> <p>Space complexity : The space complexity of the above algorithm is mainly the storage to keep all the intermediate solutions, therefore <script type=\"math/tex; mode=display\">O(N)</script>.</p> </li> \n  </ul> \n  <p><br></p> \n  <hr> \n  <h4 id=\"approach-2-mathematical-deduction\">Approach 2: Mathematical Deduction</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Actually, as it turns out, the sequence of <script type=\"math/tex; mode=display\">G(n)</script> function results is known as <a href=\"https://en.wikipedia.org/wiki/Catalan_number\">Catalan number</a> <script type=\"math/tex; mode=display\">C_n</script>. And one of the more convenient forms for calculation is defined as follows:</p> \n  <p> <script type=\"math/tex; mode=display\">\nC_0 = 1, \\qquad C_{n+1} = \\frac{2(2n+1)}{n+2}C_n \\qquad  \\qquad (4)\n</script> </p> \n  <p>We skip the proof here, which one can find following the above reference.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Given the formula (3), it becomes rather easy to calculate <script type=\"math/tex; mode=display\">G_n</script> which is actually <script type=\"math/tex; mode=display\">C_n</script>. Here are some examples: <iframe src=\"https://leetcode.com/playground/rARaS2jG/shared\" frameborder=\"0\" width=\"100%\" height=\"225\" name=\"rARaS2jG\"></iframe></p> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time complexity : <script type=\"math/tex; mode=display\">O(N)</script>, as one can see, there is one single loop in the algorithm.</li> \n   <li>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>, we use only one variable to store all the intermediate results and the final one.</li> \n  </ul> \n  <p>Analysis written by @<a href=\"https://leetcode.com/liaison/\">liaison</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 95,
    "article_live": true,
    "article_slug": "unique-binary-search-trees-ii",
    "title": "Unique Binary Search Trees II",
    "title_slug": "unique-binary-search-trees-ii",
    "content": "<p>Given an integer <em>n</em>, generate all structurally unique <strong>BST&#39;s</strong> (binary search trees) that store values 1 ...&nbsp;<em>n</em>.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 3\r\n<strong>Output:</strong>\r\n[\r\n&nbsp; [1,null,3,2],\r\n&nbsp; [3,2,null,1],\r\n&nbsp; [3,1,null,null,2],\r\n&nbsp; [2,1,3],\r\n&nbsp; [1,null,2,null,3]\r\n]\r\n<strong>Explanation:</strong>\r\nThe above output corresponds to the 5 unique BST&#39;s shown below:\r\n\r\n   1         3     3      2      1\r\n    \\       /     /      / \\      \\\r\n     3     2     1      1   3      2\r\n    /     /       \\                 \\\r\n   2     1         2                 3\r\n</pre>\r\n",
    "tags": "Dynamic Programming, Tree",
    "difficulty": 2,
    "frontend_article_id": 95,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-recursion\">Approach 1: Recursion</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <p><strong>Tree definition</strong></p> \n  <p>First of all, here is the definition of the <code>TreeNode</code> which we would use.</p> \n  <iframe src=\"https://leetcode.com/playground/eHhcmmEU/shared\" frameborder=\"0\" width=\"100%\" height=\"225\" name=\"eHhcmmEU\"></iframe> \n  <p><br> <br></p> \n  <hr> \n  <h4 id=\"approach-1-recursion\">Approach 1: Recursion</h4> \n  <p>First of all let's count how many trees do we have to construct. As you could check in <a href=\"https://leetcode.com/articles/unique-binary-search-trees/\">this article</a>, the number of possible BST is actually a <a href=\"https://en.wikipedia.org/wiki/Catalan_number\">Catalan number</a>. </p> \n  <p>Let's follow the logic from the above article, this time not to count but to actually construct the trees. </p> \n  <p><strong>Algorithm</strong></p> \n  <p>Let's pick up number <code>i</code> out of the sequence <code>1 ..n</code> and use it as the root of the current tree. Then there are <code>i - 1</code> elements available for the construction of the left subtree and <code>n - i</code> elements available for the right subtree. As we <a href=\"https://leetcode.com/articles/unique-binary-search-trees/\">already discussed</a> that results in <code>G(i - 1)</code> different left subtrees and <code>G(n - i)</code> different right subtrees, where <code>G</code> is a Catalan number. </p> \n  <p><img alt=\"BST\" src=\"../Figures/96_BST.png\"></p> \n  <p>Now let's repeat the step above for the sequence <code>1 ... i - 1</code> to construct all left subtrees, and then for the sequence <code>i + 1 ... n</code> to construct all right subtrees. </p> \n  <p>This way we have a root <code>i</code> and two lists for the possible left and right subtrees. The final step is to loop over both lists to link left and right subtrees to the root. </p> \n  <iframe src=\"https://leetcode.com/playground/dFTaeqjY/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"dFTaeqjY\"></iframe> \n  <p><strong>Complexity analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : The main computations are to construct all possible trees with a given root, that is actually Catalan number <script type=\"math/tex; mode=display\">G_n</script> as was discussed above. This is done <code>n</code> times, that results in time complexity <script type=\"math/tex; mode=display\">n G_n</script>. Catalan numbers grow as <script type=\"math/tex; mode=display\">\\frac{4^n}{n^{3/2}}</script> that gives the final complexity <script type=\"math/tex; mode=display\">\\mathcal{O}(\\frac{4^n}{n^{1/2}})</script>. Seems to be large but let's not forget that here we're asked to generate <script type=\"math/tex; mode=display\">G_n \\sim \\frac{4^n}{n^{3/2}}</script> tree objects as output.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">n G_n</script> as we keep <script type=\"math/tex; mode=display\">G_n</script> trees with <code>n</code> elements each, that results in <script type=\"math/tex; mode=display\">\\mathcal{O}(\\frac{4^n}{n^{1/2}})</script> complexity. </p> </li> \n  </ul> \n  <p>Analysis written by @<a href=\"https://leetcode.com/liaison/\">liaison</a> and @<a href=\"https://leetcode.com/andvary/\">andvary</a></p> \n </div> \n</div>"
},
{
    "frontend_question_id": 94,
    "article_live": true,
    "article_slug": "binary-tree-inorder-traversal",
    "title": "Binary Tree Inorder Traversal",
    "title_slug": "binary-tree-inorder-traversal",
    "content": "<p>Given a binary tree, return the <em>inorder</em> traversal of its nodes&#39; values.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [1,null,2,3]\r\n   1\r\n    \\\r\n     2\r\n    /\r\n   3\r\n\r\n<strong>Output:</strong> [1,3,2]</pre>\r\n\r\n<p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p>\r\n",
    "tags": "Hash Table, Stack, Tree",
    "difficulty": 2,
    "frontend_article_id": 94,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-recursive-approach\">Approach 1: Recursive Approach</a></li> \n      <li><a href=\"#approach-2-iterating-method-using-stack\">Approach 2: Iterating method using Stack</a></li> \n      <li><a href=\"#approach-3-morris-traversal\">Approach 3: Morris Traversal</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-recursive-approach\">Approach 1: Recursive Approach</h4> \n  <p>The first method to solve this problem is using recursion. This is the classical method and is straightforward. We can define a helper function to implement recursion.</p> \n  <iframe src=\"https://leetcode.com/playground/fDHBZRqB/shared\" frameborder=\"0\" width=\"100%\" height=\"378\" name=\"fDHBZRqB\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The time complexity is <script type=\"math/tex; mode=display\">O(n)</script> because the recursive function is <script type=\"math/tex; mode=display\">T(n) = 2 \\cdot T(n/2)+1</script>.</p> </li> \n   <li> <p>Space complexity : The worst case space required is <script type=\"math/tex; mode=display\">O(n)</script>, and in the average case it's <script type=\"math/tex; mode=display\">O(log(n))</script> where <script type=\"math/tex; mode=display\"> n</script> is number of nodes. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-iterating-method-using-stack\">Approach 2: Iterating method using Stack</h4> \n  <p>The strategy is very similiar to the first method, the different is using stack.</p> \n  <p>Here is an illustration:</p> \n  <p>!?!../Documents/94_Binary.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/Syki8KUX/shared\" frameborder=\"0\" width=\"100%\" height=\"344\" name=\"Syki8KUX\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-morris-traversal\">Approach 3: Morris Traversal</h4> \n  <p>In this method, we have to use a new data structure-Threaded Binary Tree, and the strategy is as follows:</p> \n  <blockquote> \n   <p>Step 1: Initialize current as root</p> \n   <p>Step 2: While current is not NULL,</p> \n   <div class=\"codehilite\">\n    <pre><span></span>If current does not have left child\n\n    a. Add current’s value\n\n    b. Go to the right, i.e., current = current.right\n\nElse\n\n    a. In current's left subtree, make current the right child of the rightmost node\n\n    b. Go to this left child, i.e., current = current.left\n</pre>\n   </div> \n  </blockquote> \n  <p>For example:</p> \n  <div class=\"codehilite\">\n   <pre><span></span>          1\n        /   \\\n       2     3\n      / \\   /\n     4   5 6\n</pre>\n  </div> \n  <p>First, 1 is the root, so initialize 1 as current, 1 has left child which is 2, the current's left subtree is</p> \n  <div class=\"codehilite\">\n   <pre><span></span>         2\n        / \\\n       4   5\n</pre>\n  </div> \n  <p>So in this subtree, the rightmost node is 5, then make the current(1) as the right child of 5. Set current = cuurent.left (current = 2). The tree now looks like:</p> \n  <div class=\"codehilite\">\n   <pre><span></span>         2\n        / \\\n       4   5\n            \\\n             1\n              \\\n               3\n              /\n             6\n</pre>\n  </div> \n  <p>For current 2, which has left child 4, we can continue with thesame process as we did above</p> \n  <div class=\"codehilite\">\n   <pre><span></span>        4\n         \\\n          2\n           \\\n            5\n             \\\n              1\n               \\\n                3\n               /\n              6\n</pre>\n  </div> \n  <p>then add 4 because it has no left child, then add 2, 5, 1, 3 one by one, for node 3 which has left child 6, do the same as above. Finally, the inorder taversal is [4,2,5,1,6,3].</p> \n  <p>For more details, please check <a href=\"https://en.wikipedia.org/wiki/Threaded_binary_tree\">Threaded binary tree</a> and <a href=\"https://stackoverflow.com/questions/5502916/explain-morris-inorder-tree-traversal-without-using-stacks-or-recursion\">Explaination of Morris Method</a></p> \n  <iframe src=\"https://leetcode.com/playground/bPQT5SAN/shared\" frameborder=\"0\" width=\"100%\" height=\"446\" name=\"bPQT5SAN\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. To prove that the time complexity is <script type=\"math/tex; mode=display\">O(n)</script>, the biggest problem lies in finding the time complexity of finding the predecessor nodes of all the nodes in the binary tree. Intuitively, the complexity is <script type=\"math/tex; mode=display\">O(nlogn)</script>, because to find the predecessor node for a single node related to the height of the tree. But in fact, finding the predecessor nodes for all nodes only needs <script type=\"math/tex; mode=display\">O(n)</script> time. Because a binary Tree with <script type=\"math/tex; mode=display\">n</script> nodes has <script type=\"math/tex; mode=display\">n-1</script> edges, the whole processing for each edges up to 2 times, one is to locate a node, and the other is to find the predecessor node. So the complexity is <script type=\"math/tex; mode=display\">O(n)</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Arraylist of size <script type=\"math/tex; mode=display\">n</script> is used.</p> </li> \n  </ul> \n </div> \n</div>"
},
{
    "frontend_question_id": 93,
    "article_live": false,
    "title": "Restore IP Addresses",
    "title_slug": "restore-ip-addresses",
    "content": "<p>Given a string containing only digits, restore it by returning all possible valid IP address combinations.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> &quot;25525511135&quot;\r\n<strong>Output:</strong> <code>[&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]\r\n</code></pre>\r\n",
    "tags": "String, Backtracking",
    "difficulty": 2,
    "frontend_article_id": 93
},
{
    "frontend_question_id": 92,
    "article_live": false,
    "title": "Reverse Linked List II",
    "title_slug": "reverse-linked-list-ii",
    "content": "<p>Reverse a linked list from position <em>m</em> to <em>n</em>. Do it in one-pass.</p>\r\n\r\n<p><strong>Note:&nbsp;</strong>1 &le; <em>m</em> &le; <em>n</em> &le; length of list.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, <em>m</em> = 2, <em>n</em> = 4\r\n<strong>Output:</strong> 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL\r\n</pre>\r\n",
    "tags": "Linked List",
    "difficulty": 2,
    "frontend_article_id": 92
},
{
    "frontend_question_id": 91,
    "article_live": false,
    "title": "Decode Ways",
    "title_slug": "decode-ways",
    "content": "<p>A message containing letters from <code>A-Z</code> is being encoded to numbers using the following mapping:</p>\r\n\r\n<pre>\r\n&#39;A&#39; -&gt; 1\r\n&#39;B&#39; -&gt; 2\r\n...\r\n&#39;Z&#39; -&gt; 26\r\n</pre>\r\n\r\n<p>Given a <strong>non-empty</strong> string containing only digits, determine the total number of ways to decode it.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> &quot;12&quot;\r\n<strong>Output:</strong> 2\r\n<strong>Explanation:</strong>&nbsp;It could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12).\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> &quot;226&quot;\r\n<strong>Output:</strong> 3\r\n<strong>Explanation:</strong>&nbsp;It could be decoded as &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), or &quot;BBF&quot; (2 2 6).</pre>\r\n",
    "tags": "String, Dynamic Programming",
    "difficulty": 2,
    "frontend_article_id": 91
},
{
    "frontend_question_id": 90,
    "article_live": false,
    "title": "Subsets II",
    "title_slug": "subsets-ii",
    "content": "<p>Given a collection of integers that might contain duplicates, <strong><em>nums</em></strong>, return all possible subsets (the power set).</p>\r\n\r\n<p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [1,2,2]\r\n<strong>Output:</strong>\r\n[\r\n  [2],\r\n  [1],\r\n  [1,2,2],\r\n  [2,2],\r\n  [1,2],\r\n  []\r\n]\r\n</pre>\r\n",
    "tags": "Array, Backtracking",
    "difficulty": 2,
    "frontend_article_id": 90
},
{
    "frontend_question_id": 89,
    "article_live": false,
    "title": "Gray Code",
    "title_slug": "gray-code",
    "content": "<p>The gray code is a binary numeral system where two successive values differ in only one bit.</p>\r\n\r\n<p>Given a non-negative integer <em>n</em> representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>&nbsp;2\r\n<strong>Output:</strong>&nbsp;<code>[0,1,3,2]</code>\r\n<strong>Explanation:</strong>\r\n00 - 0\r\n01 - 1\r\n11 - 3\r\n10 - 2\r\n\r\nFor a given&nbsp;<em>n</em>, a gray code sequence may not be uniquely defined.\r\nFor example, [0,2,3,1] is also a valid gray code sequence.\r\n\r\n00 - 0\r\n10 - 2\r\n11 - 3\r\n01 - 1\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>&nbsp;0\r\n<strong>Output:</strong>&nbsp;<code>[0]\r\n<strong>Explanation:</strong> We define the gray code sequence to begin with 0.\r\n&nbsp;            A gray code sequence of <em>n</em> has size = 2<sup>n</sup>, which for <em>n</em> = 0 the size is 2<sup>0</sup> = 1.\r\n&nbsp;            Therefore, for <em>n</em> = 0 the gray code sequence is [0].</code>\r\n</pre>\r\n",
    "tags": "Backtracking",
    "difficulty": 2,
    "frontend_article_id": 89
},
{
    "frontend_question_id": 88,
    "article_live": false,
    "title": "Merge Sorted Array",
    "title_slug": "merge-sorted-array",
    "content": "<p>Given two sorted integer arrays <em>nums1</em> and <em>nums2</em>, merge <em>nums2</em> into <em>nums1</em> as one sorted array.</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>The number of elements initialized in <em>nums1</em> and <em>nums2</em> are <em>m</em> and <em>n</em> respectively.</li>\r\n\t<li>You may assume that <em>nums1</em> has enough space (size that is greater or equal to <em>m</em> + <em>n</em>) to hold additional elements from <em>nums2</em>.</li>\r\n</ul>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>\r\nnums1 = [1,2,3,0,0,0], m = 3\r\nnums2 = [2,5,6],       n = 3\r\n\r\n<strong>Output:</strong>&nbsp;[1,2,2,3,5,6]\r\n</pre>\r\n",
    "tags": "Array, Two Pointers",
    "difficulty": 1,
    "frontend_article_id": 88
},
{
    "frontend_question_id": 87,
    "article_live": false,
    "title": "Scramble String",
    "title_slug": "scramble-string",
    "content": "<p>Given a string <em>s1</em>, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.</p>\r\n\r\n<p>Below is one possible representation of <em>s1</em> = <code>&quot;great&quot;</code>:</p>\r\n\r\n<pre>\r\n    great\r\n   /    \\\r\n  gr    eat\r\n / \\    /  \\\r\ng   r  e   at\r\n           / \\\r\n          a   t\r\n</pre>\r\n\r\n<p>To scramble the string, we may choose any non-leaf node and swap its two children.</p>\r\n\r\n<p>For example, if we choose the node <code>&quot;gr&quot;</code> and swap its two children, it produces a scrambled string <code>&quot;rgeat&quot;</code>.</p>\r\n\r\n<pre>\r\n    rgeat\r\n   /    \\\r\n  rg    eat\r\n / \\    /  \\\r\nr   g  e   at\r\n           / \\\r\n          a   t\r\n</pre>\r\n\r\n<p>We say that <code>&quot;rgeat&quot;</code> is a scrambled string of <code>&quot;great&quot;</code>.</p>\r\n\r\n<p>Similarly, if we continue to swap the children of nodes <code>&quot;eat&quot;</code> and <code>&quot;at&quot;</code>, it produces a scrambled string <code>&quot;rgtae&quot;</code>.</p>\r\n\r\n<pre>\r\n    rgtae\r\n   /    \\\r\n  rg    tae\r\n / \\    /  \\\r\nr   g  ta  e\r\n       / \\\r\n      t   a\r\n</pre>\r\n\r\n<p>We say that <code>&quot;rgtae&quot;</code> is a scrambled string of <code>&quot;great&quot;</code>.</p>\r\n\r\n<p>Given two strings <em>s1</em> and <em>s2</em> of the same length, determine if <em>s2</em> is a scrambled string of <em>s1</em>.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> s1 = &quot;great&quot;, s2 = &quot;rgeat&quot;\r\n<strong>Output:</strong> true\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> s1 = &quot;abcde&quot;, s2 = &quot;caebd&quot;\r\n<strong>Output:</strong> false</pre>\r\n",
    "tags": "String, Dynamic Programming",
    "difficulty": 3,
    "frontend_article_id": 87
},
{
    "frontend_question_id": 86,
    "article_live": false,
    "title": "Partition List",
    "title_slug": "partition-list",
    "content": "<p>Given a linked list and a value <em>x</em>, partition it such that all nodes less than <em>x</em> come before nodes greater than or equal to <em>x</em>.</p>\r\n\r\n<p>You should preserve the original relative order of the nodes in each of the two partitions.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, <em>x</em> = 3\r\n<strong>Output:</strong> 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5\r\n</pre>\r\n",
    "tags": "Linked List, Two Pointers",
    "difficulty": 2,
    "frontend_article_id": 86
},
{
    "frontend_question_id": 85,
    "article_live": false,
    "title": "Maximal Rectangle",
    "title_slug": "maximal-rectangle",
    "content": "<p>Given a 2D binary matrix filled with 0&#39;s and 1&#39;s, find the largest rectangle containing only 1&#39;s and return its area.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>\r\n[\r\n  [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],\r\n  [&quot;1&quot;,&quot;0&quot;,&quot;<strong>1</strong>&quot;,&quot;<strong>1</strong>&quot;,&quot;<strong>1</strong>&quot;],\r\n  [&quot;1&quot;,&quot;1&quot;,&quot;<strong>1</strong>&quot;,&quot;<strong>1</strong>&quot;,&quot;<strong>1</strong>&quot;],\r\n  [&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]\r\n]\r\n<strong>Output:</strong> 6\r\n</pre>\r\n",
    "tags": "Array, Hash Table, Dynamic Programming, Stack",
    "difficulty": 3,
    "frontend_article_id": 85
},
{
    "frontend_question_id": 84,
    "article_live": true,
    "article_slug": "largest-rectangle-in-histogram",
    "title": "Largest Rectangle in Histogram",
    "title_slug": "largest-rectangle-in-histogram",
    "content": "<p>Given <em>n</em> non-negative integers representing the histogram&#39;s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/12/histogram.png\" style=\"width: 188px; height: 204px;\" /><br />\r\n<small>Above is a histogram where width of each bar is 1, given height = <code>[2,1,5,6,2,3]</code>.</small></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/12/histogram_area.png\" style=\"width: 188px; height: 204px;\" /><br />\r\n<small>The largest rectangle is shown in the shaded area, which has area = <code>10</code> unit.</small></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [2,1,5,6,2,3]\r\n<strong>Output:</strong> 10\r\n</pre>\r\n",
    "tags": "Array, Stack",
    "difficulty": 3,
    "frontend_article_id": 84,
    "article_content": ""
},
{
    "frontend_question_id": 83,
    "article_live": true,
    "article_slug": "remove-duplicates-from-sorted-list",
    "title": "Remove Duplicates from Sorted List",
    "title_slug": "remove-duplicates-from-sorted-list",
    "content": "<p>Given a sorted linked list, delete all duplicates such that each element appear only <em>once</em>.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 1-&gt;1-&gt;2\r\n<strong>Output:</strong> 1-&gt;2\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 1-&gt;1-&gt;2-&gt;3-&gt;3\r\n<strong>Output:</strong> 1-&gt;2-&gt;3\r\n</pre>\r\n",
    "tags": "Linked List",
    "difficulty": 1,
    "frontend_article_id": 83,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-straight-forward-approach\">Approach 1: Straight-Forward Approach</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>This is a simple problem that merely tests your ability to manipulate list node pointers. Because the input list is sorted, we can determine if a node is a duplicate by comparing its value to the node <em>after</em> it in the list. If it is a duplicate, we change the <code>next</code> pointer of the current node so that it skips the next node and points directly to the one after the next node.</p> \n  <iframe src=\"https://leetcode.com/playground/KHvbA6CF/shared\" frameborder=\"0\" width=\"100%\" height=\"242\" name=\"KHvbA6CF\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Because each node in the list is checked exactly once to determine if it is a duplicate or not, the total run time is <script type=\"math/tex; mode=display\">O(n)</script>, where <script type=\"math/tex; mode=display\">n</script> is the number of nodes in the list.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. No additional space is used.</p> </li> \n  </ul> \n  <p><strong>Correctness</strong></p> \n  <p>We can prove the correctness of this code by defining a <em>loop invariant</em>. A loop invariant is condition that is true before and after every iteration of the loop. In this case, a loop invariant that helps us prove correctness is this:</p> \n  <blockquote> \n   <p>All nodes in the list up to the pointer <code>current</code> do not contain duplicate elements.</p> \n  </blockquote> \n  <p>We can prove that this condition is indeed a loop invariant by induction. Before going into the loop, <code>current</code> points to the head of the list. Therefore, the part of the list up to <code>current</code> contains only the head. And so it can not contain any duplicate elements. Now suppose <code>current</code> is now pointing to some node in the list (but not the last element), and the part of the list up to <code>current</code> contains no duplicate elements. After another loop iteration, one of two things happen.</p> \n  <ol> \n   <li> <p><code>current.next</code> was a duplicate of <code>current</code>. In this case, the duplicate node at <code>current.next</code> is deleted, and <code>current</code> stays pointing to the same node as before. Therefore, the condition still holds; there are still no duplicates up to <code>current</code>.</p> </li> \n   <li> <p><code>current.next</code> was not a duplicate of <code>current</code> (and, because the list is sorted, <code>current.next</code> is also not a duplicate of any other element appearing <em>before</em> <code>current</code>). In this case, <code>current</code> moves forward one step to point to <code>current.next</code>. Therefore, the condition still holds; there are no duplicates up to <code>current</code>.</p> </li> \n  </ol> \n  <p>At the last iteration of the loop, <code>current</code> must point to the last element, because afterwards, <code>current.next = null</code>. Therefore, after the loop ends, all elements up to the last element do not contain duplicates.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 82,
    "article_live": false,
    "title": "Remove Duplicates from Sorted List II",
    "title_slug": "remove-duplicates-from-sorted-list-ii",
    "content": "<p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only <em>distinct</em> numbers from the original list.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5\r\n<strong>Output:</strong> 1-&gt;2-&gt;5\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 1-&gt;1-&gt;1-&gt;2-&gt;3\r\n<strong>Output:</strong> 2-&gt;3\r\n</pre>\r\n",
    "tags": "Linked List",
    "difficulty": 2,
    "frontend_article_id": 82
},
{
    "frontend_question_id": 81,
    "article_live": false,
    "title": "Search in Rotated Sorted Array II",
    "title_slug": "search-in-rotated-sorted-array-ii",
    "content": "<p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>\r\n\r\n<p>(i.e., <code>[0,0,1,2,2,5,6]</code> might become <code>[2,5,6,0,0,1,2]</code>).</p>\r\n\r\n<p>You are given a target value to search. If found in the array return <code>true</code>, otherwise return <code>false</code>.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [2<code>,5,6,0,0,1,2]</code>, target = 0\r\n<strong>Output:</strong> true\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [2<code>,5,6,0,0,1,2]</code>, target = 3\r\n<strong>Output:</strong> false</pre>\r\n\r\n<p><strong>Follow up:</strong></p>\r\n\r\n<ul>\r\n\t<li>This is a follow up problem to&nbsp;<a href=\"/problems/search-in-rotated-sorted-array/description/\">Search in Rotated Sorted Array</a>, where <code>nums</code> may contain duplicates.</li>\r\n\t<li>Would this affect the run-time complexity? How and why?</li>\r\n</ul>\r\n",
    "tags": "Array, Binary Search",
    "difficulty": 2,
    "frontend_article_id": 81
},
{
    "frontend_question_id": 80,
    "article_live": false,
    "title": "Remove Duplicates from Sorted Array II",
    "title_slug": "remove-duplicates-from-sorted-array-ii",
    "content": "<p>Given a sorted array <em>nums</em>, remove the duplicates <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\"><strong>in-place</strong></a> such that duplicates appeared at most&nbsp;<em>twice</em> and return the new length.</p>\r\n\r\n<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\">in-place</a></strong> with O(1) extra memory.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\nGiven <em>nums</em> = <strong>[1,1,1,2,2,3]</strong>,\r\n\r\nYour function should return length = <strong><code>5</code></strong>, with the first five elements of <em><code>nums</code></em> being <strong><code>1, 1, 2, 2</code></strong> and <strong>3</strong> respectively.\r\n\r\nIt doesn&#39;t matter what you leave beyond the returned length.</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\nGiven <em>nums</em> = <strong>[0,0,1,1,1,1,2,3,3]</strong>,\r\n\r\nYour function should return length = <strong><code>7</code></strong>, with the first seven elements of <em><code>nums</code></em> being modified to&nbsp;<strong><code>0</code></strong>, <strong>0</strong>, <strong>1</strong>, <strong>1</strong>, <strong>2</strong>, <strong>3</strong> and&nbsp;<strong>3</strong> respectively.\r\n\r\nIt doesn&#39;t matter what values are set beyond&nbsp;the returned length.\r\n</pre>\r\n\r\n<p><strong>Clarification:</strong></p>\r\n\r\n<p>Confused why the returned value is an integer but your answer is an array?</p>\r\n\r\n<p>Note that the input array is passed in by <strong>reference</strong>, which means modification to the input array will be known to the caller as well.</p>\r\n\r\n<p>Internally you can think of this:</p>\r\n\r\n<pre>\r\n// <strong>nums</strong> is passed in by reference. (i.e., without making a copy)\r\nint len = removeDuplicates(nums);\r\n\r\n// any modification to <strong>nums</strong> in your function would be known by the caller.\r\n// using the length returned by your function, it prints the first <strong>len</strong> elements.\r\nfor (int i = 0; i &lt; len; i++) {\r\n&nbsp; &nbsp; print(nums[i]);\r\n}\r\n</pre>\r\n",
    "tags": "Array, Two Pointers",
    "difficulty": 2,
    "frontend_article_id": 80
},
{
    "frontend_question_id": 79,
    "article_live": false,
    "title": "Word Search",
    "title_slug": "word-search",
    "content": "<p>Given a 2D board and a word, find if the word exists in the grid.</p>\r\n\r\n<p>The word can be constructed from letters of sequentially adjacent cell, where &quot;adjacent&quot; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\nboard =\r\n[\r\n  [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;],\r\n  [&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;],\r\n  [&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;]\r\n]\r\n\r\nGiven word = &quot;<strong>ABCCED</strong>&quot;, return <strong>true</strong>.\r\nGiven word = &quot;<strong>SEE</strong>&quot;, return <strong>true</strong>.\r\nGiven word = &quot;<strong>ABCB</strong>&quot;, return <strong>false</strong>.\r\n</pre>\r\n",
    "tags": "Array, Backtracking",
    "difficulty": 2,
    "frontend_article_id": 79
},
{
    "frontend_question_id": 78,
    "article_live": false,
    "title": "Subsets",
    "title_slug": "subsets",
    "content": "<p>Given a set of <strong>distinct</strong> integers, <em>nums</em>, return all possible subsets (the power set).</p>\r\n\r\n<p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [1,2,3]\r\n<strong>Output:</strong>\r\n[\r\n  [3],\r\n&nbsp; [1],\r\n&nbsp; [2],\r\n&nbsp; [1,2,3],\r\n&nbsp; [1,3],\r\n&nbsp; [2,3],\r\n&nbsp; [1,2],\r\n&nbsp; []\r\n]</pre>\r\n",
    "tags": "Array, Backtracking, Bit Manipulation",
    "difficulty": 2,
    "frontend_article_id": 78
},
{
    "frontend_question_id": 77,
    "article_live": false,
    "title": "Combinations",
    "title_slug": "combinations",
    "content": "<p>Given two integers <em>n</em> and <em>k</em>, return all possible combinations of <em>k</em> numbers out of 1 ... <em>n</em>.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>&nbsp;n = 4, k = 2\r\n<strong>Output:</strong>\r\n[\r\n  [2,4],\r\n  [3,4],\r\n  [2,3],\r\n  [1,2],\r\n  [1,3],\r\n  [1,4],\r\n]\r\n</pre>\r\n",
    "tags": "Backtracking",
    "difficulty": 2,
    "frontend_article_id": 77
},
{
    "frontend_question_id": 76,
    "article_live": true,
    "article_slug": "minimum-window-substring",
    "title": "Minimum Window Substring",
    "title_slug": "minimum-window-substring",
    "content": "<p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: S</strong> = &quot;ADOBECODEBANC&quot;, <strong>T</strong> = &quot;ABC&quot;\r\n<strong>Output:</strong> &quot;BANC&quot;\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>If there is no such window in S that covers all characters in T, return the empty string <code>&quot;&quot;</code>.</li>\r\n\t<li>If there is such window, you are guaranteed that there will always be only one unique minimum window in S.</li>\r\n</ul>\r\n",
    "tags": "Hash Table, Two Pointers, String",
    "difficulty": 3,
    "frontend_article_id": 76,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-sliding-window\">Approach 1: Sliding Window</a></li> \n      <li><a href=\"#approach-2-optimized-sliding-window\">Approach 2: Optimized Sliding Window</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-sliding-window\">Approach 1: Sliding Window</h4> \n  <p><strong>Intuition</strong></p> \n  <p>The question asks us to return the minimum window from the string <script type=\"math/tex; mode=display\">S</script> which has all the characters of the string <script type=\"math/tex; mode=display\">T</script>. Let us call a window <code>desirable</code> if it has all the characters from <script type=\"math/tex; mode=display\">T</script>.</p> \n  <p>We can use a simple sliding window approach to solve this problem.</p> \n  <p>In any sliding window based problem we have two pointers. One <script type=\"math/tex; mode=display\">right</script> pointer whose job is to expand the current window and then we have the <script type=\"math/tex; mode=display\">left</script> pointer whose job is to contract a given window. At any point in time only one of these pointers move and the other one remains fixed.</p> \n  <p>The solution is pretty intuitive. We keep expanding the window by moving the right pointer. When the window has all the desired characters, we contract (if possible) and save the smallest window till now.</p> \n  <p>The answer is the smallest desirable window.</p> \n  <p>For eg. <code>S = \"ABAACBAB\" T = \"ABC\"</code>. Then our answer window is <code>\"ACB\"</code> and shown below is one of the possible desirable windows. </p>\n  <center> \n   <img src=\"../Figures/76/76_Minimum_Window_Substring_1.png\" width=\"500\"> \n  </center> \n  <br>\n  <p></p> \n  <p><strong>Algorithm</strong></p> \n  <ol> \n   <li> <p>We start with two pointers, <script type=\"math/tex; mode=display\">left</script> and <script type=\"math/tex; mode=display\">right</script> initially pointing to the first element of the string <script type=\"math/tex; mode=display\">S</script>.</p> </li> \n   <li> <p>We use the <script type=\"math/tex; mode=display\">right</script> pointer to expand the window until we get a desirable window i.e. a window that contains all of the characters of <script type=\"math/tex; mode=display\">T</script>.</p> </li> \n   <li> <p>Once we have a window with all the characters, we can move the left pointer ahead one by one. If the window is still a desirable one we keep on updating the minimum window size.</p> </li> \n   <li> <p>If the window is not desirable any more, we repeat <script type=\"math/tex; mode=display\">step \\; 2</script> onwards.</p> </li> \n  </ol> \n  <p></p>\n  <center> \n   <img src=\"../Figures/76/76_Minimum_Window_Substring_2.png\" width=\"500\"> \n  </center>\n  <p></p> \n  <p>The above steps are repeated until we have looked at all the windows. The smallest window is returned.</p> \n  <p></p>\n  <center> \n   <img src=\"../Figures/76/76_Minimum_Window_Substring_3.png\" width=\"500\"> \n  </center> \n  <br>\n  <p></p> \n  <iframe src=\"https://leetcode.com/playground/e5nQuXma/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"e5nQuXma\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(|S| + |T|)</script> where |S| and |T| represent the lengths of strings <script type=\"math/tex; mode=display\">S</script> and <script type=\"math/tex; mode=display\">T</script>. In the worst case we might end up visiting every element of string <script type=\"math/tex; mode=display\">S</script> twice, once by left pointer and once by right pointer. <script type=\"math/tex; mode=display\">|T|</script> represents the length of string <script type=\"math/tex; mode=display\">T</script>.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(|S| + |T|)</script>. <script type=\"math/tex; mode=display\">|S|</script> when the window size is equal to the entire string <script type=\"math/tex; mode=display\">S</script>. <script type=\"math/tex; mode=display\">|T|</script> when <script type=\"math/tex; mode=display\">T</script> has all unique characters. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-optimized-sliding-window\">Approach 2: Optimized Sliding Window</h4> \n  <p><strong>Intuition</strong></p> \n  <p>A small improvement to the above approach can reduce the time complexity of the algorithm to <script type=\"math/tex; mode=display\">O(2*|filtered\\_S| + |S| + |T|)</script>, where <script type=\"math/tex; mode=display\">filtered\\_S</script> is the string formed from S by removing all the elements not present in <script type=\"math/tex; mode=display\">T</script>.</p> \n  <p>This complexity reduction is evident when <script type=\"math/tex; mode=display\">|filtered\\_S| <<< |S|</script>.</p> \n  <p>This kind of scenario might happen when length of string <script type=\"math/tex; mode=display\">T</script> is way too small than the length of string <script type=\"math/tex; mode=display\">S</script> and string <script type=\"math/tex; mode=display\">S</script> consists of numerous characters which are not present in <script type=\"math/tex; mode=display\">T</script>.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>We create a list called <script type=\"math/tex; mode=display\">filtered\\_S</script> which has all the characters from string <script type=\"math/tex; mode=display\">S</script> along with their indices in <script type=\"math/tex; mode=display\">S</script>, but these characters should be present in <script type=\"math/tex; mode=display\">T</script>.</p> \n  <pre>  S = \"ABCDDDDDDEEAFFBC\" T = \"ABC\"\n  filtered_S = [(0, 'A'), (1, 'B'), (2, 'C'), (11, 'A'), (14, 'B'), (15, 'C')]\n  Here (0, 'A') means in string S character A is at index 0.\n</pre> \n  <p>We can now follow our sliding window approach on the smaller string <script type=\"math/tex; mode=display\">filtered\\_S</script>.</p> \n  <iframe src=\"https://leetcode.com/playground/PGDBbStw/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"PGDBbStw\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time Complexity : <script type=\"math/tex; mode=display\">O(|S| + |T|)</script> where |S| and |T| represent the lengths of strings <script type=\"math/tex; mode=display\">S</script> and <script type=\"math/tex; mode=display\">T</script>. The complexity is same as the previous approach. But in certain cases where <script type=\"math/tex; mode=display\">|filtered\\_S|</script> &lt;&lt;&lt; <script type=\"math/tex; mode=display\">|S|</script>, the complexity would reduce because the number of iterations would be <script type=\"math/tex; mode=display\">2*|filtered\\_S| + |S| + |T|</script>.</li> \n   <li>Space Complexity : <script type=\"math/tex; mode=display\">O(|S| + |T|)</script>. <br><br></li> \n  </ul> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/godayaldivya/\">@godayaldivya</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 75,
    "article_live": false,
    "title": "Sort Colors",
    "title_slug": "sort-colors",
    "content": "<p>Given an array with <em>n</em> objects colored red, white or blue, sort them <strong><a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\">in-place</a>&nbsp;</strong>so that objects of the same color are adjacent, with the colors in the order red, white and blue.</p>\r\n\r\n<p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p>\r\n\r\n<p><strong>Note:</strong>&nbsp;You are not suppose to use the library&#39;s sort function for this problem.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [2,0,2,1,1,0]\r\n<strong>Output:</strong> [0,0,1,1,2,2]</pre>\r\n\r\n<p><strong>Follow up:</strong></p>\r\n\r\n<ul>\r\n\t<li>A rather straight forward solution is a two-pass algorithm using counting sort.<br />\r\n\tFirst, iterate the array counting number of 0&#39;s, 1&#39;s, and 2&#39;s, then overwrite array with total number of 0&#39;s, then 1&#39;s and followed by 2&#39;s.</li>\r\n\t<li>Could you come up with a&nbsp;one-pass algorithm using only constant space?</li>\r\n</ul>\r\n",
    "tags": "Array, Two Pointers, Sort",
    "difficulty": 2,
    "frontend_article_id": 75
},
{
    "frontend_question_id": 74,
    "article_live": false,
    "title": "Search a 2D Matrix",
    "title_slug": "search-a-2d-matrix",
    "content": "<p>Write an efficient algorithm that searches for a value in an <em>m</em> x <em>n</em> matrix. This matrix has the following properties:</p>\r\n\r\n<ul>\r\n\t<li>Integers in each row are sorted from left to right.</li>\r\n\t<li>The first integer of each row is greater than the last integer of the previous row.</li>\r\n</ul>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>\r\nmatrix = [\r\n  [1,   3,  5,  7],\r\n  [10, 11, 16, 20],\r\n  [23, 30, 34, 50]\r\n]\r\ntarget = 3\r\n<strong>Output:</strong> true\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>\r\nmatrix = [\r\n  [1,   3,  5,  7],\r\n  [10, 11, 16, 20],\r\n  [23, 30, 34, 50]\r\n]\r\ntarget = 13\r\n<strong>Output:</strong> false</pre>\r\n",
    "tags": "Array, Binary Search",
    "difficulty": 2,
    "frontend_article_id": 74
},
{
    "frontend_question_id": 73,
    "article_live": true,
    "article_slug": "set-matrix-zeroes",
    "title": "Set Matrix Zeroes",
    "title_slug": "set-matrix-zeroes",
    "content": "<p>Given a <em>m</em> x <em>n</em> matrix, if an element is 0, set its entire row and column to 0. Do it <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\"><strong>in-place</strong></a>.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> \r\n[\r\n&nbsp; [1,1,1],\r\n&nbsp; [1,0,1],\r\n&nbsp; [1,1,1]\r\n]\r\n<strong>Output:</strong> \r\n[\r\n&nbsp; [1,0,1],\r\n&nbsp; [0,0,0],\r\n&nbsp; [1,0,1]\r\n]\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> \r\n[\r\n&nbsp; [0,1,2,0],\r\n&nbsp; [3,4,5,2],\r\n&nbsp; [1,3,1,5]\r\n]\r\n<strong>Output:</strong> \r\n[\r\n&nbsp; [0,0,0,0],\r\n&nbsp; [0,4,5,0],\r\n&nbsp; [0,3,1,0]\r\n]\r\n</pre>\r\n\r\n<p><strong>Follow up:</strong></p>\r\n\r\n<ul>\r\n\t<li>A straight forward solution using O(<em>m</em><em>n</em>) space is probably a bad idea.</li>\r\n\t<li>A simple improvement uses O(<em>m</em> + <em>n</em>) space, but still not the best solution.</li>\r\n\t<li>Could you devise a constant space solution?</li>\r\n</ul>\r\n",
    "tags": "Array",
    "difficulty": 2,
    "frontend_article_id": 73,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-additional-memory-approach\">Approach 1: Additional Memory Approach</a></li> \n      <li><a href=\"#approach-2-brute-o1-space\">Approach 2: Brute O(1) space.</a></li> \n      <li><a href=\"#approach-3-o1-space-efficient-solution\">Approach 3: O(1) Space, Efficient Solution</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <p>The question seems to be pretty simple but the trick here is that we need to modify the given matrix in place i.e. our space complexity needs to <script type=\"math/tex; mode=display\">O(1)</script>.</p> \n  <p>We will go through three different approaches to the question. The first approach makes use of additional memory while the other two don't. <br> <br></p> \n  <hr> \n  <h4 id=\"approach-1-additional-memory-approach\">Approach 1: Additional Memory Approach</h4> \n  <p><strong>Intuition</strong></p> \n  <p>If any cell of the matrix has a zero we can record its row and column number. All the cells of this recorded row and column can be marked zero in the next iteration.</p> \n  <p><strong>Algorithm</strong></p> \n  <ol> \n   <li>We make a pass over our original array and look for zero entries.</li> \n   <li>If we find that an entry at <code>[i, j]</code> is 0, then we need to record somewhere the row <code>i</code> and column <code>j</code>.</li> \n   <li> <p>So, we use two <code>sets</code>, one for the rows and one for the columns. </p><pre>    if cell[i][j] == 0 {\n        row_set.add(i)\n        column_set.add(j)\n    }</pre><p></p> </li> \n   <li> <p>Finally, we iterate over the original matrix. For every cell we check if the row <code>r</code> or column <code>c</code> had been marked earlier. If any of them was marked, we set the value in the cell to 0. </p><pre>    if r in row_set or c in column_set {\n        cell[r][c] = 0\n    }</pre><p></p> </li> \n  </ol> \n  <iframe src=\"https://leetcode.com/playground/kPV6bYHr/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"kPV6bYHr\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(M \\times N)</script> where M and N are the number of rows and columns respectively.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(M + N)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-brute-o1-space\">Approach 2: Brute O(1) space.</h4> \n  <p><strong>Intuition</strong></p> \n  <p>In the above approach we use additional memory to keep a track of rows and columns which need to be set to zero. This additional use of space can be avoided by manipulating the original array instead. </p> \n  <p><strong>Algorithm</strong></p> \n  <ol> \n   <li>Iterate over the original array and if we find an entry, say <code>cell[i][j]</code> to be 0, then we iterate over row <code>i</code> and column <code>j</code> separately and set all the <strong>non zero</strong> elements to some high negative dummy value (say <code>-1000000</code>). Note, choosing the right dummy value for your solution is dependent on the constraints of the problem. Any value outside the range of permissible values in the matrix will work as a dummy value. </li> \n   <li>Finally, we iterate over the original matrix and if we find an entry to be equal to the high negative value (constant defined initially in the code as <code>MODIFIED</code>), then we set the value in the cell to 0.</li> \n  </ol> \n  <iframe src=\"https://leetcode.com/playground/3qUZbzut/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"3qUZbzut\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time Complexity : <script type=\"math/tex; mode=display\">O((M \\times N) \\times (M + N))</script> where M and N are the number of rows and columns respectively. Even though this solution avoids using space, but is very inefficient since in worst case for every cell we might have to zero out its corresponding row and column. Thus for all <script type=\"math/tex; mode=display\">(M \\times N)</script> cells zeroing out <script type=\"math/tex; mode=display\">(M +  N)</script> cells. </li> \n   <li>Space Complexity : <script type=\"math/tex; mode=display\">O(1)</script> <br> <br></li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-o1-space-efficient-solution\">Approach 3: O(1) Space, Efficient Solution</h4> \n  <p><strong>Intuition</strong></p> \n  <p>The inefficiency in the second approach is that we might be repeatedly setting a row or column even if it was set to zero already. We can avoid this by postponing the step of setting a row or a column to zeroes.</p> \n  <blockquote> \n   <p>We can rather use the first cell of every row and column as a flag. This flag would determine whether a row or column has been set to zero. This means for every cell instead of going to <script type=\"math/tex; mode=display\">M+N</script> cells and setting it to zero we just set the flag in two cells.</p> \n  </blockquote> \n  <pre>if cell[i][j] == 0 {\n    cell[i][0] = 0\n    cell[0][j] = 0\n}\n</pre> \n  <p>These flags are used later to update the matrix. If the first cell of a row is set to zero this means the row should be marked zero. If the first cell of a column is set to zero this means the column should be marked zero.</p> \n  <p><strong>Algorithm</strong></p> \n  <ol> \n   <li> <p>We iterate over the matrix and we mark the first cell of a row <code>i</code> and first cell of a column <code>j</code>, if the condition in the pseudo code above is satisfied. i.e. if <code>cell[i][j] == 0</code>.</p> </li> \n   <li> <p>The first cell of row and column for the first row and first column is the same i.e. <code>cell[0][0]</code>. Hence, we use an additional variable to tell us if the first column had been marked or not and the <code>cell[0][0]</code> would be used to tell the same for the first row.</p> </li> \n   <li> <p>Now, we iterate over the original matrix starting from second row and second column i.e. <code>matrix[1][1]</code> onwards. For every cell we check if the row <code>r</code> or column <code>c</code> had been marked earlier by checking the respective first row cell or first column cell. If any of them was marked, we set the value in the cell to 0. Note the first row and first column serve as the <code>row_set</code> and <code>column_set</code> that we used in the first approach.</p> </li> \n   <li> <p>We then check if <code>cell[0][0] == 0</code>, if this is the case, we mark the first row as zero.</p> </li> \n   <li> <p>And finally, we check if the first column was marked, we make all entries in it as zeros.</p> </li> \n  </ol> \n  <p>!?!../Documents/73_Matrix_Zeroes.json:1000,400!?!</p> \n  <p>In the above animation we iterate all the cells and mark the corresponding first row/column cell incase of a cell with zero value.</p> \n  <p></p>\n  <center> \n   <img src=\"../Figures/73/MatrixZeros_18_1.png\" width=\"400\"> \n  </center>\n  <p></p> \n  <p>We iterate the matrix we got from the above steps and mark respective cells zeroes.</p> \n  <p></p>\n  <center> \n   <img src=\"../Figures/73/MatrixZeros_18_2.png\" width=\"400\"> \n  </center>\n  <p></p> \n  <p><br></p> \n  <iframe src=\"https://leetcode.com/playground/2tGE5XF8/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"2tGE5XF8\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time Complexity : <script type=\"math/tex; mode=display\">O(M \\times N)</script> </li> \n   <li>Space Complexity : <script type=\"math/tex; mode=display\">O(1)</script> </li> \n  </ul> \n  <p><br><br></p> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/godayaldivya/\">@godayaldivya</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 72,
    "article_live": false,
    "title": "Edit Distance",
    "title_slug": "edit-distance",
    "content": "<p>Given two words <em>word1</em> and <em>word2</em>, find the minimum number of operations required to convert <em>word1</em> to <em>word2</em>.</p>\r\n\r\n<p>You have the following 3 operations permitted on a word:</p>\r\n\r\n<ol>\r\n\t<li>Insert a character</li>\r\n\t<li>Delete a character</li>\r\n\t<li>Replace a character</li>\r\n</ol>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> word1 = &quot;horse&quot;, word2 = &quot;ros&quot;\r\n<strong>Output:</strong> 3\r\n<strong>Explanation:</strong> \r\nhorse -&gt; rorse (replace &#39;h&#39; with &#39;r&#39;)\r\nrorse -&gt; rose (remove &#39;r&#39;)\r\nrose -&gt; ros (remove &#39;e&#39;)\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> word1 = &quot;intention&quot;, word2 = &quot;execution&quot;\r\n<strong>Output:</strong> 5\r\n<strong>Explanation:</strong> \r\nintention -&gt; inention (remove &#39;t&#39;)\r\ninention -&gt; enention (replace &#39;i&#39; with &#39;e&#39;)\r\nenention -&gt; exention (replace &#39;n&#39; with &#39;x&#39;)\r\nexention -&gt; exection (replace &#39;n&#39; with &#39;c&#39;)\r\nexection -&gt; execution (insert &#39;u&#39;)\r\n</pre>\r\n",
    "tags": "String, Dynamic Programming",
    "difficulty": 3,
    "frontend_article_id": 72
},
{
    "frontend_question_id": 71,
    "article_live": false,
    "title": "Simplify Path",
    "title_slug": "simplify-path",
    "content": "<p>Given an absolute path for a file (Unix-style), simplify it.&nbsp;</p>\r\n\r\n<p>For example,<br />\r\n<strong>path</strong> = <code>&quot;/home/&quot;</code>, =&gt; <code>&quot;/home&quot;</code><br />\r\n<strong>path</strong> = <code>&quot;/a/./b/../../c/&quot;</code>, =&gt; <code>&quot;/c&quot;</code><br />\r\n<strong>path</strong> = <code>&quot;/a/../../b/../c//.//&quot;</code>, =&gt; <code>&quot;/c&quot;</code><br />\r\n<strong>path</strong> = <code>&quot;/a//b////c/d//././/..&quot;</code>, =&gt; <code>&quot;/a/b/c&quot;</code></p>\r\n\r\n<p>In a UNIX-style file system, a period (&#39;.&#39;) refers to the current directory, so it can be ignored in a simplified path. Additionally, a double period (&quot;..&quot;) moves up a directory, so it cancels out whatever the last directory was. For more information, look here:&nbsp;<a href=\"https://en.wikipedia.org/wiki/Path_(computing)#Unix_style\">https://en.wikipedia.org/wiki/Path_(computing)#Unix_style</a></p>\r\n\r\n<p><strong>Corner Cases:</strong></p>\r\n\r\n<ul>\r\n\t<li>Did you consider the case where <strong>path</strong> = <code>&quot;/../&quot;</code>?<br />\r\n\tIn this case, you should return <code>&quot;/&quot;</code>.</li>\r\n\t<li>Another corner case is the path might contain multiple slashes <code>&#39;/&#39;</code> together, such as <code>&quot;/home//foo/&quot;</code>.<br />\r\n\tIn this case, you should ignore redundant slashes and return <code>&quot;/home/foo&quot;</code>.</li>\r\n</ul>\r\n",
    "tags": "String, Stack",
    "difficulty": 2,
    "frontend_article_id": 71
},
{
    "frontend_question_id": 70,
    "article_live": true,
    "article_slug": "climbing-stairs",
    "title": "Climbing Stairs",
    "title_slug": "climbing-stairs",
    "content": "<p>You are climbing a stair case. It takes <em>n</em> steps to reach to the top.</p>\r\n\r\n<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>\r\n\r\n<p><strong>Note:</strong> Given <em>n</em> will be a positive integer.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 2\r\n<strong>Output:</strong> 2\r\n<strong>Explanation:</strong> There are two ways to climb to the top.\r\n1. 1 step + 1 step\r\n2. 2 steps\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 3\r\n<strong>Output:</strong> 3\r\n<strong>Explanation:</strong> There are three ways to climb to the top.\r\n1. 1 step + 1 step + 1 step\r\n2. 1 step + 2 steps\r\n3. 2 steps + 1 step\r\n</pre>\r\n",
    "tags": "Dynamic Programming",
    "difficulty": 1,
    "frontend_article_id": 70,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#summary\">Summary</a></li> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force\">Approach 1: Brute Force</a></li> \n      <li><a href=\"#approach-2-recursion-with-memorization\">Approach 2: Recursion with memorization</a></li> \n      <li><a href=\"#approach-3-dynamic-programming\">Approach 3: Dynamic Programming</a></li> \n      <li><a href=\"#approach-4-fibonacci-number\">Approach 4: Fibonacci Number</a></li> \n      <li><a href=\"#approach-5-binets-method\">Approach 5: Binets Method</a></li> \n      <li><a href=\"#approach-6-fibonacci-formula\">Approach 6: Fibonacci Formula</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"summary\">Summary</h2> \n  <p>You are climbing a stair case. It takes n steps to reach to the top.</p> \n  <p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force\">Approach 1: Brute Force</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In this brute force approach we take all possible step combinations i.e. 1 and 2, at every step. At every step we are calling the function <script type=\"math/tex; mode=display\">climbStairs</script> for step <script type=\"math/tex; mode=display\">1</script> and <script type=\"math/tex; mode=display\">2</script>, and return the sum of returned values of both functions.</p> \n  <p> <script type=\"math/tex; mode=display\">\nclimbStairs(i,n)=(i + 1, n) + climbStairs(i + 2, n)\n</script> </p> \n  <p>where <script type=\"math/tex; mode=display\">i</script> defines the current step and <script type=\"math/tex; mode=display\">n</script> defines the destination step.</p> \n  <iframe src=\"https://leetcode.com/playground/hsaTWc5g/shared\" frameborder=\"0\" width=\"100%\" height=\"293\" name=\"hsaTWc5g\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(2^n)</script>. Size of recursion tree will be <script type=\"math/tex; mode=display\">2^n</script>.</p> <p>Recursion tree for n=5 would be like this:</p> <p><img alt=\"Climbing_Stairs\" src=\"../Figures/70_Climbing_Stairs_rt.jpg\"></p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The depth of the recursion tree can go upto <script type=\"math/tex; mode=display\">n</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-recursion-with-memorization\">Approach 2: Recursion with memorization</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In the previous approach we are redundantly calculating the result for every step. Instead, we can store the result at each step in <script type=\"math/tex; mode=display\">memo</script> array and directly returning the result from the memo array whenever that function is called again.</p> \n  <p>In this way we are pruning recursion tree with the help of <script type=\"math/tex; mode=display\">memo</script> array and reducing the size of recursion tree upto <script type=\"math/tex; mode=display\">n</script>.</p> \n  <iframe src=\"https://leetcode.com/playground/scquGskN/shared\" frameborder=\"0\" width=\"100%\" height=\"378\" name=\"scquGskN\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Size of recursion tree can go upto <script type=\"math/tex; mode=display\">n</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The depth of recursion tree can go upto <script type=\"math/tex; mode=display\">n</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-dynamic-programming\">Approach 3: Dynamic Programming</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>As we can see this problem can be broken into subproblems, and it contains the optimal substructure property i.e. its optimal solution can be constructed efficiently from optimal solutions of its subproblems, we can use dynamic programming to solve this problem.</p> \n  <p>One can reach <script type=\"math/tex; mode=display\">i^{th}</script> step in one of the two ways:</p> \n  <ol> \n   <li> <p>Taking a single step from <script type=\"math/tex; mode=display\">(i-1)^{th}</script> step.</p> </li> \n   <li> <p>Taking a step of <script type=\"math/tex; mode=display\">2</script> from <script type=\"math/tex; mode=display\">(i-2)^{th}</script> step.</p> </li> \n  </ol> \n  <p>So, the total number of ways to reach <script type=\"math/tex; mode=display\">i^{th}</script> is equal to sum of ways of reaching <script type=\"math/tex; mode=display\">(i-1)^{th}</script> step and ways of reaching <script type=\"math/tex; mode=display\">(i-2)^{th}</script> step.</p> \n  <p>Let <script type=\"math/tex; mode=display\">dp[i]</script> denotes the number of ways to reach on <script type=\"math/tex; mode=display\">i^{th}</script> step:</p> \n  <p> <script type=\"math/tex; mode=display\">\ndp[i]=dp[i-1]+dp[i-2]\n</script> </p> \n  <p>Example:</p> \n  <!--![Climbing_Stairs](../Figures/70_Climbing_Stairs.gif)--> \n  <p>!?!../Documents/70_Climbing_Stairs.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/XVWef4ek/shared\" frameborder=\"0\" width=\"100%\" height=\"293\" name=\"XVWef4ek\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Single loop upto <script type=\"math/tex; mode=display\">n</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. <script type=\"math/tex; mode=display\">dp</script> array of size <script type=\"math/tex; mode=display\">n</script> is used. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-4-fibonacci-number\">Approach 4: Fibonacci Number</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In the above approach we have used <script type=\"math/tex; mode=display\">dp</script> array where <script type=\"math/tex; mode=display\">dp[i]=dp[i-1]+dp[i-2]</script>. It can be easily analysed that <script type=\"math/tex; mode=display\">dp[i]</script> is nothing but <script type=\"math/tex; mode=display\">i^{th}</script> fibonacci number.</p> \n  <p> <script type=\"math/tex; mode=display\">\nFib(n)=Fib(n-1)+Fib(n-2)\n</script> </p> \n  <p>Now we just have to find <script type=\"math/tex; mode=display\">n^{th}</script> number of the fibonacci series having <script type=\"math/tex; mode=display\">1</script> and <script type=\"math/tex; mode=display\">2</script> their first and second term respectively, i.e. <script type=\"math/tex; mode=display\">Fib(1)=1</script> and <script type=\"math/tex; mode=display\">Fib(2)=2</script>.</p> \n  <iframe src=\"https://leetcode.com/playground/T5uQ67Np/shared\" frameborder=\"0\" width=\"100%\" height=\"310\" name=\"T5uQ67Np\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Single loop upto <script type=\"math/tex; mode=display\">n</script> is required to calculate <script type=\"math/tex; mode=display\">n^{th}</script> fibonacci number.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant space is used. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-5-binets-method\">Approach 5: Binets Method</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>This is an interesting solution which uses matrix multiplication to obtain the <script type=\"math/tex; mode=display\">n^{th}</script> Fibonacci Number. The matrix takes the following form:</p> \n  <p> <script type=\"math/tex; mode=display\">\n\\left[ {\\begin{array}{cc} F_{n+1} & F_n \\\\  F_n & F_{n-1}     \\end{array} } \\right] = \\left[ {\\begin{array}{cc} 1 & 1 \\\\  1 & 0     \\end{array} } \\right]\n</script> </p> \n  <p>Let's say <script type=\"math/tex; mode=display\">Q=\\left[ {\\begin{array}{cc} F_{n+1} & F_n \\\\  F_n & F_{n-1}     \\end{array} } \\right]</script>. As per the method, the <script type=\"math/tex; mode=display\">n^{th}</script> Fibonacci Number is given by <script type=\"math/tex; mode=display\">Q^{n-1}[0,0]</script>.</p> \n  <p>Let's look at the proof of this method.</p> \n  <p>We can prove this method using Mathematical Induction. We know, this matrix gives the correct result for the <script type=\"math/tex; mode=display\">3^{rd}</script> term(base case). Since <script type=\"math/tex; mode=display\">Q^2 = \\left[ {\\begin{array}{cc} 2 & 1 \\\\  1 & 1     \\end{array} } \\right]</script>. This proves that the base case holds.</p> \n  <p>Assume that this method holds for finding the <script type=\"math/tex; mode=display\">n^{th}</script> Fibonacci Number, i.e. <script type=\"math/tex; mode=display\">F_n=Q^{n-1}[0,0]</script>, where <script type=\"math/tex; mode=display\">\nQ^{n-1}=\\left[ {\\begin{array}{cc} F_{n} & F_{n-1} \\\\  F_{n-1} & F_{n-2}     \\end{array} } \\right]\n</script> </p> \n  <p>Now, we need to prove that with the above two conditions holding true, the method is valid for finding the <script type=\"math/tex; mode=display\">(n+1)^{th}</script> Fibonacci Number, i.e. <script type=\"math/tex; mode=display\">F_{n+1}=Q^{n}[0,0]</script>.</p> \n  <p>Proof: <script type=\"math/tex; mode=display\">Q^{n} = \\left[ {\\begin{array}{cc} F_{n} & F_{n-1} \\\\  F_{n-1} & F_{n-2}     \\end{array} } \\right]\\left[ {\\begin{array}{cc} 1 & 1 \\\\  1 & 0     \\end{array} } \\right]</script>. <script type=\"math/tex; mode=display\">Q^{n} = \\left[ {\\begin{array}{cc} F_{n}+F_{n-1} & F_n \\\\  F_{n-1}+F_{n-2} & F_{n-1}    \\end{array} } \\right]</script> <script type=\"math/tex; mode=display\">Q^{n} = \\left[ {\\begin{array}{cc} F_{n+1} & F_n \\\\  F_n & F_{n-1}     \\end{array} } \\right]</script> </p> \n  <p>Thus, <script type=\"math/tex; mode=display\">F_{n+1}=Q^{n}[0,0]</script>. This completes the proof of this method.</p> \n  <p>The only variation we need to do for our problem is that we need to modify the initial terms to 2 and 1 instead of 1 and 0 in the Fibonacci series. Or, another way is to use the same initial <script type=\"math/tex; mode=display\">Q</script> matrix and use <script type=\"math/tex; mode=display\">result = Q^{n}[0,0]</script> to get the final result. This happens because the initial terms we have to use are the 2nd and 3rd terms of the otherwise normal Fibonacci Series.</p> \n  <p><iframe src=\"https://leetcode.com/playground/MWidkJkG/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"MWidkJkG\"></iframe></p> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(log(n))</script>. Traversing on <script type=\"math/tex; mode=display\">log(n)</script> bits.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant space is used.</p> </li> \n  </ul> \n  <p>Proof of Time Complexity:</p> \n  <p>Let's say there is a matrix <script type=\"math/tex; mode=display\">M</script> to be raised to power <script type=\"math/tex; mode=display\">n</script>. Suppose, <script type=\"math/tex; mode=display\">n</script> is the power of 2. Thus, <script type=\"math/tex; mode=display\">n = 2^i</script>, <script type=\"math/tex; mode=display\">i\\in\\mathbb{N}</script>, where <script type=\"math/tex; mode=display\">\\mathbb{N}</script> represents the set of natural numbers(including 0). We can represent in the form of a tree:</p> \n  <p align=\"center\"><img alt=\"Climbing Stairs\" src=\"../Figures/70_Climbing_Stairs.PNG\"></p> \n  <p>Meaning that: <script type=\"math/tex; mode=display\">M^n = M^{n/2}.M^{n/2} = .... = \\prod_{1}^{n} M^{1}</script> </p> \n  <p>So, to calculate <script type=\"math/tex; mode=display\">M^{n}</script> matrix, we should calculate <script type=\"math/tex; mode=display\">M^{n/2}</script> matrix and multiply it by itself. To calculate <script type=\"math/tex; mode=display\">M^{n/2}</script> we would have to do the same with <script type=\"math/tex; mode=display\">M^{n/4}</script> and so on.</p> \n  <p>Obviously, the tree height is <script type=\"math/tex; mode=display\">log_{2}n</script>.</p> \n  <p>Let’s estimate <script type=\"math/tex; mode=display\">M^{n}</script> calculation time. <script type=\"math/tex; mode=display\">M</script> matrix is of the same size in any power . Therefore, we can perform the multiplication of two matrices in any power in <script type=\"math/tex; mode=display\">O(1)</script>. We should perform <script type=\"math/tex; mode=display\">log_2{n}</script> of such multiplications. So, <script type=\"math/tex; mode=display\">M^{n}</script> calculation complexity is <script type=\"math/tex; mode=display\">O(log_{2}n)</script>.</p> \n  <p>In case, the number <script type=\"math/tex; mode=display\">n</script> is not a power of two, we can break it in terms of powers of 2 using its binary representation:</p> \n  <p> <script type=\"math/tex; mode=display\">\nn= \\sum_{p\\in P} 2^{p}, \\text{where }P\\subset\\mathbb{N}\n</script> </p> \n  <p>Thus, we can obtain the final result using:</p> \n  <p> <script type=\"math/tex; mode=display\">\nM^{n} = \\prod_{p\\in P} M^{2^{p}}\n</script> </p> \n  <p>This is the method we've used in our implementation. Again, the complexity remains <script type=\"math/tex; mode=display\">O(log_{2}n)</script> as we have limited the number of multiplications to <script type=\"math/tex; mode=display\">O(log_{2}n)</script>. <br> <br></p> \n  <hr> \n  <h4 id=\"approach-6-fibonacci-formula\">Approach 6: Fibonacci Formula</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>We can find <script type=\"math/tex; mode=display\">n^{th}</script> fibonacci number using this formula:</p> \n  <p> <script type=\"math/tex; mode=display\">\nF_n = 1/\\sqrt{5}\\left[ \\left(\\frac{1+\\sqrt{5}}{2}\\right)^{n} - \\left(\\frac{1-\\sqrt{5}}{2}\\right)^{n} \\right]\n</script> </p> \n  <p>For the given problem, the Fibonacci sequence is defined by <script type=\"math/tex; mode=display\">F_0 = 1</script>, <script type=\"math/tex; mode=display\">F_1= 1</script>, <script type=\"math/tex; mode=display\">F_1= 2</script>, <script type=\"math/tex; mode=display\">F_{n+2}= F_{n+1} + F_n</script>. A standard method of trying to solve such recursion formulas is assume <script type=\"math/tex; mode=display\">F_n</script> of the form <script type=\"math/tex; mode=display\">F_n= a^n</script>. Then, of course, <script type=\"math/tex; mode=display\">F_{n+1} = a^{n+1}</script> and <script type=\"math/tex; mode=display\">F_{n+2}= a^{n+2}</script> so the equation becomes <script type=\"math/tex; mode=display\">a^{n+2}= a^{n+1}+ a^n</script>. If we divide the entire equation by an we arrive at <script type=\"math/tex; mode=display\">a^2= a + 1</script> or the quadratic equation <script type=\"math/tex; mode=display\">a^2 - a- 1= 0</script>.</p> \n  <p>Solving this by the quadratic formula, we get:</p> \n  <p> <script type=\"math/tex; mode=display\">\na=1/\\sqrt{5}\\left(\\left(\\frac{1\\pm \\sqrt{5}}{2}\\right)\\right)\n</script> </p> \n  <p>The general solution, thus takes the form:</p> \n  <p> <script type=\"math/tex; mode=display\">\nF_n = A\\left(\\frac{1+\\sqrt{5}}{2}\\right)^{n} + B\\left(\\frac{1-\\sqrt{5}}{2}\\right)^{n}\n</script> </p> \n  <p>For <script type=\"math/tex; mode=display\">n=0</script>, we get <script type=\"math/tex; mode=display\">A + B = 1</script> </p> \n  <p>For <script type=\"math/tex; mode=display\">n=1</script>, we get <script type=\"math/tex; mode=display\">A\\left(\\frac{1+\\sqrt{5}}{2}\\right) + B\\left(\\frac{1-\\sqrt{5}}{2}\\right) = 1</script> </p> \n  <p>Solving the above equations, we get:</p> \n  <p> <script type=\"math/tex; mode=display\">\nA = \\left(\\frac{1+\\sqrt{5}}{2\\sqrt{5}}\\right), B = \\left(\\frac{1-\\sqrt{5}}{2\\sqrt{5}}\\right)\n</script> </p> \n  <p>Putting these values of <script type=\"math/tex; mode=display\">A</script> and <script type=\"math/tex; mode=display\">B</script> in the above general solution equation, we get:</p> \n  <p> <script type=\"math/tex; mode=display\">\nF_n = 1/\\sqrt{5}\\left( \\left(\\frac{1+\\sqrt{5}}{2}\\right)^{n+1} - \\left(\\frac{1-\\sqrt{5}}{2}\\right)^{n+1} \\right)\n</script> </p> \n  <iframe src=\"https://leetcode.com/playground/M5yAazaU/shared\" frameborder=\"0\" width=\"100%\" height=\"174\" name=\"M5yAazaU\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(log(n))</script>. <script type=\"math/tex; mode=display\">pow</script> method takes <script type=\"math/tex; mode=display\">log(n)</script> time.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant space is used.</p> </li> \n  </ul> \n </div> \n</div>"
},
{
    "frontend_question_id": 69,
    "article_live": false,
    "title": "Sqrt(x)",
    "title_slug": "sqrtx",
    "content": "<p>Implement <code>int sqrt(int x)</code>.</p>\r\n\r\n<p>Compute and return the square root of <em>x</em>, where&nbsp;<em>x</em>&nbsp;is guaranteed to be a non-negative integer.</p>\r\n\r\n<p>Since the return type&nbsp;is an integer, the decimal digits are truncated and only the integer part of the result&nbsp;is returned.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 4\r\n<strong>Output:</strong> 2\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 8\r\n<strong>Output:</strong> 2\r\n<strong>Explanation:</strong> The square root of 8 is 2.82842..., and since \r\n&nbsp;            the decimal part is truncated, 2 is returned.\r\n</pre>\r\n",
    "tags": "Math, Binary Search",
    "difficulty": 1,
    "frontend_article_id": 69
},
{
    "frontend_question_id": 68,
    "article_live": false,
    "title": "Text Justification",
    "title_slug": "text-justification",
    "content": "<p>Given an array of words and a width&nbsp;<em>maxWidth</em>, format the text such that each line has exactly <em>maxWidth</em> characters and is fully (left and right) justified.</p>\r\n\r\n<p>You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces <code>&#39; &#39;</code> when necessary so that each line has exactly <em>maxWidth</em> characters.</p>\r\n\r\n<p>Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.</p>\r\n\r\n<p>For the last line of text, it should be left justified and no <strong>extra</strong> space is inserted between words.</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>A word is defined as a character sequence consisting&nbsp;of non-space characters only.</li>\r\n\t<li>Each word&#39;s length is&nbsp;guaranteed to be greater than 0 and not exceed <em>maxWidth</em>.</li>\r\n\t<li>The input array <code>words</code>&nbsp;contains at least one word.</li>\r\n</ul>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>\r\nwords = [&quot;This&quot;, &quot;is&quot;, &quot;an&quot;, &quot;example&quot;, &quot;of&quot;, &quot;text&quot;, &quot;justification.&quot;]\r\nmaxWidth = 16\r\n<strong>Output:</strong>\r\n[\r\n&nbsp; &nbsp;&quot;This &nbsp; &nbsp;is &nbsp; &nbsp;an&quot;,\r\n&nbsp; &nbsp;&quot;example &nbsp;of text&quot;,\r\n&nbsp; &nbsp;&quot;justification. &nbsp;&quot;\r\n]\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>\r\nwords = [&quot;What&quot;,&quot;must&quot;,&quot;be&quot;,&quot;acknowledgment&quot;,&quot;shall&quot;,&quot;be&quot;]\r\nmaxWidth = 16\r\n<strong>Output:</strong>\r\n[\r\n&nbsp; &quot;What &nbsp; must &nbsp; be&quot;,\r\n&nbsp; &quot;acknowledgment &nbsp;&quot;,\r\n&nbsp; &quot;shall be &nbsp; &nbsp; &nbsp; &nbsp;&quot;\r\n]\r\n<strong>Explanation:</strong> Note that the last line is &quot;shall be    &quot; instead of &quot;shall     be&quot;,\r\n&nbsp;            because the last line must be left-justified instead of fully-justified.\r\n             Note that the second line is also left-justified becase it contains only one word.\r\n</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>\r\nwords = [&quot;Science&quot;,&quot;is&quot;,&quot;what&quot;,&quot;we&quot;,&quot;understand&quot;,&quot;well&quot;,&quot;enough&quot;,&quot;to&quot;,&quot;explain&quot;,\r\n&nbsp;        &quot;to&quot;,&quot;a&quot;,&quot;computer.&quot;,&quot;Art&quot;,&quot;is&quot;,&quot;everything&quot;,&quot;else&quot;,&quot;we&quot;,&quot;do&quot;]\r\nmaxWidth = 20\r\n<strong>Output:</strong>\r\n[\r\n&nbsp; &quot;Science &nbsp;is &nbsp;what we&quot;,\r\n  &quot;understand &nbsp; &nbsp; &nbsp;well&quot;,\r\n&nbsp; &quot;enough to explain to&quot;,\r\n&nbsp; &quot;a &nbsp;computer. &nbsp;Art is&quot;,\r\n&nbsp; &quot;everything &nbsp;else &nbsp;we&quot;,\r\n&nbsp; &quot;do &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot;\r\n]\r\n</pre>\r\n",
    "tags": "String",
    "difficulty": 3,
    "frontend_article_id": 68
},
{
    "frontend_question_id": 67,
    "article_live": false,
    "title": "Add Binary",
    "title_slug": "add-binary",
    "content": "<p>Given two binary strings, return their sum (also a binary string).</p>\r\n\r\n<p>The input strings are both <strong>non-empty</strong> and contains only characters <code>1</code> or&nbsp;<code>0</code>.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> a = &quot;11&quot;, b = &quot;1&quot;\r\n<strong>Output:</strong> &quot;100&quot;</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> a = &quot;1010&quot;, b = &quot;1011&quot;\r\n<strong>Output:</strong> &quot;10101&quot;</pre>\r\n",
    "tags": "Math, String",
    "difficulty": 1,
    "frontend_article_id": 67
},
{
    "frontend_question_id": 66,
    "article_live": false,
    "title": "Plus One",
    "title_slug": "plus-one",
    "content": "<p>Given a <strong>non-empty</strong> array of digits&nbsp;representing a non-negative integer, plus one to the integer.</p>\r\n\r\n<p>The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.</p>\r\n\r\n<p>You may assume the integer does not contain any leading zero, except the number 0 itself.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [1,2,3]\r\n<strong>Output:</strong> [1,2,4]\r\n<strong>Explanation:</strong> The array represents the integer 123.\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [4,3,2,1]\r\n<strong>Output:</strong> [4,3,2,2]\r\n<strong>Explanation:</strong> The array represents the integer 4321.\r\n</pre>\r\n",
    "tags": "Array, Math",
    "difficulty": 1,
    "frontend_article_id": 66
},
{
    "frontend_question_id": 65,
    "article_live": false,
    "title": "Valid Number",
    "title_slug": "valid-number",
    "content": "<p>Validate if a given string can be interpreted as&nbsp;a decimal number.</p>\r\n\r\n<p>Some examples:<br />\r\n<code>&quot;0&quot;</code> =&gt; <code>true</code><br />\r\n<code>&quot; 0.1 &quot;</code> =&gt; <code>true</code><br />\r\n<code>&quot;abc&quot;</code> =&gt; <code>false</code><br />\r\n<code>&quot;1 a&quot;</code> =&gt; <code>false</code><br />\r\n<code>&quot;2e10&quot;</code> =&gt; <code>true</code><br />\r\n<code>&quot; -90e3&nbsp; &nbsp;&quot;</code> =&gt; <code>true</code><br />\r\n<code>&quot; 1e&quot;</code> =&gt; <code>false</code><br />\r\n<code>&quot;e3&quot;</code> =&gt; <code>false</code><br />\r\n<code>&quot; 6e-1&quot;</code> =&gt; <code>true</code><br />\r\n<code>&quot; 99e2.5&nbsp;&quot;</code> =&gt; <code>false</code><br />\r\n<code>&quot;53.5e93&quot;</code> =&gt; <code>true</code><br />\r\n<code>&quot; --6 &quot;</code> =&gt; <code>false</code><br />\r\n<code>&quot;-+3&quot;</code> =&gt; <code>false</code><br />\r\n<code>&quot;95a54e53&quot;</code> =&gt; <code>false</code></p>\r\n\r\n<p><strong>Note:</strong> It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one. However, here is a list of characters that can be in a valid decimal number:</p>\r\n\r\n<ul>\r\n\t<li>Numbers 0-9</li>\r\n\t<li>Exponent - &quot;e&quot;</li>\r\n\t<li>Positive/negative sign - &quot;+&quot;/&quot;-&quot;</li>\r\n\t<li>Decimal point - &quot;.&quot;</li>\r\n</ul>\r\n\r\n<p>Of course, the context of these characters also matters in the input.</p>\r\n\r\n<p><strong>Update (2015-02-10):</strong><br />\r\nThe signature of the <code>C++</code> function had been updated. If you still see your function signature accepts a <code>const char *</code> argument, please click the reload button to reset your code definition.</p>\r\n",
    "tags": "Math, String",
    "difficulty": 3,
    "frontend_article_id": 65
},
{
    "frontend_question_id": 64,
    "article_live": true,
    "article_slug": "minimum-path-sum",
    "title": "Minimum Path Sum",
    "title_slug": "minimum-path-sum",
    "content": "<p>Given a <em>m</em> x <em>n</em> grid filled with non-negative numbers, find a path from top left to bottom right which <em>minimizes</em> the sum of all numbers along its path.</p>\r\n\r\n<p><strong>Note:</strong> You can only move either down or right at any point in time.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>\r\n[\r\n&nbsp; [1,3,1],\r\n  [1,5,1],\r\n  [4,2,1]\r\n]\r\n<strong>Output:</strong> 7\r\n<strong>Explanation:</strong> Because the path 1&rarr;3&rarr;1&rarr;1&rarr;1 minimizes the sum.\r\n</pre>\r\n",
    "tags": "Array, Dynamic Programming",
    "difficulty": 2,
    "frontend_article_id": 64,
    "article_content": ""
},
{
    "frontend_question_id": 63,
    "article_live": true,
    "article_slug": "unique-paths-ii",
    "title": "Unique Paths II",
    "title_slug": "unique-paths-ii",
    "content": "<p>A robot is located at the top-left corner of a <em>m</em> x <em>n</em> grid (marked &#39;Start&#39; in the diagram below).</p>\r\n\r\n<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked &#39;Finish&#39; in the diagram below).</p>\r\n\r\n<p>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p>\r\n\r\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png\" style=\"width: 400px; height: 183px;\" /></p>\r\n\r\n<p>An obstacle and empty space is marked as <code>1</code> and <code>0</code> respectively in the grid.</p>\r\n\r\n<p><strong>Note:</strong> <em>m</em> and <em>n</em> will be at most 100.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:\r\n</strong>[\r\n&nbsp; [0,0,0],\r\n&nbsp; [0,1,0],\r\n&nbsp; [0,0,0]\r\n]\r\n<strong>Output:</strong> 2\r\n<strong>Explanation:</strong>\r\nThere is one obstacle in the middle of the 3x3 grid above.\r\nThere are two ways to reach the bottom-right corner:\r\n1. Right -&gt; Right -&gt; Down -&gt; Down\r\n2. Down -&gt; Down -&gt; Right -&gt; Right\r\n</pre>\r\n",
    "tags": "Array, Dynamic Programming",
    "difficulty": 2,
    "frontend_article_id": 63,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-dynamic-programming\">Approach 1: Dynamic Programming</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-dynamic-programming\">Approach 1: Dynamic Programming</h4> \n  <p><strong>Intuition</strong></p> \n  <p>The robot can only move either down or right. Hence any cell in the first row can only be reached from the cell left to it.</p> \n  <p></p>\n  <center>\n   <p></p> \n   <p>!?!../Documents/63_Unique_Paths_2_1.json:500,415!?!</p> \n   <p></p>\n  </center>\n  <p></p> \n  <p>And, any cell in the first column can only be reached from the cell above it.</p> \n  <p></p>\n  <center>\n   <p></p> \n   <p>!?!../Documents/63_Unique_Paths_2_2.json:500,415!?!</p> \n   <p></p>\n  </center>\n  <p></p> \n  <p>For any other cell in the grid, we can reach it either from the cell to left of it or the cell above it.</p> \n  <p>If any cell has an obstacle, we won't let that cell contribute to any path.</p> \n  <p>We will be iterating the array from left-to-right and top-to-bottom. Thus, before reaching any cell we would have the number of ways of reaching the predecessor cells. This is what makes it a <code>Dynamic Programming</code> problem. We will be using the <code>obstacleGrid</code> array as the DP array thus not utilizing any additional space.</p> \n  <p><code>Note:</code> As per the question, cell with an obstacle has a value <code>1</code>. We would use this value to make sure if a cell needs to be included in the path or not. After that we can use the same cell to store the number of ways to reach that cell.</p> \n  <p><strong>Algorithm</strong></p> \n  <ol> \n   <li>If the first cell i.e. <code>obstacleGrid[0,0]</code> contains <code>1</code>, this means there is an obstacle in the first cell. Hence the robot won't be able to make any move and we would return the number of ways as <code>0</code>.</li> \n   <li>Otherwise, if <code>obstacleGrid[0,0]</code> has a <code>0</code> originally we set it to <code>1</code> and move ahead.</li> \n   <li>Iterate the first row. If a cell originally contains a <code>1</code>, this means the current cell has an obstacle and shouldn't contribute to any path. Hence, set the value of that cell to <code>0</code>. Otherwise, set it to the value of previous cell i.e. <code>obstacleGrid[i,j] = obstacleGrid[i,j-1]</code></li> \n   <li>Iterate the first column. If a cell originally contains a <code>1</code>, this means the current cell has an obstacle and shouldn't contribute to any path. Hence, set the value of that cell to <code>0</code>. Otherwise, set it to the value of previous cell i.e. <code>obstacleGrid[i,j] = obstacleGrid[i-1,j]</code></li> \n   <li>Now, iterate through the array starting from cell <code>obstacleGrid[1,1]</code>. If a cell originally doesn't contain any obstacle then the number of ways of reaching that cell would be the sum of number of ways of reaching the cell above it and number of ways of reaching the cell to the left of it. <pre>    obstacleGrid[i,j] = obstacleGrid[i-1,j] + obstacleGrid[i,j-1]</pre></li> \n   <li>If a cell contains an obstacle set it to <code>0</code> and continue. This is done to make sure it doesn't contribute to any other path.</li> \n  </ol> \n  <p>Following is the animation to explain the algorithm's steps: </p>\n  <center>\n   <p></p> \n   <p>!?!../Documents/63_Unique_Paths_2_3.json:500,415!?!</p> \n   <p></p>\n  </center>\n  <p></p> \n  <p><br></p> \n  <iframe src=\"https://leetcode.com/playground/bmmKXqeu/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"bmmKXqeu\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time Complexity: <script type=\"math/tex; mode=display\">O(M \\times N)</script>. The rectangular grid given to us is of size <script type=\"math/tex; mode=display\">M \\times N</script> and we process each cell just once. </li> \n   <li>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>. We are utilizing the <code>obstacleGrid</code> as the DP array. Hence, no extra space.</li> \n  </ul> \n  <p><br><br></p> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/godayaldivya/\">@godayaldivya</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 62,
    "article_live": false,
    "title": "Unique Paths",
    "title_slug": "unique-paths",
    "content": "<p>A robot is located at the top-left corner of a <em>m</em> x <em>n</em> grid (marked &#39;Start&#39; in the diagram below).</p>\r\n\r\n<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked &#39;Finish&#39; in the diagram below).</p>\r\n\r\n<p>How many possible unique paths are there?</p>\r\n\r\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png\" style=\"width: 400px; height: 183px;\" /><br />\r\n<small>Above is a 7 x 3 grid. How many possible unique paths are there?</small></p>\r\n\r\n<p><strong>Note:</strong> <em>m</em> and <em>n</em> will be at most 100.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> m = 3, n = 2\r\n<strong>Output:</strong> 3\r\n<strong>Explanation:</strong>\r\nFrom the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\r\n1. Right -&gt; Right -&gt; Down\r\n2. Right -&gt; Down -&gt; Right\r\n3. Down -&gt; Right -&gt; Right\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> m = 7, n = 3\r\n<strong>Output:</strong> 28</pre>\r\n",
    "tags": "Array, Dynamic Programming",
    "difficulty": 2,
    "frontend_article_id": 62
},
{
    "frontend_question_id": 61,
    "article_live": false,
    "title": "Rotate List",
    "title_slug": "rotate-list",
    "content": "<p>Given a linked&nbsp;list, rotate the list to the right by <em>k</em> places, where <em>k</em> is non-negative.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2\r\n<strong>Output:</strong> 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL\r\n<strong>Explanation:</strong>\r\nrotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL\r\nrotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 0-&gt;1-&gt;2-&gt;NULL, k = 4\r\n<strong>Output:</strong> <code>2-&gt;0-&gt;1-&gt;NULL</code>\r\n<strong>Explanation:</strong>\r\nrotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULL\r\nrotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULL\r\nrotate 3 steps to the right:&nbsp;<code>0-&gt;1-&gt;2-&gt;NULL</code>\r\nrotate 4 steps to the right:&nbsp;<code>2-&gt;0-&gt;1-&gt;NULL</code></pre>\r\n",
    "tags": "Linked List, Two Pointers",
    "difficulty": 2,
    "frontend_article_id": 61
},
{
    "frontend_question_id": 60,
    "article_live": false,
    "title": "Permutation Sequence",
    "title_slug": "permutation-sequence",
    "content": "<p>The set <code>[1,2,3,...,<em>n</em>]</code> contains a total of <em>n</em>! unique permutations.</p>\r\n\r\n<p>By listing and labeling all of the permutations in order, we get the following sequence for <em>n</em> = 3:</p>\r\n\r\n<ol>\r\n\t<li><code>&quot;123&quot;</code></li>\r\n\t<li><code>&quot;132&quot;</code></li>\r\n\t<li><code>&quot;213&quot;</code></li>\r\n\t<li><code>&quot;231&quot;</code></li>\r\n\t<li><code>&quot;312&quot;</code></li>\r\n\t<li><code>&quot;321&quot;</code></li>\r\n</ol>\r\n\r\n<p>Given <em>n</em> and <em>k</em>, return the <em>k</em><sup>th</sup> permutation sequence.</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>Given <em>n</em> will be between 1 and 9 inclusive.</li>\r\n\t<li>Given&nbsp;<em>k</em>&nbsp;will be between 1 and <em>n</em>! inclusive.</li>\r\n</ul>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> n = 3, k = 3\r\n<strong>Output:</strong> &quot;213&quot;\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> n = 4, k = 9\r\n<strong>Output:</strong> &quot;2314&quot;\r\n</pre>\r\n",
    "tags": "Math, Backtracking",
    "difficulty": 2,
    "frontend_article_id": 60
},
{
    "frontend_question_id": 59,
    "article_live": false,
    "title": "Spiral Matrix II",
    "title_slug": "spiral-matrix-ii",
    "content": "<p>Given a positive integer <em>n</em>, generate a square matrix filled with elements from 1 to <em>n</em><sup>2</sup> in spiral order.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 3\r\n<strong>Output:</strong>\r\n[\r\n [ 1, 2, 3 ],\r\n [ 8, 9, 4 ],\r\n [ 7, 6, 5 ]\r\n]\r\n</pre>\r\n",
    "tags": "Array",
    "difficulty": 2,
    "frontend_article_id": 59
},
{
    "frontend_question_id": 58,
    "article_live": false,
    "title": "Length of Last Word",
    "title_slug": "length-of-last-word",
    "content": "<p>Given a string <i>s</i> consists of upper/lower-case alphabets and empty space characters <code>' '</code>, return the length of last word in the string.</p>\r\n\r\n<p>If the last word does not exist, return 0.</p>\r\n\r\n<p><b>Note:</b> A word is defined as a character sequence consists of non-space characters only.</p>\r\n\r\n<p><b>Example:</b>\r\n<pre>\r\n<b>Input:</b> \"Hello World\"\r\n<b>Output:</b> 5\r\n</pre>\r\n</p>",
    "tags": "String",
    "difficulty": 1,
    "frontend_article_id": 58
},
{
    "frontend_question_id": 57,
    "article_live": false,
    "title": "Insert Interval",
    "title_slug": "insert-interval",
    "content": "<p>Given a set of <em>non-overlapping</em> intervals, insert a new interval into the intervals (merge if necessary).</p>\r\n\r\n<p>You may assume that the intervals were initially sorted according to their start times.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> intervals = [[1,3],[6,9]], newInterval = [2,5]\r\n<strong>Output:</strong> [[1,5],[6,9]]\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> intervals = <code>[[1,2],[3,5],[6,7],[8,10],[12,16]]</code>, newInterval = <code>[4,8]</code>\r\n<strong>Output:</strong> [[1,2],[3,10],[12,16]]\r\n<strong>Explanation:</strong> Because the new interval <code>[4,8]</code> overlaps with <code>[3,5],[6,7],[8,10]</code>.</pre>\r\n",
    "tags": "Array, Sort",
    "difficulty": 3,
    "frontend_article_id": 57
},
{
    "frontend_question_id": 56,
    "article_live": true,
    "article_slug": "merge-intervals",
    "title": "Merge Intervals",
    "title_slug": "merge-intervals",
    "content": "<p>Given a collection of intervals, merge all overlapping intervals.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [[1,3],[2,6],[8,10],[15,18]]\r\n<strong>Output:</strong> [[1,6],[8,10],[15,18]]\r\n<strong>Explanation:</strong> Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [[1,4],[4,5]]\r\n<strong>Output:</strong> [[1,5]]\r\n<strong>Explanation:</strong> Intervals [1,4] and [4,5] are considerred overlapping.</pre>\r\n",
    "tags": "Array, Sort",
    "difficulty": 2,
    "frontend_article_id": 56,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-connected-components\">Approach 1: Connected Components</a></li> \n      <li><a href=\"#approach-2-sorting\">Approach 2: Sorting</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-connected-components\">Approach 1: Connected Components</h4> \n  <p><strong>Intuition</strong></p> \n  <p>If we draw a graph (with intervals as nodes) that contains undirected edges between all pairs of intervals that overlap, then all intervals in each <em>connected component</em> of the graph can be merged into a single interval.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>With the above intuition in mind, we can represent the graph as an adjacency list, inserting directed edges in both directions to simulate undirected edges. Then, to determine which connected component each node is it, we perform graph traversals from arbitrary unvisited nodes until all nodes have been visited. To do this efficiently, we store visited nodes in a <code>Set</code>, allowing for constant time containment checks and insertion. Finally, we consider each connected component, merging all of its intervals by constructing a new <code>Interval</code> with <code>start</code> equal to the minimum start among them and <code>end</code> equal to the maximum end.</p> \n  <p>This algorithm is correct simply because it is basically the brute force solution. We compare every interval to every other interval, so we know exactly which intervals overlap. The reason for the connected component search is that two intervals may not directly overlap, but might overlap indirectly via a third interval. See the example below to see this more clearly.</p> \n  <p align=\"center\"><img alt=\"Components Example\" src=\"../Figures/56/component.png\"></p> \n  <p>Although (1, 5) and (6, 10) do not directly overlap, either would overlap with the other if first merged with (4, 7). There are two connected components, so if we merge their nodes, we expect to get the following two merged intervals:</p> \n  <p>(1, 10), (15, 20)</p> \n  <iframe src=\"https://leetcode.com/playground/TruEhoZB/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"TruEhoZB\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^2)</script> </p> <p>Building the graph costs <script type=\"math/tex; mode=display\">O(V + E) = O(V) + O(E) = O(n) + O(n^2) = O(n^2)</script> time, as in the worst case all intervals are mutually overlapping. Traversing the graph has the same cost (although it might appear higher at first) because our <code>visited</code> set guarantees that each node will be visited exactly once. Finally, because each node is part of exactly one component, the merge step costs <script type=\"math/tex; mode=display\">O(V) = O(n)</script> time. This all adds up as follows:</p> <p> <script type=\"math/tex; mode=display\">\n    O(n^2) + O(n^2) + O(n) = O(n^2)\n</script> </p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n^2)</script> </p> <p>As previously mentioned, in the worst case, all intervals are mutually overlapping, so there will be an edge for every pair of intervals. Therefore, the memory footprint is quadratic in the input size.</p> </li> \n  </ul> \n  <p><br></p> \n  <hr> \n  <h4 id=\"approach-2-sorting\">Approach 2: Sorting</h4> \n  <p><strong>Intuition</strong></p> \n  <p>If we sort the intervals by their <code>start</code> value, then each set of intervals that can be merged will appear as a contiguous \"run\" in the sorted list.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>First, we sort the list as described. Then, we insert the first interval into our <code>merged</code> list and continue considering each interval in turn as follows: If the current interval begins <em>after</em> the previous interval ends, then they do not overlap and we can append the current interval to <code>merged</code>. Otherwise, they do overlap, and we merge them by updating the <code>end</code> of the previous interval if it is less than the <code>end</code> of the current interval.</p> \n  <p>A simple proof by contradiction shows that this algorithm always produces the correct answer. First, suppose that the algorithm at some point fails to merge two intervals that should be merged. This would imply that there exists some triple of indices <script type=\"math/tex; mode=display\">i</script>, <script type=\"math/tex; mode=display\">j</script>, and <script type=\"math/tex; mode=display\">k</script> in a list of intervals <script type=\"math/tex; mode=display\">ints</script> such that <script type=\"math/tex; mode=display\">i < j < k</script> and (<script type=\"math/tex; mode=display\">ints[i]</script>, <script type=\"math/tex; mode=display\">ints[k]</script>) can be merged, but neither (<script type=\"math/tex; mode=display\">ints[i]</script>, <script type=\"math/tex; mode=display\">ints[j]</script>) nor (<script type=\"math/tex; mode=display\">ints[j]</script>, <script type=\"math/tex; mode=display\">ints[k]</script>) can be merged. From this scenario follow several inequalities:</p> \n  <p> <script type=\"math/tex; mode=display\">\n\\begin{aligned}\n    ints[i].end < ints[j].start \\\\\n    ints[j].end < ints[k].start \\\\\n    ints[i].end \\geq ints[k].start \\\\\n\\end{aligned}\n</script> </p> \n  <p>We can chain these inequalities (along with the following inequality, implied by the well-formedness of the intervals: <script type=\"math/tex; mode=display\">ints[j].start \\leq ints[j].end</script>) to demonstrate a contradiction:</p> \n  <p> <script type=\"math/tex; mode=display\">\n\\begin{aligned}\n    ints[i].end < ints[j].start \\leq ints[j].end < ints[k].start \\\\\n    ints[i].end \\geq ints[k].start\n\\end{aligned}\n</script> </p> \n  <p>Therefore, all mergeable intervals must occur in a contiguous run of the sorted list.</p> \n  <p align=\"center\"><img alt=\"Sorting Example\" src=\"../Figures/56/sort.png\"></p> \n  <p>Consider the example above, where the intervals are sorted, and then all mergeable intervals form contiguous blocks.</p> \n  <iframe src=\"https://leetcode.com/playground/vuieZqQG/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"vuieZqQG\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(nlgn)</script> </p> <p>Other than the <code>sort</code> invocation, we do a simple linear scan of the list, so the runtime is dominated by the <script type=\"math/tex; mode=display\">O(nlgn)</script> complexity of sorting.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script> (or <script type=\"math/tex; mode=display\">O(n)</script>)</p> <p>If we can sort <code>intervals</code> in place, we do not need more than constant additional space. Otherwise, we must allocate linear space to store a copy of <code>intervals</code> and sort that.</p> </li> \n  </ul> \n </div> \n</div>"
},
{
    "frontend_question_id": 55,
    "article_live": true,
    "article_slug": "jump-game",
    "title": "Jump Game",
    "title_slug": "jump-game",
    "content": "<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>\r\n\r\n<p>Each element in the array represents your maximum jump length at that position.</p>\r\n\r\n<p>Determine if you are able to reach the last index.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [2,3,1,1,4]\r\n<strong>Output:</strong> true\r\n<strong>Explanation:</strong> Jump 1 step from index 0 to 1, then 3 steps to the last index.\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [3,2,1,0,4]\r\n<strong>Output:</strong> false\r\n<strong>Explanation:</strong> You will always arrive at index 3 no matter what. Its maximum\r\n&nbsp;            jump length is 0, which makes it impossible to reach the last index.\r\n</pre>\r\n",
    "tags": "Array, Greedy",
    "difficulty": 2,
    "frontend_article_id": 55,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#naming\">Naming</a></li> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-backtracking\">Approach 1: Backtracking</a></li> \n      <li><a href=\"#approach-2-dynamic-programming-top-down\">Approach 2: Dynamic Programming Top-down</a></li> \n      <li><a href=\"#approach-3-dynamic-programming-bottom-up\">Approach 3: Dynamic Programming Bottom-up</a></li> \n      <li><a href=\"#approach-4-greedy\">Approach 4: Greedy</a></li> \n     </ul> </li> \n    <li><a href=\"#conclusion\">Conclusion</a></li> \n    <li><a href=\"#appendix-a-complexity-analysis-for-approach-1\">Appendix A - Complexity Analysis for Approach 1</a></li> \n    <li><a href=\"#references\">References</a></li> \n   </ul> \n  </div> \n  <h2 id=\"naming\">Naming</h2> \n  <ul> \n   <li>We call a position in the array a <strong>\"good index\"</strong> if starting at that position, we can reach the last index. Otherwise, that index is called a <strong>\"bad index\"</strong>. The problem then reduces to whether or not index 0 is a \"good index\".</li> \n  </ul> \n  <h2 id=\"solution\">Solution</h2> \n  <p>This is a dynamic programming<sup>[1]</sup> question. Usually, solving and fully understanding a dynamic programming problem is a 4 step process:</p> \n  <ol> \n   <li>Start with the recursive backtracking solution</li> \n   <li>Optimize by using a memoization table (top-down<sup>[3]</sup> dynamic programming)</li> \n   <li>Remove the need for recursion (bottom-up dynamic programming)</li> \n   <li>Apply final tricks to reduce the time / memory complexity</li> \n  </ol> \n  <p>All solutions presented below produce the correct result, but they differ in run time and memory requirements. <br> <br></p> \n  <hr> \n  <h4 id=\"approach-1-backtracking\">Approach 1: Backtracking</h4> \n  <p>This is the inefficient solution where we try every single jump pattern that takes us from the first position to the last. We start from the first position and jump to every index that is reachable. We repeat the process until last index is reached. When stuck, backtrack.</p> \n  <iframe src=\"https://leetcode.com/playground/RqXZ95zM/shared\" frameborder=\"0\" width=\"100%\" height=\"395\" name=\"RqXZ95zM\"></iframe> \n  <p>One quick optimization we can do for the code above is to check the <code>nextPosition</code> from right to left. The theoretical worst case performance is the same, but in practice, for silly examples, the code might run faster. Intuitively, this means we always try to make the biggest jump such that we reach the end as soon as possible</p> \n  <p>The change required is:</p> \n  <iframe src=\"https://leetcode.com/playground/VPA68r4B/shared\" frameborder=\"0\" width=\"100%\" height=\"123\" name=\"VPA68r4B\"></iframe> \n  <p>For instance, in the example below, if we start from index <strong>0</strong>, jump as far as possible and reach <strong>1</strong>, jump as far as possible and reach <strong>6</strong>. By doing so, we determine that <strong>0</strong> is a <em>GOOD</em> index in 3 steps.</p> \n  <table> \n   <thead> \n    <tr> \n     <th align=\"center\">Index</th> \n     <th align=\"center\">0</th> \n     <th align=\"center\">1</th> \n     <th align=\"center\">2</th> \n     <th align=\"center\">3</th> \n     <th align=\"center\">4</th> \n     <th align=\"center\">5</th> \n     <th align=\"center\">6</th> \n    </tr> \n   </thead> \n   <tbody> \n    <tr> \n     <td align=\"center\">nums</td> \n     <td align=\"center\">1</td> \n     <td align=\"center\">5</td> \n     <td align=\"center\">2</td> \n     <td align=\"center\">1</td> \n     <td align=\"center\">0</td> \n     <td align=\"center\">2</td> \n     <td align=\"center\">0</td> \n    </tr> \n   </tbody> \n  </table> \n  <p>To illustrate the worst case, where this optimization has no effect, take the example below. Index <strong>6</strong> cannot be reached from any position, but all combinations will be tried.</p> \n  <table> \n   <thead> \n    <tr> \n     <th align=\"center\">Index</th> \n     <th align=\"center\">0</th> \n     <th align=\"center\">1</th> \n     <th align=\"center\">2</th> \n     <th align=\"center\">3</th> \n     <th align=\"center\">4</th> \n     <th align=\"center\">5</th> \n     <th align=\"center\">6</th> \n    </tr> \n   </thead> \n   <tbody> \n    <tr> \n     <td align=\"center\">nums</td> \n     <td align=\"center\">5</td> \n     <td align=\"center\">4</td> \n     <td align=\"center\">3</td> \n     <td align=\"center\">2</td> \n     <td align=\"center\">1</td> \n     <td align=\"center\">0</td> \n     <td align=\"center\">0</td> \n    </tr> \n   </tbody> \n  </table> \n  <p>The first few steps of the backtracking algorithm for the example above are: 0 -&gt; 4 -&gt; 5 -&gt; 4 -&gt; 0 -&gt; 3 -&gt; 5 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; etc.</p> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(2^n)</script>. There are <script type=\"math/tex; mode=display\">2^n</script> (upper bound) ways of jumping from the first position to the last, where <script type=\"math/tex; mode=display\">n</script> is the length of array <code>nums</code>. For a complete proof, please refer to Appendix A.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Recursion requires additional memory for the stack frames. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-dynamic-programming-top-down\">Approach 2: Dynamic Programming Top-down</h4> \n  <p>Top-down Dynamic Programming can be thought of as optimized backtracking. It relies on the observation that once we determine that a certain index is good / bad, this result will never change. This means that we can store the result and not need to recompute it every time.</p> \n  <p>Therefore, for each position in the array, we remember whether the index is good or bad. Let's call this array <code>memo</code> and let its values be either one of: GOOD, BAD, UNKNOWN. This technique is called memoization<sup>[2]</sup>.</p> \n  <p>An example of a memoization table for input array <code>nums = [2, 4, 2, 1, 0, 2, 0]</code> can be seen in the diagram below. We write <strong>G</strong> for a <em>GOOD</em> position and <strong>B</strong> for a <em>BAD</em> one. We can see that we cannot start from indices 2, 3 or 4 and eventually reach last index (6), but we can do that from indices 0, 1, 5 and (trivially) 6.</p> \n  <table> \n   <thead> \n    <tr> \n     <th align=\"center\">Index</th> \n     <th align=\"center\">0</th> \n     <th align=\"center\">1</th> \n     <th align=\"center\">2</th> \n     <th align=\"center\">3</th> \n     <th align=\"center\">4</th> \n     <th align=\"center\">5</th> \n     <th align=\"center\">6</th> \n    </tr> \n   </thead> \n   <tbody> \n    <tr> \n     <td align=\"center\">nums</td> \n     <td align=\"center\">2</td> \n     <td align=\"center\">4</td> \n     <td align=\"center\">2</td> \n     <td align=\"center\">1</td> \n     <td align=\"center\">0</td> \n     <td align=\"center\">2</td> \n     <td align=\"center\">0</td> \n    </tr> \n    <tr> \n     <td align=\"center\">memo</td> \n     <td align=\"center\">G</td> \n     <td align=\"center\">G</td> \n     <td align=\"center\">B</td> \n     <td align=\"center\">B</td> \n     <td align=\"center\">B</td> \n     <td align=\"center\">G</td> \n     <td align=\"center\">G</td> \n    </tr> \n   </tbody> \n  </table> \n  <p><strong>Steps</strong></p> \n  <ol> \n   <li>Initially, all elements of the <code>memo</code> table are <em>UNKNOWN</em>, except for the last one, which is (trivially) <em>GOOD</em> (it can reach itself)</li> \n   <li>Modify the backtracking algorithm such that the recursive step first checks if the index is known (<em>GOOD</em> / <em>BAD</em>)\n    <ol> \n     <li>If it is known then return <em>True</em> / <em>False</em></li> \n     <li>Otherwise perform the backtracking steps as before</li> \n    </ol> </li> \n   <li>Once we determine the value of the current index, we store it in the <code>memo</code> table</li> \n  </ol> \n  <iframe src=\"https://leetcode.com/playground/4R2mQwK5/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"4R2mQwK5\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^2)</script>. For every element in the array, say <code>i</code>, we are looking at the next <code>nums[i]</code> elements to its right aiming to find a <em>GOOD</em> index. <code>nums[i]</code> can be at most <script type=\"math/tex; mode=display\">n</script>, where <script type=\"math/tex; mode=display\">n</script> is the length of array <code>nums</code>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(2n) = O(n)</script>. First n originates from recursion. Second n comes from the usage of the memo table. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-dynamic-programming-bottom-up\">Approach 3: Dynamic Programming Bottom-up</h4> \n  <p>Top-down to bottom-up conversion is done by eliminating recursion. In practice, this achieves better performance as we no longer have the method stack overhead and might even benefit from some caching. More importantly, this step opens up possibilities for future optimization. The recursion is usually eliminated by trying to reverse the order of the steps from the top-down approach.</p> \n  <p>The observation to make here is that we only ever jump to the right. This means that if we start from the right of the array, every time we will query a position to our right, that position has already be determined as being <em>GOOD</em> or <em>BAD</em>. This means we don't need to recurse anymore, as we will always hit the <code>memo</code> table.</p> \n  <iframe src=\"https://leetcode.com/playground/SqDcPdpN/shared\" frameborder=\"0\" width=\"100%\" height=\"480\" name=\"SqDcPdpN\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^2)</script>. For every element in the array, say <code>i</code>, we are looking at the next <code>nums[i]</code> elements to its right aiming to find a <em>GOOD</em> index. <code>nums[i]</code> can be at most <script type=\"math/tex; mode=display\">n</script>, where <script type=\"math/tex; mode=display\">n</script> is the length of array <code>nums</code>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. This comes from the usage of the memo table. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-4-greedy\">Approach 4: Greedy</h4> \n  <p>Once we have our code in the bottom-up state, we can make one final, important observation. From a given position, when we try to see if we can jump to a <em>GOOD</em> position, we only ever use one - the first one (see the break statement). In other words, the left-most one. If we keep track of this left-most <em>GOOD</em> position as a separate variable, we can avoid searching for it in the array. Not only that, but we can stop using the array altogether.</p> \n  <p>Iterating right-to-left, for each position we check if there is a potential jump that reaches a <em>GOOD</em> index (<code>currPosition + nums[currPosition] &gt;= leftmostGoodIndex</code>). If we can reach a <em>GOOD</em> index, then our position is itself <em>GOOD</em>. Also, this new <em>GOOD</em> position will be the new leftmost <em>GOOD</em> index. Iteration continues until the beginning of the array. If first position is a <em>GOOD</em> index then we can reach the last index from the first position.</p> \n  <p>To illustrate this scenario, we will use the diagram below, for input array <code>nums = [9, 4, 2, 1, 0, 2, 0]</code>. We write <strong>G</strong> for <em>GOOD</em>, <strong>B</strong> for <em>BAD</em> and <strong>U</strong> for <em>UNKNOWN</em>. Let's assume we have iterated all the way to position 0 and we need to decide if index 0 is <em>GOOD</em>. Since index 1 was determined to be <em>GOOD</em>, it is enough to jump there and then be sure we can eventually reach index 6. It does not matter that <code>nums[0]</code> is big enough to jump all the way to the last index. All we need is <strong>one</strong> way.</p> \n  <table> \n   <thead> \n    <tr> \n     <th align=\"center\">Index</th> \n     <th align=\"center\">0</th> \n     <th align=\"center\">1</th> \n     <th align=\"center\">2</th> \n     <th align=\"center\">3</th> \n     <th align=\"center\">4</th> \n     <th align=\"center\">5</th> \n     <th align=\"center\">6</th> \n    </tr> \n   </thead> \n   <tbody> \n    <tr> \n     <td align=\"center\">nums</td> \n     <td align=\"center\">9</td> \n     <td align=\"center\">4</td> \n     <td align=\"center\">2</td> \n     <td align=\"center\">1</td> \n     <td align=\"center\">0</td> \n     <td align=\"center\">2</td> \n     <td align=\"center\">0</td> \n    </tr> \n    <tr> \n     <td align=\"center\">memo</td> \n     <td align=\"center\">U</td> \n     <td align=\"center\">G</td> \n     <td align=\"center\">B</td> \n     <td align=\"center\">B</td> \n     <td align=\"center\">B</td> \n     <td align=\"center\">G</td> \n     <td align=\"center\">G</td> \n    </tr> \n   </tbody> \n  </table> \n  <iframe src=\"https://leetcode.com/playground/9p3KyBwa/shared\" frameborder=\"0\" width=\"100%\" height=\"242\" name=\"9p3KyBwa\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. We are doing a single pass through the <code>nums</code> array, hence <script type=\"math/tex; mode=display\">n</script> steps, where <script type=\"math/tex; mode=display\">n</script> is the length of array <code>nums</code>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. We are not using any extra memory.</p> </li> \n  </ul> \n  <h2 id=\"conclusion\">Conclusion</h2> \n  <p>The question left unanswered is how should one approach such a question in an interview scenario. I would say \"it depends\". The perfect solution is cleaner and shorter than all the other versions, but it might not be so straightforward to figure out.</p> \n  <p>The (recursive) backtracking is the easiest to figure out, so it is worth mentioning it verbally while warming up for the tougher challenge. It might be that your interviewer actually wants to see that solution, but if not, mention that there might be a dynamic programming solution and try to think how could you use a memoization table. If you figure it out and the interviewer wants you to go for the top-down approach, it will not generally be time to think of the bottom-up version, but I would always mention the advantages of this technique as a final thought in the interview.</p> \n  <p>Most people are stuck when converting from top-down Dynamic Programming (expressed naturally in recursion) to bottom-up. Practicing similar problems will help bridge this gap.</p> \n  <h2 id=\"appendix-a-complexity-analysis-for-approach-1\">Appendix A - Complexity Analysis for <a href=\"#approach-1-backtracking\">Approach 1</a></h2> \n  <p>There are <script type=\"math/tex; mode=display\">2^n</script> (upper bound) ways of jumping from the first position to the last, where <script type=\"math/tex; mode=display\">n</script> is the length of array <code>nums</code>. We get this recursively. Let <script type=\"math/tex; mode=display\">T(x)</script> be the number of possible ways of jumping from position <strong>x</strong> to position <strong>n</strong>. <script type=\"math/tex; mode=display\">T(n) = 1</script> trivially. <script type=\"math/tex; mode=display\">T(x) = \\sum_{i = x + 1}^{n} T(i)</script> because from position <strong>x</strong> we can potentially jump to all following positions <strong>i</strong> and then from there there are <script type=\"math/tex; mode=display\">T(i)</script> ways of continuing. Notice this is an upper bound.</p> \n  <p> <script type=\"math/tex; mode=display\">\n\\begin{align*}\nT(x) &= \\sum_{i = x + 1}^{n} T(i) \\\\\nT(x) &= T(x + 1) + \\sum_{i = x + 2}^{n} T(i) \\\\\nT(x) &= T(x + 1) + T(x + 1) \\\\\nT(x) &= 2 * T(x + 1)\n\\end{align*}\n</script> </p> \n  <p>Now by induction, assume <script type=\"math/tex; mode=display\">T(x) = 2^{n - x - 1}</script> and prove <script type=\"math/tex; mode=display\">T(x - 1) = 2^{n - (x - 1) - 1}</script> </p> \n  <p> <script type=\"math/tex; mode=display\">\n\\begin{align*}\nT(x - 1) &= 2 * T(x) \\\\\nT(x - 1) &= 2 * 2^{n - x - 1} \\\\\nT(x - 1) &= 2^{n - x - 1 + 1} \\\\\nT(x - 1) &= 2^{n - (x - 1) - 1}\n\\end{align*}\n</script> </p> \n  <p>Therefore, since we start from position 1, <script type=\"math/tex; mode=display\">T(1) = 2^{n - 2}</script>. Final complexity <script type=\"math/tex; mode=display\">O(2^{n - 2})</script> = <script type=\"math/tex; mode=display\">O(2^n)</script>.</p> \n  <h2 id=\"references\">References</h2> \n  <ul> \n   <li>[1] <a href=\"https://en.wikipedia.org/wiki/Dynamic_programming\">https://en.wikipedia.org/wiki/Dynamic_programming</a></li> \n   <li>[2] <a href=\"https://en.wikipedia.org/wiki/Memoization\">https://en.wikipedia.org/wiki/Memoization</a></li> \n   <li>[3] <a href=\"https://en.wikipedia.org/wiki/Top-down_and_bottom-up_design\">https://en.wikipedia.org/wiki/Top-down_and_bottom-up_design</a></li> \n  </ul> \n </div> \n</div>"
},
{
    "frontend_question_id": 54,
    "article_live": true,
    "article_slug": "spiral-matrix",
    "title": "Spiral Matrix",
    "title_slug": "spiral-matrix",
    "content": "<p>Given a matrix of <em>m</em> x <em>n</em> elements (<em>m</em> rows, <em>n</em> columns), return all elements of the matrix in spiral order.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>\r\n[\r\n [ 1, 2, 3 ],\r\n [ 4, 5, 6 ],\r\n [ 7, 8, 9 ]\r\n]\r\n<strong>Output:</strong> [1,2,3,6,9,8,7,4,5]\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n<pre>\r\n<strong>Input:</strong>\r\n[\r\n  [1, 2, 3, 4],\r\n  [5, 6, 7, 8],\r\n  [9,10,11,12]\r\n]\r\n<strong>Output:</strong> [1,2,3,4,8,12,11,10,9,5,6,7]\r\n</pre>",
    "tags": "Array",
    "difficulty": 2,
    "frontend_article_id": 54,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-simulation\">Approach 1: Simulation</a></li> \n    <li><a href=\"#approach-2-layer-by-layer\">Approach 2: Layer-by-Layer</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-simulation\">Approach 1: Simulation</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Draw the path that the spiral makes. We know that the path should turn clockwise whenever it would go out of bounds or into a cell that was previously visited.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Let the array have <script type=\"math/tex; mode=display\">\\text{R}</script> rows and <script type=\"math/tex; mode=display\">\\text{C}</script> columns. <script type=\"math/tex; mode=display\">\\text{seen[r][c]}</script> denotes that the cell on the<script type=\"math/tex; mode=display\">\\text{r}</script>-th row and <script type=\"math/tex; mode=display\">\\text{c}</script>-th column was previously visited. Our current position is <script type=\"math/tex; mode=display\">\\text{(r, c)}</script>, facing direction <script type=\"math/tex; mode=display\">\\text{di}</script>, and we want to visit <script type=\"math/tex; mode=display\">\\text{R}</script> x <script type=\"math/tex; mode=display\">\\text{C}</script> total cells.</p> \n  <p>As we move through the matrix, our candidate next position is <script type=\"math/tex; mode=display\">\\text{(cr, cc)}</script>. If the candidate is in the bounds of the matrix and unseen, then it becomes our next position; otherwise, our next position is the one after performing a clockwise turn.</p> \n  <iframe src=\"https://leetcode.com/playground/62u9UXjz/shared\" frameborder=\"0\" width=\"100%\" height=\"497\" name=\"62u9UXjz\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the total number of elements in the input matrix. We add every element in the matrix to our final answer.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the information stored in <code>seen</code> and in <code>ans</code>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-layer-by-layer\">Approach 2: Layer-by-Layer</h4> \n  <p><strong>Intuition</strong></p> \n  <p>The answer will be all the elements in clockwise order from the first-outer layer, followed by the elements from the second-outer layer, and so on.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>We define the <script type=\"math/tex; mode=display\">\\text{k}</script>-th outer layer of a matrix as all elements that have minimum distance to some border equal to <script type=\"math/tex; mode=display\">\\text{k}</script>. For example, the following matrix has all elements in the first-outer layer equal to 1, all elements in the second-outer layer equal to 2, and all elements in the third-outer layer equal to 3.</p> \n  <div class=\"codehilite\">\n   <pre><span></span>[[1, 1, 1, 1, 1, 1, 1],\n [1, 2, 2, 2, 2, 2, 1],\n [1, 2, 3, 3, 3, 2, 1],\n [1, 2, 2, 2, 2, 2, 1],\n [1, 1, 1, 1, 1, 1, 1]]\n</pre>\n  </div> \n  <p>For each outer layer, we want to iterate through its elements in clockwise order starting from the top left corner. Suppose the current outer layer has top-left coordinates <script type=\"math/tex; mode=display\">\\text{(r1, c1)}</script> and bottom-right coordinates <script type=\"math/tex; mode=display\">\\text{(r2, c2)}</script>.</p> \n  <p>Then, the top row is the set of elements <script type=\"math/tex; mode=display\">\\text{(r1, c)}</script> for <script type=\"math/tex; mode=display\">\\text{c = c1,...,c2}</script>, in that order. The rest of the right side is the set of elements <script type=\"math/tex; mode=display\">\\text{(r, c2)}</script> for <script type=\"math/tex; mode=display\">\\text{r = r1+1,...,r2}</script>, in that order. Then, if there are four sides to this layer (ie., <script type=\"math/tex; mode=display\">\\text{r1 < r2}</script> and <script type=\"math/tex; mode=display\">\\text{c1 < c2}</script>), we iterate through the bottom side and left side as shown in the solutions below.</p> \n  <p><img alt=\"SpiralMatrix\" src=\"../Figures/54_spiralmatrix.png\"></p> \n  <iframe src=\"https://leetcode.com/playground/hWE2c3x4/shared\" frameborder=\"0\" width=\"100%\" height=\"446\" name=\"hWE2c3x4\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, where <script type=\"math/tex; mode=display\">N</script> is the total number of elements in the input matrix. We add every element in the matrix to our final answer.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(N)</script>, the information stored in <code>ans</code>.</p> </li> \n  </ul> \n </div> \n</div>"
},
{
    "frontend_question_id": 53,
    "article_live": false,
    "title": "Maximum Subarray",
    "title_slug": "maximum-subarray",
    "content": "<p>Given an integer array <code>nums</code>, find the contiguous subarray&nbsp;(containing at least one number) which has the largest sum and return its sum.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [-2,1,-3,4,-1,2,1,-5,4],\r\n<strong>Output:</strong> 6\r\n<strong>Explanation:</strong>&nbsp;[4,-1,2,1] has the largest sum = 6.\r\n</pre>\r\n\r\n<p><strong>Follow up:</strong></p>\r\n\r\n<p>If you have figured out the O(<em>n</em>) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p>\r\n",
    "tags": "Array, Divide and Conquer, Dynamic Programming",
    "difficulty": 1,
    "frontend_article_id": 53
},
{
    "frontend_question_id": 52,
    "article_live": false,
    "title": "N-Queens II",
    "title_slug": "n-queens-ii",
    "content": "<p>The <em>n</em>-queens puzzle is the problem of placing <em>n</em> queens on an <em>n</em>&times;<em>n</em> chessboard such that no two queens attack each other.</p>\r\n\r\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/12/8-queens.png\" style=\"width: 258px; height: 276px;\" /></p>\r\n\r\n<p>Given an integer&nbsp;<em>n</em>, return the number of&nbsp;distinct solutions to the&nbsp;<em>n</em>-queens puzzle.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 4\r\n<strong>Output:</strong> 2\r\n<strong>Explanation:</strong> There are two distinct solutions to the 4-queens puzzle as shown below.\r\n[\r\n&nbsp;[&quot;.Q..&quot;, &nbsp;// Solution 1\r\n&nbsp; &quot;...Q&quot;,\r\n&nbsp; &quot;Q...&quot;,\r\n&nbsp; &quot;..Q.&quot;],\r\n\r\n&nbsp;[&quot;..Q.&quot;, &nbsp;// Solution 2\r\n&nbsp; &quot;Q...&quot;,\r\n&nbsp; &quot;...Q&quot;,\r\n&nbsp; &quot;.Q..&quot;]\r\n]\r\n</pre>\r\n",
    "tags": "Backtracking",
    "difficulty": 3,
    "frontend_article_id": 52
},
{
    "frontend_question_id": 51,
    "article_live": false,
    "title": "N-Queens",
    "title_slug": "n-queens",
    "content": "<p>The <em>n</em>-queens puzzle is the problem of placing <em>n</em> queens on an <em>n</em>&times;<em>n</em> chessboard such that no two queens attack each other.</p>\r\n\r\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/10/12/8-queens.png\" style=\"width: 258px; height: 276px;\" /></p>\r\n\r\n<p>Given an integer <em>n</em>, return all distinct solutions to the <em>n</em>-queens puzzle.</p>\r\n\r\n<p>Each solution contains a distinct board configuration of the <em>n</em>-queens&#39; placement, where <code>&#39;Q&#39;</code> and <code>&#39;.&#39;</code> both indicate a queen and an empty space respectively.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 4\r\n<strong>Output:</strong> [\r\n [&quot;.Q..&quot;,  // Solution 1\r\n  &quot;...Q&quot;,\r\n  &quot;Q...&quot;,\r\n  &quot;..Q.&quot;],\r\n\r\n [&quot;..Q.&quot;,  // Solution 2\r\n  &quot;Q...&quot;,\r\n  &quot;...Q&quot;,\r\n  &quot;.Q..&quot;]\r\n]\r\n<strong>Explanation:</strong> There exist two distinct solutions to the 4-queens puzzle as shown above.\r\n</pre>\r\n",
    "tags": "Backtracking",
    "difficulty": 3,
    "frontend_article_id": 51
},
{
    "frontend_question_id": 50,
    "article_live": true,
    "article_slug": "powx-n",
    "title": "Pow(x, n)",
    "title_slug": "powx-n",
    "content": "<p>Implement <a href=\"http://www.cplusplus.com/reference/valarray/pow/\" target=\"_blank\">pow(<em>x</em>, <em>n</em>)</a>, which calculates&nbsp;<em>x</em> raised to the power <em>n</em> (x<sup><span style=\"font-size:10.8333px\">n</span></sup>).</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 2.00000, 10\r\n<strong>Output:</strong> 1024.00000\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 2.10000, 3\r\n<strong>Output:</strong> 9.26100\r\n</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 2.00000, -2\r\n<strong>Output:</strong> 0.25000\r\n<strong>Explanation:</strong> 2<sup>-2</sup> = 1/2<sup>2</sup> = 1/4 = 0.25\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>-100.0 &lt; <em>x</em> &lt; 100.0</li>\r\n\t<li><em>n</em> is a 32-bit signed integer, within the range&nbsp;[&minus;2<sup>31</sup>,&nbsp;2<sup>31&nbsp;</sup>&minus; 1]</li>\r\n</ul>\r\n",
    "tags": "Math, Binary Search",
    "difficulty": 2,
    "frontend_article_id": 50,
    "article_content": ""
},
{
    "frontend_question_id": 49,
    "article_live": true,
    "article_slug": "group-anagrams",
    "title": "Group Anagrams",
    "title_slug": "group-anagrams",
    "content": "<p>Given an array of strings, group anagrams together.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> <code>[&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</code>,\r\n<strong>Output:</strong>\r\n[\r\n  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],\r\n  [&quot;nat&quot;,&quot;tan&quot;],\r\n  [&quot;bat&quot;]\r\n]</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>All inputs will be in lowercase.</li>\r\n\t<li>The order of your output does not&nbsp;matter.</li>\r\n</ul>\r\n",
    "tags": "Hash Table, String",
    "difficulty": 2,
    "frontend_article_id": 49,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-categorize-by-sorted-string\">Approach 1: Categorize by Sorted String</a></li> \n    <li><a href=\"#approach-2-categorize-by-count\">Approach 2: Categorize by Count</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-categorize-by-sorted-string\">Approach 1: Categorize by Sorted String</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Two strings are anagrams if and only if their sorted strings are equal.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Maintain a map <code>ans : {String -&gt; List}</code> where each key <script type=\"math/tex; mode=display\">\\text{K}</script> is a sorted string, and each value is the list of strings from the initial input that when sorted, are equal to <script type=\"math/tex; mode=display\">\\text{K}</script>.</p> \n  <p>In Java, we will store the key as a string, eg. <code>code</code>. In Python, we will store the key as a hashable tuple, eg. <code>('c', 'o', 'd', 'e')</code>.</p> \n  <p><img alt=\"Anagrams\" src=\"../Figures/49_groupanagrams1.png\"></p> \n  <iframe src=\"https://leetcode.com/playground/HwiBG7Pz/shared\" frameborder=\"0\" width=\"100%\" height=\"293\" name=\"HwiBG7Pz\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(NK \\log K)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>strs</code>, and <script type=\"math/tex; mode=display\">K</script> is the maximum length of a string in <code>strs</code>. The outer loop has complexity <script type=\"math/tex; mode=display\">O(N)</script> as we iterate through each string. Then, we sort each string in <script type=\"math/tex; mode=display\">O(K \\log K)</script> time.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(NK)</script>, the total information content stored in <code>ans</code>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-categorize-by-count\">Approach 2: Categorize by Count</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Two strings are anagrams if and only if their character counts (respective number of occurrences of each character) are the same.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>We can transform each string <script type=\"math/tex; mode=display\">\\text{s}</script> into a character count, <script type=\"math/tex; mode=display\">\\text{count}</script>, consisting of 26 non-negative integers representing the number of <script type=\"math/tex; mode=display\">\\text{a}</script>'s, <script type=\"math/tex; mode=display\">\\text{b}</script>'s, <script type=\"math/tex; mode=display\">\\text{c}</script>'s, etc. We use these counts as the basis for our hash map.</p> \n  <p>In Java, the hashable representation of our count will be a string delimited with '<strong>#</strong>' characters. For example, <code>abbccc</code> will be <code>#1#2#3#0#0#0...#0</code> where there are 26 entries total. In python, the representation will be a tuple of the counts. For example, <code>abbccc</code> will be <code>(1, 2, 3, 0, 0, ..., 0)</code>, where again there are 26 entries total.</p> \n  <p><img alt=\"Anagrams\" src=\"../Figures/49_groupanagrams2.png\"></p> \n  <iframe src=\"https://leetcode.com/playground/DvDMzZTX/shared\" frameborder=\"0\" width=\"100%\" height=\"412\" name=\"DvDMzZTX\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: <script type=\"math/tex; mode=display\">O(NK)</script>, where <script type=\"math/tex; mode=display\">N</script> is the length of <code>strs</code>, and <script type=\"math/tex; mode=display\">K</script> is the maximum length of a string in <code>strs</code>. Counting each string is linear in the size of the string, and we count every string.</p> </li> \n   <li> <p>Space Complexity: <script type=\"math/tex; mode=display\">O(NK)</script>, the total information content stored in <code>ans</code>.</p> </li> \n  </ul> \n </div> \n</div>"
},
{
    "frontend_question_id": 48,
    "article_live": false,
    "title": "Rotate Image",
    "title_slug": "rotate-image",
    "content": "<p>You are given an <em>n</em> x <em>n</em> 2D matrix representing an image.</p>\r\n\r\n<p>Rotate the image by 90 degrees (clockwise).</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<p>You have to rotate the image <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\"><strong>in-place</strong></a>, which means you have to modify the input 2D matrix directly. <strong>DO NOT</strong> allocate another 2D matrix and do the rotation.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\nGiven <strong>input matrix</strong> = \r\n[\r\n  [1,2,3],\r\n  [4,5,6],\r\n  [7,8,9]\r\n],\r\n\r\nrotate the input matrix <strong>in-place</strong> such that it becomes:\r\n[\r\n  [7,4,1],\r\n  [8,5,2],\r\n  [9,6,3]\r\n]\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\nGiven <strong>input matrix</strong> =\r\n[\r\n  [ 5, 1, 9,11],\r\n  [ 2, 4, 8,10],\r\n  [13, 3, 6, 7],\r\n  [15,14,12,16]\r\n], \r\n\r\nrotate the input matrix <strong>in-place</strong> such that it becomes:\r\n[\r\n  [15,13, 2, 5],\r\n  [14, 3, 4, 1],\r\n  [12, 6, 8, 9],\r\n  [16, 7,10,11]\r\n]\r\n</pre>\r\n",
    "tags": "Array",
    "difficulty": 2,
    "frontend_article_id": 48
},
{
    "frontend_question_id": 47,
    "article_live": false,
    "title": "Permutations II",
    "title_slug": "permutations-ii",
    "content": "<p>Given a collection of numbers that might contain duplicates, return all possible unique permutations.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [1,1,2]\r\n<strong>Output:</strong>\r\n[\r\n  [1,1,2],\r\n  [1,2,1],\r\n  [2,1,1]\r\n]\r\n</pre>\r\n",
    "tags": "Backtracking",
    "difficulty": 2,
    "frontend_article_id": 47
},
{
    "frontend_question_id": 46,
    "article_live": false,
    "title": "Permutations",
    "title_slug": "permutations",
    "content": "<p>Given a collection of <strong>distinct</strong> integers, return all possible permutations.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [1,2,3]\r\n<strong>Output:</strong>\r\n[\r\n  [1,2,3],\r\n  [1,3,2],\r\n  [2,1,3],\r\n  [2,3,1],\r\n  [3,1,2],\r\n  [3,2,1]\r\n]\r\n</pre>\r\n",
    "tags": "Backtracking",
    "difficulty": 2,
    "frontend_article_id": 46
},
{
    "frontend_question_id": 45,
    "article_live": false,
    "title": "Jump Game II",
    "title_slug": "jump-game-ii",
    "content": "<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>\r\n\r\n<p>Each element in the array represents your maximum jump length at that position.</p>\r\n\r\n<p>Your goal is to reach the last index in the minimum number of jumps.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [2,3,1,1,4]\r\n<strong>Output:</strong> 2\r\n<strong>Explanation:</strong> The minimum number of jumps to reach the last index is 2.\r\n    Jump 1 step from index 0 to 1, then 3 steps to the last index.</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<p>You can assume that you can always reach the last index.</p>\r\n",
    "tags": "Array, Greedy",
    "difficulty": 3,
    "frontend_article_id": 45
},
{
    "frontend_question_id": 44,
    "article_live": false,
    "title": "Wildcard Matching",
    "title_slug": "wildcard-matching",
    "content": "<p>Given an input string (<code>s</code>) and a pattern (<code>p</code>), implement wildcard pattern matching with support for <code>&#39;?&#39;</code> and <code>&#39;*&#39;</code>.</p>\r\n\r\n<pre>\r\n&#39;?&#39; Matches any single character.\r\n&#39;*&#39; Matches any sequence of characters (including the empty sequence).\r\n</pre>\r\n\r\n<p>The matching should cover the <strong>entire</strong> input string (not partial).</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>s</code>&nbsp;could be empty and contains only lowercase letters <code>a-z</code>.</li>\r\n\t<li><code>p</code> could be empty and contains only lowercase letters <code>a-z</code>, and characters like <code><font face=\"monospace\">?</font></code>&nbsp;or&nbsp;<code>*</code>.</li>\r\n</ul>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>\r\ns = &quot;aa&quot;\r\np = &quot;a&quot;\r\n<strong>Output:</strong> false\r\n<strong>Explanation:</strong> &quot;a&quot; does not match the entire string &quot;aa&quot;.\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>\r\ns = &quot;aa&quot;\r\np = &quot;*&quot;\r\n<strong>Output:</strong> true\r\n<strong>Explanation:</strong>&nbsp;&#39;*&#39; matches any sequence.\r\n</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>\r\ns = &quot;cb&quot;\r\np = &quot;?a&quot;\r\n<strong>Output:</strong> false\r\n<strong>Explanation:</strong>&nbsp;&#39;?&#39; matches &#39;c&#39;, but the second letter is &#39;a&#39;, which does not match &#39;b&#39;.\r\n</pre>\r\n\r\n<p><strong>Example 4:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>\r\ns = &quot;adceb&quot;\r\np = &quot;*a*b&quot;\r\n<strong>Output:</strong> true\r\n<strong>Explanation:</strong>&nbsp;The first &#39;*&#39; matches the empty sequence, while the second &#39;*&#39; matches the substring &quot;dce&quot;.\r\n</pre>\r\n\r\n<p><strong>Example 5:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>\r\ns = &quot;acdcb&quot;\r\np = &quot;a*c?b&quot;\r\n<strong>Output:</strong> false\r\n</pre>\r\n",
    "tags": "String, Dynamic Programming, Backtracking, Greedy",
    "difficulty": 3,
    "frontend_article_id": 44
},
{
    "frontend_question_id": 43,
    "article_live": false,
    "title": "Multiply Strings",
    "title_slug": "multiply-strings",
    "content": "<p>Given two non-negative integers <code>num1</code> and <code>num2</code> represented as strings, return the product of <code>num1</code> and <code>num2</code>, also represented as a string.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> num1 = &quot;2&quot;, num2 = &quot;3&quot;\r\n<strong>Output:</strong> &quot;6&quot;</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> num1 = &quot;123&quot;, num2 = &quot;456&quot;\r\n<strong>Output:</strong> &quot;56088&quot;\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li>The length of both <code>num1</code> and <code>num2</code> is &lt; 110.</li>\r\n\t<li>Both <code>num1</code> and <code>num2</code> contain&nbsp;only digits <code>0-9</code>.</li>\r\n\t<li>Both <code>num1</code> and <code>num2</code>&nbsp;do not contain any leading zero, except the number 0 itself.</li>\r\n\t<li>You <strong>must not use any built-in BigInteger library</strong> or <strong>convert the inputs to integer</strong> directly.</li>\r\n</ol>\r\n",
    "tags": "Math, String",
    "difficulty": 2,
    "frontend_article_id": 43
},
{
    "frontend_question_id": 42,
    "article_live": true,
    "article_slug": "trapping-rain-water",
    "title": "Trapping Rain Water",
    "title_slug": "trapping-rain-water",
    "content": "<p>Given <em>n</em> non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p>\r\n\r\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png\" style=\"width: 412px; height: 161px;\" /><br />\r\n<small>The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. <strong>Thanks Marcos</strong> for contributing this image!</small></p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [0,1,0,2,1,0,1,3,2,1,2,1]\r\n<strong>Output:</strong> 6</pre>\r\n",
    "tags": "Array, Two Pointers, Stack",
    "difficulty": 3,
    "frontend_article_id": 42,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force\">Approach 1: Brute force</a></li> \n      <li><a href=\"#approach-2-dynamic-programming\">Approach 2: Dynamic Programming</a></li> \n      <li><a href=\"#approach-3-using-stacks\">Approach 3: Using stacks</a></li> \n      <li><a href=\"#approach-4-using-2-pointers\">Approach 4: Using 2 pointers</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force\">Approach 1: Brute force</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Do as directed in question. For each element in the array, we find the maximum level of water it can trap after the rain, which is equal to the minimum of maximum height of bars on both the sides minus its own height.</p> \n  <p><strong>Algorithm</strong></p> \n  <ul> \n   <li>Initialize <script type=\"math/tex; mode=display\">ans=0</script> </li> \n   <li>Iterate the array from left to right:\n    <ul> \n     <li>Initialize <script type=\"math/tex; mode=display\">\\text{max_left}=0</script> and <script type=\"math/tex; mode=display\">\\text{max_right}=0</script> </li> \n     <li>Iterate from the current element to the beginning of array updating:\n      <ul> \n       <li> <script type=\"math/tex; mode=display\">\\text{max_left}=\\max(\\text{max_left},\\text{height}[j])</script> </li> \n      </ul> </li> \n     <li>Iterate from the current element to the end of array updating:\n      <ul> \n       <li> <script type=\"math/tex; mode=display\">\\text{max_right}=\\max(\\text{max_right},\\text{height}[j])</script> </li> \n      </ul> </li> \n     <li>Add <script type=\"math/tex; mode=display\">\\min(\\text{max_left},\\text{max_right}) - \\text{height}[i]</script> to <script type=\"math/tex; mode=display\">\\text{ans}</script> </li> \n    </ul> </li> \n  </ul> \n  <iframe src=\"https://leetcode.com/playground/sQFpTWMZ/shared\" frameborder=\"0\" width=\"100%\" height=\"327\" name=\"sQFpTWMZ\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity: <script type=\"math/tex; mode=display\">O(n^2)</script>. For each element of array, we iterate the left and right parts.</p> </li> \n   <li> <p>Space complexity: <script type=\"math/tex; mode=display\">O(1)</script> extra space. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-dynamic-programming\">Approach 2: Dynamic Programming</h4> \n  <p><strong>Intuition</strong></p> \n  <p>In brute force, we iterate over the left and right parts again and again just to find the highest bar size upto that index. But, this could be stored. Voila, dynamic programming.</p> \n  <p>The concept is illustrated as shown:</p> \n  <p align=\"center\"><img alt=\"Dynamic programming\" src=\"../Figures/42/trapping_rain_water.png\" width=\"500px\"></p> \n  <p><strong>Algorithm</strong></p> \n  <ul> \n   <li>Find maximum height of bar from the left end upto an index i in the array <script type=\"math/tex; mode=display\">\\text{left_max}</script>.</li> \n   <li>Find maximum height of bar from the right end upto an index i in the array <script type=\"math/tex; mode=display\">\\text{right_max}</script>.</li> \n   <li>Iterate over the <script type=\"math/tex; mode=display\">\\text{height}</script> array and update ans:\n    <ul> \n     <li>Add <script type=\"math/tex; mode=display\">\\min(\\text{max_left}[i],\\text{max_right}[i]) - \\text{height}[i]</script> to <script type=\"math/tex; mode=display\">ans</script> </li> \n    </ul> </li> \n  </ul> \n  <iframe src=\"https://leetcode.com/playground/njgFCz7X/shared\" frameborder=\"0\" width=\"100%\" height=\"395\" name=\"njgFCz7X\"></iframe> \n  <p><strong>Complexity analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity: <script type=\"math/tex; mode=display\">O(n)</script>.</p> \n    <ul> \n     <li>We store the maximum heights upto a point using 2 iterations of <script type=\"math/tex; mode=display\">O(n)</script> each.</li> \n     <li>We finally update <script type=\"math/tex; mode=display\">\\text{ans}</script> using the stored values in <script type=\"math/tex; mode=display\">O(n)</script>.</li> \n    </ul> </li> \n   <li> <p>Space complexity: <script type=\"math/tex; mode=display\">O(n)</script> extra space.</p> \n    <ul> \n     <li>Additional <script type=\"math/tex; mode=display\">O(n)</script> space for <script type=\"math/tex; mode=display\">\\text{left_max}</script> and <script type=\"math/tex; mode=display\">\\text{right_max}</script> arrays than in <a href=\"#approach-1-brute-force\">Approach 1</a>. <br> <br></li> \n    </ul> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-using-stacks\">Approach 3: Using stacks</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Instead of storing the largest bar upto an index as in <a href=\"#approach-2-dynamic-programming\">Approach 2</a>, we can use stack to keep track of the bars that are bounded by longer bars and hence, may store water. Using the stack, we can do the calculations in only one iteration.</p> \n  <p>We keep a stack and iterate over the array. We add the index of the bar to the stack if bar is smaller than or equal to the bar at top of stack, which means that the current bar is bounded by the previous bar in the stack. If we found a bar longer than that at the top, we are sure that the bar at the top of the stack is bounded by the current bar and a previous bar in the stack, hence, we can pop it and add resulting trapped water to <script type=\"math/tex; mode=display\">\\text{ans}</script>.</p> \n  <p><strong>Algorithm</strong></p> \n  <ul> \n   <li>Use stack to store the indices of the bars.</li> \n   <li>Iterate the array:\n    <ul> \n     <li>While stack is not empty and <script type=\"math/tex; mode=display\">\\text{height}[current]>\\text{height}[st.top()]</script> \n      <ul> \n       <li>It means that the stack element can be popped. Pop the top element as <script type=\"math/tex; mode=display\">\\text{top}</script>.</li> \n       <li>Find the distance between the current element and the element at top of stack, which is to be filled. <script type=\"math/tex; mode=display\">\\text{distance} = \\text{current} - \\text{st.top}() - 1</script> </li> \n       <li>Find the bounded height <script type=\"math/tex; mode=display\">\\text{bounded_height} = \\min(\\text{height[current]}, \\text{height[st.top()]}) - \\text{height[top]}</script> </li> \n       <li>Add resulting trapped water to answer <script type=\"math/tex; mode=display\">\\text{ans} += \\text{distance} * \\text{bounded_height}</script> </li> \n      </ul> </li> \n     <li>Push current index to top of the stack</li> \n     <li>Move <script type=\"math/tex; mode=display\">\\text{current}</script> to the next position</li> \n    </ul> </li> \n  </ul> \n  <iframe src=\"https://leetcode.com/playground/oFQMEyqr/shared\" frameborder=\"0\" width=\"100%\" height=\"361\" name=\"oFQMEyqr\"></iframe> \n  <p><strong>Complexity analysis</strong></p> \n  <ul> \n   <li>Time complexity: <script type=\"math/tex; mode=display\">O(n)</script>.\n    <ul> \n     <li>Single iteration of <script type=\"math/tex; mode=display\">O(n)</script> in which each bar can be touched at most twice(due to insertion and deletion from stack) and insertion and deletion from stack takes <script type=\"math/tex; mode=display\">O(1)</script> time.</li> \n    </ul> </li> \n   <li>Space complexity: <script type=\"math/tex; mode=display\">O(n)</script>. Stack can take upto <script type=\"math/tex; mode=display\">O(n)</script> space in case of stairs-like or flat structure. <br> <br></li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-4-using-2-pointers\">Approach 4: Using 2 pointers</h4> \n  <p><strong>Intuition</strong> As in <a href=\"#approach-2-dynamic-programming\">Approach 2</a>, instead of computing the left and right parts seperately, we may think of some way to do it in one iteration. From the figure in dynamic programming approach, notice that as long as <script type=\"math/tex; mode=display\">\\text{right_max}[i]>\\text{left_max}[i]</script> (from element 0 to 6), the water trapped depends upon the left_max, and similar is the case when <script type=\"math/tex; mode=display\">\\text{left_max}[i]>\\text{right_max}[i]</script> (from element 8 to 11). So, we can say that if there is a larger bar at one end (say right), we are assured that the water trapped would be dependant on height of bar in current direction (from left to right). As soon as we find the bar at other end (right) is smaller, we start iterating in opposite direction (from right to left). We must maintain <script type=\"math/tex; mode=display\">\\text{left_max}</script> and <script type=\"math/tex; mode=display\">\\text{right_max}</script> during the iteration, but now we can do it in one iteration using 2 pointers, switching between the two.</p> \n  <p><strong>Algorithm</strong></p> \n  <ul> \n   <li>Initialize <script type=\"math/tex; mode=display\">\\text{left}</script> pointer to 0 and <script type=\"math/tex; mode=display\">\\text{right}</script> pointer to size-1</li> \n   <li>While <script type=\"math/tex; mode=display\">\\text{left}< \\text{right}</script>, do:\n    <ul> \n     <li>If <script type=\"math/tex; mode=display\">\\text{height[left]}</script> is smaller than <script type=\"math/tex; mode=display\">\\text{height[right]}</script> </li> \n     <li>If <script type=\"math/tex; mode=display\">\\text{height[left]}>=\\text{left_max}</script>, update <script type=\"math/tex; mode=display\">\\text{left_max}</script> \n      <ul> \n       <li>Else add <script type=\"math/tex; mode=display\">\\text{left_max}-\\text{height[left]}</script> to <script type=\"math/tex; mode=display\">\\text{ans}</script> </li> \n       <li>Add 1 to <script type=\"math/tex; mode=display\">\\text{left}</script>.</li> \n      </ul> </li> \n     <li>Else\n      <ul> \n       <li>If <script type=\"math/tex; mode=display\">\\text{height[right]}>=\\text{right_max}</script>, update <script type=\"math/tex; mode=display\">\\text{right_max}</script> </li> \n       <li>Else add <script type=\"math/tex; mode=display\">\\text{right_max}-\\text{height[right]}</script> to <script type=\"math/tex; mode=display\">\\text{ans}</script> </li> \n       <li>Subtract 1 from <script type=\"math/tex; mode=display\">\\text{right}</script>.</li> \n      </ul> </li> \n    </ul> </li> \n  </ul> \n  <p>Refer the example for better understanding: !?!../Documents/42_trapping_rain_water.json:1000,662!?!</p> \n  <iframe src=\"https://leetcode.com/playground/WkcdjvDh/shared\" frameborder=\"0\" width=\"100%\" height=\"344\" name=\"WkcdjvDh\"></iframe> \n  <p><strong>Complexity analysis</strong></p> \n  <ul> \n   <li>Time complexity: <script type=\"math/tex; mode=display\">O(n)</script>. Single iteration of <script type=\"math/tex; mode=display\">O(n)</script>.</li> \n   <li>Space complexity: <script type=\"math/tex; mode=display\">O(1)</script> extra space. Only constant space required for <script type=\"math/tex; mode=display\">\\text{left}</script>, <script type=\"math/tex; mode=display\">\\text{right}</script>, <script type=\"math/tex; mode=display\">\\text{left_max}</script> and <script type=\"math/tex; mode=display\">\\text{right_max}</script>.</li> \n  </ul> \n </div> \n</div>"
},
{
    "frontend_question_id": 41,
    "article_live": false,
    "title": "First Missing Positive",
    "title_slug": "first-missing-positive",
    "content": "<p>Given an unsorted integer array, find the smallest missing&nbsp;positive integer.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\nInput: [1,2,0]\r\nOutput: 3\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\nInput: [3,4,-1,1]\r\nOutput: 2\r\n</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\nInput: [7,8,9,11,12]\r\nOutput: 1\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<p>Your algorithm should run in <em>O</em>(<em>n</em>) time and uses constant extra space.</p>\r\n",
    "tags": "Array",
    "difficulty": 3,
    "frontend_article_id": 41
},
{
    "frontend_question_id": 40,
    "article_live": false,
    "title": "Combination Sum II",
    "title_slug": "combination-sum-ii",
    "content": "<p>Given a collection of candidate numbers (<code>candidates</code>) and a target number (<code>target</code>), find all unique combinations in <code>candidates</code>&nbsp;where the candidate numbers sums to <code>target</code>.</p>\r\n\r\n<p>Each number in <code>candidates</code>&nbsp;may only be used <strong>once</strong> in the combination.</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>All numbers (including <code>target</code>) will be positive integers.</li>\r\n\t<li>The solution set must not contain duplicate combinations.</li>\r\n</ul>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> candidates =&nbsp;<code>[10,1,2,7,6,1,5]</code>, target =&nbsp;<code>8</code>,\r\n<strong>A solution set is:</strong>\r\n[\r\n  [1, 7],\r\n  [1, 2, 5],\r\n  [2, 6],\r\n  [1, 1, 6]\r\n]\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> candidates =&nbsp;[2,5,2,1,2], target =&nbsp;5,\r\n<strong>A solution set is:</strong>\r\n[\r\n&nbsp; [1,2,2],\r\n&nbsp; [5]\r\n]\r\n</pre>\r\n",
    "tags": "Array, Backtracking",
    "difficulty": 2,
    "frontend_article_id": 40
},
{
    "frontend_question_id": 39,
    "article_live": false,
    "title": "Combination Sum",
    "title_slug": "combination-sum",
    "content": "<p>Given a <strong>set</strong> of candidate numbers (<code>candidates</code>) <strong>(without duplicates)</strong> and a target number (<code>target</code>), find all unique combinations in <code>candidates</code>&nbsp;where the candidate numbers sums to <code>target</code>.</p>\r\n\r\n<p>The <strong>same</strong> repeated number may be chosen from <code>candidates</code>&nbsp;unlimited number of times.</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>All numbers (including <code>target</code>) will be positive integers.</li>\r\n\t<li>The solution set must not contain duplicate combinations.</li>\r\n</ul>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> candidates = <code>[2,3,6,7], </code>target = <code>7</code>,\r\n<strong>A solution set is:</strong>\r\n[\r\n  [7],\r\n  [2,2,3]\r\n]\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> candidates = [2,3,5]<code>, </code>target = 8,\r\n<strong>A solution set is:</strong>\r\n[\r\n&nbsp; [2,2,2,2],\r\n&nbsp; [2,3,3],\r\n&nbsp; [3,5]\r\n]\r\n</pre>\r\n",
    "tags": "Array, Backtracking",
    "difficulty": 2,
    "frontend_article_id": 39
},
{
    "frontend_question_id": 38,
    "article_live": false,
    "title": "Count and Say",
    "title_slug": "count-and-say",
    "content": "<p>The count-and-say sequence is the sequence of integers with the first five terms as following:</p>\r\n\r\n<pre>\r\n1.     1\r\n2.     11\r\n3.     21\r\n4.     1211\r\n5.     111221\r\n</pre>\r\n\r\n<p><code>1</code> is read off as <code>&quot;one 1&quot;</code> or <code>11</code>.<br />\r\n<code>11</code> is read off as <code>&quot;two 1s&quot;</code> or <code>21</code>.<br />\r\n<code>21</code> is read off as <code>&quot;one 2</code>, then <code>one 1&quot;</code> or <code>1211</code>.</p>\r\n\r\n<p>Given an integer <i>n</i>&nbsp;where 1 &le; <em>n</em> &le; 30, generate the <i>n</i><sup>th</sup> term of the count-and-say sequence.</p>\r\n\r\n<p>Note: Each term of the sequence of integers will be represented as a string.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> 1\r\n<b>Output:</b> &quot;1&quot;\r\n</pre>\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> 4\r\n<b>Output:</b> &quot;1211&quot;</pre>\r\n",
    "tags": "String",
    "difficulty": 1,
    "frontend_article_id": 38
},
{
    "frontend_question_id": 37,
    "article_live": false,
    "title": "Sudoku Solver",
    "title_slug": "sudoku-solver",
    "content": "<p>Write a program to solve a Sudoku puzzle by filling the empty cells.</p>\r\n\r\n<p>A&nbsp;sudoku solution must satisfy <strong>all of&nbsp;the following rules</strong>:</p>\r\n\r\n<ol>\r\n\t<li>Each of the digits&nbsp;<code>1-9</code> must occur exactly&nbsp;once in each row.</li>\r\n\t<li>Each of the digits&nbsp;<code>1-9</code>&nbsp;must occur&nbsp;exactly once in each column.</li>\r\n\t<li>Each of the the digits&nbsp;<code>1-9</code> must occur exactly once in each of the 9 <code>3x3</code> sub-boxes of the grid.</li>\r\n</ol>\r\n\r\n<p>Empty cells are indicated by the character <code>&#39;.&#39;</code>.</p>\r\n\r\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png\" style=\"height:250px; width:250px\" /><br />\r\n<small>A sudoku puzzle...</small></p>\r\n\r\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png\" style=\"height:250px; width:250px\" /><br />\r\n<small>...and its solution numbers marked in red.</small></p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>The given board&nbsp;contain only digits <code>1-9</code> and the character <code>&#39;.&#39;</code>.</li>\r\n\t<li>You may assume that the given Sudoku puzzle will have a single unique solution.</li>\r\n\t<li>The given board size is always <code>9x9</code>.</li>\r\n</ul>\r\n",
    "tags": "Hash Table, Backtracking",
    "difficulty": 3,
    "frontend_article_id": 37
},
{
    "frontend_question_id": 36,
    "article_live": false,
    "title": "Valid Sudoku",
    "title_slug": "valid-sudoku",
    "content": "<p>Determine if a&nbsp;9x9 Sudoku board&nbsp;is valid.&nbsp;Only the filled cells need to be validated&nbsp;<strong>according to the following rules</strong>:</p>\r\n\r\n<ol>\r\n\t<li>Each row&nbsp;must contain the&nbsp;digits&nbsp;<code>1-9</code> without repetition.</li>\r\n\t<li>Each column must contain the digits&nbsp;<code>1-9</code>&nbsp;without repetition.</li>\r\n\t<li>Each of the 9 <code>3x3</code> sub-boxes of the grid must contain the digits&nbsp;<code>1-9</code>&nbsp;without repetition.</li>\r\n</ol>\r\n\r\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png\" style=\"height:250px; width:250px\" /><br />\r\n<small>A partially filled sudoku which is valid.</small></p>\r\n\r\n<p>The Sudoku board could be partially filled, where empty cells are filled with the character <code>&#39;.&#39;</code>.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>\r\n[\r\n  [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],\r\n  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],\r\n  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],\r\n  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],\r\n  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],\r\n  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],\r\n  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],\r\n  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],\r\n  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]\r\n]\r\n<strong>Output:</strong> true\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>\r\n[\r\n&nbsp; [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],\r\n&nbsp; [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],\r\n&nbsp; [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],\r\n&nbsp; [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],\r\n&nbsp; [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],\r\n&nbsp; [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],\r\n&nbsp; [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],\r\n&nbsp; [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],\r\n&nbsp; [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]\r\n]\r\n<strong>Output:</strong> false\r\n<strong>Explanation:</strong> Same as Example 1, except with the <strong>5</strong> in the top left corner being \r\n    modified to <strong>8</strong>. Since there are two 8&#39;s in the top left 3x3 sub-box, it is invalid.\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>A Sudoku board (partially filled) could be valid but is not necessarily solvable.</li>\r\n\t<li>Only the filled cells need to be validated according to the mentioned&nbsp;rules.</li>\r\n\t<li>The given board&nbsp;contain only digits <code>1-9</code> and the character <code>&#39;.&#39;</code>.</li>\r\n\t<li>The given board size is always <code>9x9</code>.</li>\r\n</ul>\r\n",
    "tags": "Hash Table",
    "difficulty": 2,
    "frontend_article_id": 36
},
{
    "frontend_question_id": 35,
    "article_live": false,
    "title": "Search Insert Position",
    "title_slug": "search-insert-position",
    "content": "<p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>\r\n\r\n<p>You may assume no duplicates in the array.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [1,3,5,6], 5\r\n<strong>Output:</strong> 2\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [1,3,5,6], 2\r\n<strong>Output:</strong> 1\r\n</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [1,3,5,6], 7\r\n<strong>Output:</strong> 4\r\n</pre>\r\n\r\n<p><strong>Example 4:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [1,3,5,6], 0\r\n<strong>Output:</strong> 0\r\n</pre>\r\n",
    "tags": "Array, Binary Search",
    "difficulty": 1,
    "frontend_article_id": 35
},
{
    "frontend_question_id": 34,
    "article_live": true,
    "article_slug": "find-first-and-last-position-element-sorted-array",
    "title": "Find First and Last Position of Element in Sorted Array",
    "title_slug": "find-first-and-last-position-of-element-in-sorted-array",
    "content": "<p>Given an array of integers <code>nums</code> sorted in ascending order, find the starting and ending position of a given <code>target</code> value.</p>\r\n\r\n<p>Your algorithm&#39;s runtime complexity must be in the order of <em>O</em>(log <em>n</em>).</p>\r\n\r\n<p>If the target is not found in the array, return <code>[-1, -1]</code>.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [<code>5,7,7,8,8,10]</code>, target = 8\r\n<strong>Output:</strong> [3,4]</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [<code>5,7,7,8,8,10]</code>, target = 6\r\n<strong>Output:</strong> [-1,-1]</pre>\r\n",
    "tags": "Array, Binary Search",
    "difficulty": 2,
    "frontend_article_id": 34,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-linear-scan\">Approach 1: Linear Scan</a></li> \n    <li><a href=\"#approach-2-binary-search\">Approach 2: Binary Search</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-linear-scan\">Approach 1: Linear Scan</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Checking every index for <code>target</code> exhausts the search space, so it must work.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>First, we do a linear scan of <code>nums</code> from the left, <code>break</code>ing when we find an instance of <code>target</code>. If we never <code>break</code>, then <code>target</code> is not present, so we can return the \"error code\" of <code>[-1, -1]</code> early. Given that we did find a valid left index, we can do a second linear scan, but this time from the right. In this case, the first instance of <code>target</code> encountered will be the rightmost one (and because a leftmost one exists, there is guaranteed to also be a rightmost one). We then simply return a list containing the two located indices.</p> \n  <iframe src=\"https://leetcode.com/playground/3Qq9cbHX/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"3Qq9cbHX\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script> </p> <p>This brute-force approach examines each of the <code>n</code> elements of <code>nums</code> exactly twice, so the overall runtime is linear.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script> </p> <p>The linear scan method allocates a fixed-size array and a few integers, so it has a constant-size memory footprint.</p> </li> \n  </ul> \n  <p><br></p> \n  <hr> \n  <h4 id=\"approach-2-binary-search\">Approach 2: Binary Search</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Because the array is sorted, we can use binary search to locate the left and rightmost indices.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>The overall algorithm works fairly similarly to the linear scan approach, except for the subroutine used to find the left and rightmost indices themselves. Here, we use a modified binary search to search a sorted array, with a few minor adjustments. First, because we are locating the leftmost (or rightmost) index containing <code>target</code> (rather than returning <code>true</code> iff we find <code>target</code>), the algorithm does not terminate as soon as we find a match. Instead, we continue to search until <code>lo == hi</code> and they contain some index at which <code>target</code> can be found.</p> \n  <p>The other change is the introduction of the <code>left</code> parameter, which is a boolean indicating what to do in the event that <code>target == nums[mid]</code>; if <code>left</code> is <code>true</code>, then we \"recurse\" on the left subarray on ties. Otherwise, we go right. To see why this is correct, consider the situation where we find <code>target</code> at index <code>i</code>. The leftmost <code>target</code> cannot occur at any index greater than <code>i</code>, so we never need to consider the right subarray. The same argument applies to the rightmost index.</p> \n  <p>The first animation below shows the process for finding the leftmost index, and the second shows the process for finding the index right of the rightmost index.</p> \n  <p>!?!../Documents/34_Search_for_a_Range_left.json:1280,720!?!</p> \n  <p>!?!../Documents/34_Search_for_a_Range_right.json:1280,720!?!</p> \n  <iframe src=\"https://leetcode.com/playground/3J9unhAP/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"3J9unhAP\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(\\log_{10}(n))</script> </p> <p>Because binary search cuts the search space roughly in half on each iteration, there can be at most <script type=\"math/tex; mode=display\">\\lceil \\log_{10}(n) \\rceil</script> iterations. Binary search is invoked twice, so the overall complexity is logarithmic.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script> </p> <p>All work is done in place, so the overall memory usage is constant.</p> </li> \n  </ul> \n </div> \n</div>"
},
{
    "frontend_question_id": 33,
    "article_live": false,
    "title": "Search in Rotated Sorted Array",
    "title_slug": "search-in-rotated-sorted-array",
    "content": "<p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>\r\n\r\n<p>(i.e., <code>[0,1,2,4,5,6,7]</code> might become <code>[4,5,6,7,0,1,2]</code>).</p>\r\n\r\n<p>You are given a target value to search. If found in the array return its index, otherwise return <code>-1</code>.</p>\r\n\r\n<p>You may assume no duplicate exists in the array.</p>\r\n\r\n<p>Your algorithm&#39;s runtime complexity must be in the order of&nbsp;<em>O</em>(log&nbsp;<em>n</em>).</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [<code>4,5,6,7,0,1,2]</code>, target = 0\r\n<strong>Output:</strong> 4\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [<code>4,5,6,7,0,1,2]</code>, target = 3\r\n<strong>Output:</strong> -1</pre>\r\n",
    "tags": "Array, Binary Search",
    "difficulty": 2,
    "frontend_article_id": 33
},
{
    "frontend_question_id": 32,
    "article_live": true,
    "article_slug": "longest-valid-parentheses",
    "title": "Longest Valid Parentheses",
    "title_slug": "longest-valid-parentheses",
    "content": "<p>Given a string containing just the characters <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code>, find the length of the longest valid (well-formed) parentheses substring.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> &quot;(()&quot;\r\n<strong>Output:</strong> 2\r\n<strong>Explanation:</strong> The longest valid parentheses substring is <code>&quot;()&quot;</code>\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> &quot;<code>)()())</code>&quot;\r\n<strong>Output:</strong> 4\r\n<strong>Explanation:</strong> The longest valid parentheses substring is <code>&quot;()()&quot;</code>\r\n</pre>\r\n",
    "tags": "String, Dynamic Programming",
    "difficulty": 3,
    "frontend_article_id": 32,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#summary\">Summary</a></li> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force\">Approach 1: Brute Force</a></li> \n      <li><a href=\"#approach-2-using-dynamic-programming\">Approach 2: Using Dynamic Programming</a></li> \n      <li><a href=\"#approach-3-using-stack\">Approach 3: Using Stack</a></li> \n      <li><a href=\"#approach-4-without-extra-space\">Approach 4: Without extra space</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"summary\">Summary</h2> \n  <p>We need to determine the length of the largest valid substring of parentheses from a given string.</p> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force\">Approach 1: Brute Force</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In this approach, we consider every possible non-empty even length substring from the given string and check whether it's a valid string of parentheses or not. In order to check the validity, we use the Stack's Method.</p> \n  <p>Every time we encounter a <script type=\"math/tex; mode=display\">\\text{‘(’}</script>, we push it onto the stack. For every <script type=\"math/tex; mode=display\">\\text{‘)’}</script> encountered, we pop a <script type=\"math/tex; mode=display\">\\text{‘(’}</script> from the stack. If <script type=\"math/tex; mode=display\">\\text{‘(’}</script> isn't available on the stack for popping at anytime or if stack contains some elements after processing complete substring, the substring of parentheses is invalid. In this way, we repeat the process for every possible substring and we keep on storing the length of the longest valid string found so far.</p> \n  <div class=\"codehilite\">\n   <pre><span></span>Example:\n\"((())\"\n\n(( --&gt; invalid\n(( --&gt; invalid\n() --&gt; valid, length=2\n)) --&gt; invalid\n((()--&gt; invalid\n(())--&gt; valid, length=4\nmaxlength=4\n</pre>\n  </div> \n  <iframe src=\"https://leetcode.com/playground/smDecW2X/shared\" frameborder=\"0\" width=\"100%\" height=\"497\" name=\"smDecW2X\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^3)</script>. Generating every possible substring from a string of length <script type=\"math/tex; mode=display\">n</script> requires <script type=\"math/tex; mode=display\">O(n^2)</script>. Checking validity of a string of length <script type=\"math/tex; mode=display\">n</script> requires <script type=\"math/tex; mode=display\">O(n)</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. A stack of depth <script type=\"math/tex; mode=display\">n</script> will be required for the longest substring. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-using-dynamic-programming\">Approach 2: Using Dynamic Programming</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>This problem can be solved by using Dynamic Programming. We make use of a <script type=\"math/tex; mode=display\">\\text{dp}</script> array where <script type=\"math/tex; mode=display\">i</script>th element of <script type=\"math/tex; mode=display\">\\text{dp}</script> represents the length of the longest valid substring ending at <script type=\"math/tex; mode=display\">i</script>th index. We initialize the complete <script type=\"math/tex; mode=display\">\\text{dp}</script> array with 0's. Now, it's obvious that the valid substrings must end with <script type=\"math/tex; mode=display\">\\text{‘)’}</script>. This further leads to the conclusion that the substrings ending with <script type=\"math/tex; mode=display\">\\text{‘(’}</script> will always contain '0' at their corresponding <script type=\"math/tex; mode=display\">\\text{dp}</script> indices. Thus, we update the <script type=\"math/tex; mode=display\">\\text{dp}</script> array only when <script type=\"math/tex; mode=display\">\\text{‘)’}</script> is encountered.</p> \n  <p>To fill <script type=\"math/tex; mode=display\">\\text{dp}</script> array we will check every two consecutive characters of the string and if</p> \n  <ol> \n   <li> <p> <script type=\"math/tex; mode=display\">\\text{s}[i] = \\text{‘)’}</script> and <script type=\"math/tex; mode=display\">\\text{s}[i - 1] = \\text{‘(’}</script>, i.e. string looks like <script type=\"math/tex; mode=display\">``.......()\" \\Rightarrow</script> </p> <p> <script type=\"math/tex; mode=display\">\n\\text{dp}[i]=\\text{dp}[i-2]+2\n</script> </p> <p>We do so because the ending \"()\" portion is a valid substring anyhow and leads to an increment of 2 in the length of the just previous valid substring's length.</p> </li> \n   <li> <p> <script type=\"math/tex; mode=display\">\\text{s}[i] = \\text{‘)’}</script> and <script type=\"math/tex; mode=display\">\\text{s}[i - 1] = \\text{‘)’}</script>, i.e. string looks like <script type=\"math/tex; mode=display\">``.......))\" \\Rightarrow</script> </p> <p>if <script type=\"math/tex; mode=display\">\\text{s}[i - \\text{dp}[i - 1] - 1] = \\text{‘(’}</script> then</p> <p> <script type=\"math/tex; mode=display\">\n\\text{dp}[i]=\\text{dp}[i-1]+\\text{dp}[i-\\text{dp}[i-1]-2]+2\n</script> </p> </li> \n  </ol> \n  <p>The reason behind this is that if the 2nd last <script type=\"math/tex; mode=display\">\\text{‘)’}</script> was a part of a valid substring (say <script type=\"math/tex; mode=display\">sub_s</script>), for the last <script type=\"math/tex; mode=display\">\\text{‘)’}</script> to be a part of a larger substring, there must be a corresponding starting <script type=\"math/tex; mode=display\">\\text{‘(’}</script> which lies before the valid substring of which the 2nd last <script type=\"math/tex; mode=display\">\\text{‘)’}</script> is a part (i.e. before <script type=\"math/tex; mode=display\">sub_s</script>). Thus, if the character before <script type=\"math/tex; mode=display\">sub_s</script> happens to be <script type=\"math/tex; mode=display\">\\text{‘(’}</script>, we update the <script type=\"math/tex; mode=display\">\\text{dp}[i]</script> as an addition of <script type=\"math/tex; mode=display\">2</script> in the length of <script type=\"math/tex; mode=display\">sub_s</script> which is <script type=\"math/tex; mode=display\">\\text{dp}[i-1]</script>. To this, we also add the length of the valid substring just before the term \"(,sub_s,)\" , i.e. <script type=\"math/tex; mode=display\">\\text{dp}[i-\\text{dp}[i-1]-2]</script>.</p> \n  <p>For better understanding of this method, see this example:</p> \n  <!--![Longest_Valid_Parenthesis](../Figures/32_LongestValidParenthesisDP.gif)--> \n  <p>!?!../Documents/32_Longest_Valid2.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/YGuAh4tp/shared\" frameborder=\"0\" width=\"100%\" height=\"344\" name=\"YGuAh4tp\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Single traversal of string to fill dp array is done.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. dp array of size <script type=\"math/tex; mode=display\">n</script> is used. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-using-stack\">Approach 3: Using Stack</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Instead of finding every possible string and checking its validity, we can make use of stack while scanning the given string to check if the string scanned so far is valid, and also the length of the longest valid string. In order to do so, we start by pushing <script type=\"math/tex; mode=display\">-1</script> onto the stack.</p> \n  <p>For every <script type=\"math/tex; mode=display\">\\text{‘(’}</script> encountered, we push its index onto the stack.</p> \n  <p>For every <script type=\"math/tex; mode=display\">\\text{‘)’}</script> encountered, we pop the topmost element and subtract the current element's index from the top element of the stack, which gives the length of the currently encountered valid string of parentheses. If while popping the element, the stack becomes empty, we push the current element's index onto the stack. In this way, we keep on calculating the lengths of the valid substrings, and return the length of the longest valid string at the end.</p> \n  <p>See this example for better understanding.</p> \n  <!--![Longest_Valid_Parenthesis](../Figures/32_LongestValidParenthesisSTACK.gif)--> \n  <p>!?!../Documents/32_Longest_Valid_stack_new.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/A2oPe4yE/shared\" frameborder=\"0\" width=\"100%\" height=\"412\" name=\"A2oPe4yE\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. <script type=\"math/tex; mode=display\">n</script> is the length of the given string..</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The size of stack can go up to <script type=\"math/tex; mode=display\">n</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-4-without-extra-space\">Approach 4: Without extra space</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In this approach, we make use of two counters <script type=\"math/tex; mode=display\">left</script> and <script type=\"math/tex; mode=display\">right</script>. First, we start traversing the string from the left towards the right and for every <script type=\"math/tex; mode=display\">\\text{‘(’}</script> encountered, we increment the <script type=\"math/tex; mode=display\">left</script> counter and for every <script type=\"math/tex; mode=display\">\\text{‘)’}</script> encountered, we increment the <script type=\"math/tex; mode=display\">right</script> counter. Whenever <script type=\"math/tex; mode=display\">left</script> becomes equal to <script type=\"math/tex; mode=display\">right</script>, we calculate the length of the current valid string and keep track of maximum length substring found so far. If <script type=\"math/tex; mode=display\">right</script> becomes greater than <script type=\"math/tex; mode=display\">left</script> we reset <script type=\"math/tex; mode=display\">left</script> and <script type=\"math/tex; mode=display\">right</script> to <script type=\"math/tex; mode=display\">0</script>.</p> \n  <p>Next, we start traversing the string from right to left and similar procedure is applied.</p> \n  <p>Example of this approach:</p> \n  <!--![Longest_Valid_Parenthesis](../Figures/32_LongestValidParenthesisLR.gif)--> \n  <p>!?!../Documents/32_Longest_Validlr.json:1000,563!?!</p> \n  <iframe src=\"https://leetcode.com/playground/RsBpRHK7/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"RsBpRHK7\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Two traversals of the string.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Only two extra variables <script type=\"math/tex; mode=display\">left</script> and <script type=\"math/tex; mode=display\">right</script> are needed.</p> </li> \n  </ul> \n </div> \n</div>"
},
{
    "frontend_question_id": 31,
    "article_live": true,
    "article_slug": "next-permutation",
    "title": "Next Permutation",
    "title_slug": "next-permutation",
    "content": "<p>Implement <strong>next permutation</strong>, which rearranges numbers into the lexicographically next greater permutation of numbers.</p>\r\n\r\n<p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p>\r\n\r\n<p>The replacement must be <strong><a href=\"http://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\">in-place</a></strong> and use only constant&nbsp;extra memory.</p>\r\n\r\n<p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</p>\r\n\r\n<p><code>1,2,3</code> &rarr; <code>1,3,2</code><br />\r\n<code>3,2,1</code> &rarr; <code>1,2,3</code><br />\r\n<code>1,1,5</code> &rarr; <code>1,5,1</code></p>\r\n",
    "tags": "Array",
    "difficulty": 2,
    "frontend_article_id": 31,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#summary\">Summary</a></li> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force\">Approach 1: Brute Force</a></li> \n      <li><a href=\"#approach-2-single-pass-approach\">Approach 2: Single Pass Approach</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"summary\">Summary</h2> \n  <p>We need to find the next lexicographic permutation of the given list of numbers than the number formed by the given array.</p> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force\">Approach 1: Brute Force</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In this approach, we find out every possible permutation of list formed by the elements of the given array and find out the permutation which is just larger than the given one. But this one will be a very naive approach, since it requires us to find out every possible permutation which will take really long time and the implementation is complex. Thus, this approach is not acceptable at all. Hence, we move on directly to the correct approach.</p> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time complexity : <script type=\"math/tex; mode=display\">O(n!)</script>. Total possible permutations is <script type=\"math/tex; mode=display\">n!</script>.</li> \n   <li>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Since an array will be used to store the permutations. <br> <br></li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-single-pass-approach\">Approach 2: Single Pass Approach</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>First, we observe that for any given sequence that is in descending order, no next larger permutation is possible. For example, no next permutation is possible for the following array: <code>[9, 5, 4, 3, 1]</code></p> \n  <p>We need to find the first pair of two successive numbers <script type=\"math/tex; mode=display\">a[i]</script> and <script type=\"math/tex; mode=display\">a[i-1]</script>, from the right, which satisfy <script type=\"math/tex; mode=display\">a[i] > a[i-1]</script>. Now, no rearrangements to the right of <script type=\"math/tex; mode=display\">a[i-1]</script> can create a larger permutation since that subarray consists of numbers in descending order. Thus, we need to rearrange the numbers to the right of <script type=\"math/tex; mode=display\">a[i-1]</script> including itself.</p> \n  <p>Now, what kind of rearrangement will produce the next larger number? We want to create the permutation just larger than the current one. Therefore, we need to replace the number <script type=\"math/tex; mode=display\">a[i-1]</script> with the number which is just larger than itself among the numbers lying to its right section, say <script type=\"math/tex; mode=display\">a[j]</script>.</p> \n  <p><img alt=\" Next Permutation \" src=\"https://leetcode.com/media/original_images/31_nums_graph.png\"></p> \n  <p>We swap the numbers <script type=\"math/tex; mode=display\">a[i-1]</script> and <script type=\"math/tex; mode=display\">a[j]</script>. We now have the correct number at index <script type=\"math/tex; mode=display\">i-1</script>. But still the current permutation isn't the permutation that we are looking for. We need the smallest permutation that can be formed by using the numbers only to the right of <script type=\"math/tex; mode=display\">a[i-1]</script>. Therefore, we need to place those numbers in ascending order to get their smallest permutation.</p> \n  <p>But, recall that while scanning the numbers from the right, we simply kept decrementing the index until we found the pair <script type=\"math/tex; mode=display\">a[i]</script> and <script type=\"math/tex; mode=display\">a[i-1]</script> where, <script type=\"math/tex; mode=display\">a[i] > a[i-1]</script>. Thus, all numbers to the right of <script type=\"math/tex; mode=display\">a[i-1]</script> were already sorted in descending order. Furthermore, swapping <script type=\"math/tex; mode=display\">a[i-1]</script> and <script type=\"math/tex; mode=display\">a[j]</script> didn't change that order. Therefore, we simply need to reverse the numbers following <script type=\"math/tex; mode=display\">a[i-1]</script> to get the next smallest lexicographic permutation.</p> \n  <p>The following animation will make things clearer:</p> \n  <p><img alt=\"Next Permutation\" src=\"https://leetcode.com/media/original_images/31_Next_Permutation.gif\"></p> \n  <iframe src=\"https://leetcode.com/playground/tJPs3ERV/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"tJPs3ERV\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. In worst case, only two scans of the whole array are needed.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. No extra space is used. In place replacements are done.</p> </li> \n  </ul> \n </div> \n</div>"
},
{
    "frontend_question_id": 30,
    "article_live": false,
    "title": "Substring with Concatenation of All Words",
    "title_slug": "substring-with-concatenation-of-all-words",
    "content": "<p>You are given a string, <strong>s</strong>, and a list of words, <strong>words</strong>, that are all of the same length. Find all starting indices of substring(s) in <strong>s</strong> that is a concatenation of each word in <strong>words</strong> exactly once and without any intervening characters.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:\r\n  s =</strong> &quot;barfoothefoobarman&quot;,\r\n<strong>  words = </strong>[&quot;foo&quot;,&quot;bar&quot;]\r\n<strong>Output:</strong> <code>[0,9]</code>\r\n<strong>Explanation:</strong> Substrings starting at index 0 and 9 are &quot;barfoor&quot; and &quot;foobar&quot; respectively.\r\nThe output order does not matter, returning [9,0] is fine too.\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:\r\n  s =</strong> &quot;wordgoodstudentgoodword&quot;,\r\n<strong>  words = </strong>[&quot;word&quot;,&quot;student&quot;]\r\n<strong>Output:</strong> <code>[]</code>\r\n</pre>\r\n",
    "tags": "Hash Table, Two Pointers, String",
    "difficulty": 3,
    "frontend_article_id": 30
},
{
    "frontend_question_id": 29,
    "article_live": false,
    "title": "Divide Two Integers",
    "title_slug": "divide-two-integers",
    "content": "<p>Given two integers <code>dividend</code> and <code>divisor</code>, divide two integers without using multiplication, division and mod operator.</p>\r\n\r\n<p>Return the quotient after dividing <code>dividend</code> by <code>divisor</code>.</p>\r\n\r\n<p>The integer division should truncate toward zero.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> dividend = 10, divisor = 3\r\n<strong>Output:</strong> 3</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> dividend = 7, divisor = -3\r\n<strong>Output:</strong> -2</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>Both dividend and divisor&nbsp;will be&nbsp;32-bit&nbsp;signed integers.</li>\r\n\t<li>The divisor will never be 0.</li>\r\n\t<li>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [&minus;2<sup>31</sup>, &nbsp;2<sup>31</sup> &minus; 1]. For the purpose of this problem, assume that your function returns 2<sup>31</sup> &minus; 1 when the division result&nbsp;overflows.</li>\r\n</ul>\r\n",
    "tags": "Math, Binary Search",
    "difficulty": 2,
    "frontend_article_id": 29
},
{
    "frontend_question_id": 28,
    "article_live": false,
    "title": "Implement strStr()",
    "title_slug": "implement-strstr",
    "content": "<p>Implement <a href=\"http://www.cplusplus.com/reference/cstring/strstr/\" target=\"_blank\">strStr()</a>.</p>\r\n\r\n<p>Return the index of the first occurrence of needle in haystack, or <strong>-1</strong> if needle is not part of haystack.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> haystack = &quot;hello&quot;, needle = &quot;ll&quot;\r\n<strong>Output:</strong> 2\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;\r\n<strong>Output:</strong> -1\r\n</pre>\r\n\r\n<p><strong>Clarification:</strong></p>\r\n\r\n<p>What should we return when <code>needle</code> is an empty string? This is a great question to ask during an interview.</p>\r\n\r\n<p>For the purpose of this problem, we will return 0 when <code>needle</code> is an empty string. This is consistent to C&#39;s&nbsp;<a href=\"http://www.cplusplus.com/reference/cstring/strstr/\" target=\"_blank\">strstr()</a> and Java&#39;s&nbsp;<a href=\"https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)\" target=\"_blank\">indexOf()</a>.</p>\r\n",
    "tags": "Two Pointers, String",
    "difficulty": 1,
    "frontend_article_id": 28
},
{
    "frontend_question_id": 27,
    "article_live": true,
    "article_slug": "remove-element",
    "title": "Remove Element",
    "title_slug": "remove-element",
    "content": "<p>Given an array <em>nums</em> and a value <em>val</em>, remove all instances of that value <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\"><strong>in-place</strong></a> and return the new length.</p>\r\n\r\n<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\">in-place</a></strong> with O(1) extra memory.</p>\r\n\r\n<p>The order of elements can be changed. It doesn&#39;t matter what you leave beyond the new length.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\nGiven <em>nums</em> = <strong>[3,2,2,3]</strong>, <em>val</em> = <strong>3</strong>,\r\n\r\nYour function should return length = <strong>2</strong>, with the first two elements of <em>nums</em> being <strong>2</strong>.\r\n\r\nIt doesn&#39;t matter what you leave beyond the returned length.\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\nGiven <em>nums</em> = <strong>[0,1,2,2,3,0,4,2]</strong>, <em>val</em> = <strong>2</strong>,\r\n\r\nYour function should return length = <strong><code>5</code></strong>, with the first five elements of <em><code>nums</code></em> containing&nbsp;<strong><code>0</code></strong>, <strong><code>1</code></strong>, <strong><code>3</code></strong>, <strong><code>0</code></strong>, and&nbsp;<strong>4</strong>.\r\n\r\nNote that the order of those five elements can be arbitrary.\r\n\r\nIt doesn&#39;t matter what values are set beyond&nbsp;the returned length.</pre>\r\n\r\n<p><strong>Clarification:</strong></p>\r\n\r\n<p>Confused why the returned value is an integer but your answer is an array?</p>\r\n\r\n<p>Note that the input array is passed in by <strong>reference</strong>, which means modification to the input array will be known to the caller as well.</p>\r\n\r\n<p>Internally you can think of this:</p>\r\n\r\n<pre>\r\n// <strong>nums</strong> is passed in by reference. (i.e., without making a copy)\r\nint len = removeElement(nums, val);\r\n\r\n// any modification to <strong>nums</strong> in your function would be known by the caller.\r\n// using the length returned by your function, it prints the first <strong>len</strong> elements.\r\nfor (int i = 0; i &lt; len; i++) {\r\n&nbsp; &nbsp; print(nums[i]);\r\n}</pre>\r\n",
    "tags": "Array, Two Pointers",
    "difficulty": 1,
    "frontend_article_id": 27,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#summary\">Summary</a></li> \n    <li><a href=\"#hints\">Hints</a></li> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-two-pointers\">Approach 1: Two Pointers</a></li> \n      <li><a href=\"#approach-2-two-pointers-when-elements-to-remove-are-rare\">Approach 2: Two Pointers - when elements to remove are rare</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"summary\">Summary</h2> \n  <p>This is a pretty easy problem, but one may get confused by the term \"in-place\" and thought it is impossible to remove an element from the array without making a copy of the array.</p> \n  <h2 id=\"hints\">Hints</h2> \n  <ol> \n   <li>Try two pointers.</li> \n   <li>Did you use the property of \"the order of elements can be changed\"?</li> \n   <li>What happens when the elements to remove are rare?</li> \n  </ol> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-two-pointers\">Approach 1: Two Pointers</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Since question asked us to remove all elements of the given value in-place, we have to handle it with <script type=\"math/tex; mode=display\">O(1)</script> extra space. How to solve it? We can keep two pointers <script type=\"math/tex; mode=display\">i</script> and <script type=\"math/tex; mode=display\">j</script>, where <script type=\"math/tex; mode=display\">i</script> is the slow-runner while <script type=\"math/tex; mode=display\">j</script> is the fast-runner.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>When <script type=\"math/tex; mode=display\">nums[j]</script> equals to the given value, skip this element by incrementing <script type=\"math/tex; mode=display\">j</script>. As long as <script type=\"math/tex; mode=display\">nums[j] \\neq val</script>, we copy <script type=\"math/tex; mode=display\">nums[j]</script> to <script type=\"math/tex; mode=display\">nums[i]</script> and increment both indexes at the same time. Repeat the process until <script type=\"math/tex; mode=display\">j</script> reaches the end of the array and the new length is <script type=\"math/tex; mode=display\">i</script>.</p> \n  <p>This solution is very similar to the solution to <a href=\"https://leetcode.com/articles/remove-duplicates-from-sorted-array/\">Remove Duplicates from Sorted Array</a>.</p> \n  <iframe src=\"https://leetcode.com/playground/ykwunWxa/shared\" frameborder=\"0\" width=\"100%\" height=\"225\" name=\"ykwunWxa\"></iframe> \n  <p><strong>Complexity analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Assume the array has a total of <script type=\"math/tex; mode=display\">n</script> elements, both <script type=\"math/tex; mode=display\">i</script> and <script type=\"math/tex; mode=display\">j</script> traverse at most <script type=\"math/tex; mode=display\">2n</script> steps.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-two-pointers-when-elements-to-remove-are-rare\">Approach 2: Two Pointers - when elements to remove are rare</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Now consider cases where the array contains few elements to remove. For example, <script type=\"math/tex; mode=display\">nums = [1,2,3,5,4], val = 4</script>. The previous algorithm will do unnecessary copy operation of the first four elements. Another example is <script type=\"math/tex; mode=display\">nums = [4,1,2,3,5], val = 4</script>. It seems unnecessary to move elements <script type=\"math/tex; mode=display\">[1,2,3,5]</script> one step left as the problem description mentions that the order of elements could be changed.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>When we encounter <script type=\"math/tex; mode=display\">nums[i] = val</script>, we can swap the current element out with the last element and dispose the last one. This essentially reduces the array's size by 1.</p> \n  <p>Note that the last element that was swapped in could be the value you want to remove itself. But don't worry, in the next iteration we will still check this element.</p> \n  <iframe src=\"https://leetcode.com/playground/hF6wWHYr/shared\" frameborder=\"0\" width=\"100%\" height=\"293\" name=\"hF6wWHYr\"></iframe> \n  <p><strong>Complexity analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Both <script type=\"math/tex; mode=display\">i</script> and <script type=\"math/tex; mode=display\">n</script> traverse at most <script type=\"math/tex; mode=display\">n</script> steps. In this approach, the number of assignment operation is equal to the number of elements to remove. So it is more efficient if elements to remove are rare.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n  </ul> \n </div> \n</div>"
},
{
    "frontend_question_id": 26,
    "article_live": true,
    "article_slug": "remove-duplicates-from-sorted-array",
    "title": "Remove Duplicates from Sorted Array",
    "title_slug": "remove-duplicates-from-sorted-array",
    "content": "<p>Given a sorted array <em>nums</em>, remove the duplicates <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\"><strong>in-place</strong></a> such that each element appear only <em>once</em> and return the new length.</p>\r\n\r\n<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\">in-place</a></strong> with O(1) extra memory.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\nGiven <em>nums</em> = <strong>[1,1,2]</strong>,\r\n\r\nYour function should return length = <strong><code>2</code></strong>, with the first two elements of <em><code>nums</code></em> being <strong><code>1</code></strong> and <strong><code>2</code></strong> respectively.\r\n\r\nIt doesn&#39;t matter what you leave beyond the returned length.</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\nGiven <em>nums</em> = <strong>[0,0,1,1,1,2,2,3,3,4]</strong>,\r\n\r\nYour function should return length = <strong><code>5</code></strong>, with the first five elements of <em><code>nums</code></em> being modified to&nbsp;<strong><code>0</code></strong>, <strong><code>1</code></strong>, <strong><code>2</code></strong>, <strong><code>3</code></strong>, and&nbsp;<strong><code>4</code></strong> respectively.\r\n\r\nIt doesn&#39;t matter what values are set beyond&nbsp;the returned length.\r\n</pre>\r\n\r\n<p><strong>Clarification:</strong></p>\r\n\r\n<p>Confused why the returned value is an integer but your answer is an array?</p>\r\n\r\n<p>Note that the input array is passed in by <strong>reference</strong>, which means modification to the input array will be known to the caller as well.</p>\r\n\r\n<p>Internally you can think of this:</p>\r\n\r\n<pre>\r\n// <strong>nums</strong> is passed in by reference. (i.e., without making a copy)\r\nint len = removeDuplicates(nums);\r\n\r\n// any modification to <strong>nums</strong> in your function would be known by the caller.\r\n// using the length returned by your function, it prints the first <strong>len</strong> elements.\r\nfor (int i = 0; i &lt; len; i++) {\r\n&nbsp; &nbsp; print(nums[i]);\r\n}</pre>\r\n",
    "tags": "Array, Two Pointers",
    "difficulty": 1,
    "frontend_article_id": 26,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-two-pointers\">Approach 1: Two Pointers</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-two-pointers\">Approach 1: Two Pointers</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Since the array is already sorted, we can keep two pointers <script type=\"math/tex; mode=display\">i</script> and <script type=\"math/tex; mode=display\">j</script>, where <script type=\"math/tex; mode=display\">i</script> is the slow-runner while <script type=\"math/tex; mode=display\">j</script> is the fast-runner. As long as <script type=\"math/tex; mode=display\">nums[i] = nums[j]</script>, we increment <script type=\"math/tex; mode=display\">j</script> to skip the duplicate.</p> \n  <p>When we encounter <script type=\"math/tex; mode=display\">nums[j] \\neq nums[i]</script>, the duplicate run has ended so we must copy its value to <script type=\"math/tex; mode=display\">nums[i + 1]</script>. <script type=\"math/tex; mode=display\">i</script> is then incremented and we repeat the same process again until <script type=\"math/tex; mode=display\">j</script> reaches the end of array.</p> \n  <iframe src=\"https://leetcode.com/playground/p8jPfpcx/shared\" frameborder=\"0\" width=\"100%\" height=\"242\" name=\"p8jPfpcx\"></iframe> \n  <p><strong>Complexity analysis</strong></p> \n  <ul> \n   <li> <p>Time complextiy : <script type=\"math/tex; mode=display\">O(n)</script>. Assume that <script type=\"math/tex; mode=display\">n</script> is the length of array. Each of <script type=\"math/tex; mode=display\">i</script> and <script type=\"math/tex; mode=display\">j</script> traverses at most <script type=\"math/tex; mode=display\">n</script> steps.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n  </ul> \n </div> \n</div>"
},
{
    "frontend_question_id": 25,
    "article_live": false,
    "title": "Reverse Nodes in k-Group",
    "title_slug": "reverse-nodes-in-k-group",
    "content": "<p>Given a linked list, reverse the nodes of a linked list <em>k</em> at a time and return its modified list.</p>\r\n\r\n<p><em>k</em> is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of <em>k</em> then left-out nodes in the end should remain as it is.</p>\r\n\r\n<ul>\r\n</ul>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<p>Given this linked list: <code>1-&gt;2-&gt;3-&gt;4-&gt;5</code></p>\r\n\r\n<p>For <em>k</em> = 2, you should return: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code></p>\r\n\r\n<p>For <em>k</em> = 3, you should return: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code></p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>Only constant extra memory is allowed.</li>\r\n\t<li>You may not alter the values in the list&#39;s nodes, only nodes itself may be changed.</li>\r\n</ul>\r\n",
    "tags": "Linked List",
    "difficulty": 3,
    "frontend_article_id": 25
},
{
    "frontend_question_id": 24,
    "article_live": false,
    "title": "Swap Nodes in Pairs",
    "title_slug": "swap-nodes-in-pairs",
    "content": "<p>Given a&nbsp;linked list, swap every two adjacent nodes and return its head.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\nGiven <code>1-&gt;2-&gt;3-&gt;4</code>, you should return the list as <code>2-&gt;1-&gt;4-&gt;3</code>.</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>Your algorithm should use only constant extra space.</li>\r\n\t<li>You may <strong>not</strong> modify the values in the list&#39;s nodes, only nodes itself may be changed.</li>\r\n</ul>\r\n",
    "tags": "Linked List",
    "difficulty": 2,
    "frontend_article_id": 24
},
{
    "frontend_question_id": 23,
    "article_live": true,
    "article_slug": "merge-k-sorted-list",
    "title": "Merge k Sorted Lists",
    "title_slug": "merge-k-sorted-lists",
    "content": "<p>Merge <em>k</em> sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>\r\n[\r\n&nbsp; 1-&gt;4-&gt;5,\r\n&nbsp; 1-&gt;3-&gt;4,\r\n&nbsp; 2-&gt;6\r\n]\r\n<strong>Output:</strong> 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6\r\n</pre>\r\n",
    "tags": "Linked List, Divide and Conquer, Heap",
    "difficulty": 3,
    "frontend_article_id": 23,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force\">Approach 1: Brute Force</a></li> \n      <li><a href=\"#approach-2-compare-one-by-one\">Approach 2: Compare one by one</a></li> \n      <li><a href=\"#approach-3-optimize-approach-2-by-priority-queue\">Approach 3: Optimize Approach 2 by Priority Queue</a></li> \n      <li><a href=\"#approach-4-merge-lists-one-by-one\">Approach 4: Merge lists one by one</a></li> \n      <li><a href=\"#approach-5-merge-with-divide-and-conquer\">Approach 5: Merge with Divide And Conquer</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force\">Approach 1: Brute Force</h4> \n  <p><strong>Intuition &amp; Algorithm</strong></p> \n  <ul> \n   <li>Traverse all the linked lists and collect the values of the nodes into an array.</li> \n   <li>Sort and iterate over this array to get the proper value of nodes.</li> \n   <li>Create a new sorted linked list and extend it with the new nodes.</li> \n  </ul> \n  <p>As for sorting, you can refer <a href=\"https://www.cs.cmu.edu/~adamchik/15-121/lectures/Sorting%20Algorithms/sorting.html\">here</a> for more about sorting algorithms.</p> \n  <iframe src=\"https://leetcode.com/playground/kCxLKUfQ/shared\" frameborder=\"0\" width=\"100%\" height=\"327\" name=\"kCxLKUfQ\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(N\\log N)</script> where <script type=\"math/tex; mode=display\">N</script> is the total number of nodes.</p> \n    <ul> \n     <li>Collecting all the values costs <script type=\"math/tex; mode=display\">O(N)</script> time.</li> \n     <li>A stable sorting algorithm costs <script type=\"math/tex; mode=display\">O(N\\log N)</script> time.</li> \n     <li>Iterating for creating the linked list costs <script type=\"math/tex; mode=display\">O(N)</script> time.</li> \n    </ul> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(N)</script>.</p> \n    <ul> \n     <li>Sorting cost <script type=\"math/tex; mode=display\">O(N)</script> space (depends on the algorithm you choose).</li> \n     <li>Creating a new linked list costs <script type=\"math/tex; mode=display\">O(N)</script> space. <br> <br></li> \n    </ul> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-compare-one-by-one\">Approach 2: Compare one by one</h4> \n  <p><strong>Algorithm</strong></p> \n  <ul> \n   <li>Compare every <script type=\"math/tex; mode=display\">\\text{k}</script> nodes (head of every linked list) and get the node with the smallest value.</li> \n   <li>Extend the final sorted linked list with the selected nodes.</li> \n  </ul> \n  <p>!?!../Documents/23_Merge_lists.json:1000,563!?!</p> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(kN)</script> where <script type=\"math/tex; mode=display\">\\text{k}</script> is the number of linked lists.</p> \n    <ul> \n     <li>Almost every selection of node in final linked costs <script type=\"math/tex; mode=display\">O(k)</script> (<script type=\"math/tex; mode=display\">\\text{k-1}</script> times comparison).</li> \n     <li>There are <script type=\"math/tex; mode=display\">N</script> nodes in the final linked list.</li> \n    </ul> </li> \n   <li> <p>Space complexity :</p> \n    <ul> \n     <li> <script type=\"math/tex; mode=display\">O(n)</script> Creating a new linked list costs <script type=\"math/tex; mode=display\">O(n)</script> space.</li> \n     <li> <script type=\"math/tex; mode=display\">O(1)</script> It's not hard to apply in-place method - connect selected nodes instead of creating new nodes to fill the new linked list. <br> <br></li> \n    </ul> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-optimize-approach-2-by-priority-queue\">Approach 3: Optimize Approach 2 by Priority Queue</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Almost the same as the one above but optimize the <strong>comparison process</strong> by <strong>priority queue</strong>. You can refer <a href=\"https://en.wikipedia.org/wiki/Priority_queue\">here</a> for more information about it.</p> \n  <iframe src=\"https://leetcode.com/playground/wnXfryCD/shared\" frameborder=\"0\" width=\"100%\" height=\"412\" name=\"wnXfryCD\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(N\\log k)</script> where <script type=\"math/tex; mode=display\">\\text{k}</script> is the number of linked lists.</p> \n    <ul> \n     <li>The comparison cost will be reduced to <script type=\"math/tex; mode=display\">O(\\log k)</script> for every pop and insertion to priority queue. But finding the node with the smallest value just costs <script type=\"math/tex; mode=display\">O(1)</script> time.</li> \n     <li>There are <script type=\"math/tex; mode=display\">N</script> nodes in the final linked list.</li> \n    </ul> </li> \n   <li> <p>Space complexity :</p> \n    <ul> \n     <li> <script type=\"math/tex; mode=display\">O(n)</script> Creating a new linked list costs <script type=\"math/tex; mode=display\">O(n)</script> space.</li> \n     <li> <script type=\"math/tex; mode=display\">O(k)</script> The code above present applies in-place method which cost <script type=\"math/tex; mode=display\">O(1)</script> space. And the priority queue (often implemented with heaps) costs <script type=\"math/tex; mode=display\">O(k)</script> space (it's far less than <script type=\"math/tex; mode=display\">N</script> in most situations). <br> <br></li> \n    </ul> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-4-merge-lists-one-by-one\">Approach 4: Merge lists one by one</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Convert merge <script type=\"math/tex; mode=display\">\\text{k}</script> lists problem to merge 2 lists (<script type=\"math/tex; mode=display\">\\text{k-1}</script>) times. Here is the <a href=\"https://leetcode.com/problems/merge-two-sorted-lists/description/\">merge 2 lists</a> problem page.</p> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(kN)</script> where <script type=\"math/tex; mode=display\">\\text{k}</script> is the number of linked lists.</p> \n    <ul> \n     <li>We can merge two sorted linked list in <script type=\"math/tex; mode=display\">O(n)</script> time where <script type=\"math/tex; mode=display\">n</script> is the total number of nodes in two lists.</li> \n     <li>Sum up the merge process and we can get: <script type=\"math/tex; mode=display\">O(\\sum_{i=1}^{k-1} (i*(\\frac{N}{k}) + \\frac{N}{k})) = O(kN)</script>.</li> \n    </ul> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script> </p> \n    <ul> \n     <li>We can merge two sorted linked list in <script type=\"math/tex; mode=display\">O(1)</script> space. <br> <br></li> \n    </ul> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-5-merge-with-divide-and-conquer\">Approach 5: Merge with Divide And Conquer</h4> \n  <p><strong>Intuition &amp; Algorithm</strong></p> \n  <p>This approach walks alongside the one above but is improved a lot. We don't need to traverse most nodes many times repeatedly</p> \n  <ul> \n   <li> <p>Pair up <script type=\"math/tex; mode=display\">\\text{k}</script> lists and merge each pair.</p> </li> \n   <li> <p>After the first pairing, <script type=\"math/tex; mode=display\">\\text{k}</script> lists are merged into <script type=\"math/tex; mode=display\">k/2</script> lists with average <script type=\"math/tex; mode=display\">2N/k</script> length, then <script type=\"math/tex; mode=display\">k/4</script>, <script type=\"math/tex; mode=display\">k/8</script> and so on.</p> </li> \n   <li> <p>Repeat this procedure until we get the final sorted linked list.</p> </li> \n  </ul> \n  <p>Thus, we'll traverse almost <script type=\"math/tex; mode=display\">N</script> nodes per pairing and merging, and repeat this procedure about <script type=\"math/tex; mode=display\">\\log_{2}{k}</script> times.</p> \n  <p align=\"align\"><img alt=\"Divide_and_Conquer\" src=\"../Figures/23/23_divide_and_conquer_new.png\"></p> \n  <iframe src=\"https://leetcode.com/playground/8nnKQ4tP/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"8nnKQ4tP\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(N\\log k)</script> where <script type=\"math/tex; mode=display\">\\text{k}</script> is the number of linked lists.</p> \n    <ul> \n     <li>We can merge two sorted linked list in <script type=\"math/tex; mode=display\">O(n)</script> time where <script type=\"math/tex; mode=display\">n</script> is the total number of nodes in two lists.</li> \n     <li>Sum up the merge process and we can get: <script type=\"math/tex; mode=display\">O\\big(\\sum_{i=1}^{log_{2}{k}}N \\big)= O(N\\log k)</script> </li> \n    </ul> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script> </p> \n    <ul> \n     <li>We can merge two sorted linked lists in <script type=\"math/tex; mode=display\">O(1)</script> space.</li> \n    </ul> </li> \n  </ul> \n </div> \n</div>"
},
{
    "frontend_question_id": 22,
    "article_live": true,
    "article_slug": "generate-parentheses",
    "title": "Generate Parentheses",
    "title_slug": "generate-parentheses",
    "content": "<p>\r\nGiven <i>n</i> pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\r\n</p>\r\n\r\n<p>\r\nFor example, given <i>n</i> = 3, a solution set is:\r\n</p>\r\n<pre>\r\n[\r\n  \"((()))\",\r\n  \"(()())\",\r\n  \"(())()\",\r\n  \"()(())\",\r\n  \"()()()\"\r\n]\r\n</pre>",
    "tags": "String, Backtracking",
    "difficulty": 2,
    "frontend_article_id": 22,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#approach-1-brute-force\">Approach 1: Brute Force</a></li> \n    <li><a href=\"#approach-2-backtracking\">Approach 2: Backtracking</a></li> \n    <li><a href=\"#approach-3-closure-number\">Approach 3: Closure Number</a></li> \n   </ul> \n  </div> \n  <h4 id=\"approach-1-brute-force\">Approach 1: Brute Force</h4> \n  <p><strong>Intuition</strong></p> \n  <p>We can generate all <script type=\"math/tex; mode=display\">2^{2n}</script> sequences of <code>'('</code> and <code>')'</code> characters. Then, we will check if each one is valid.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>To generate all sequences, we use a recursion. All sequences of length <code>n</code> is just <code>'('</code> plus all sequences of length <code>n-1</code>, and then <code>')'</code> plus all sequences of length <code>n-1</code>.</p> \n  <p>To check whether a sequence is valid, we keep track of <code>balance</code>, the net number of opening brackets minus closing brackets. If it falls below zero at any time, or doesn't end in zero, the sequence is invalid - otherwise it is valid.</p> \n  <iframe src=\"https://leetcode.com/playground/eDRvbWjL/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"eDRvbWjL\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity : <script type=\"math/tex; mode=display\">O(2^{2n}n)</script>. For each of <script type=\"math/tex; mode=display\">2^{2n}</script> sequences, we need to create and validate the sequence, which takes <script type=\"math/tex; mode=display\">O(n)</script> work.</p> </li> \n   <li> <p>Space Complexity : <script type=\"math/tex; mode=display\">O(2^{2n}n)</script>. Naively, every sequence could be valid. See <a href=\"#approach-3-closure-number\">Approach 3</a> for development of a tighter asymptotic bound. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-backtracking\">Approach 2: Backtracking</h4> \n  <p><strong>Intuition and Algorithm</strong></p> \n  <p>Instead of adding <code>'('</code> or <code>')'</code> every time as in <a href=\"#approach-1-brute-force\">Approach 1</a>, let's only add them when we know it will remain a valid sequence. We can do this by keeping track of the number of opening and closing brackets we have placed so far.</p> \n  <p>We can start an opening bracket if we still have one (of <code>n</code>) left to place. And we can start a closing bracket if it would not exceed the number of opening brackets.</p> \n  <iframe src=\"https://leetcode.com/playground/npPa38Mh/shared\" frameborder=\"0\" width=\"100%\" height=\"378\" name=\"npPa38Mh\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <p>Our complexity analysis rests on understanding how many elements there are in <code>generateParenthesis(n)</code>. This analysis is outside the scope of this article, but it turns out this is the <code>n</code>-th Catalan number <script type=\"math/tex; mode=display\">\\dfrac{1}{n+1}\\binom{2n}{n}</script>, which is bounded asymptotically by <script type=\"math/tex; mode=display\">\\dfrac{4^n}{n\\sqrt{n}}</script>.</p> \n  <ul> \n   <li> <p>Time Complexity : <script type=\"math/tex; mode=display\">O(\\dfrac{4^n}{\\sqrt{n}})</script>. Each valid sequence has at most <code>n</code> steps during the backtracking procedure.</p> </li> \n   <li> <p>Space Complexity : <script type=\"math/tex; mode=display\">O(\\dfrac{4^n}{\\sqrt{n}})</script>, as described above, and using <script type=\"math/tex; mode=display\">O(n)</script> space to store the sequence. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-closure-number\">Approach 3: Closure Number</h4> \n  <p><strong>Intuition</strong></p> \n  <p>To enumerate something, generally we would like to express it as a sum of disjoint subsets that are easier to count.</p> \n  <p>Consider the <em>closure number</em> of a valid parentheses sequence <code>S</code>: the least <code>index &gt;= 0</code> so that <code>S[0], S[1], ..., S[2*index+1]</code> is valid. Clearly, every parentheses sequence has a unique <em>closure number</em>. We can try to enumerate them individually.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>For each closure number <code>c</code>, we know the starting and ending brackets must be at index <code>0</code> and <code>2*c + 1</code>. Then, the <code>2*c</code> elements between must be a valid sequence, plus the rest of the elements must be a valid sequence.</p> \n  <iframe src=\"https://leetcode.com/playground/Z3ZYfRAo/shared\" frameborder=\"0\" width=\"100%\" height=\"293\" name=\"Z3ZYfRAo\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time and Space Complexity : <script type=\"math/tex; mode=display\">O(\\dfrac{4^n}{\\sqrt{n}})</script>. The analysis is similar to <a href=\"#approach-2-backtracking\">Approach 2</a>.</li> \n  </ul> \n </div> \n</div>"
},
{
    "frontend_question_id": 21,
    "article_live": true,
    "article_slug": "merged-two-sorted-lists",
    "title": "Merge Two Sorted Lists",
    "title_slug": "merge-two-sorted-lists",
    "content": "<p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>\r\n\r\n<p><b>Example:</b>\r\n<pre>\r\n<b>Input:</b> 1->2->4, 1->3->4\r\n<b>Output:</b> 1->1->2->3->4->4\r\n</pre>\r\n</p>",
    "tags": "Linked List",
    "difficulty": 1,
    "frontend_article_id": 21,
    "article_content": ""
},
{
    "frontend_question_id": 20,
    "article_live": true,
    "article_slug": "valid-parentheses",
    "title": "Valid Parentheses",
    "title_slug": "valid-parentheses",
    "content": "<p>Given a string containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p>\r\n\r\n<p>An input string is valid if:</p>\r\n\r\n<ol>\r\n\t<li>Open brackets must be closed by the same type of brackets.</li>\r\n\t<li>Open brackets must be closed in the correct order.</li>\r\n</ol>\r\n\r\n<p>Note that an empty string is&nbsp;also considered valid.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> &quot;()&quot;\r\n<strong>Output:</strong> true\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> &quot;()[]{}&quot;\r\n<strong>Output:</strong> true\r\n</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> &quot;(]&quot;\r\n<strong>Output:</strong> false\r\n</pre>\r\n\r\n<p><strong>Example 4:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> &quot;([)]&quot;\r\n<strong>Output:</strong> false\r\n</pre>\r\n\r\n<p><strong>Example 5:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> &quot;{[]}&quot;\r\n<strong>Output:</strong> true\r\n</pre>\r\n",
    "tags": "String, Stack",
    "difficulty": 1,
    "frontend_article_id": 20,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-stacks\">Approach 1: Stacks</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <p><br> <strong>Intuition</strong></p> \n  <p>Imagine you are writing a small compiler for your college project and one of the tasks (or say sub-tasks) for the compiler would be to detect if the parenthesis are in place or not.</p> \n  <p>The algorithm we will look at in this article can be then used to process all the parenthesis in the program your compiler is compiling and checking if all the parenthesis are in place. This makes checking if a given string of parenthesis is valid or not, an important programming problem.</p> \n  <p>The expressions that we will deal with in this problem can consist of three different type of parenthesis:</p> \n  <ul> \n   <li><code>()</code>,</li> \n   <li><code>{}</code> and</li> \n   <li><code>[]</code></li> \n  </ul> \n  <p>Before looking at how we can check if a given expression consisting of these parenthesis is valid or not, let us look at a simpler version of the problem that consists of just one type of parenthesis. So, the expressions we can encounter in this simplified version of the problem are e.g.</p> \n  <pre>(((((()))))) -- VALID\n\n()()()()     -- VALID\n\n(((((((()    -- INVALID\n\n((()(())))   -- VALID\n</pre> \n  <p>Let's look at a simple algorithm to deal with this problem.</p> \n  <ol> \n   <li>We process the expression one bracket at a time starting from the left.</li> \n   <li>Suppose we encounter an opening bracket i.e. <code>(</code>, it may or may not be an invalid expression because there can be a matching ending bracket somewhere in the remaining part of the expression. Here, we simply increment the counter keeping track of left parenthesis till now. <code>left += 1</code></li> \n   <li> <p>If we encounter a closing bracket, this has two meanings:</p> \n    <ol> \n     <li>One, there was no matching opening bracket for this closing bracket and in that case we have an invalid expression. This is the case when <code>left == 0</code> i.e. when there are no unmatched left brackets available.</li> \n     <li>We had <code>some unmatched</code> opening bracket available to match this closing bracket. This is the case when <code>left &gt; 0</code> i.e. we have unmatched left brackets available.</li> \n    </ol> </li> \n   <li> <p>If we encounter a closing bracket i.e. <code>)</code> when <code>left == 0</code>, then we have an invalid expression on our hands. Else, we decrement <code>left</code> thus reducing the number of unmatched left parenthesis available.</p> </li> \n   <li>Continue processing the string until all parenthesis have been processed.</li> \n   <li>If in the end we still have unmatched left parenthesis available, this implies an invalid expression.</li> \n  </ol> \n  <p>The reason we discussed this particular algorithm here is because the approach for the original problem derives its inspiration from this very solution. Have a look at the following dry run of the algorithm we discussed to have a better understanding.</p> \n  <p>!?!../Documents/20_Simple.json:1000,400!?!</p> \n  <p>If we try and follow the same approach for our original problem, then it simply won't work. The reason a simple counter based approach works above is because all the parenthesis are of the same type. So when we encounter a closing bracket, we simply assume a corresponding opening matching bracket to be available i.e. if <code>left &gt; 0</code>.</p> \n  <p>But, in our problem, if we encounter say <code>]</code>, we don't really know if there is a corresponding opening <code>[</code> available or not. You could say:</p> \n  <blockquote> \n   <p>Why not maintain a separate counter for the different types of parenthesis?</p> \n  </blockquote> \n  <p>This doesn't work because the relative placement of the parenthesis also matters here. e.g.:</p> \n  <pre>[{]\n</pre> \n  <p>If we simply keep counters here, then as soon as we encounter the closing square bracket, we would know there is an unmatched opening square bracket available as well. But, the <strong>closest unmatched opening bracket available is a curly bracket and not a square bracket</strong> and hence the counting approach breaks here. <br> <br></p> \n  <hr> \n  <h4 id=\"approach-1-stacks\">Approach 1: Stacks</h4> \n  <p>An interesting property about a valid parenthesis expression is that a sub-expression of a valid expression should also be a valid expression. (Not every sub-expression) e.g.</p> \n  <p></p>\n  <center> \n   <img src=\"../Figures/20/20-Valid-Parentheses-Recursive-Property.png\" width=\"700\">\n  </center>\n  <p></p> \n  <p>Also, if you look at the above structure carefully, the color coded cells mark the opening and closing pairs of parenthesis. The entire expression is valid, but sub portions of it are also valid in themselves. This lends a sort of a recursive structure to the problem. For e.g. Consider the expression enclosed within the two green parenthesis in the diagram above. The opening bracket at index <code>1</code> and the corresponding closing bracket at index <code>6</code>.</p> \n  <blockquote> \n   <p>What if whenever we encounter a matching pair of parenthesis in the expression, we simply remove it from the expression?</p> \n  </blockquote> \n  <p>Let's have a look at this idea below where remove the smaller expressions one at a time from the overall expression and since this is a valid expression, we would be left with an empty string in the end.</p> \n  <p>!?!../Documents/20_Recursive.json:1000,400!?!</p> \n  <blockquote> \n   <p>The stack data structure can come in handy here in representing this recursive structure of the problem. We can't really process this from the inside out because we don't have an idea about the overall structure. But, the stack can help us process this recursively i.e. from outside to inwards.</p> \n  </blockquote> \n  <p>Let us have a look at the algorithm for this problem using stacks as the intermediate data structure.</p> \n  <p><strong>Algorithm</strong></p> \n  <ol> \n   <li>Initialize a stack S.</li> \n   <li>Process each bracket of the expression one at a time.</li> \n   <li>If we encounter an opening bracket, we simply push it onto the stack. This means we will process it later, let us simply move onto the <strong>sub-expression</strong> ahead.</li> \n   <li>If we encounter a closing bracket, then we check the element on top of the stack. If the element at the top of the stack is an opening bracket <code>of the same type</code>, then we pop it off the stack and continue processing. Else, this implies an invalid expression.</li> \n   <li>In the end, if we are left with a stack still having elements, then this implies an invalid expression.</li> \n  </ol> \n  <p>We'll have a look a dry run for the algorithm and then move onto the implementation.</p> \n  <p>!?!../Documents/20_Stack.json:1000,560!?!</p> \n  <p>Let us now have a look at the implementation for this algorithm.</p> \n  <iframe src=\"https://leetcode.com/playground/ubaUuDdD/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"ubaUuDdD\"></iframe> \n  <p><strong>Complexity analysis</strong></p> \n  <ul> \n   <li>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script> because we simply traverse the given string one character at a time and push and pop operations on a stack take <script type=\"math/tex; mode=display\">O(1)</script> time.</li> \n   <li>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script> as we push all opening brackets onto the stack and in the worst case, we will end up pushing all the brackets onto the stack. e.g. <code>((((((((((</code>.</li> \n  </ul> \n  <p><br> <br></p> \n  <hr> \n  <p>Analysis written by: <a href=\"https://leetcode.com/sachinmalhotra1993\">@sachinmalhotra1993</a>.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 19,
    "article_live": true,
    "article_slug": "remove-nth-node-from-end-of-list",
    "title": "Remove Nth Node From End of List",
    "title_slug": "remove-nth-node-from-end-of-list",
    "content": "<p>Given a linked list, remove the <em>n</em>-th node from the end of list and return its head.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\nGiven linked list: <strong>1-&gt;2-&gt;3-&gt;4-&gt;5</strong>, and <strong><em>n</em> = 2</strong>.\r\n\r\nAfter removing the second node from the end, the linked list becomes <strong>1-&gt;2-&gt;3-&gt;5</strong>.\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<p>Given <em>n</em> will always be valid.</p>\r\n\r\n<p><strong>Follow up:</strong></p>\r\n\r\n<p>Could you do this in one pass?</p>\r\n",
    "tags": "Linked List, Two Pointers",
    "difficulty": 2,
    "frontend_article_id": 19,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#summary\">Summary</a></li> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-two-pass-algorithm\">Approach 1: Two pass algorithm</a></li> \n      <li><a href=\"#approach-2-one-pass-algorithm\">Approach 2: One pass algorithm</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"summary\">Summary</h2> \n  <p>This article is for beginners. It introduces the following idea: Linked List traversal and removal of nth element from the end.</p> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-two-pass-algorithm\">Approach 1: Two pass algorithm</h4> \n  <p><strong>Intuition</strong></p> \n  <p>We notice that the problem could be simply reduced to another one : Remove the <script type=\"math/tex; mode=display\">(L - n + 1)</script> th node from the beginning in the list , where <script type=\"math/tex; mode=display\">L</script> is the list length. This problem is easy to solve once we found list length <script type=\"math/tex; mode=display\">L</script>.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>First we will add an auxiliary \"dummy\" node, which points to the list head. The \"dummy\" node is used to simplify some corner cases such as a list with only one node, or removing the head of the list. On the first pass, we find the list length <script type=\"math/tex; mode=display\">L</script>. Then we set a pointer to the dummy node and start to move it through the list till it comes to the <script type=\"math/tex; mode=display\">(L - n)</script> th node. We relink <code>next</code> pointer of the <script type=\"math/tex; mode=display\">(L - n)</script> th node to the <script type=\"math/tex; mode=display\">(L - n + 2)</script> th node and we are done.</p> \n  <p align=\"center\"><img alt=\"Remove the nth element from a list\" src=\"https://leetcode.com/media/original_images/19_Remove_nth_node_from_end_of_listA.png\"></p> \n  <p align=\"center\"><em>Figure 1. Remove the L - n + 1 th element from a list.</em></p> \n  <iframe src=\"https://leetcode.com/playground/mjMSbADc/shared\" frameborder=\"0\" width=\"100%\" height=\"361\" name=\"mjMSbADc\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(L)</script>.</p> <p>The algorithm makes two traversal of the list, first to calculate list length <script type=\"math/tex; mode=display\">L</script> and second to find the <script type=\"math/tex; mode=display\">(L - n)</script> th node. There are <script type=\"math/tex; mode=display\">2L-n</script> operations and time complexity is <script type=\"math/tex; mode=display\">O(L)</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>.</p> <p>We only used constant extra space. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-one-pass-algorithm\">Approach 2: One pass algorithm</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>The above algorithm could be optimized to one pass. Instead of one pointer, we could use two pointers. The first pointer advances the list by <script type=\"math/tex; mode=display\">n+1</script> steps from the beginning, while the second pointer starts from the beginning of the list. Now, both pointers are exactly separated by <script type=\"math/tex; mode=display\">n</script> nodes apart. We maintain this constant gap by advancing both pointers together until the first pointer arrives past the last node. The second pointer will be pointing at the <script type=\"math/tex; mode=display\">n</script>th node counting from the last. We relink the next pointer of the node referenced by the second pointer to point to the node's next next node.</p> \n  <p align=\"center\"><img alt=\"Remove the nth element from a list\" src=\"https://leetcode.com/media/original_images/19_Remove_nth_node_from_end_of_listB.png\"></p> \n  <p align=\"center\"><em>Figure 2. Remove the nth element from end of a list.</em></p> \n  <iframe src=\"https://leetcode.com/playground/BPxLi8Wz/shared\" frameborder=\"0\" width=\"100%\" height=\"344\" name=\"BPxLi8Wz\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(L)</script>.</p> <p>The algorithm makes one traversal of the list of <script type=\"math/tex; mode=display\">L</script> nodes. Therefore time complexity is <script type=\"math/tex; mode=display\">O(L)</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>.</p> <p>We only used constant extra space.</p> </li> \n  </ul> \n </div> \n</div>"
},
{
    "frontend_question_id": 18,
    "article_live": false,
    "title": "4Sum",
    "title_slug": "4sum",
    "content": "<p>Given an array <code>nums</code> of <em>n</em> integers and an integer <code>target</code>, are there elements <em>a</em>, <em>b</em>, <em>c</em>, and <em>d</em> in <code>nums</code> such that <em>a</em> + <em>b</em> + <em>c</em> + <em>d</em> = <code>target</code>? Find all unique quadruplets in the array which gives the sum of <code>target</code>.</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<p>The solution set must not contain duplicate quadruplets.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\nGiven array nums = [1, 0, -1, 0, -2, 2], and target = 0.\r\n\r\nA solution set is:\r\n[\r\n  [-1,  0, 0, 1],\r\n  [-2, -1, 1, 2],\r\n  [-2,  0, 0, 2]\r\n]\r\n</pre>\r\n",
    "tags": "Array, Hash Table, Two Pointers",
    "difficulty": 2,
    "frontend_article_id": 18
},
{
    "frontend_question_id": 17,
    "article_live": false,
    "title": "Letter Combinations of a Phone Number",
    "title_slug": "letter-combinations-of-a-phone-number",
    "content": "<p>Given a string containing digits from <code>2-9</code> inclusive, return all possible letter combinations that the number could represent.</p>\r\n\r\n<p>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p>\r\n\r\n<p><img src=\"http://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png\" /></p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>&quot;23&quot;\r\n<strong>Output:</strong> [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<p>Although the above answer is in lexicographical order, your answer could be in any order you want.</p>\r\n",
    "tags": "String, Backtracking",
    "difficulty": 2,
    "frontend_article_id": 17
},
{
    "frontend_question_id": 16,
    "article_live": false,
    "title": "3Sum Closest",
    "title_slug": "3sum-closest",
    "content": "<p>Given an array <code>nums</code> of <em>n</em> integers and an integer <code>target</code>, find three integers in <code>nums</code>&nbsp;such that the sum is closest to&nbsp;<code>target</code>. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\nGiven array nums = [-1, 2, 1, -4], and target = 1.\r\n\r\nThe sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\r\n</pre>\r\n",
    "tags": "Array, Two Pointers",
    "difficulty": 2,
    "frontend_article_id": 16
},
{
    "frontend_question_id": 15,
    "article_live": false,
    "title": "3Sum",
    "title_slug": "3sum",
    "content": "<p>Given an array <code>nums</code> of <em>n</em> integers, are there elements <em>a</em>, <em>b</em>, <em>c</em> in <code>nums</code> such that <em>a</em> + <em>b</em> + <em>c</em> = 0? Find all unique triplets in the array which gives the sum of zero.</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<p>The solution set must not contain duplicate triplets.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\nGiven array nums = [-1, 0, 1, 2, -1, -4],\r\n\r\nA solution set is:\r\n[\r\n  [-1, 0, 1],\r\n  [-1, -1, 2]\r\n]\r\n</pre>\r\n",
    "tags": "Array, Two Pointers",
    "difficulty": 2,
    "frontend_article_id": 15
},
{
    "frontend_question_id": 14,
    "article_live": true,
    "article_slug": "longest-common-prefix",
    "title": "Longest Common Prefix",
    "title_slug": "longest-common-prefix",
    "content": "<p>Write a function to find the longest common prefix string amongst an array of strings.</p>\r\n\r\n<p>If there is no common prefix, return an empty string <code>&quot;&quot;</code>.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>[&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]\r\n<strong>Output:</strong> &quot;fl&quot;\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>[&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]\r\n<strong>Output:</strong> &quot;&quot;\r\n<strong>Explanation:</strong> There is no common prefix among the input strings.\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<p>All given inputs are in lowercase letters <code>a-z</code>.</p>\r\n",
    "tags": "String",
    "difficulty": 1,
    "frontend_article_id": 14,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-horizontal-scanning\">Approach 1: Horizontal scanning</a></li> \n      <li><a href=\"#approach-2-vertical-scanning\">Approach 2: Vertical scanning</a></li> \n      <li><a href=\"#approach-3-divide-and-conquer\">Approach 3: Divide and conquer</a></li> \n      <li><a href=\"#approach-4-binary-search\">Approach 4: Binary search</a></li> \n      <li><a href=\"#further-thoughts-follow-up\">Further Thoughts / Follow up</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-horizontal-scanning\">Approach 1: Horizontal scanning</h4> \n  <p><strong>Intuition</strong></p> \n  <p>For a start we will describe a simple way of finding the longest prefix shared by a set of strings <script type=\"math/tex; mode=display\">LCP(S_1  \\ldots  S_n)</script>. We will use the observation that :</p> \n  <p> <script type=\"math/tex; mode=display\">LCP(S_1 \\ldots S_n) = LCP(LCP(LCP(S_1, S_2),S_3),\\ldots S_n)</script> </p> \n  <p><strong>Algorithm</strong></p> \n  <p>To employ this idea, the algorithm iterates through the strings <script type=\"math/tex; mode=display\">[S_1  \\ldots  S_n]</script>, finding at each iteration <script type=\"math/tex; mode=display\">i</script> the longest common prefix of strings <script type=\"math/tex; mode=display\">LCP(S_1  \\ldots  S_i)</script> When <script type=\"math/tex; mode=display\">LCP(S_1  \\ldots  S_i)</script> is an empty string, the algorithm ends. Otherwise after <script type=\"math/tex; mode=display\">n</script> iterations, the algorithm returns <script type=\"math/tex; mode=display\">LCP(S_1  \\ldots  S_n)</script>.</p> \n  <p align=\"center\"><img alt=\"Finding the longest common prefix\" src=\"https://leetcode.com/media/original_images/14_basic.png\" width=\"539px\"></p> \n  <p align=\"center\"><em>Figure 1. Finding the longest common prefix (Horizontal scanning)</em></p> \n  <p><iframe src=\"https://leetcode.com/playground/bbV4Q4kA/shared\" frameborder=\"0\" width=\"100%\" height=\"225\" name=\"bbV4Q4kA\"></iframe></p> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(S)</script> , where S is the sum of all characters in all strings.</p> <p>In the worst case all <script type=\"math/tex; mode=display\">n</script> strings are the same. The algorithm compares the string <script type=\"math/tex; mode=display\">S1</script> with the other strings <script type=\"math/tex; mode=display\">[S_2 \\ldots S_n]</script> There are <script type=\"math/tex; mode=display\">S</script> character comparisons, where <script type=\"math/tex; mode=display\">S</script> is the sum of all characters in the input array.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. We only used constant extra space. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-vertical-scanning\">Approach 2: Vertical scanning</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>Imagine a very short string is at the end of the array. The above approach will still do <script type=\"math/tex; mode=display\">S</script> comparisons. One way to optimize this case is to do vertical scanning. We compare characters from top to bottom on the same column (same character index of the strings) before moving on to the next column.</p> \n  <iframe src=\"https://leetcode.com/playground/mr4Poe66/shared\" frameborder=\"0\" width=\"100%\" height=\"242\" name=\"mr4Poe66\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time complexity : <script type=\"math/tex; mode=display\">O(S)</script> , where S is the sum of all characters in all strings. In the worst case there will be <script type=\"math/tex; mode=display\">n</script> equal strings with length <script type=\"math/tex; mode=display\">m</script> and the algorithm performs <script type=\"math/tex; mode=display\">S = m*n</script> character comparisons. Even though the worst case is still the same as <a href=\"#approach-1-horizontal-scanning\">Approach 1</a>, in the best case there are at most <script type=\"math/tex; mode=display\">n*minLen</script> comparisons where <script type=\"math/tex; mode=display\">minLen</script> is the length of the shortest string in the array.</li> \n   <li>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. We only used constant extra space. <br> <br></li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-divide-and-conquer\">Approach 3: Divide and conquer</h4> \n  <p><strong>Intuition</strong></p> \n  <p>The idea of the algorithm comes from the associative property of LCP operation. We notice that : <script type=\"math/tex; mode=display\">LCP(S_1 \\ldots S_n) = LCP(LCP(S_1 \\ldots S_k), LCP (S_{k+1} \\ldots S_n))</script> , where <script type=\"math/tex; mode=display\">LCP(S_1 \\ldots S_n)</script> is the longest common prefix in set of strings <script type=\"math/tex; mode=display\">[S_1 \\ldots S_n]</script> , <script type=\"math/tex; mode=display\">1 < k < n</script> </p> \n  <p><strong>Algorithm</strong></p> \n  <p>To apply the observation above, we use divide and conquer technique, where we split the <script type=\"math/tex; mode=display\">LCP(S_i \\ldots S_j)</script> problem into two subproblems <script type=\"math/tex; mode=display\">LCP(S_i \\ldots S_{mid})</script> and <script type=\"math/tex; mode=display\">LCP(S_{mid+1} \\ldots S_j)</script>, where <code>mid</code> is <script type=\"math/tex; mode=display\">\\frac{i + j}{2}</script>. We use their solutions <code>lcpLeft</code> and <code>lcpRight</code> to construct the solution of the main problem <script type=\"math/tex; mode=display\">LCP(S_i \\ldots S_j)</script>. To accomplish this we compare one by one the characters of <code>lcpLeft</code> and <code>lcpRight</code> till there is no character match. The found common prefix of <code>lcpLeft</code> and <code>lcpRight</code> is the solution of the <script type=\"math/tex; mode=display\">LCP(S_i \\ldots S_j)</script>.</p> \n  <p align=\"center\"><img alt=\"Finding the longest common prefix\" src=\"https://leetcode.com/media/original_images/14_lcp_diviso_et_lmpera.png\" width=\"539px\"></p> \n  <p align=\"center\"><em>Figure 2. Finding the longest common prefix of strings using divide and conquer technique</em></p> \n  <iframe src=\"https://leetcode.com/playground/d66Zy6on/shared\" frameborder=\"0\" width=\"100%\" height=\"480\" name=\"d66Zy6on\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <p>In the worst case we have <script type=\"math/tex; mode=display\">n</script> equal strings with length <script type=\"math/tex; mode=display\">m</script> </p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(S)</script>, where <script type=\"math/tex; mode=display\">S</script> is the number of all characters in the array, <script type=\"math/tex; mode=display\">S = m*n</script> Time complexity is <script type=\"math/tex; mode=display\">2 \\cdot T\\left ( \\frac{n}{2} \\right ) + O(m)</script>. Therefore time complexity is <script type=\"math/tex; mode=display\">O(S)</script>. In the best case this algorithm performs <script type=\"math/tex; mode=display\">O(minLen \\cdot n)</script> comparisons, where <script type=\"math/tex; mode=display\">minLen</script> is the shortest string of the array</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(m \\cdot log(n))</script> </p> <p>There is a memory overhead since we store recursive calls in the execution stack. There are <script type=\"math/tex; mode=display\">log(n)</script> recursive calls, each store need <script type=\"math/tex; mode=display\">m</script> space to store the result, so space complexity is <script type=\"math/tex; mode=display\">O(m \\cdot log(n))</script> </p> </li> \n  </ul> \n  <p><br></p> \n  <hr> \n  <h4 id=\"approach-4-binary-search\">Approach 4: Binary search</h4> \n  <p>The idea is to apply binary search method to find the string with maximum value <code>L</code>, which is common prefix of all of the strings. The algorithm searches space is the interval <script type=\"math/tex; mode=display\">(0 \\ldots minLen)</script>, where <code>minLen</code> is minimum string length and the maximum possible common prefix. Each time search space is divided in two equal parts, one of them is discarded, because it is sure that it doesn't contain the solution. There are two possible cases: <em> <code>S[1...mid]</code> is not a common string. This means that for each <code>j &gt; i S[1..j]</code> is not a common string and we discard the second half of the search space. </em> <code>S[1...mid]</code> is common string. This means that for for each <code>i &lt; j S[1..i]</code> is a common string and we discard the first half of the search space, because we try to find longer common prefix.</p> \n  <p align=\"center\"><img alt=\"Finding the longest common prefix\" src=\"https://leetcode.com/media/original_images/14_lcp_binary_search.png\" width=\"539px\"></p> \n  <p align=\"center\"><em>Figure 3. Finding the longest common prefix of strings using binary search technique</em></p> \n  <iframe src=\"https://leetcode.com/playground/YtQyTJEL/shared\" frameborder=\"0\" width=\"100%\" height=\"480\" name=\"YtQyTJEL\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <p>In the worst case we have <script type=\"math/tex; mode=display\">n</script> equal strings with length <script type=\"math/tex; mode=display\">m</script> </p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(S \\cdot log(n))</script>, where <script type=\"math/tex; mode=display\">S</script> is the sum of all characters in all strings.</p> <p>The algorithm makes <script type=\"math/tex; mode=display\">log(n)</script> iterations, for each of them there are <script type=\"math/tex; mode=display\">S =  m*n</script> comparisons, which gives in total <script type=\"math/tex; mode=display\">O(S \\cdot log(n))</script> time complexity.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. We only used constant extra space. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"further-thoughts-follow-up\">Further Thoughts / Follow up</h4> \n  <p>Let's take a look at a slightly different problem:</p> \n  <blockquote> \n   <p>Given a set of keys S = <script type=\"math/tex; mode=display\">[S_1,S_2 \\ldots S_n]</script>, find the longest common prefix among a string <code>q</code> and S. This LCP query will be called frequently.</p> \n  </blockquote> \n  <p>We could optimize LCP queries by storing the set of keys S in a Trie. For more information about Trie, please see this article <a href=\"https://leetcode.com/articles/implement-trie-prefix-tree/\">Implement a trie (Prefix trie)</a>. In a Trie, each node descending from the root represents a common prefix of some keys. But we need to find the longest common prefix of a string <code>q</code> and all key strings. This means that we have to find the deepest path from the root, which satisfies the following conditions: <em> it is prefix of query string <code>q</code> </em> each node along the path must contain only one child element. Otherwise the found path will not be a common prefix among all strings. * the path doesn't comprise of nodes which are marked as end of key. Otherwise the path couldn't be a prefix a of key which is shorter than itself.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>The only question left, is how to find the deepest path in the Trie, that fulfills the requirements above. The most effective way is to build a trie from <script type=\"math/tex; mode=display\">[S_1 \\ldots   S_n]</script> strings. Then find the prefix of query string <code>q</code> in the Trie. We traverse the Trie from the root, till it is impossible to continue the path in the Trie because one of the conditions above is not satisfied.</p> \n  <p align=\"center\"><img alt=\"Finding the longest common prefix using Trie\" src=\"https://leetcode.com/media/original_images/14_lcp_trie.png\" width=\"539px\"></p> \n  <p align=\"center\"><em>Figure 4. Finding the longest common prefix of strings using Trie</em></p> \n  <iframe src=\"https://leetcode.com/playground/rhqENjWQ/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"rhqENjWQ\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <p>In the worst case query <script type=\"math/tex; mode=display\">q</script> has length <script type=\"math/tex; mode=display\">m</script> and it is equal to all <script type=\"math/tex; mode=display\">n</script> strings of the array.</p> \n  <ul> \n   <li> <p>Time complexity : preprocessing <script type=\"math/tex; mode=display\">O(S)</script>, where <script type=\"math/tex; mode=display\">S</script> is the number of all characters in the array, LCP query <script type=\"math/tex; mode=display\">O(m)</script>.</p> <p>Trie build has <script type=\"math/tex; mode=display\">O(S)</script> time complexity. To find the common prefix of <script type=\"math/tex; mode=display\">q</script> in the Trie takes in the worst case <script type=\"math/tex; mode=display\">O(m)</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(S)</script>. We only used additional <script type=\"math/tex; mode=display\">S</script> extra space for the Trie.</p> </li> \n  </ul> \n </div> \n</div>"
},
{
    "frontend_question_id": 13,
    "article_live": false,
    "title": "Roman to Integer",
    "title_slug": "roman-to-integer",
    "content": "<p>Roman numerals are represented by seven different symbols:&nbsp;<code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.</p>\r\n\r\n<pre>\r\n<strong>Symbol</strong>       <strong>Value</strong>\r\nI             1\r\nV             5\r\nX             10\r\nL             50\r\nC             100\r\nD             500\r\nM             1000</pre>\r\n\r\n<p>For example,&nbsp;two is written as <code>II</code>&nbsp;in Roman numeral, just two one&#39;s added together. Twelve is written as, <code>XII</code>, which is simply <code>X</code> + <code>II</code>. The number twenty seven is written as <code>XXVII</code>, which is <code>XX</code> + <code>V</code> + <code>II</code>.</p>\r\n\r\n<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not <code>IIII</code>. Instead, the number four is written as <code>IV</code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as <code>IX</code>. There are six instances where subtraction is used:</p>\r\n\r\n<ul>\r\n\t<li><code>I</code> can be placed before <code>V</code> (5) and <code>X</code> (10) to make 4 and 9.&nbsp;</li>\r\n\t<li><code>X</code> can be placed before <code>L</code> (50) and <code>C</code> (100) to make 40 and 90.&nbsp;</li>\r\n\t<li><code>C</code> can be placed before <code>D</code> (500) and <code>M</code> (1000) to make 400 and 900.</li>\r\n</ul>\r\n\r\n<p>Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>&nbsp;&quot;III&quot;\r\n<strong>Output:</strong> 3</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>&nbsp;&quot;IV&quot;\r\n<strong>Output:</strong> 4</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>&nbsp;&quot;IX&quot;\r\n<strong>Output:</strong> 9</pre>\r\n\r\n<p><strong>Example 4:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>&nbsp;&quot;LVIII&quot;\r\n<strong>Output:</strong> 58\r\n<strong>Explanation:</strong> L = 50, V= 5, III = 3.\r\n</pre>\r\n\r\n<p><strong>Example 5:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>&nbsp;&quot;MCMXCIV&quot;\r\n<strong>Output:</strong> 1994\r\n<strong>Explanation:</strong> M = 1000, CM = 900, XC = 90 and IV = 4.</pre>\r\n",
    "tags": "Math, String",
    "difficulty": 1,
    "frontend_article_id": 13
},
{
    "frontend_question_id": 12,
    "article_live": false,
    "title": "Integer to Roman",
    "title_slug": "integer-to-roman",
    "content": "<p>Roman numerals are represented by seven different symbols:&nbsp;<code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.</p>\r\n\r\n<pre>\r\n<strong>Symbol</strong>       <strong>Value</strong>\r\nI             1\r\nV             5\r\nX             10\r\nL             50\r\nC             100\r\nD             500\r\nM             1000</pre>\r\n\r\n<p>For example,&nbsp;two is written as <code>II</code>&nbsp;in Roman numeral, just two one&#39;s added together. Twelve is written as, <code>XII</code>, which is simply <code>X</code> + <code>II</code>. The number twenty seven is written as <code>XXVII</code>, which is <code>XX</code> + <code>V</code> + <code>II</code>.</p>\r\n\r\n<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not <code>IIII</code>. Instead, the number four is written as <code>IV</code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as <code>IX</code>. There are six instances where subtraction is used:</p>\r\n\r\n<ul>\r\n\t<li><code>I</code> can be placed before <code>V</code> (5) and <code>X</code> (10) to make 4 and 9.&nbsp;</li>\r\n\t<li><code>X</code> can be placed before <code>L</code> (50) and <code>C</code> (100) to make 40 and 90.&nbsp;</li>\r\n\t<li><code>C</code> can be placed before <code>D</code> (500) and <code>M</code> (1000) to make 400 and 900.</li>\r\n</ul>\r\n\r\n<p>Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>&nbsp;3\r\n<strong>Output:</strong> &quot;III&quot;</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>&nbsp;4\r\n<strong>Output:</strong> &quot;IV&quot;</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>&nbsp;9\r\n<strong>Output:</strong> &quot;IX&quot;</pre>\r\n\r\n<p><strong>Example 4:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>&nbsp;58\r\n<strong>Output:</strong> &quot;LVIII&quot;\r\n<strong>Explanation:</strong> L = 50, V = 5, III = 3.\r\n</pre>\r\n\r\n<p><strong>Example 5:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>&nbsp;1994\r\n<strong>Output:</strong> &quot;MCMXCIV&quot;\r\n<strong>Explanation:</strong> M = 1000, CM = 900, XC = 90 and IV = 4.</pre>\r\n",
    "tags": "Math, String",
    "difficulty": 2,
    "frontend_article_id": 12
},
{
    "frontend_question_id": 11,
    "article_live": true,
    "article_slug": "container-with-most-water",
    "title": "Container With Most Water",
    "title_slug": "container-with-most-water",
    "content": "<p>Given <i>n</i> non-negative integers <i>a<sub>1</sub></i>, <i>a<sub>2</sub></i>, ..., <i>a<sub>n&nbsp;</sub></i>, where each represents a point at coordinate (<i>i</i>, <i>a<sub>i</sub></i>). <i>n</i> vertical lines are drawn such that the two endpoints of line <i>i</i> is at (<i>i</i>, <i>a<sub>i</sub></i>) and (<i>i</i>, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>\r\n\r\n<p><strong>Note:&nbsp;</strong>You may not slant the container and <i>n</i> is at least 2.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg\" style=\"width: 600px; height: 287px;\" /></p>\r\n\r\n<p><small>The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain&nbsp;is 49. </small></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [1,8,6,2,5,4,8,3,7]\r\n<strong>Output:</strong> 49</pre>\r\n",
    "tags": "Array, Two Pointers",
    "difficulty": 2,
    "frontend_article_id": 11,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#summary\">Summary</a></li> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force\">Approach 1: Brute Force</a></li> \n      <li><a href=\"#approach-2-two-pointer-approach\">Approach 2: Two Pointer Approach</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"summary\">Summary</h2> \n  <p>We have to maximize the Area that can be formed between the vertical lines using the shorter line as length and the distance between the lines as the width of the rectangle forming the area.</p> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force\">Approach 1: Brute Force</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>In this case, we will simply consider the area for every possible pair of the lines and find out the maximum area out of those.</p> \n  <iframe src=\"https://leetcode.com/playground/43UTUorK/shared\" frameborder=\"0\" width=\"100%\" height=\"208\" name=\"43UTUorK\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time complexity : <script type=\"math/tex; mode=display\">O(n^2)</script>. Calculating area for all <script type=\"math/tex; mode=display\">\\dfrac{n(n-1)}{2}</script> height pairs.</li> \n   <li>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant extra space is used. <br> <br></li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-two-pointer-approach\">Approach 2: Two Pointer Approach</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>The intuition behind this approach is that the area formed between the lines will always be limited by the height of the shorter line. Further, the farther the lines, the more will be the area obtained.</p> \n  <p>We take two pointers, one at the beginning and one at the end of the array constituting the length of the lines. Futher, we maintain a variable <script type=\"math/tex; mode=display\">maxarea</script> to store the maximum area obtained till now. At every step, we find out the area formed between them, update <script type=\"math/tex; mode=display\">maxarea</script> and move the pointer pointing to the shorter line towards the other end by one step.</p> \n  <p>The algorithm can be better understood by looking at the example below:</p> \n  <div class=\"codehilite\">\n   <pre><span></span>1 8 6 2 5 4 8 3 7\n</pre>\n  </div> \n  <!--![Water_Continer](https://leetcode.com/media/original_images/11_Container_Water.gif)--> \n  <p>!?!../Documents/11_Container_Water.json:1000,563!?!</p> \n  <p>How this approach works?</p> \n  <p>Initially we consider the area constituting the exterior most lines. Now, to maximize the area, we need to consider the area between the lines of larger lengths. If we try to move the pointer at the longer line inwards, we won't gain any increase in area, since it is limited by the shorter line. But moving the shorter line's pointer could turn out to be beneficial, as per the same argument, despite the reduction in the width. This is done since a relatively longer line obtained by moving the shorter line's pointer might overcome the reduction in area caused by the width reduction.</p> \n  <p>For further clarification click <a href=\"https://discuss.leetcode.com/topic/3462/yet-another-way-to-see-what-happens-in-the-o-n-algorithm\">here</a> and for the proof click <a href=\"https://discuss.leetcode.com/topic/503/anyone-who-has-a-o-n-algorithm/2\">here</a>.</p> \n  <iframe src=\"https://leetcode.com/playground/L9fLAXj4/shared\" frameborder=\"0\" width=\"100%\" height=\"276\" name=\"L9fLAXj4\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Single pass.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. Constant space is used.</p> </li> \n  </ul> \n </div> \n</div>"
},
{
    "frontend_question_id": 10,
    "article_live": true,
    "article_slug": "regular-expression-matching",
    "title": "Regular Expression Matching",
    "title_slug": "regular-expression-matching",
    "content": "<p>Given an input string (<code>s</code>) and a pattern (<code>p</code>), implement regular expression matching with support for <code>&#39;.&#39;</code> and <code>&#39;*&#39;</code>.</p>\r\n\r\n<pre>\r\n&#39;.&#39; Matches any single character.\r\n&#39;*&#39; Matches zero or more of the preceding element.\r\n</pre>\r\n\r\n<p>The matching should cover the <strong>entire</strong> input string (not partial).</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>s</code>&nbsp;could be empty and contains only lowercase letters <code>a-z</code>.</li>\r\n\t<li><code>p</code> could be empty and contains only lowercase letters <code>a-z</code>, and characters like&nbsp;<code>.</code>&nbsp;or&nbsp;<code>*</code>.</li>\r\n</ul>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>\r\ns = &quot;aa&quot;\r\np = &quot;a&quot;\r\n<strong>Output:</strong> false\r\n<strong>Explanation:</strong> &quot;a&quot; does not match the entire string &quot;aa&quot;.\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>\r\ns = &quot;aa&quot;\r\np = &quot;a*&quot;\r\n<strong>Output:</strong> true\r\n<strong>Explanation:</strong>&nbsp;&#39;*&#39; means zero or more of the precedeng&nbsp;element, &#39;a&#39;. Therefore, by repeating &#39;a&#39; once, it becomes &quot;aa&quot;.\r\n</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>\r\ns = &quot;ab&quot;\r\np = &quot;.*&quot;\r\n<strong>Output:</strong> true\r\n<strong>Explanation:</strong>&nbsp;&quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;.\r\n</pre>\r\n\r\n<p><strong>Example 4:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>\r\ns = &quot;aab&quot;\r\np = &quot;c*a*b&quot;\r\n<strong>Output:</strong> true\r\n<strong>Explanation:</strong>&nbsp;c can be repeated 0 times, a can be repeated 1 time. Therefore it matches &quot;aab&quot;.\r\n</pre>\r\n\r\n<p><strong>Example 5:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>\r\ns = &quot;mississippi&quot;\r\np = &quot;mis*is*p*.&quot;\r\n<strong>Output:</strong> false\r\n</pre>\r\n",
    "tags": "String, Dynamic Programming, Backtracking",
    "difficulty": 3,
    "frontend_article_id": 10,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-recursion\">Approach 1: Recursion</a></li> \n      <li><a href=\"#approach-2-dynamic-programming\">Approach 2: Dynamic Programming</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-recursion\">Approach 1: Recursion</h4> \n  <p><strong>Intuition</strong></p> \n  <p>If there were no Kleene stars (the <code>*</code> wildcard character for regular expressions), the problem would be easier - we simply check from left to right if each character of the text matches the pattern.</p> \n  <p>When a star is present, we may need to check many different suffixes of the text and see if they match the rest of the pattern. A recursive solution is a straightforward way to represent this relationship.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Without a Kleene star, our solution would look like this:</p> \n  <iframe src=\"https://leetcode.com/playground/Z2XSmAHG/shared\" frameborder=\"0\" width=\"100%\" height=\"123\" name=\"Z2XSmAHG\"></iframe> \n  <p>If a star is present in the pattern, it will be in the second position <script type=\"math/tex; mode=display\">\\text{pattern[1]}</script>. Then, we may ignore this part of the pattern, or delete a matching character in the text. If we have a match on the remaining strings after any of these operations, then the initial inputs matched.</p> \n  <iframe src=\"https://leetcode.com/playground/EX8cYcs3/shared\" frameborder=\"0\" width=\"100%\" height=\"293\" name=\"EX8cYcs3\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: Let <script type=\"math/tex; mode=display\">T, P</script> be the lengths of the text and the pattern respectively. In the worst case, a call to <code>match(text[i:], pattern[2j:])</code> will be made <script type=\"math/tex; mode=display\">\\binom{i+j}{i}</script> times, and strings of the order <script type=\"math/tex; mode=display\">O(T - i)</script> and <script type=\"math/tex; mode=display\">O(P - 2*j)</script> will be made. Thus, the complexity has the order <script type=\"math/tex; mode=display\">\\sum_{i = 0}^T \\sum_{j = 0}^{P/2} \\binom{i+j}{i} O(T+P-i-2j)</script>. With some effort outside the scope of this article, we can show this is bounded by <script type=\"math/tex; mode=display\">O\\big((T+P)2^{T + \\frac{P}{2}}\\big)</script>.</p> </li> \n   <li> <p>Space Complexity: For every call to <code>match</code>, we will create those strings as described above, possibly creating duplicates. If memory is not freed, this will also take a total of <script type=\"math/tex; mode=display\">O\\big((T+P)2^{T + \\frac{P}{2}}\\big)</script> space, even though there are only order <script type=\"math/tex; mode=display\">O(T^2 + P^2)</script> unique suffixes of <script type=\"math/tex; mode=display\">P</script> and <script type=\"math/tex; mode=display\">T</script> that are actually required. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-dynamic-programming\">Approach 2: Dynamic Programming</h4> \n  <p><strong>Intuition</strong></p> \n  <p>As the problem has an <strong>optimal substructure</strong>, it is natural to cache intermediate results. We ask the question <script type=\"math/tex; mode=display\">\\text{dp(i, j)}</script>: does <script type=\"math/tex; mode=display\">\\text{text[i:]}</script> and <script type=\"math/tex; mode=display\">\\text{pattern[j:]}</script> match? We can describe our answer in terms of answers to questions involving smaller strings.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>We proceed with the same recursion as in <a href=\"#approach-1-recursion\">Approach 1</a>, except because calls will only ever be made to <code>match(text[i:], pattern[j:])</code>, we use <script type=\"math/tex; mode=display\">\\text{dp(i, j)}</script> to handle those calls instead, saving us expensive string-building operations and allowing us to cache the intermediate results.</p> \n  <p><em>Top-Down Variation</em> <iframe src=\"https://leetcode.com/playground/Fpg6LXEX/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"Fpg6LXEX\"></iframe></p> \n  <p><em>Bottom-Up Variation</em></p> \n  <iframe src=\"https://leetcode.com/playground/dmAyPDG3/shared\" frameborder=\"0\" width=\"100%\" height=\"395\" name=\"dmAyPDG3\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time Complexity: Let <script type=\"math/tex; mode=display\">T, P</script> be the lengths of the text and the pattern respectively. The work for every call to <code>dp(i, j)</code> for <script type=\"math/tex; mode=display\">i=0, ... ,T</script>; <script type=\"math/tex; mode=display\">j=0, ... ,P</script> is done once, and it is <script type=\"math/tex; mode=display\">O(1)</script> work. Hence, the time complexity is <script type=\"math/tex; mode=display\">O(TP)</script>.</p> </li> \n   <li> <p>Space Complexity: The only memory we use is the <script type=\"math/tex; mode=display\">O(TP)</script> boolean entries in our cache. Hence, the space complexity is <script type=\"math/tex; mode=display\">O(TP)</script>.</p> </li> \n  </ul> \n </div> \n</div>"
},
{
    "frontend_question_id": 9,
    "article_live": true,
    "article_slug": "palindrome-number",
    "title": "Palindrome Number",
    "title_slug": "palindrome-number",
    "content": "<p>Determine whether an integer is a palindrome. An integer&nbsp;is&nbsp;a&nbsp;palindrome when it&nbsp;reads the same backward as forward.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 121\r\n<strong>Output:</strong> true\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> -121\r\n<strong>Output:</strong> false\r\n<strong>Explanation:</strong> From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\r\n</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 10\r\n<strong>Output:</strong> false\r\n<strong>Explanation:</strong> Reads 01 from right to left. Therefore it is not a palindrome.\r\n</pre>\r\n\r\n<p><strong>Follow up:</strong></p>\r\n\r\n<p>Coud you solve&nbsp;it without converting the integer to a string?</p>\r\n",
    "tags": "Math",
    "difficulty": 1,
    "frontend_article_id": 9,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-revert-half-of-the-number\">Approach 1: Revert half of the number</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-revert-half-of-the-number\">Approach 1: Revert half of the number</h4> \n  <p><strong>Intuition</strong></p> \n  <p>The first idea that comes to mind is to convert the number into string, and check if the string is a palindrome, but this would require extra non-constant space for creating the string which is not allowed by the problem description.</p> \n  <p>Second idea would be reverting the number itself, and then compare the number with original number, if they are the same, then the number is a palindrome. However, if the reversed number is larger than <script type=\"math/tex; mode=display\">\\text{int.MAX}</script>, we will hit integer overflow problem.</p> \n  <p>Following the thoughts based on the second idea, to avoid the overflow issue of the reverted number, what if we only revert half of the <script type=\"math/tex; mode=display\">\\text{int}</script> number? After all, the reverse of the last half of the palindrome should be the same as the first half of the number, if the number is a palindrome.</p> \n  <p>For example, if the input is <code>1221</code>, if we can revert the last part of the number \"12<strong>21</strong>\" from \"<strong>21</strong>\" to \"<strong>12</strong>\", and compare it with the first half of the number \"12\", since 12 is the same as 12, we know that the number is a palindrome.</p> \n  <p>Let's see how we could translate this idea into an algorithm.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>First of all we should take care of some edge cases. All negative numbers are not palindrome, for example: -123 is not a palindrome since the '-' does not equal to '3'. So we can return false for all negative numbers.</p> \n  <p>Now let's think about how to revert the last half of the number. For number <code>1221</code>, if we do <code>1221 % 10</code>, we get the last digit <code>1</code>, to get the second to the last digit, we need to remove the last digit from <code>1221</code>, we could do so by dividing it by 10, <code>1221 / 10 = 122</code>. Then we can get the last digit again by doing a modulus by 10, <code>122 % 10 = 2</code>, and if we multiply the last digit by 10 and add the second last digit, <code>1 * 10 + 2 = 12</code>, it gives us the reverted number we want. Continuing this process would give us the reverted number with more digits.</p> \n  <p>Now the question is, how do we know that we've reached the half of the number?</p> \n  <p>Since we divided the number by 10, and multiplied the reversed number by 10, when the original number is less than the reversed number, it means we've processed half of the number digits.</p> \n  <iframe src=\"https://leetcode.com/playground/A2cW8TnM/shared\" frameborder=\"0\" width=\"100%\" height=\"446\" name=\"A2cW8TnM\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(\\log_{10}(n))</script>. We divided the input by 10 for every iteration, so the time complexity is <script type=\"math/tex; mode=display\">O(\\log_{10}(n))</script> </p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n  </ul> \n </div> \n</div>"
},
{
    "frontend_question_id": 8,
    "article_live": false,
    "title": "String to Integer (atoi)",
    "title_slug": "string-to-integer-atoi",
    "content": "<p>Implement <code><span>atoi</span></code> which&nbsp;converts a string to an integer.</p>\r\n\r\n<p>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</p>\r\n\r\n<p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p>\r\n\r\n<p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</p>\r\n\r\n<p>If no valid conversion could be performed, a zero value is returned.</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>Only the space character <code>&#39; &#39;</code> is considered as whitespace character.</li>\r\n\t<li>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [&minus;2<sup>31</sup>,&nbsp; 2<sup>31&nbsp;</sup>&minus; 1]. If the numerical value is out of the range of representable values, INT_MAX (2<sup>31&nbsp;</sup>&minus; 1) or INT_MIN (&minus;2<sup>31</sup>) is returned.</li>\r\n</ul>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> &quot;42&quot;\r\n<strong>Output:</strong> 42\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> &quot;   -42&quot;\r\n<strong>Output:</strong> -42\r\n<strong>Explanation:</strong> The first non-whitespace character is &#39;-&#39;, which is the minus sign.\r\n&nbsp;            Then take as many numerical digits as possible, which gets 42.\r\n</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> &quot;4193 with words&quot;\r\n<strong>Output:</strong> 4193\r\n<strong>Explanation:</strong> Conversion stops at digit &#39;3&#39; as the next character is not a numerical digit.\r\n</pre>\r\n\r\n<p><strong>Example 4:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> &quot;words and 987&quot;\r\n<strong>Output:</strong> 0\r\n<strong>Explanation:</strong> The first non-whitespace character is &#39;w&#39;, which is not a numerical \r\n&nbsp;            digit or a +/- sign. Therefore no valid conversion could be performed.</pre>\r\n\r\n<p><strong>Example 5:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> &quot;-91283472332&quot;\r\n<strong>Output:</strong> -2147483648\r\n<strong>Explanation:</strong> The number &quot;-91283472332&quot; is out of the range of a 32-bit signed integer.\r\n&nbsp;            Thefore INT_MIN (&minus;2<sup>31</sup>) is returned.</pre>\r\n",
    "tags": "Math, String",
    "difficulty": 2,
    "frontend_article_id": 8
},
{
    "frontend_question_id": 7,
    "article_live": true,
    "article_slug": "reverse-integer",
    "title": "Reverse Integer",
    "title_slug": "reverse-integer",
    "content": "<p>Given a 32-bit signed integer, reverse digits of an integer.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 123\r\n<strong>Output:</strong> 321\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> -123\r\n<strong>Output:</strong> -321\r\n</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 120\r\n<strong>Output:</strong> 21\r\n</pre>\r\n\r\n<p><strong>Note:</strong><br />\r\nAssume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [&minus;2<sup>31</sup>,&nbsp; 2<sup>31&nbsp;</sup>&minus; 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p>\r\n",
    "tags": "Math",
    "difficulty": 1,
    "frontend_article_id": 7,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-pop-and-push-digits-check-before-overflow\">Approach 1: Pop and Push Digits &amp; Check before Overflow</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-pop-and-push-digits-check-before-overflow\">Approach 1: Pop and Push Digits &amp; Check before Overflow</h4> \n  <p><strong>Intuition</strong></p> \n  <p>We can build up the reverse integer one digit at a time. While doing so, we can check beforehand whether or not appending another digit would cause overflow.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Reversing an integer can be done similarly to reversing a string.</p> \n  <p>We want to repeatedly \"pop\" the last digit off of <script type=\"math/tex; mode=display\">x</script> and \"push\" it to the back of the <script type=\"math/tex; mode=display\">\\text{rev}</script>. In the end, <script type=\"math/tex; mode=display\">\\text{rev}</script> will be the reverse of the <script type=\"math/tex; mode=display\">x</script>.</p> \n  <p>To \"pop\" and \"push\" digits without the help of some auxiliary stack/array, we can use math.</p> \n  <div class=\"codehilite\">\n   <pre><span></span><span class=\"c1\">//pop operation:</span>\n<span class=\"n\">pop</span> <span class=\"o\">=</span> <span class=\"n\">x</span> <span class=\"o\">%</span> <span class=\"mi\">10</span><span class=\"p\">;</span>\n<span class=\"n\">x</span> <span class=\"o\">/=</span> <span class=\"mi\">10</span><span class=\"p\">;</span>\n\n<span class=\"c1\">//push operation:</span>\n<span class=\"n\">temp</span> <span class=\"o\">=</span> <span class=\"n\">rev</span> <span class=\"o\">*</span> <span class=\"mi\">10</span> <span class=\"o\">+</span> <span class=\"n\">pop</span><span class=\"p\">;</span>\n<span class=\"n\">rev</span> <span class=\"o\">=</span> <span class=\"n\">temp</span><span class=\"p\">;</span>\n</pre>\n  </div> \n  <p>However, this approach is dangerous, because the statement <script type=\"math/tex; mode=display\">\\text{temp} = \\text{rev} \\cdot 10 + \\text{pop}</script> can cause overflow.</p> \n  <p>Luckily, it is easy to check beforehand whether or this statement would cause an overflow.</p> \n  <p>To explain, lets assume that <script type=\"math/tex; mode=display\">\\text{rev}</script> is positive.</p> \n  <ol> \n   <li>If <script type=\"math/tex; mode=display\">temp = \\text{rev} \\cdot 10 + \\text{pop}</script> causes overflow, then it must be that <script type=\"math/tex; mode=display\">\\text{rev} \\geq \\frac{INTMAX}{10}</script> </li> \n   <li>If <script type=\"math/tex; mode=display\">\\text{rev} > \\frac{INTMAX}{10}</script>, then <script type=\"math/tex; mode=display\">temp = \\text{rev} \\cdot 10 + \\text{pop}</script> is guaranteed to overflow.</li> \n   <li>If <script type=\"math/tex; mode=display\">\\text{rev} == \\frac{INTMAX}{10}</script>, then <script type=\"math/tex; mode=display\">temp = \\text{rev} \\cdot 10 + \\text{pop}</script> will overflow if and only if <script type=\"math/tex; mode=display\">\\text{pop} > 7</script> </li> \n  </ol> \n  <p>Similar logic can be applied when <script type=\"math/tex; mode=display\">\\text{rev}</script> is negative.</p> \n  <iframe src=\"https://leetcode.com/playground/Ufhk9yCy/shared\" frameborder=\"0\" width=\"100%\" height=\"293\" name=\"Ufhk9yCy\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time Complexity: <script type=\"math/tex; mode=display\">O(\\log(x))</script>. There are roughly <script type=\"math/tex; mode=display\">\\log_{10}(x)</script> digits in <script type=\"math/tex; mode=display\">x</script>.</li> \n   <li>Space Complexity: <script type=\"math/tex; mode=display\">O(1)</script>.</li> \n  </ul> \n </div> \n</div>"
},
{
    "frontend_question_id": 6,
    "article_live": true,
    "article_slug": "zigzag-conversion",
    "title": "ZigZag Conversion",
    "title_slug": "zigzag-conversion",
    "content": "<p>The string <code>&quot;PAYPALISHIRING&quot;</code> is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p>\r\n\r\n<pre>\r\nP   A   H   N\r\nA P L S I I G\r\nY   I   R\r\n</pre>\r\n\r\n<p>And then read line by line: <code>&quot;PAHNAPLSIIGYIR&quot;</code></p>\r\n\r\n<p>Write the code that will take a string and make this conversion given a number of rows:</p>\r\n\r\n<pre>\r\nstring convert(string s, int numRows);</pre>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> s = &quot;PAYPALISHIRING&quot;, numRows = 3\r\n<strong>Output:</strong> &quot;PAHNAPLSIIGYIR&quot;\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> s = &quot;PAYPALISHIRING&quot;, numRows =&nbsp;4\r\n<strong>Output:</strong>&nbsp;&quot;PINALSIGYAHRPI&quot;\r\n<strong>Explanation:</strong>\r\n\r\nP     I    N\r\nA   L S  I G\r\nY A   H R\r\nP     I</pre>\r\n",
    "tags": "String",
    "difficulty": 2,
    "frontend_article_id": 6,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-sort-by-row\">Approach 1: Sort by Row</a></li> \n      <li><a href=\"#approach-2-visit-by-row\">Approach 2: Visit by Row</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-sort-by-row\">Approach 1: Sort by Row</h4> \n  <p><strong>Intuition</strong></p> \n  <p>By iterating through the string from left to right, we can easily determine which row in the Zig-Zag pattern that a character belongs to.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>We can use <script type=\"math/tex; mode=display\">\\text{min}( \\text{numRows}, \\text{len}(s))</script> lists to represent the non-empty rows of the Zig-Zag Pattern.</p> \n  <p>Iterate through <script type=\"math/tex; mode=display\">s</script> from left to right, appending each character to the appropriate row. The appropriate row can be tracked using two variables: the current row and the current direction.</p> \n  <p>The current direction changes only when we moved up to the topmost row or moved down to the bottommost row.</p> \n  <iframe src=\"https://leetcode.com/playground/F7ATKV4h/shared\" frameborder=\"0\" width=\"100%\" height=\"446\" name=\"F7ATKV4h\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time Complexity: <script type=\"math/tex; mode=display\">O(n)</script>, where <script type=\"math/tex; mode=display\">n == \\text{len}(s)</script> </li> \n   <li>Space Complexity: <script type=\"math/tex; mode=display\">O(n)</script> </li> \n  </ul> \n  <p><br></p> \n  <hr> \n  <h4 id=\"approach-2-visit-by-row\">Approach 2: Visit by Row</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Visit the characters in the same order as reading the Zig-Zag pattern line by line.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Visit all characters in row 0 first, then row 1, then row 2, and so on...</p> \n  <p>For all whole numbers <script type=\"math/tex; mode=display\">k</script>,</p> \n  <ul> \n   <li>Characters in row <script type=\"math/tex; mode=display\">0</script> are located at indexes <script type=\"math/tex; mode=display\">k \\; (2 \\cdot \\text{numRows} - 2)</script> </li> \n   <li>Characters in row <script type=\"math/tex; mode=display\">\\text{numRows}-1</script> are located at indexes <script type=\"math/tex; mode=display\">k \\; (2 \\cdot \\text{numRows} - 2) + \\text{numRows} - 1</script> </li> \n   <li>Characters in inner row <script type=\"math/tex; mode=display\">i</script> are located at indexes <script type=\"math/tex; mode=display\">k \\; (2 \\cdot \\text{numRows}-2)+i</script> and <script type=\"math/tex; mode=display\">(k+1)(2 \\cdot \\text{numRows}-2)- i</script>.</li> \n  </ul> \n  <iframe src=\"https://leetcode.com/playground/Deg3hGi4/shared\" frameborder=\"0\" width=\"100%\" height=\"395\" name=\"Deg3hGi4\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li>Time Complexity: <script type=\"math/tex; mode=display\">O(n)</script>, where <script type=\"math/tex; mode=display\">n == \\text{len}(s)</script>. Each index is visited once.</li> \n   <li>Space Complexity: <script type=\"math/tex; mode=display\">O(n)</script>. For the cpp implementation, <script type=\"math/tex; mode=display\">O(1)</script> if return string is not considered extra space.</li> \n  </ul> \n </div> \n</div>"
},
{
    "frontend_question_id": 5,
    "article_live": true,
    "article_slug": "longest-palindromic-substring",
    "title": "Longest Palindromic Substring",
    "title_slug": "longest-palindromic-substring",
    "content": "<p>Given a string <strong>s</strong>, find the longest palindromic substring in <strong>s</strong>. You may assume that the maximum length of <strong>s</strong> is 1000.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> &quot;babad&quot;\r\n<strong>Output:</strong> &quot;bab&quot;\r\n<strong>Note:</strong> &quot;aba&quot; is also a valid answer.\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> &quot;cbbd&quot;\r\n<strong>Output:</strong> &quot;bb&quot;\r\n</pre>\r\n",
    "tags": "String, Dynamic Programming",
    "difficulty": 2,
    "frontend_article_id": 5,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#summary\">Summary</a></li> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-longest-common-substring\">Approach 1: Longest Common Substring</a></li> \n      <li><a href=\"#approach-2-brute-force\">Approach 2: Brute Force</a></li> \n      <li><a href=\"#approach-3-dynamic-programming\">Approach 3: Dynamic Programming</a></li> \n      <li><a href=\"#approach-4-expand-around-center\">Approach 4: Expand Around Center</a></li> \n      <li><a href=\"#approach-5-manachers-algorithm\">Approach 5: Manacher's Algorithm</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"summary\">Summary</h2> \n  <p>This article is for intermediate readers. It introduces the following ideas: Palindrome, Dynamic Programming and String Manipulation. Make sure you understand what a palindrome means. A palindrome is a string which reads the same in both directions. For example, <script type=\"math/tex; mode=display\">S</script> = \"aba\" is a palindrome, <script type=\"math/tex; mode=display\">S</script> = \"abc\" is not.</p> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-longest-common-substring\">Approach 1: Longest Common Substring</h4> \n  <p><strong>Common mistake</strong></p> \n  <p>Some people will be tempted to come up with a quick solution, which is unfortunately flawed (however can be corrected easily):</p> \n  <blockquote> \n   <p>Reverse <script type=\"math/tex; mode=display\">S</script> and become <script type=\"math/tex; mode=display\">S'</script>. Find the longest common substring between <script type=\"math/tex; mode=display\">S</script> and <script type=\"math/tex; mode=display\">S'</script>, which must also be the longest palindromic substring.</p> \n  </blockquote> \n  <p>This seemed to work, let’s see some examples below.</p> \n  <p>For example, <script type=\"math/tex; mode=display\">S</script> = \"caba\", <script type=\"math/tex; mode=display\">S'</script> = \"abac\".</p> \n  <p>The longest common substring between <script type=\"math/tex; mode=display\">S</script> and <script type=\"math/tex; mode=display\">S'</script> is \"aba\", which is the answer.</p> \n  <p>Let’s try another example: <script type=\"math/tex; mode=display\">S</script> = \"abacdfgdcaba\", <script type=\"math/tex; mode=display\">S'</script> = \"abacdgfdcaba\".</p> \n  <p>The longest common substring between <script type=\"math/tex; mode=display\">S</script> and <script type=\"math/tex; mode=display\">S'</script> is \"abacd\". Clearly, this is not a valid palindrome.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>We could see that the longest common substring method fails when there exists a reversed copy of a non-palindromic substring in some other part of <script type=\"math/tex; mode=display\">S</script>. To rectify this, each time we find a longest common substring candidate, we check if the substring’s indices are the same as the reversed substring’s original indices. If it is, then we attempt to update the longest palindrome found so far; if not, we skip this and find the next candidate.</p> \n  <p>This gives us an <script type=\"math/tex; mode=display\">O(n^2)</script> Dynamic Programming solution which uses <script type=\"math/tex; mode=display\">O(n^2)</script> space (could be improved to use <script type=\"math/tex; mode=display\">O(n)</script> space). Please read more about Longest Common Substring <a href=\"https://en.wikipedia.org/wiki/Longest_common_substring\">here</a>. <br> <br></p> \n  <hr> \n  <h4 id=\"approach-2-brute-force\">Approach 2: Brute Force</h4> \n  <p>The obvious brute force solution is to pick all possible starting and ending positions for a substring, and verify if it is a palindrome.</p> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^3)</script>. Assume that <script type=\"math/tex; mode=display\">n</script> is the length of the input string, there are a total of <script type=\"math/tex; mode=display\">\\binom{n}{2} = \\frac{n(n-1)}{2}</script> such substrings (excluding the trivial solution where a character itself is a palindrome). Since verifying each substring takes <script type=\"math/tex; mode=display\">O(n)</script> time, the run time complexity is <script type=\"math/tex; mode=display\">O(n^3)</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-dynamic-programming\">Approach 3: Dynamic Programming</h4> \n  <p>To improve over the brute force solution, we first observe how we can avoid unnecessary re-computation while validating palindromes. Consider the case \"ababa\". If we already knew that \"bab\" is a palindrome, it is obvious that \"ababa\" must be a palindrome since the two left and right end letters are the same.</p> \n  <p>We define <script type=\"math/tex; mode=display\">P(i,j)</script> as following:</p> \n  <p> <script type=\"math/tex; mode=display\">\nP(i,j) =\n     \\begin{cases}\n       \\text{true,} &\\quad\\text{if the substring } S_i \\dots S_j \\text{ is a palindrome}\\\\\n       \\text{false,} &\\quad\\text{otherwise.} \\\n     \\end{cases}\n</script> </p> \n  <p>Therefore,</p> \n  <p> <script type=\"math/tex; mode=display\">\nP(i, j) = ( P(i+1, j-1) \\text{ and } S_i == S_j )\n</script> </p> \n  <p>The base cases are:</p> \n  <p> <script type=\"math/tex; mode=display\">\nP(i, i) = true\n</script> </p> \n  <p> <script type=\"math/tex; mode=display\">\nP(i, i+1) = ( S_i == S_{i+1} )\n</script> </p> \n  <p>This yields a straight forward DP solution, which we first initialize the one and two letters palindromes, and work our way up finding all three letters palindromes, and so on...</p> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^2)</script>. This gives us a runtime complexity of <script type=\"math/tex; mode=display\">O(n^2)</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n^2)</script>. It uses <script type=\"math/tex; mode=display\">O(n^2)</script> space to store the table.</p> </li> \n  </ul> \n  <p><strong>Additional Exercise</strong></p> \n  <p>Could you improve the above space complexity further and how? <br> <br></p> \n  <hr> \n  <h4 id=\"approach-4-expand-around-center\">Approach 4: Expand Around Center</h4> \n  <p>In fact, we could solve it in <script type=\"math/tex; mode=display\">O(n^2)</script> time using only constant space.</p> \n  <p>We observe that a palindrome mirrors around its center. Therefore, a palindrome can be expanded from its center, and there are only <script type=\"math/tex; mode=display\">2n - 1</script> such centers.</p> \n  <p>You might be asking why there are <script type=\"math/tex; mode=display\">2n - 1</script> but not <script type=\"math/tex; mode=display\">n</script> centers? The reason is the center of a palindrome can be in between two letters. Such palindromes have even number of letters (such as \"abba\") and its center are between the two 'b's.</p> \n  <iframe src=\"https://leetcode.com/playground/zeAppovt/shared\" frameborder=\"0\" width=\"100%\" height=\"446\" name=\"zeAppovt\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^2)</script>. Since expanding a palindrome around its center could take <script type=\"math/tex; mode=display\">O(n)</script> time, the overall complexity is <script type=\"math/tex; mode=display\">O(n^2)</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-5-manachers-algorithm\">Approach 5: Manacher's Algorithm</h4> \n  <p>There is even an <script type=\"math/tex; mode=display\">O(n)</script> algorithm called Manacher's algorithm, explained <a href=\"https://articles.leetcode.com/longest-palindromic-substring-part-ii/\">here in detail</a>. However, it is a non-trivial algorithm, and no one expects you to come up with this algorithm in a 45 minutes coding session. But, please go ahead and understand it, I promise it will be a lot of fun.</p> \n </div> \n</div>"
},
{
    "frontend_question_id": 4,
    "article_live": true,
    "article_slug": "median-of-two-sorted-arrays",
    "title": "Median of Two Sorted Arrays",
    "title_slug": "median-of-two-sorted-arrays",
    "content": "<p>There are two sorted arrays <b>nums1</b> and <b>nums2</b> of size m and n respectively.</p>\r\n\r\n<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>\r\n\r\n<p>You may assume <strong>nums1</strong> and <strong>nums2</strong>&nbsp;cannot be both empty.</p>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\nnums1 = [1, 3]\r\nnums2 = [2]\r\n\r\nThe median is 2.0\r\n</pre>\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\nnums1 = [1, 2]\r\nnums2 = [3, 4]\r\n\r\nThe median is (2 + 3)/2 = 2.5\r\n</pre>\r\n",
    "tags": "Array, Binary Search, Divide and Conquer",
    "difficulty": 3,
    "frontend_article_id": 4,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-recursive-approach\">Approach 1: Recursive Approach</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-recursive-approach\">Approach 1: Recursive Approach</h4> \n  <p>To solve this problem, we need to understand \"What is the use of median\". In statistics, the median is used for:</p> \n  <blockquote> \n   <p>Dividing a set into two equal length subsets, that one subset is always greater than the other.</p> \n  </blockquote> \n  <p>If we understand the use of median for dividing, we are very close to the answer.</p> \n  <p>First let's cut <script type=\"math/tex; mode=display\">\\text{A}</script> into two parts at a random position <script type=\"math/tex; mode=display\">i</script>:</p> \n  <div class=\"codehilite\">\n   <pre><span></span>          left_A             |        right_A\n    A[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]\n</pre>\n  </div> \n  <p>Since <script type=\"math/tex; mode=display\">\\text{A}</script> has <script type=\"math/tex; mode=display\">m</script> elements, so there are <script type=\"math/tex; mode=display\">m+1</script> kinds of cutting (<script type=\"math/tex; mode=display\">i = 0 \\sim m</script>).</p> \n  <p>And we know:</p> \n  <blockquote> \n   <p> <script type=\"math/tex; mode=display\">\\text{len}(\\text{left\\_A}) = i, \\text{len}(\\text{right\\_A}) = m - i</script>.</p> \n   <p>Note: when <script type=\"math/tex; mode=display\">i = 0</script>, <script type=\"math/tex; mode=display\">\\text{left\\_A}</script> is empty, and when <script type=\"math/tex; mode=display\">i = m</script>, <script type=\"math/tex; mode=display\">\\text{right\\_A}</script> is empty.</p> \n  </blockquote> \n  <p>With the same way, cut <script type=\"math/tex; mode=display\">\\text{B}</script> into two parts at a random position <script type=\"math/tex; mode=display\">j</script>:</p> \n  <div class=\"codehilite\">\n   <pre><span></span>          left_B             |        right_B\n    B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]\n</pre>\n  </div> \n  <p>Put <script type=\"math/tex; mode=display\">\\text{left\\_A}</script> and <script type=\"math/tex; mode=display\">\\text{left\\_B}</script> into one set, and put <script type=\"math/tex; mode=display\">\\text{right\\_A}</script> and <script type=\"math/tex; mode=display\">\\text{right\\_B}</script> into another set. Let's name them <script type=\"math/tex; mode=display\">\\text{left\\_part}</script> and <script type=\"math/tex; mode=display\">\\text{right\\_part}</script>:</p> \n  <div class=\"codehilite\">\n   <pre><span></span>          left_part          |        right_part\n    A[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]\n    B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]\n</pre>\n  </div> \n  <p>If we can ensure:</p> \n  <blockquote> \n   <ol> \n    <li> <script type=\"math/tex; mode=display\">\\text{len}(\\text{left\\_part}) = \\text{len}(\\text{right\\_part})</script> </li> \n    <li> <script type=\"math/tex; mode=display\">\\max(\\text{left\\_part}) \\leq \\min(\\text{right\\_part})</script> </li> \n   </ol> \n  </blockquote> \n  <p>then we divide all elements in <script type=\"math/tex; mode=display\">\\{\\text{A}, \\text{B}\\}</script> into two parts with equal length, and one part is always greater than the other. Then</p> \n  <p> <script type=\"math/tex; mode=display\">\n\\text{median} = \\frac{\\text{max}(\\text{left}\\_\\text{part}) + \\text{min}(\\text{right}\\_\\text{part})}{2}\n</script> </p> \n  <p>To ensure these two conditions, we just need to ensure:</p> \n  <blockquote> \n   <ol> \n    <li> <p> <script type=\"math/tex; mode=display\">i + j = m - i + n - j</script> (or: <script type=\"math/tex; mode=display\">m - i + n - j + 1</script>)<br> if <script type=\"math/tex; mode=display\">n \\geq m</script>, we just need to set: <script type=\"math/tex; mode=display\"> \\ i = 0 \\sim m,\\  j = \\frac{m + n + 1}{2} - i \\\\</script> </p> </li> \n    <li> <p> <script type=\"math/tex; mode=display\">\\text{B}[j-1] \\leq \\text{A}[i]</script> and <script type=\"math/tex; mode=display\">\\text{A}[i-1] \\leq \\text{B}[j]</script> </p> </li> \n   </ol> \n  </blockquote> \n  <p>ps.1 For simplicity, I presume <script type=\"math/tex; mode=display\">\\text{A}[i-1], \\text{B}[j-1], \\text{A}[i], \\text{B}[j]</script> are always valid even if <script type=\"math/tex; mode=display\">i=0</script>, <script type=\"math/tex; mode=display\">i=m</script>, <script type=\"math/tex; mode=display\">j=0</script>, or <script type=\"math/tex; mode=display\">j=n</script>. I will talk about how to deal with these edge values at last.</p> \n  <p>ps.2 Why <script type=\"math/tex; mode=display\">n \\geq m</script>? Because I have to make sure <script type=\"math/tex; mode=display\">j</script> is non-negative since <script type=\"math/tex; mode=display\">0 \\leq i \\leq m</script> and <script type=\"math/tex; mode=display\">j = \\frac{m + n + 1}{2} - i</script>. If <script type=\"math/tex; mode=display\">n < m</script>, then <script type=\"math/tex; mode=display\">j</script> may be negative, that will lead to wrong result.</p> \n  <p>So, all we need to do is:</p> \n  <blockquote> \n   <p>Searching <script type=\"math/tex; mode=display\">i</script> in <script type=\"math/tex; mode=display\">[0, m]</script>, to find an object <script type=\"math/tex; mode=display\">i</script> such that:</p> \n   <p> <script type=\"math/tex; mode=display\">\\qquad \\text{B}[j-1] \\leq \\text{A}[i]\\ </script> and <script type=\"math/tex; mode=display\">\\ \\text{A}[i-1] \\leq \\text{B}[j],\\ </script> where <script type=\"math/tex; mode=display\">j = \\frac{m + n + 1}{2} - i</script> </p> \n  </blockquote> \n  <p>And we can do a binary search following steps described below:</p> \n  <ol> \n   <li>Set <script type=\"math/tex; mode=display\">\\text{imin} = 0</script>, <script type=\"math/tex; mode=display\">\\text{imax} = m</script>, then start searching in <script type=\"math/tex; mode=display\">[\\text{imin}, \\text{imax}]</script> </li> \n   <li>Set <script type=\"math/tex; mode=display\">i = \\frac{\\text{imin} + \\text{imax}}{2}</script>, <script type=\"math/tex; mode=display\">j = \\frac{m + n + 1}{2} - i</script> </li> \n   <li> <p>Now we have <script type=\"math/tex; mode=display\">\\text{len}(\\text{left}\\_\\text{part})=\\text{len}(\\text{right}\\_\\text{part})</script>. And there are only 3 situations that we may encounter: </p> \n    <ul> \n     <li> <p> <script type=\"math/tex; mode=display\">\\text{B}[j-1] \\leq \\text{A}[i]</script> and <script type=\"math/tex; mode=display\">\\text{A}[i-1] \\leq \\text{B}[j]</script> <br> Means we have found the object <script type=\"math/tex; mode=display\">i</script>, so stop searching. </p> </li> \n     <li> <p> <script type=\"math/tex; mode=display\">\\text{B}[j-1] > \\text{A}[i]</script> <br> Means <script type=\"math/tex; mode=display\">\\text{A}[i]</script> is too small. We must adjust <script type=\"math/tex; mode=display\">i</script> to get <script type=\"math/tex; mode=display\">\\text{B}[j-1] \\leq \\text{A}[i]</script>.<br> Can we increase <script type=\"math/tex; mode=display\">i</script>?<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes. Because when <script type=\"math/tex; mode=display\">i</script> is increased, <script type=\"math/tex; mode=display\">j</script> will be decreased.<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;So <script type=\"math/tex; mode=display\">\\text{B}[j-1]</script> is decreased and <script type=\"math/tex; mode=display\">\\text{A}[i]</script> is increased, and <script type=\"math/tex; mode=display\">\\text{B}[j-1] \\leq \\text{A}[i]</script> may<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;be satisfied.<br> Can we decrease <script type=\"math/tex; mode=display\">i</script>?<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No! Because when <script type=\"math/tex; mode=display\">i</script> is decreased, <script type=\"math/tex; mode=display\">j</script> will be increased.<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;So <script type=\"math/tex; mode=display\">\\text{B}[j-1]</script> is increased and <script type=\"math/tex; mode=display\">\\text{A}[i]</script> is decreased, and <script type=\"math/tex; mode=display\">\\text{B}[j-1] \\leq \\text{A}[i]</script> will<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;be never satisfied.<br> So we must increase <script type=\"math/tex; mode=display\">i</script>. That is, we must adjust the searching range to <script type=\"math/tex; mode=display\">[i+1, \\text{imax}]</script>.<br> So, set <script type=\"math/tex; mode=display\">\\text{imin} = i+1</script>, and goto 2.</p> </li> \n     <li> <p> <script type=\"math/tex; mode=display\">\\text{A}[i-1] > \\text{B}[j]</script>:<br> Means <script type=\"math/tex; mode=display\">\\text{A}[i-1]</script> is too big. And we must decrease <script type=\"math/tex; mode=display\">i</script> to get <script type=\"math/tex; mode=display\">\\text{A}[i-1]\\leq \\text{B}[j]</script>.<br> That is, we must adjust the searching range to <script type=\"math/tex; mode=display\">[\\text{imin}, i-1]</script>.<br> So, set <script type=\"math/tex; mode=display\">\\text{imax} = i-1</script>, and goto 2.</p> </li> \n    </ul> </li> \n  </ol> \n  <p>When the object <script type=\"math/tex; mode=display\">i</script> is found, the median is:</p> \n  <blockquote> \n   <p> <script type=\"math/tex; mode=display\">\\max(\\text{A}[i-1], \\text{B}[j-1]), \\ </script> when <script type=\"math/tex; mode=display\">m + n</script> is odd</p> \n   <p> <script type=\"math/tex; mode=display\">\\frac{\\max(\\text{A}[i-1], \\text{B}[j-1]) + \\min(\\text{A}[i], \\text{B}[j])}{2}, \\ </script> when <script type=\"math/tex; mode=display\">m + n</script> is even</p> \n  </blockquote> \n  <p>Now let's consider the edges values <script type=\"math/tex; mode=display\">i=0,i=m,j=0,j=n</script> where <script type=\"math/tex; mode=display\">\\text{A}[i-1],\\text{B}[j-1],\\text{A}[i],\\text{B}[j]</script> may not exist. Actually this situation is easier than you think.</p> \n  <p>What we need to do is ensuring that <script type=\"math/tex; mode=display\">\\text{max}(\\text{left}\\_\\text{part}) \\leq \\text{min}(\\text{right}\\_\\text{part})</script>. So, if <script type=\"math/tex; mode=display\">i</script> and <script type=\"math/tex; mode=display\">j</script> are not edges values (means <script type=\"math/tex; mode=display\">\\text{A}[i-1],\n\\text{B}[j-1],\\text{A}[i],\\text{B}[j]</script> all exist), then we must check both <script type=\"math/tex; mode=display\">\\text{B}[j-1] \\leq \\text{A}[i]</script> and <script type=\"math/tex; mode=display\">\\text{A}[i-1] \\leq \\text{B}[j]</script>. But if some of <script type=\"math/tex; mode=display\">\\text{A}[i-1],\\text{B}[j-1],\\text{A}[i],\\text{B}[j]</script> don't exist, then we don't need to check one (or both) of these two conditions. For example, if <script type=\"math/tex; mode=display\">i=0</script>, then <script type=\"math/tex; mode=display\">\\text{A}[i-1]</script> doesn't exist, then we don't need to check <script type=\"math/tex; mode=display\">\\text{A}[i-1] \\leq \\text{B}[j]</script>. So, what we need to do is:</p> \n  <blockquote> \n   <p>Searching <script type=\"math/tex; mode=display\">i</script> in <script type=\"math/tex; mode=display\">[0, m]</script>, to find an object <script type=\"math/tex; mode=display\">i</script> such that:</p> \n   <p> <script type=\"math/tex; mode=display\">(j = 0</script> or <script type=\"math/tex; mode=display\">i = m</script> or <script type=\"math/tex; mode=display\">\\text{B}[j-1] \\leq \\text{A}[i])</script> and<br> <script type=\"math/tex; mode=display\">(i = 0</script> or <script type=\"math/tex; mode=display\">j = n</script> or <script type=\"math/tex; mode=display\">\\text{A}[i-1] \\leq \\text{B}[j]),</script> where <script type=\"math/tex; mode=display\">j = \\frac{m + n + 1}{2} - i</script> </p> \n  </blockquote> \n  <p>And in a searching loop, we will encounter only three situations:</p> \n  <blockquote> \n   <ol> \n    <li> <script type=\"math/tex; mode=display\">(j = 0</script> or <script type=\"math/tex; mode=display\">i = m</script> or <script type=\"math/tex; mode=display\">\\text{B}[j-1] \\leq \\text{A}[i])</script> and<br> <script type=\"math/tex; mode=display\">(i = 0</script> or <script type=\"math/tex; mode=display\">j = n</script> or <script type=\"math/tex; mode=display\">\\text{A}[i-1] \\leq \\text{B}[j])</script> <br> Means <script type=\"math/tex; mode=display\">i</script> is perfect, we can stop searching.</li> \n    <li> <script type=\"math/tex; mode=display\">j > 0</script> and <script type=\"math/tex; mode=display\">i < m</script> and <script type=\"math/tex; mode=display\">\\text{B}[j - 1] > \\text{A}[i]</script> <br> Means <script type=\"math/tex; mode=display\">i</script> is too small, we must increase it.</li> \n    <li> <script type=\"math/tex; mode=display\">i > 0</script> and <script type=\"math/tex; mode=display\">j < n</script> and <script type=\"math/tex; mode=display\">\\text{A}[i - 1] > \\text{B}[j]</script> <br> Means <script type=\"math/tex; mode=display\">i</script> is too big, we must decrease it.</li> \n   </ol> \n  </blockquote> \n  <p>Thanks to <a href=\"https://leetcode.com/Quentin.chen\">@Quentin.chen</a> for pointing out that: <script type=\"math/tex; mode=display\">i < m \\implies j > 0</script> and <script type=\"math/tex; mode=display\">i > 0 \\implies j < n</script>. Because:</p> \n  <blockquote> \n   <p> <script type=\"math/tex; mode=display\">m \\leq n,\\  i < m \\implies j = \\frac{m+n+1}{2} - i > \\frac{m+n+1}{2} - m \\geq \\frac{2m+1}{2} - m \\geq 0</script> </p> \n   <p> <script type=\"math/tex; mode=display\">m \\leq n,\\  i > 0 \\implies j = \\frac{m+n+1}{2} - i < \\frac{m+n+1}{2} \\leq \\frac{2n+1}{2} \\leq n</script> </p> \n  </blockquote> \n  <p>So in situation 2. and 3. , we don't need to check whether <script type=\"math/tex; mode=display\">j > 0</script> and whether <script type=\"math/tex; mode=display\">j < n</script>.</p> \n  <iframe src=\"https://leetcode.com/playground/X5mgSxnd/shared\" frameborder=\"0\" width=\"100%\" height=\"500\" name=\"X5mgSxnd\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity: <script type=\"math/tex; mode=display\">O\\big(\\log\\big(\\text{min}(m,n)\\big)\\big)</script>.<br> At first, the searching range is <script type=\"math/tex; mode=display\">[0, m]</script>. And the length of this searching range will be reduced by half after each loop. So, we only need <script type=\"math/tex; mode=display\">\\log(m)</script> loops. Since we do constant operations in each loop, so the time complexity is <script type=\"math/tex; mode=display\">O\\big(\\log(m)\\big)</script>. Since <script type=\"math/tex; mode=display\">m \\leq n</script>, so the time complexity is <script type=\"math/tex; mode=display\">O\\big(\\log\\big(\\text{min}(m,n)\\big)\\big)</script>.</p> </li> \n   <li> <p>Space complexity: <script type=\"math/tex; mode=display\">O(1)</script>.<br> We only need constant memory to store <script type=\"math/tex; mode=display\">9</script> local variables, so the space complexity is <script type=\"math/tex; mode=display\">O(1)</script>.</p> </li> \n  </ul> \n </div> \n</div>"
},
{
    "frontend_question_id": 3,
    "article_live": true,
    "article_slug": "longest-substring-without-repeating-characters",
    "title": "Longest Substring Without Repeating Characters",
    "title_slug": "longest-substring-without-repeating-characters",
    "content": "<p>Given a string, find the length of the <b>longest substring</b> without repeating characters.</p>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">&quot;abcabcbb&quot;</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">3 \r\n<strong>Explanation:</strong></span> The answer is <code>&quot;abc&quot;</code>, with the length of 3. \r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">&quot;bbbbb&quot;</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">1\r\n</span><span id=\"example-output-1\"><strong>Explanation: </strong>T</span>he answer is <code>&quot;b&quot;</code>, with the length of 1.\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-3-1\">&quot;pwwkew&quot;</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">3\r\n</span><span id=\"example-output-1\"><strong>Explanation: </strong></span>The answer is <code>&quot;wke&quot;</code>, with the length of 3. \r\n             Note that the answer must be a <b>substring</b>, <code>&quot;pwke&quot;</code> is a <i>subsequence</i> and not a substring.\r\n</pre>\r\n</div>\r\n</div>\r\n</div>\r\n",
    "tags": "Hash Table, Two Pointers, String",
    "difficulty": 2,
    "frontend_article_id": 3,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force\">Approach 1: Brute Force</a></li> \n      <li><a href=\"#approach-2-sliding-window\">Approach 2: Sliding Window</a></li> \n      <li><a href=\"#approach-3-sliding-window-optimized\">Approach 3: Sliding Window Optimized</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force\">Approach 1: Brute Force</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Check all the substring one by one to see if it has no duplicate character.</p> \n  <p><strong>Algorithm</strong></p> \n  <p>Suppose we have a function <code>boolean allUnique(String substring)</code> which will return true if the characters in the substring are all unique, otherwise false. We can iterate through all the possible substrings of the given string <code>s</code> and call the function <code>allUnique</code>. If it turns out to be true, then we update our answer of the maximum length of substring without duplicate characters.</p> \n  <p>Now let's fill the missing parts:</p> \n  <ol> \n   <li> <p>To enumerate all substrings of a given string, we enumerate the start and end indices of them. Suppose the start and end indices are <script type=\"math/tex; mode=display\">i</script> and <script type=\"math/tex; mode=display\">j</script>, respectively. Then we have <script type=\"math/tex; mode=display\">0 \\leq i \\lt j \\leq n</script> (here end index <script type=\"math/tex; mode=display\">j</script> is exclusive by convention). Thus, using two nested loops with <script type=\"math/tex; mode=display\">i</script> from 0 to <script type=\"math/tex; mode=display\">n - 1</script> and <script type=\"math/tex; mode=display\">j</script> from <script type=\"math/tex; mode=display\">i+1</script> to <script type=\"math/tex; mode=display\">n</script>, we can enumerate all the substrings of <code>s</code>.</p> </li> \n   <li> <p>To check if one string has duplicate characters, we can use a set. We iterate through all the characters in the string and put them into the <code>set</code> one by one. Before putting one character, we check if the set already contains it. If so, we return <code>false</code>. After the loop, we return <code>true</code>.</p> </li> \n  </ol> \n  <iframe src=\"https://leetcode.com/playground/dDeYomT6/shared\" frameborder=\"0\" width=\"100%\" height=\"395\" name=\"dDeYomT6\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^3)</script>.</p> <p>To verify if characters within index range <script type=\"math/tex; mode=display\">[i, j)</script> are all unique, we need to scan all of them. Thus, it costs <script type=\"math/tex; mode=display\">O(j - i)</script> time.</p> <p>For a given <code>i</code>, the sum of time costed by each <script type=\"math/tex; mode=display\">j \\in [i+1, n]</script> is</p> <p> <script type=\"math/tex; mode=display\">\n\\sum_{i+1}^{n}O(j - i)\n</script> </p> <p>Thus, the sum of all the time consumption is:</p> <p> <script type=\"math/tex; mode=display\">\nO\\left(\\sum_{i = 0}^{n - 1}\\left(\\sum_{j = i + 1}^{n}(j - i)\\right)\\right) =\nO\\left(\\sum_{i = 0}^{n - 1}\\frac{(1 + n - i)(n - i)}{2}\\right) =\nO(n^3)\n</script> </p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(min(n, m))</script>. We need <script type=\"math/tex; mode=display\">O(k)</script> space for checking a substring has no duplicate characters, where <script type=\"math/tex; mode=display\">k</script> is the size of the <code>Set</code>. The size of the Set is upper bounded by the size of the string <script type=\"math/tex; mode=display\">n</script> and the size of the charset/alphabet <script type=\"math/tex; mode=display\">m</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-sliding-window\">Approach 2: Sliding Window</h4> \n  <p><strong>Algorithm</strong></p> \n  <p>The naive approach is very straightforward. But it is too slow. So how can we optimize it?</p> \n  <p>In the naive approaches, we repeatedly check a substring to see if it has duplicate character. But it is unnecessary. If a substring <script type=\"math/tex; mode=display\">s_{ij}</script> from index <script type=\"math/tex; mode=display\">i</script> to <script type=\"math/tex; mode=display\">j - 1</script> is already checked to have no duplicate characters. We only need to check if <script type=\"math/tex; mode=display\">s[j]</script> is already in the substring <script type=\"math/tex; mode=display\">s_{ij}</script>.</p> \n  <p>To check if a character is already in the substring, we can scan the substring, which leads to an <script type=\"math/tex; mode=display\">O(n^2)</script> algorithm. But we can do better.</p> \n  <p>By using HashSet as a sliding window, checking if a character in the current can be done in <script type=\"math/tex; mode=display\">O(1)</script>.</p> \n  <p>A sliding window is an abstract concept commonly used in array/string problems. A window is a range of elements in the array/string which usually defined by the start and end indices, i.e. <script type=\"math/tex; mode=display\">[i, j)</script> (left-closed, right-open). A sliding window is a window \"slides\" its two boundaries to the certain direction. For example, if we slide <script type=\"math/tex; mode=display\">[i, j)</script> to the right by <script type=\"math/tex; mode=display\">1</script> element, then it becomes <script type=\"math/tex; mode=display\">[i+1, j+1)</script> (left-closed, right-open).</p> \n  <p>Back to our problem. We use HashSet to store the characters in current window <script type=\"math/tex; mode=display\">[i, j)</script> (<script type=\"math/tex; mode=display\">j = i</script> initially). Then we slide the index <script type=\"math/tex; mode=display\">j</script> to the right. If it is not in the HashSet, we slide <script type=\"math/tex; mode=display\">j</script> further. Doing so until s[j] is already in the HashSet. At this point, we found the maximum size of substrings without duplicate characters start with index <script type=\"math/tex; mode=display\">i</script>. If we do this for all <script type=\"math/tex; mode=display\">i</script>, we get our answer.</p> \n  <iframe src=\"https://leetcode.com/playground/gajHJS2a/shared\" frameborder=\"0\" width=\"100%\" height=\"361\" name=\"gajHJS2a\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(2n) = O(n)</script>. In the worst case each character will be visited twice by <script type=\"math/tex; mode=display\">i</script> and <script type=\"math/tex; mode=display\">j</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(min(m, n))</script>. Same as the previous approach. We need <script type=\"math/tex; mode=display\">O(k)</script> space for the sliding window, where <script type=\"math/tex; mode=display\">k</script> is the size of the <code>Set</code>. The size of the Set is upper bounded by the size of the string <script type=\"math/tex; mode=display\">n</script> and the size of the charset/alphabet <script type=\"math/tex; mode=display\">m</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-sliding-window-optimized\">Approach 3: Sliding Window Optimized</h4> \n  <p>The above solution requires at most 2n steps. In fact, it could be optimized to require only n steps. Instead of using a set to tell if a character exists or not, we could define a mapping of the characters to its index. Then we can skip the characters immediately when we found a repeated character.</p> \n  <p>The reason is that if <script type=\"math/tex; mode=display\">s[j]</script> have a duplicate in the range <script type=\"math/tex; mode=display\">[i, j)</script> with index <script type=\"math/tex; mode=display\">j'</script>, we don't need to increase <script type=\"math/tex; mode=display\">i</script> little by little. We can skip all the elements in the range <script type=\"math/tex; mode=display\">[i, j']</script> and let <script type=\"math/tex; mode=display\">i</script> to be <script type=\"math/tex; mode=display\">j' + 1</script> directly.</p> \n  <p><strong>Java (Using HashMap)</strong></p> \n  <iframe src=\"https://leetcode.com/playground/ers9VnKH/shared\" frameborder=\"0\" width=\"100%\" height=\"310\" name=\"ers9VnKH\"></iframe> \n  <p><strong>Java (Assuming ASCII 128)</strong></p> \n  <p>The previous implements all have no assumption on the charset of the string <code>s</code>.</p> \n  <p>If we know that the charset is rather small, we can replace the <code>Map</code> with an integer array as direct access table.</p> \n  <p>Commonly used tables are:</p> \n  <ul> \n   <li><code>int[26]</code> for Letters 'a' - 'z' or 'A' - 'Z'</li> \n   <li><code>int[128]</code> for ASCII</li> \n   <li><code>int[256]</code> for Extended ASCII</li> \n  </ul> \n  <iframe src=\"https://leetcode.com/playground/KgRWfFiE/shared\" frameborder=\"0\" width=\"100%\" height=\"276\" name=\"KgRWfFiE\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. Index <script type=\"math/tex; mode=display\">j</script> will iterate <script type=\"math/tex; mode=display\">n</script> times.</p> </li> \n   <li> <p>Space complexity (HashMap) : <script type=\"math/tex; mode=display\">O(min(m, n))</script>. Same as the previous approach.</p> </li> \n   <li> <p>Space complexity (Table): <script type=\"math/tex; mode=display\">O(m)</script>. <script type=\"math/tex; mode=display\">m</script> is the size of the charset.</p> </li> \n  </ul> \n </div> \n</div>"
},
{
    "frontend_question_id": 2,
    "article_live": true,
    "article_slug": "add-two-numbers",
    "title": "Add Two Numbers",
    "title_slug": "add-two-numbers",
    "content": "<p>You are given two <b>non-empty</b> linked lists representing two non-negative integers. The digits are stored in <b>reverse order</b> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>\r\n\r\n<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>\r\n\r\n<p><b>Example:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)\r\n<b>Output:</b> 7 -&gt; 0 -&gt; 8\r\n<b>Explanation:</b> 342 + 465 = 807.\r\n</pre>\r\n",
    "tags": "Linked List, Math",
    "difficulty": 2,
    "frontend_article_id": 2,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-elementary-math\">Approach 1: Elementary Math</h4> \n  <p><strong>Intuition</strong></p> \n  <p>Keep track of the carry using a variable and simulate digits-by-digits sum starting from the head of list, which contains the least-significant digit.</p> \n  <p align=\"center\"><img alt=\"Illustration of Adding two numbers\" src=\"../Figures/2_add_two_numbers.svg\" width=\"539px\"></p> \n  <p align=\"center\"><em>Figure 1. Visualization of the addition of two numbers: <script type=\"math/tex; mode=display\">342 + 465 = 807</script>.<br> Each node contains a single digit and the digits are stored in reverse order.</em></p> \n  <p><strong>Algorithm</strong></p> \n  <p>Just like how you would sum two numbers on a piece of paper, we begin by summing the least-significant digits, which is the head of <script type=\"math/tex; mode=display\">l1</script> and <script type=\"math/tex; mode=display\">l2</script>. Since each digit is in the range of <script type=\"math/tex; mode=display\">0 \\ldots 9</script>, summing two digits may \"overflow\". For example <script type=\"math/tex; mode=display\">5 + 7 = 12</script>. In this case, we set the current digit to <script type=\"math/tex; mode=display\">2</script> and bring over the <script type=\"math/tex; mode=display\">carry = 1</script> to the next iteration. <script type=\"math/tex; mode=display\">carry</script> must be either <script type=\"math/tex; mode=display\">0</script> or <script type=\"math/tex; mode=display\">1</script> because the largest possible sum of two digits (including the carry) is <script type=\"math/tex; mode=display\">9 + 9 + 1 = 19</script>.</p> \n  <p>The pseudocode is as following:</p> \n  <ul> \n   <li>Initialize current node to dummy head of the returning list.</li> \n   <li>Initialize carry to <script type=\"math/tex; mode=display\">0</script>.</li> \n   <li>Initialize <script type=\"math/tex; mode=display\">p</script> and <script type=\"math/tex; mode=display\">q</script> to head of <script type=\"math/tex; mode=display\">l1</script> and <script type=\"math/tex; mode=display\">l2</script> respectively.</li> \n   <li>Loop through lists <script type=\"math/tex; mode=display\">l1</script> and <script type=\"math/tex; mode=display\">l2</script> until you reach both ends.\n    <ul> \n     <li>Set <script type=\"math/tex; mode=display\">x</script> to node <script type=\"math/tex; mode=display\">p</script>'s value. If <script type=\"math/tex; mode=display\">p</script> has reached the end of <script type=\"math/tex; mode=display\">l1</script>, set to <script type=\"math/tex; mode=display\">0</script>.</li> \n     <li>Set <script type=\"math/tex; mode=display\">y</script> to node <script type=\"math/tex; mode=display\">q</script>'s value. If <script type=\"math/tex; mode=display\">q</script> has reached the end of <script type=\"math/tex; mode=display\">l2</script>, set to <script type=\"math/tex; mode=display\">0</script>.</li> \n     <li>Set <script type=\"math/tex; mode=display\">sum = x + y + carry</script>.</li> \n     <li>Update <script type=\"math/tex; mode=display\">carry = sum / 10</script>.</li> \n     <li>Create a new node with the digit value of <script type=\"math/tex; mode=display\">(sum \\bmod 10)</script> and set it to current node's next, then advance current node to next.</li> \n     <li>Advance both <script type=\"math/tex; mode=display\">p</script> and <script type=\"math/tex; mode=display\">q</script>.</li> \n    </ul> </li> \n   <li>Check if <script type=\"math/tex; mode=display\">carry = 1</script>, if so append a new node with digit <script type=\"math/tex; mode=display\">1</script> to the returning list.</li> \n   <li>Return dummy head's next node.</li> \n  </ul> \n  <p>Note that we use a dummy head to simplify the code. Without a dummy head, you would have to write extra conditional statements to initialize the head's value.</p> \n  <p>Take extra caution of the following cases:</p> \n  <table> \n   <thead> \n    <tr> \n     <th>Test case</th> \n     <th>Explanation</th> \n    </tr> \n   </thead> \n   <tbody> \n    <tr> \n     <td> <script type=\"math/tex; mode=display\">l1=[0,1]</script><br><script type=\"math/tex; mode=display\">l2=[0,1,2]</script> </td> \n     <td>When one list is longer than the other.</td> \n    </tr> \n    <tr> \n     <td> <script type=\"math/tex; mode=display\">l1=[]</script><br><script type=\"math/tex; mode=display\">l2=[0,1]</script> </td> \n     <td>When one list is null, which means an empty list.</td> \n    </tr> \n    <tr> \n     <td> <script type=\"math/tex; mode=display\">l1=[9,9]</script><br><script type=\"math/tex; mode=display\">l2=[1]</script> </td> \n     <td>The sum could have an extra carry of one at the end, which is easy to forget.</td> \n    </tr> \n   </tbody> \n  </table> \n  <iframe src=\"https://leetcode.com/playground/5onAHA8v/shared\" frameborder=\"0\" width=\"100%\" height=\"378\" name=\"5onAHA8v\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(\\max(m, n))</script>. Assume that <script type=\"math/tex; mode=display\">m</script> and <script type=\"math/tex; mode=display\">n</script> represents the length of <script type=\"math/tex; mode=display\">l1</script> and <script type=\"math/tex; mode=display\">l2</script> respectively, the algorithm above iterates at most <script type=\"math/tex; mode=display\">\\max(m, n)</script> times.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(\\max(m, n))</script>. The length of the new list is at most <script type=\"math/tex; mode=display\">\\max(m,n) + 1</script>.</p> </li> \n  </ul> \n  <p><strong>Follow up</strong></p> \n  <p>What if the the digits in the linked list are stored in non-reversed order? For example:</p> \n  <p> <script type=\"math/tex; mode=display\">\n(3 \\to 4 \\to 2) + (4 \\to 6 \\to 5) = 8 \\to 0 \\to 7\n</script> </p> \n </div> \n</div>"
},
{
    "frontend_question_id": 1,
    "article_live": true,
    "article_slug": "two-sum",
    "title": "Two Sum",
    "title_slug": "two-sum",
    "content": "<p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p>\r\n\r\n<p>You may assume that each input would have <strong><em>exactly</em></strong> one solution, and you may not use the <em>same</em> element twice.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\nGiven nums = [2, 7, 11, 15], target = 9,\r\n\r\nBecause nums[<strong>0</strong>] + nums[<strong>1</strong>] = 2 + 7 = 9,\r\nreturn [<strong>0</strong>, <strong>1</strong>].\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n",
    "tags": "Array, Hash Table",
    "difficulty": 1,
    "frontend_article_id": 1,
    "article_content": "<div class=\"article-body\"> \n <div class=\"block-markdown\"> \n  <div class=\"toc\"> \n   <ul> \n    <li><a href=\"#solution\">Solution</a>\n     <ul> \n      <li><a href=\"#approach-1-brute-force\">Approach 1: Brute Force</a></li> \n      <li><a href=\"#approach-2-two-pass-hash-table\">Approach 2: Two-pass Hash Table</a></li> \n      <li><a href=\"#approach-3-one-pass-hash-table\">Approach 3: One-pass Hash Table</a></li> \n     </ul> </li> \n   </ul> \n  </div> \n  <h2 id=\"solution\">Solution</h2> \n  <hr> \n  <h4 id=\"approach-1-brute-force\">Approach 1: Brute Force</h4> \n  <p>The brute force approach is simple. Loop through each element <script type=\"math/tex; mode=display\">x</script> and find if there is another value that equals to <script type=\"math/tex; mode=display\">target - x</script>.</p> \n  <iframe src=\"https://leetcode.com/playground/CLZq9vzU/shared\" frameborder=\"0\" width=\"100%\" height=\"225\" name=\"CLZq9vzU\"></iframe> \n  <p><strong>Complexity Analysis</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n^2)</script>. For each element, we try to find its complement by looping through the rest of array which takes <script type=\"math/tex; mode=display\">O(n)</script> time. Therefore, the time complexity is <script type=\"math/tex; mode=display\">O(n^2)</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(1)</script>. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-2-two-pass-hash-table\">Approach 2: Two-pass Hash Table</h4> \n  <p>To improve our run time complexity, we need a more efficient way to check if the complement exists in the array. If the complement exists, we need to look up its index. What is the best way to maintain a mapping of each element in the array to its index? A hash table.</p> \n  <p>We reduce the look up time from <script type=\"math/tex; mode=display\">O(n)</script> to <script type=\"math/tex; mode=display\">O(1)</script> by trading space for speed. A hash table is built exactly for this purpose, it supports fast look up in <em>near</em> constant time. I say \"near\" because if a collision occurred, a look up could degenerate to <script type=\"math/tex; mode=display\">O(n)</script> time. But look up in hash table should be amortized <script type=\"math/tex; mode=display\">O(1)</script> time as long as the hash function was chosen carefully.</p> \n  <p>A simple implementation uses two iterations. In the first iteration, we add each element's value and its index to the table. Then, in the second iteration we check if each element's complement (<script type=\"math/tex; mode=display\">target - nums[i]</script>) exists in the table. Beware that the complement must not be <script type=\"math/tex; mode=display\">nums[i]</script> itself!</p> \n  <iframe src=\"https://leetcode.com/playground/QhqBrfm7/shared\" frameborder=\"0\" width=\"100%\" height=\"276\" name=\"QhqBrfm7\"></iframe> \n  <p><strong>Complexity Analysis:</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. We traverse the list containing <script type=\"math/tex; mode=display\">n</script> elements exactly twice. Since the hash table reduces the look up time to <script type=\"math/tex; mode=display\">O(1)</script>, the time complexity is <script type=\"math/tex; mode=display\">O(n)</script>.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The extra space required depends on the number of items stored in the hash table, which stores exactly <script type=\"math/tex; mode=display\">n</script> elements. <br> <br></p> </li> \n  </ul> \n  <hr> \n  <h4 id=\"approach-3-one-pass-hash-table\">Approach 3: One-pass Hash Table</h4> \n  <p>It turns out we can do it in one-pass. While we iterate and inserting elements into the table, we also look back to check if current element's complement already exists in the table. If it exists, we have found a solution and return immediately.</p> \n  <iframe src=\"https://leetcode.com/playground/fbBQEjxv/shared\" frameborder=\"0\" width=\"100%\" height=\"242\" name=\"fbBQEjxv\"></iframe> \n  <p><strong>Complexity Analysis:</strong></p> \n  <ul> \n   <li> <p>Time complexity : <script type=\"math/tex; mode=display\">O(n)</script>. We traverse the list containing <script type=\"math/tex; mode=display\">n</script> elements only once. Each look up in the table costs only <script type=\"math/tex; mode=display\">O(1)</script> time.</p> </li> \n   <li> <p>Space complexity : <script type=\"math/tex; mode=display\">O(n)</script>. The extra space required depends on the number of items stored in the hash table, which stores at most <script type=\"math/tex; mode=display\">n</script> elements.</p> </li> \n  </ul> \n </div> \n</div>"
}]